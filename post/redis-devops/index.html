<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/icon.png" color="#222">
  <meta name="google-site-verification" content="HffpR8NKoAvdPtHw1WLz8yun_UKXOBTbuFVpUH6i77Q">







<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: true,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="《Redis开发与运维》">
<meta property="og:url" content="https://blog.shixinyu.space/post/redis-devops/index.html">
<meta property="og:site_name" content="Xinyu's Space">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8ronsawmbj30ku0aft9d.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g8rmou0bzdj30hx0kb0xe.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g8tfeooj3zj30k60hptbk.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8u1rzsipij30n811un3c.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8u27kw8tmj30u00ws7ff.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g91c1tnqngj30ky0m3djy.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g91co0mb8fj30g40hz770.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g91e0yu7flj30if0o442t.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g91vyy7e25j30h909875n.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xk5bba1j30jh0hejtq.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xn7bm5rj30j30lqgp7.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xwacukej30hu0d8gnx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g91z58ncm8j30iv0frgpv.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g94c4oj8s0j30y20mmtfb.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g94i0a1qirj30u00wg49h.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g94ig5abpxj30zi0u0tkp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g97yccw87dj30kt0dq0w8.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g982kp4di3j30lh0fadim.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g994eh8oswj30lt0fr41y.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bsaxy49ij30kq0eetcb.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9chovnyqwj30lm0ls77d.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9chuf4cjdj30ld0hogp4.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9chunrge9j30mh0hbtbn.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cieyqdx2j30je0riwj1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9e35sce95j30m505ywfm.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9i5gd6qalj30n80nowkd.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9ic768uakj30ho0m8jve.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9icdly6hpj30j30ebq5o.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9icgp2fv1j30ju0gwtcv.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9jh857qqpj30ji0ehq6u.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9jhell5zkj30gy0hc417.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9jhkc00w3j30he0b3q5k.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9jhv81y3pj30j00jrwhp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9qoovqnpwj30u00vlk0z.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9qop67mnjj311m0ti0z1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9qp56c761j30u010847e.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enly0i2dj30g10i1ac8.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enotipdrj30in0hvq5t.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9ens6v1czj30md068q4q.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enykatrkj30lu0m9tf4.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enz0x9eaj30mh0jsgr7.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eoakg0wrj30md0g0jty.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eo4ku5pyj30mg095acq.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eobx2323j30m20ed0vb.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eomw75jpj30lp0lt43y.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eol3rlkmj30mz07fq4l.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9qrmwcp5ij30il0black.jpg">
<meta property="og:updated_time" content="2020-03-18T09:09:34.899Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8ronsawmbj30ku0aft9d.jpg">

<link rel="canonical" href="https://blog.shixinyu.space/post/redis-devops/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>
<meta name="google-site-verification" content="HffpR8NKoAvdPtHw1WLz8yun_UKXOBTbuFVpUH6i77Q">
<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js"></script>
  <title>《Redis开发与运维》 | Xinyu's Space</title>
  
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-88938102-1"></script>
    <script pjax="">
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-88938102-1');
      }
    </script>






  <style>html {
  line-height: 1.15; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
}
body {
  margin: 0;
}
main {
  display: block;
}
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
hr {
  box-sizing: content-box; /* 1 */
  height: 0; /* 1 */
  overflow: visible; /* 2 */
}
pre {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}
a {
  background: transparent;
}
abbr[title] {
  border-bottom: none; /* 1 */
  text-decoration: underline; /* 2 */
  text-decoration: underline dotted; /* 2 */
}
b,
strong {
  font-weight: bolder;
}
code,
kbd,
samp {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}
small {
  font-size: 80%;
}
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sub {
  bottom: -0.25em;
}
sup {
  top: -0.5em;
}
img {
  border-style: none;
}
button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-size: 100%; /* 1 */
  line-height: 1.15; /* 1 */
  margin: 0; /* 2 */
}
button,
input {
/* 1 */
  overflow: visible;
}
button,
select {
/* 1 */
  text-transform: none;
}
button,
[type='button'],
[type='reset'],
[type='submit'] {
  -webkit-appearance: button;
}
button::-moz-focus-inner,
[type='button']::-moz-focus-inner,
[type='reset']::-moz-focus-inner,
[type='submit']::-moz-focus-inner {
  border-style: none;
  padding: 0;
}
button:-moz-focusring,
[type='button']:-moz-focusring,
[type='reset']:-moz-focusring,
[type='submit']:-moz-focusring {
  outline: 1px dotted ButtonText;
}
fieldset {
  padding: 0.35em 0.75em 0.625em;
}
legend {
  box-sizing: border-box; /* 1 */
  color: inherit; /* 2 */
  display: table; /* 1 */
  max-width: 100%; /* 1 */
  padding: 0; /* 3 */
  white-space: normal; /* 1 */
}
progress {
  vertical-align: baseline;
}
textarea {
  overflow: auto;
}
[type='checkbox'],
[type='radio'] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}
[type='number']::-webkit-inner-spin-button,
[type='number']::-webkit-outer-spin-button {
  height: auto;
}
[type='search'] {
  outline-offset: -2px; /* 2 */
  -webkit-appearance: textfield; /* 1 */
}
[type='search']::-webkit-search-decoration {
  -webkit-appearance: none;
}
::-webkit-file-upload-button {
  font: inherit; /* 2 */
  -webkit-appearance: button; /* 1 */
}
details {
  display: block;
}
summary {
  display: list-item;
}
template {
  display: none;
}
[hidden] {
  display: none;
}
::selection {
  background: #262a30;
  color: #fff;
}
html,
body {
  height: 100%;
}
body {
  background: #eee;
  color: #555;
  font-family: 'Roboto', "PingFang SC", "Microsoft YaHei", sans-serif;
  font-size: 1em;
  line-height: 2;
}
@media (max-width: 991px) {
  body {
    padding-left: 0 !important;
    padding-right: 0 !important;
  }
}
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: 'Roboto', "PingFang SC", "Microsoft YaHei", sans-serif;
  font-weight: bold;
  line-height: 1.5;
  margin: 20px 0 15px;
  padding: 0;
}
h1 {
  font-size: 1.5em;
}
h2 {
  font-size: 1.375em;
}
h3 {
  font-size: 1.25em;
}
h4 {
  font-size: 1.125em;
}
h5 {
  font-size: 1em;
}
h6 {
  font-size: 0.875em;
}
p {
  margin: 0 0 20px 0;
}
a,
span.exturl {
  overflow-wrap: break-word;
  word-wrap: break-word;
  border-bottom: 1px solid #999;
  color: #555;
  outline: 0;
  text-decoration: none;
  cursor: pointer;
}
a:hover,
span.exturl:hover {
  border-bottom-color: #222;
  color: #222;
}
iframe,
img,
video {
  display: block;
  margin-left: auto;
  margin-right: auto;
  max-width: 100%;
}
hr {
  background-color: #ddd;
  background-image: repeating-linear-gradient(-45deg, #fff, #fff 4px, transparent 4px, transparent 8px);
  border: 0;
  height: 3px;
  margin: 40px 0;
}
blockquote {
  border-left: 4px solid #ddd;
  color: #666;
  margin: 0;
  padding: 0 15px;
}
blockquote cite::before {
  content: '-';
  padding: 0 5px;
}
dt {
  font-weight: 700;
}
dd {
  margin: 0;
  padding: 0;
}
kbd {
  background-color: #f5f5f5;
  background-image: linear-gradient(#eee, #fff, #eee);
  border: 1px solid #ccc;
  border-radius: 0.2em;
  box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1);
  font-family: inherit;
  padding: 0.1em 0.3em;
  white-space: nowrap;
}
.table-container {
  -webkit-overflow-scrolling: touch;
  overflow: auto;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
  font-size: 0.875em;
  margin: 0 0 20px 0;
  width: 100%;
}
table > tbody > tr:nth-of-type(odd) {
  background: #f9f9f9;
}
table > tbody > tr:hover {
  background: #f5f5f5;
}
caption,
th,
td {
  font-weight: normal;
  padding: 8px;
  text-align: left;
  vertical-align: middle;
}
th,
td {
  border: 1px solid #ddd;
  border-bottom: 3px solid #ddd;
}
th {
  font-weight: 700;
  padding-bottom: 10px;
}
td {
  border-bottom-width: 1px;
}
.btn {
  background: #fff;
  border: 2px solid #555;
  border-radius: 2px;
  color: #555;
  display: inline-block;
  font-size: 0.875em;
  line-height: 2;
  padding: 0 20px;
  text-decoration: none;
  transition-property: background-color;
  transition-delay: 0s;
  transition-duration: 0.2s;
  transition-timing-function: ease-in-out;
}
.btn:hover {
  background: #222;
  border-color: #222;
  color: #fff;
}
.btn + .btn {
  margin: 0 0 8px 8px;
}
.btn .fa-fw {
  text-align: left;
  width: 1.285714285714286em;
}
.toggle {
  line-height: 0;
}
.toggle .toggle-line {
  background: #fff;
  display: inline-block;
  height: 2px;
  left: 0;
  position: relative;
  top: 0;
  transition: all 0.4s;
  vertical-align: top;
  width: 100%;
}
.toggle .toggle-line:not(:first-child) {
  margin-top: 3px;
}
.toggle.toggle-arrow .toggle-line-first {
  left: 50%;
  top: 2px;
  transform: rotate(45deg);
  width: 50%;
}
.toggle.toggle-arrow .toggle-line-middle {
  left: 2px;
  width: 90%;
}
.toggle.toggle-arrow .toggle-line-last {
  left: 50%;
  top: -2px;
  transform: rotate(-45deg);
  width: 50%;
}
.toggle.toggle-close .toggle-line-first {
  transform: rotate(-45deg);
  top: 5px;
}
.toggle.toggle-close .toggle-line-middle {
  opacity: 0;
}
.toggle.toggle-close .toggle-line-last {
  transform: rotate(45deg);
  top: -5px;
}
.highlight-wrap {
  position: relative;
}
.highlight-wrap:hover .copy-btn,
.highlight-wrap .copy-btn:focus {
  opacity: 1;
}
.copy-btn {
  color: #333;
  cursor: pointer;
  display: inline-block;
  font-weight: 700;
  line-height: 1.6;
  opacity: 0;
  outline: 0;
  padding: 2px 6px;
  position: absolute;
  transition: opacity 0.3s ease-in-out;
  vertical-align: middle;
  white-space: nowrap;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  user-select: none;
  background: #fff;
  border: 0;
  font-size: 0.8125em;
  right: 0;
  top: 0;
}
pre,
.highlight {
  background: #f7f7f7;
  color: #4d4d4c;
  line-height: 1.6;
  margin: 0 auto 20px;
}
pre,
code {
  font-family: consolas, Menlo, monospace, "PingFang SC", "Microsoft YaHei";
}
code {
  background: #eee;
  border-radius: 3px;
  color: #555;
  padding: 2px 4px;
  overflow-wrap: break-word;
  word-wrap: break-word;
}
pre {
  overflow: auto;
  padding: 10px;
}
pre code {
  background: none;
  color: #4d4d4c;
  font-size: 0.875em;
  padding: 0;
  text-shadow: none;
}
.highlight *::selection {
  background: #d6d6d6;
}
.highlight pre {
  border: 0;
  margin: 0;
  padding: 10px 0;
}
.highlight table {
  border: 0;
  margin: 0;
  width: auto;
}
.highlight td {
  border: 0;
  padding: 0;
}
.highlight figcaption {
  background: #eee;
  color: #4d4d4c;
  line-height: 1em;
  margin: 0;
  padding: 0.5em;
}
.highlight figcaption::before,
.highlight figcaption::after {
  content: ' ';
  display: table;
}
.highlight figcaption::after {
  clear: both;
}
.highlight figcaption a {
  color: #4d4d4c;
  float: right;
}
.highlight figcaption a:hover {
  border-bottom-color: #4d4d4c;
}
.highlight .gutter pre {
  background: #eff2f3;
  color: #869194;
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
}
.highlight .code pre {
  background: #f7f7f7;
  padding-left: 10px;
  width: 100%;
}
.gutter {
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  user-select: none;
}
.gist table {
  width: auto;
}
.gist table td {
  border: 0;
}
pre .deletion {
  background: #fdd;
}
pre .addition {
  background: #dfd;
}
pre .meta {
  color: #eab700;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  user-select: none;
}
pre .comment {
  color: #8e908c;
}
pre .variable,
pre .attribute,
pre .tag,
pre .name,
pre .regexp,
pre .ruby .constant,
pre .xml .tag .title,
pre .xml .pi,
pre .xml .doctype,
pre .html .doctype,
pre .css .id,
pre .css .class,
pre .css .pseudo {
  color: #c82829;
}
pre .number,
pre .preprocessor,
pre .built_in,
pre .builtin-name,
pre .literal,
pre .params,
pre .constant,
pre .command {
  color: #f5871f;
}
pre .ruby .class .title,
pre .css .rules .attribute,
pre .string,
pre .symbol,
pre .value,
pre .inheritance,
pre .header,
pre .ruby .symbol,
pre .xml .cdata,
pre .special,
pre .formula {
  color: #718c00;
}
pre .title,
pre .css .hexcolor {
  color: #3e999f;
}
pre .function,
pre .python .decorator,
pre .python .title,
pre .ruby .function .title,
pre .ruby .title .keyword,
pre .perl .sub,
pre .javascript .title,
pre .coffeescript .title {
  color: #4271ae;
}
pre .keyword,
pre .javascript .function {
  color: #8959a8;
}
.blockquote-center {
  border-left: none;
  margin: 40px 0;
  padding: 0;
  position: relative;
  text-align: center;
}
.blockquote-center::before,
.blockquote-center::after {
  background-repeat: no-repeat;
  background-size: 22px 22px;
  content: ' ';
  display: block;
  height: 24px;
  opacity: 0.2;
  position: absolute;
  width: 100%;
}
.blockquote-center::before {
  background-image: url("../images/quote-l.svg");
  background-position: 0 -6px;
  border-top: 1px solid #ccc;
  top: -20px;
}
.blockquote-center::after {
  background-image: url("../images/quote-r.svg");
  background-position: 100% 8px;
  border-bottom: 1px solid #ccc;
  bottom: -20px;
}
.blockquote-center p,
.blockquote-center div {
  text-align: center;
}
.post-body .group-picture img {
  border: 0;
  margin: 0 auto;
  padding: 0 3px;
}
.post-body .group-picture-row {
  margin-bottom: 6px;
  overflow: hidden;
}
.post-body .group-picture-column {
  float: left;
  margin-bottom: 10px;
}
.post-body .label {
  display: inline;
  padding: 0 2px;
}
.post-body .label.default {
  background: #f0f0f0;
}
.post-body .label.primary {
  background: #efe6f7;
}
.post-body .label.info {
  background: #e5f2f8;
}
.post-body .label.success {
  background: #e7f4e9;
}
.post-body .label.warning {
  background: #fcf6e1;
}
.post-body .label.danger {
  background: #fae8eb;
}
.post-body .tabs {
  margin-bottom: 20px;
}
.post-body .tabs,
.tabs-comment {
  display: block;
  padding-top: 10px;
  position: relative;
}
.post-body .tabs ul.nav-tabs,
.tabs-comment ul.nav-tabs {
  display: flex;
  flex-wrap: wrap;
  margin: 0;
  margin-bottom: -1px;
  padding: 0;
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs,
  .tabs-comment ul.nav-tabs {
    display: block;
    margin-bottom: 5px;
  }
}
.post-body .tabs ul.nav-tabs li.tab,
.tabs-comment ul.nav-tabs li.tab {
  background: #fff;
  border-bottom: 1px solid #ddd;
  border-left: 1px solid transparent;
  border-right: 1px solid transparent;
  border-top: 3px solid transparent;
  flex-grow: 1;
  list-style-type: none;
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs li.tab,
  .tabs-comment ul.nav-tabs li.tab {
    border-bottom: 1px solid transparent;
    border-left: 3px solid transparent;
    border-right: 1px solid transparent;
    border-top: 1px solid transparent;
  }
}
.post-body .tabs ul.nav-tabs li.tab a,
.tabs-comment ul.nav-tabs li.tab a {
  border-bottom: initial;
  display: block;
  line-height: 1.8em;
  outline: 0;
  padding: 0.25em 0.75em;
  text-align: center;
  transition-delay: 0s;
  transition-duration: 0.2s;
  transition-timing-function: ease-out;
}
.post-body .tabs ul.nav-tabs li.tab a i,
.tabs-comment ul.nav-tabs li.tab a i {
  width: 1.285714285714286em;
}
.post-body .tabs ul.nav-tabs li.tab.active,
.tabs-comment ul.nav-tabs li.tab.active {
  border-bottom: 1px solid transparent;
  border-left: 1px solid #ddd;
  border-right: 1px solid #ddd;
  border-top: 3px solid #fc6423;
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs li.tab.active,
  .tabs-comment ul.nav-tabs li.tab.active {
    border-bottom: 1px solid #ddd;
    border-left: 3px solid #fc6423;
    border-right: 1px solid #ddd;
    border-top: 1px solid #ddd;
  }
}
.post-body .tabs ul.nav-tabs li.tab.active a,
.tabs-comment ul.nav-tabs li.tab.active a {
  color: #555;
  cursor: default;
}
.post-body .tabs .tab-content .tab-pane,
.tabs-comment .tab-content .tab-pane {
  border: 1px solid #ddd;
  padding: 20px 20px 0 20px;
}
.post-body .tabs .tab-content .tab-pane:not(.active),
.tabs-comment .tab-content .tab-pane:not(.active) {
  display: none;
}
.post-body .tabs .tab-content .tab-pane.active,
.tabs-comment .tab-content .tab-pane.active {
  display: block;
}
.post-body .note {
  margin-bottom: 20px;
  padding: 15px;
  position: relative;
  border: 1px solid #eee;
  border-left-width: 5px;
  border-radius: 3px;
}
.post-body .note h2,
.post-body .note h3,
.post-body .note h4,
.post-body .note h5,
.post-body .note h6 {
  margin-top: 0;
  border-bottom: initial;
  margin-bottom: 0;
  padding-top: 0;
}
.post-body .note p:first-child,
.post-body .note ul:first-child,
.post-body .note ol:first-child,
.post-body .note table:first-child,
.post-body .note pre:first-child,
.post-body .note blockquote:first-child,
.post-body .note img:first-child {
  margin-top: 0;
}
.post-body .note p:last-child,
.post-body .note ul:last-child,
.post-body .note ol:last-child,
.post-body .note table:last-child,
.post-body .note pre:last-child,
.post-body .note blockquote:last-child,
.post-body .note img:last-child {
  margin-bottom: 0;
}
.post-body .note.default {
  border-left-color: #777;
}
.post-body .note.default h2,
.post-body .note.default h3,
.post-body .note.default h4,
.post-body .note.default h5,
.post-body .note.default h6 {
  color: #777;
}
.post-body .note.primary {
  border-left-color: #6f42c1;
}
.post-body .note.primary h2,
.post-body .note.primary h3,
.post-body .note.primary h4,
.post-body .note.primary h5,
.post-body .note.primary h6 {
  color: #6f42c1;
}
.post-body .note.info {
  border-left-color: #428bca;
}
.post-body .note.info h2,
.post-body .note.info h3,
.post-body .note.info h4,
.post-body .note.info h5,
.post-body .note.info h6 {
  color: #428bca;
}
.post-body .note.success {
  border-left-color: #5cb85c;
}
.post-body .note.success h2,
.post-body .note.success h3,
.post-body .note.success h4,
.post-body .note.success h5,
.post-body .note.success h6 {
  color: #5cb85c;
}
.post-body .note.warning {
  border-left-color: #f0ad4e;
}
.post-body .note.warning h2,
.post-body .note.warning h3,
.post-body .note.warning h4,
.post-body .note.warning h5,
.post-body .note.warning h6 {
  color: #f0ad4e;
}
.post-body .note.danger {
  border-left-color: #d9534f;
}
.post-body .note.danger h2,
.post-body .note.danger h3,
.post-body .note.danger h4,
.post-body .note.danger h5,
.post-body .note.danger h6 {
  color: #d9534f;
}
.pagination .prev,
.pagination .next,
.pagination .page-number,
.pagination .space {
  display: inline-block;
  margin: 0 10px;
  padding: 0 11px;
  position: relative;
  top: -1px;
}
@media (max-width: 767px) {
  .pagination .prev,
  .pagination .next,
  .pagination .page-number,
  .pagination .space {
    margin: 0 5px;
  }
}
.pagination {
  border-top: 1px solid #eee;
  margin: 120px 0 0;
  text-align: center;
}
.pagination .prev,
.pagination .next,
.pagination .page-number {
  border-bottom: 0;
  border-top: 1px solid #eee;
  transition-property: border-color;
  transition-delay: 0s;
  transition-duration: 0.2s;
  transition-timing-function: ease-in-out;
}
.pagination .prev:hover,
.pagination .next:hover,
.pagination .page-number:hover {
  border-top-color: #222;
}
.pagination .space {
  margin: 0;
  padding: 0;
}
.pagination .prev {
  margin-left: 0;
}
.pagination .next {
  margin-right: 0;
}
.pagination .page-number.current {
  background: #ccc;
  border-top-color: #ccc;
  color: #fff;
}
@media (max-width: 767px) {
  .pagination {
    border-top: none;
  }
  .pagination .prev,
  .pagination .next,
  .pagination .page-number {
    border-bottom: 1px solid #eee;
    border-top: 0;
    margin-bottom: 10px;
    padding: 0 10px;
  }
  .pagination .prev:hover,
  .pagination .next:hover,
  .pagination .page-number:hover {
    border-bottom-color: #222;
  }
}
.comments {
  margin: 60px 20px 0;
  overflow: hidden;
}
.comment-button-group {
  display: flex;
  flex-wrap: wrap-reverse;
  justify-content: center;
  margin: 1em 0;
}
.comment-button-group .comment-button {
  margin: 0.1em 0.2em;
}
.comment-button-group .comment-button.active {
  background: #222;
  border-color: #222;
  color: #fff;
}
.comment-position {
  display: none;
}
.comment-position.active {
  display: block;
}
.tabs-comment {
  background: #fff;
  margin-top: 4em;
  padding-top: 0;
}
.tabs-comment .comments {
  border: 0;
  box-shadow: none;
  margin-top: 0;
  padding-top: 0;
}
.container {
  min-height: 100%;
  position: relative;
}
.main-inner {
  margin: 0 auto;
  width: calc(100% - 20px);
}
@media (min-width: 1200px) {
  .main-inner {
    width: 1160px;
  }
}
@media (min-width: 1600px) {
  .main-inner {
    width: 73%;
  }
}
.header {
  background: transparent;
}
.header-inner {
  margin: 0 auto;
  position: relative;
  width: calc(100% - 20px);
}
@media (min-width: 1200px) {
  .header-inner {
    width: 1160px;
  }
}
@media (min-width: 1600px) {
  .header-inner {
    width: 73%;
  }
}
.headband {
  background: #222;
  height: 3px;
}
.site-meta {
  margin: 0;
  text-align: center;
}
@media (max-width: 767px) {
  .site-meta {
    text-align: center;
  }
}
.brand {
  background: #222;
  border-bottom: none;
  color: #fff;
  display: inline-block;
  line-height: 1.375em;
  padding: 0 40px;
  position: relative;
}
.brand:hover {
  color: #fff;
}
.site-title {
  display: inline-block;
  font-family: 'Roboto', "PingFang SC", "Microsoft YaHei", sans-serif;
  font-size: 1.375em;
  font-weight: normal;
  line-height: 1.5;
  vertical-align: top;
}
.site-subtitle {
  color: #ddd;
  font-size: 0.8125em;
  margin-top: 10px;
}
.use-motion .brand {
  opacity: 0;
}
.use-motion .site-title,
.use-motion .site-subtitle,
.use-motion .custom-logo-image {
  opacity: 0;
  position: relative;
  top: -10px;
}
.site-nav-toggle {
  display: none;
  left: 10px;
  position: absolute;
}
@media (max-width: 767px) {
  .site-nav-toggle {
    display: block;
  }
}
.site-nav-toggle .toggle {
  background: transparent;
  border: 0;
  margin-top: 2px;
  padding: 10px;
  width: 22px;
}
.site-nav-toggle .toggle .toggle-line {
  background: #555;
  border-radius: 1px;
}
.site-nav {
  display: block;
}
@media (max-width: 767px) {
  .site-nav {
    border-top: 1px solid #ddd;
    clear: both;
    display: none;
    margin: 0 -10px;
    padding: 0 10px;
  }
}
.site-nav.site-nav-on {
  display: block;
}
.menu {
  margin-top: 20px;
  padding-left: 0;
  text-align: center;
}
.menu-item {
  display: inline-block;
  list-style: none;
  margin: 0 10px;
}
@media (max-width: 767px) {
  .menu-item {
    margin-top: 10px;
  }
}
.menu-item a,
.menu-item span.exturl {
  border-bottom: 0;
  display: block;
  font-size: 0.8125em;
  transition-property: border-color;
  transition-delay: 0s;
  transition-duration: 0.2s;
  transition-timing-function: ease-in-out;
}
@media (hover: none) {
  .menu-item a:hover,
  .menu-item span.exturl:hover {
    border-bottom-color: transparent !important;
  }
}
.menu-item .fa {
  margin-right: 8px;
}
.menu-item .badge {
  display: inline-block;
  font-weight: 700;
  line-height: 1;
  margin-left: 0.35em;
  margin-top: 0.35em;
  text-align: center;
  white-space: nowrap;
}
@media (max-width: 767px) {
  .menu-item .badge {
    float: right;
    margin-left: 0;
  }
}
.use-motion .menu-item {
  opacity: 0;
}
.github-corner :hover .octo-arm {
  animation: octocat-wave 560ms ease-in-out;
}
.github-corner svg {
  border: 0;
  color: #fff;
  fill: #222;
  position: absolute;
  right: 0;
  top: 0;
  z-index: 1000;
}
@media (max-width: 991px) {
  .github-corner svg {
    color: #222;
    fill: #fff;
  }
  .github-corner .github-corner:hover .octo-arm {
    animation: none;
  }
  .github-corner .github-corner .octo-arm {
    animation: octocat-wave 560ms ease-in-out;
  }
}
@-moz-keyframes octocat-wave {
  0%, 100% {
    transform: rotate(0);
  }
  20%, 60% {
    transform: rotate(-25deg);
  }
  40%, 80% {
    transform: rotate(10deg);
  }
}
@-webkit-keyframes octocat-wave {
  0%, 100% {
    transform: rotate(0);
  }
  20%, 60% {
    transform: rotate(-25deg);
  }
  40%, 80% {
    transform: rotate(10deg);
  }
}
@-o-keyframes octocat-wave {
  0%, 100% {
    transform: rotate(0);
  }
  20%, 60% {
    transform: rotate(-25deg);
  }
  40%, 80% {
    transform: rotate(10deg);
  }
}
@keyframes octocat-wave {
  0%, 100% {
    transform: rotate(0);
  }
  20%, 60% {
    transform: rotate(-25deg);
  }
  40%, 80% {
    transform: rotate(10deg);
  }
}
.sidebar {
  background: #222;
  bottom: 0;
  box-shadow: inset 0 2px 6px #000;
  position: fixed;
  top: 0;
  z-index: 1200;
}
.sidebar a,
.sidebar span.exturl {
  border-bottom-color: #555;
  color: #999;
}
.sidebar a:hover,
.sidebar span.exturl:hover {
  border-bottom-color: #eee;
  color: #eee;
}
@media (max-width: 991px) {
  .sidebar {
    display: none;
  }
}
.sidebar-inner {
  color: #999;
  padding: 20px 10px;
  text-align: center;
}
.site-overview-wrap {
  overflow-x: hidden;
  overflow-y: auto;
}
.cc-license {
  margin-top: 10px;
  text-align: center;
}
.cc-license .cc-opacity {
  border-bottom: none;
  opacity: 0.7;
}
.cc-license .cc-opacity:hover {
  opacity: 0.9;
}
.cc-license img {
  display: inline-block;
}
.site-author-image {
  border: 1px solid #eee;
  display: block;
  height: auto;
  margin: 0 auto;
  max-width: 120px;
  padding: 2px;
  border-radius: 50%;
}
.site-author-name {
  color: #222;
  font-weight: 600;
  margin: 0;
  text-align: center;
}
.site-description {
  color: #999;
  font-size: 0.8125em;
  margin-top: 0;
  text-align: center;
}
.links-of-author {
  margin-top: 15px;
}
.links-of-author a,
.links-of-author span.exturl {
  border-bottom-color: #555;
  display: inline-block;
  font-size: 0.8125em;
  margin-bottom: 10px;
  margin-right: 10px;
  vertical-align: middle;
  transition-delay: 0s;
  transition-duration: 0.2s;
  transition-timing-function: ease-in-out;
}
.links-of-author a::before,
.links-of-author span.exturl::before {
  background: #ff4e14;
  border-radius: 50%;
  content: ' ';
  display: inline-block;
  height: 4px;
  margin-right: 3px;
  vertical-align: middle;
  width: 4px;
}
.feed-link,
.chat {
  margin-top: 15px;
}
.feed-link a,
.chat a {
  border: 1px solid #fc6423;
  border-radius: 4px;
  color: #fc6423;
  display: inline-block;
  padding: 0 15px;
}
.feed-link a .fa,
.chat a .fa {
  margin-right: 5px;
}
.feed-link a:hover,
.chat a:hover {
  background: #fc6423;
  border: 1px solid #fc6423;
  color: #fff;
}
.feed-link a:hover .fa,
.chat a:hover .fa {
  color: #fff;
}
.links-of-blogroll {
  font-size: 0.8125em;
  margin-top: 10px;
}
.links-of-blogroll-title {
  font-size: 0.875em;
  font-weight: 600;
  margin-top: 0;
}
.links-of-blogroll-list {
  list-style: none;
  margin: 0;
  padding: 0;
}
.links-of-blogroll-item {
  padding: 2px 10px;
}
.links-of-blogroll-item a,
.links-of-blogroll-item span.exturl {
  box-sizing: border-box;
  display: inline-block;
  max-width: 280px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
#sidebar-dimmer {
  display: none;
}
@media (max-width: 767px) {
  #sidebar-dimmer {
    background: #000;
    display: block;
    height: 100%;
    left: 100%;
    opacity: 0;
    position: fixed;
    top: 0;
    width: 100%;
    z-index: 1100;
  }
  .sidebar-active + #sidebar-dimmer {
    opacity: 0.7;
    transform: translateX(-100%);
    transition: opacity 0.5s;
  }
}
.sidebar-nav {
  margin: 0;
  padding-bottom: 20px;
  padding-left: 0;
}
.sidebar-nav li {
  border-bottom: 1px solid transparent;
  color: #555;
  cursor: pointer;
  display: inline-block;
  font-size: 0.875em;
}
.sidebar-nav li.sidebar-nav-overview {
  margin-left: 10px;
}
.sidebar-nav li:hover {
  color: #fc6423;
}
.sidebar-nav .sidebar-nav-active {
  border-bottom-color: #fc6423;
  color: #fc6423;
}
.sidebar-nav .sidebar-nav-active:hover {
  color: #fc6423;
}
.sidebar-panel {
  display: none;
}
.sidebar-panel-active {
  display: block;
}
.sidebar-toggle {
  background: #222;
  bottom: 45px;
  cursor: pointer;
  height: 14px;
  left: 30px;
  padding: 5px;
  position: fixed;
  width: 14px;
  z-index: 1300;
}
@media (max-width: 991px) {
  .sidebar-toggle {
    left: 20px;
    opacity: 0.8;
    display: none;
  }
}
.sidebar-toggle:hover .toggle-line {
  background: #fc6423;
}
.post-toc-wrap {
  overflow-x: hidden;
  overflow-y: auto;
}
.post-toc {
  font-size: 0.875em;
}
.post-toc ol {
  list-style: none;
  margin: 0;
  padding: 0 2px 5px 10px;
  text-align: left;
}
.post-toc ol > ol {
  padding-left: 0;
}
.post-toc ol a {
  border-bottom-color: #ccc;
  color: #666;
  transition-property: all;
  transition-delay: 0s;
  transition-duration: 0.2s;
  transition-timing-function: ease-in-out;
}
.post-toc ol a:hover {
  border-bottom-color: #000;
  color: #000;
}
.post-toc .nav-item {
  line-height: 1.8;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.post-toc .nav .nav-child {
  display: none;
}
.post-toc .nav .active > .nav-child {
  display: block;
}
.post-toc .nav .active-current > .nav-child {
  display: block;
}
.post-toc .nav .active-current > .nav-child > .nav-item {
  display: block;
}
.post-toc .nav .active > a {
  border-bottom-color: #fc6423;
  color: #fc6423;
}
.post-toc .nav .active-current > a {
  color: #fc6423;
}
.post-toc .nav .active-current > a:hover {
  color: #fc6423;
}
.site-state {
  display: flex;
  justify-content: center;
  line-height: 1.4;
  margin-top: 10px;
  overflow: hidden;
  text-align: center;
  white-space: nowrap;
}
.site-state-item {
  padding: 0 15px;
}
.site-state-item:not(:first-child) {
  border-left: 1px solid #eee;
}
.site-state-item a {
  border-bottom: none;
}
.site-state-item-count {
  color: inherit;
  display: block;
  font-size: 1em;
  font-weight: 600;
  text-align: center;
}
.site-state-item-name {
  color: #999;
  font-size: 0.8125em;
}
.footer {
  color: #999;
  font-size: 0.875em;
  padding: 20px 0;
}
.footer.footer-fixed {
  bottom: 0;
  left: 0;
  position: absolute;
  right: 0;
}
.footer img {
  border: 0;
}
.footer-inner {
  box-sizing: border-box;
  margin: 0 auto;
  text-align: center;
  width: calc(100% - 20px);
}
@media (min-width: 1200px) {
  .footer-inner {
    width: 1160px;
  }
}
@media (min-width: 1600px) {
  .footer-inner {
    width: 73%;
  }
}
.with-love {
  color: #ff0000;
  display: inline-block;
  margin: 0 5px;
  animation: iconAnimate 1.33s ease-in-out infinite;
}
.powered-by,
.theme-info {
  display: inline-block;
}
@-moz-keyframes iconAnimate {
  0%, 100% {
    transform: scale(1);
  }
  10%, 30% {
    transform: scale(0.9);
  }
  20%, 40%, 60%, 80% {
    transform: scale(1.1);
  }
  50%, 70% {
    transform: scale(1.1);
  }
}
@-webkit-keyframes iconAnimate {
  0%, 100% {
    transform: scale(1);
  }
  10%, 30% {
    transform: scale(0.9);
  }
  20%, 40%, 60%, 80% {
    transform: scale(1.1);
  }
  50%, 70% {
    transform: scale(1.1);
  }
}
@-o-keyframes iconAnimate {
  0%, 100% {
    transform: scale(1);
  }
  10%, 30% {
    transform: scale(0.9);
  }
  20%, 40%, 60%, 80% {
    transform: scale(1.1);
  }
  50%, 70% {
    transform: scale(1.1);
  }
}
@keyframes iconAnimate {
  0%, 100% {
    transform: scale(1);
  }
  10%, 30% {
    transform: scale(0.9);
  }
  20%, 40%, 60%, 80% {
    transform: scale(1.1);
  }
  50%, 70% {
    transform: scale(1.1);
  }
}
.back-to-top {
  background: #eee;
  font-size: 12px;
  margin: 8px -10px -20px;
  opacity: 0;
  text-align: center;
  transition-delay: 0s;
  transition-duration: 0.2s;
  transition-timing-function: ease-in-out;
}
.back-to-top.back-to-top-on {
  cursor: pointer;
  opacity: 0.6;
}
.back-to-top.back-to-top-on:hover {
  opacity: 0.8;
}
.reading-progress-bar {
  background: #37c6c0;
  display: block;
  height: 3px;
  left: 0;
  position: fixed;
  top: 0;
  width: 0;
  z-index: 1500;
}
.post-body {
  overflow-wrap: break-word;
  word-wrap: break-word;
  font-family: 'Roboto', "PingFang SC", "Microsoft YaHei", sans-serif;
}
@media (min-width: 1200px) {
  .post-body {
    font-size: 1.125em;
  }
}
.post-body span.exturl .fa {
  font-size: 0.875em;
  margin-left: 4px;
}
.post-body .image-caption,
.post-body .figure .caption {
  color: #999;
  font-size: 0.875em;
  font-weight: bold;
  line-height: 1;
  margin: -20px auto 15px;
  text-align: center;
}
.post-sticky-flag {
  display: inline-block;
  transform: rotate(30deg);
}
.post-button {
  margin-top: 40px;
  text-align: center;
}
.use-motion .post-block,
.use-motion .pagination,
.use-motion .comments {
  opacity: 0;
}
.use-motion .post-header {
  opacity: 0;
}
.use-motion .post-body {
  opacity: 0;
}
.use-motion .collection-header {
  opacity: 0;
}
.posts-collapse {
  margin-left: 55px;
  position: relative;
}
@media (max-width: 767px) {
  .posts-collapse {
    margin-left: 20px;
    margin-right: 20px;
  }
}
.posts-collapse .collection-title {
  font-size: 1.125em;
  position: relative;
}
.posts-collapse .collection-title::before {
  background: #999;
  border: 1px solid #fff;
  border-radius: 50%;
  content: ' ';
  height: 10px;
  left: 0;
  margin-left: -6px;
  margin-top: -4px;
  position: absolute;
  top: 50%;
  width: 10px;
}
.posts-collapse .collection-year {
  margin: 60px 0;
  position: relative;
}
.posts-collapse .collection-year::before {
  background: #bbb;
  border-radius: 50%;
  content: ' ';
  height: 8px;
  left: 0;
  margin-left: -4px;
  margin-top: -4px;
  position: absolute;
  top: 50%;
  width: 8px;
}
.posts-collapse .collection-header {
  display: inline-block;
  margin: 0 0 0 20px;
}
.posts-collapse .collection-header small {
  color: #bbb;
  margin-left: 5px;
}
.posts-collapse .post-header {
  border-bottom: 1px dashed #ccc;
  margin: 30px 0;
  padding-left: 15px;
  position: relative;
  transition-property: border;
  transition-delay: 0s;
  transition-duration: 0.2s;
  transition-timing-function: ease-in-out;
}
.posts-collapse .post-header::before {
  background: #bbb;
  border: 1px solid #fff;
  border-radius: 50%;
  content: ' ';
  height: 6px;
  left: 0;
  margin-left: -4px;
  position: absolute;
  top: 0.75em;
  transition-property: background;
  width: 6px;
  transition-delay: 0s;
  transition-duration: 0.2s;
  transition-timing-function: ease-in-out;
}
.posts-collapse .post-header:hover {
  border-bottom-color: #666;
}
.posts-collapse .post-header:hover::before {
  background: #222;
}
.posts-collapse .post-meta {
  display: inline;
  font-size: 0.75em;
  margin-right: 10px;
}
.posts-collapse .post-title {
  display: inline;
  font-size: 1em;
  font-weight: normal;
  margin-bottom: 0;
  margin-top: 0;
}
.posts-collapse .post-title a,
.posts-collapse .post-title span.exturl {
  border-bottom: none;
  color: #666;
}
.posts-collapse::before {
  background: #f5f5f5;
  content: ' ';
  height: 100%;
  left: 0;
  margin-left: -2px;
  position: absolute;
  top: 1.25em;
  width: 4px;
}
.posts-collapse .fa-external-link {
  font-size: 0.875em;
  margin-left: 5px;
}
.post-eof {
  background: #ccc;
  height: 1px;
  margin: 80px auto 60px;
  text-align: center;
  width: 8%;
}
.post-block:last-child .post-eof {
  display: none;
}
.posts-expand {
  padding-top: 40px;
}
@media (max-width: 767px) {
  .posts-expand {
    margin: 0 20px;
  }
}
@media (min-width: 992px) {
  .post-body {
    text-align: justify;
  }
}
@media (max-width: 991px) {
  .post-body {
    text-align: justify;
  }
}
.post-body h2,
.post-body h3,
.post-body h4,
.post-body h5,
.post-body h6 {
  padding-top: 10px;
}
.post-body h2 .header-anchor,
.post-body h3 .header-anchor,
.post-body h4 .header-anchor,
.post-body h5 .header-anchor,
.post-body h6 .header-anchor {
  border-bottom-style: none;
  color: #ccc;
  float: right;
  margin-left: 10px;
  visibility: hidden;
}
.post-body h2 .header-anchor:hover,
.post-body h3 .header-anchor:hover,
.post-body h4 .header-anchor:hover,
.post-body h5 .header-anchor:hover,
.post-body h6 .header-anchor:hover {
  color: inherit;
}
.post-body h2:hover .header-anchor,
.post-body h3:hover .header-anchor,
.post-body h4:hover .header-anchor,
.post-body h5:hover .header-anchor,
.post-body h6:hover .header-anchor {
  visibility: visible;
}
.post-body img {
  border: 1px solid #ddd;
  box-sizing: border-box;
  padding: 3px;
}
@media (max-width: 767px) {
  .post-body img {
    padding: initial;
  }
}
.post-body iframe,
.post-body img,
.post-body video {
  margin-bottom: 20px;
}
.post-body .video-container {
  height: 0;
  margin-bottom: 20px;
  overflow: hidden;
  padding-top: 75%;
  position: relative;
  width: 100%;
}
.post-body .video-container iframe,
.post-body .video-container object,
.post-body .video-container embed {
  height: 100%;
  left: 0;
  margin: 0;
  position: absolute;
  top: 0;
  width: 100%;
}
.post-gallery {
  border-collapse: separate;
  display: table;
  table-layout: fixed;
  width: 100%;
}
.post-gallery .post-gallery-img {
  border: 0;
  display: table-cell;
  text-align: center;
  vertical-align: middle;
}
.post-gallery .post-gallery-img img {
  border: 0;
  max-height: 100%;
  max-width: 100%;
}
.post-gallery-row {
  display: table-row;
}
.posts-expand .post-header {
  font-size: 1.125em;
}
.posts-expand .post-title {
  overflow-wrap: break-word;
  word-wrap: break-word;
  font-weight: 400;
  margin: initial;
  text-align: center;
}
.posts-expand .post-title-link {
  border-bottom: none;
  color: #555;
  display: inline-block;
  position: relative;
  vertical-align: top;
}
.posts-expand .post-title-link::before {
  background: #000;
  bottom: 0;
  content: '';
  height: 2px;
  left: 0;
  position: absolute;
  transform: scaleX(0);
  visibility: hidden;
  width: 100%;
  transition-delay: 0s;
  transition-duration: 0.2s;
  transition-timing-function: ease-in-out;
}
.posts-expand .post-title-link:hover::before {
  transform: scaleX(1);
  visibility: visible;
}
.posts-expand .post-title-link .fa {
  font-size: 0.875em;
  margin-left: 5px;
}
.posts-expand .post-meta {
  color: #999;
  font-family: 'Roboto', "PingFang SC", "Microsoft YaHei", sans-serif;
  font-size: 0.75em;
  margin: 3px 0 60px 0;
  text-align: center;
}
.posts-expand .post-meta .post-description {
  font-size: 0.875em;
  margin-top: 2px;
}
.posts-expand .post-meta time {
  border-bottom: 1px dashed #999;
  cursor: pointer;
}
.post-meta .post-meta-item + .post-meta-item::before {
  content: '|';
  margin: 0 0.5em;
}
.post-meta-divider {
  margin: 0 0.5em;
}
.post-meta-item-icon {
  margin-right: 3px;
}
@media (max-width: 991px) {
  .post-meta-item-icon {
    display: inline-block;
  }
}
@media (max-width: 991px) {
  .post-meta-item-text {
    display: none;
  }
}
.post-nav {
  border-top: 1px solid #eee;
  display: table;
  margin-top: 15px;
  width: 100%;
}
.post-nav-divider {
  display: table-cell;
  width: 10%;
}
.post-nav-item {
  display: table-cell;
  padding: 10px 0 0 0;
  vertical-align: top;
  width: 45%;
}
.post-nav-item a {
  border-bottom: none;
  color: #555;
  display: block;
  font-size: 0.875em;
  line-height: 1.6;
  position: relative;
}
.post-nav-item a:hover {
  border-bottom: none;
  color: #222;
}
.post-nav-item a:active {
  top: 2px;
}
.post-nav-item .fa {
  font-size: 0.75em;
  margin-right: 5px;
}
.post-nav-prev a {
  padding-left: 5px;
}
.post-nav-next {
  text-align: right;
}
.post-nav-next a {
  padding-right: 5px;
}
.post-nav-next .fa {
  margin-left: 5px;
}
.rtl.post-body p,
.rtl.post-body a,
.rtl.post-body h1,
.rtl.post-body h2,
.rtl.post-body h3,
.rtl.post-body h4,
.rtl.post-body h5,
.rtl.post-body h6,
.rtl.post-body li,
.rtl.post-body ul,
.rtl.post-body ol {
  direction: rtl;
  font-family: UKIJ Ekran;
}
.rtl.post-title {
  font-family: UKIJ Ekran;
}
.post-tags {
  margin-top: 40px;
  text-align: center;
}
.post-tags a {
  display: inline-block;
  font-size: 0.8125em;
}
.post-tags a:not(:last-child) {
  margin-right: 10px;
}
.post-widgets {
  border-top: 1px solid #eee;
  margin-top: 15px;
  text-align: center;
}
.wp_rating {
  height: 20px;
  line-height: 20px;
  margin-top: 10px;
  padding-top: 6px;
  text-align: center;
}
.social-like {
  display: flex;
  font-size: 0.875em;
  justify-content: center;
  text-align: center;
}
.reward-container {
  margin: 20px auto;
  padding: 10px 0;
  text-align: center;
  width: 90%;
}
.reward-container button {
  background: #ff2a2a;
  border: 0;
  border-radius: 5px;
  color: #fff;
  cursor: pointer;
  display: inline-block;
  letter-spacing: normal;
  line-height: 2;
  margin: 0;
  outline: 0;
  padding: 0 15px;
  text-indent: 0;
  text-shadow: none;
  text-transform: none;
  vertical-align: text-top;
}
.reward-container button:hover {
  background: #f55;
}
#qr {
  padding-top: 20px;
}
#qr a {
  border: 0;
}
#qr img {
  display: inline-block;
  margin: 0.8em 2em 0 2em;
  max-width: 100%;
  width: 180px;
}
#qr p {
  text-align: center;
}
.category-all-page .category-all-title {
  text-align: center;
}
.category-all-page .category-all {
  margin-top: 20px;
}
.category-all-page .category-list {
  list-style: none;
  margin: 0;
  padding: 0;
}
.category-all-page .category-list-item {
  margin: 5px 10px;
}
.category-all-page .category-list-count {
  color: #bbb;
}
.category-all-page .category-list-count::before {
  content: ' (';
  display: inline;
}
.category-all-page .category-list-count::after {
  content: ') ';
  display: inline;
}
.category-all-page .category-list-child {
  padding-left: 10px;
}
.event-list {
  padding: 0;
}
.event-list hr {
  background: #222;
  margin: 20px 0 45px 0;
}
.event-list hr::after {
  background: #222;
  color: #fff;
  content: 'NOW';
  display: inline-block;
  font-weight: bold;
  padding: 0 5px;
  text-align: right;
}
.event-list .event {
  background: #222;
  margin: 20px 0;
  min-height: 40px;
  padding: 15px 0 15px 10px;
}
.event-list .event .event-summary {
  color: #fff;
  margin: 0;
  padding-bottom: 3px;
}
.event-list .event .event-summary::before {
  animation: dot-flash 1s alternate infinite ease-in-out;
  color: #fff;
  content: '\f111';
  display: inline-block;
  font-family: 'FontAwesome';
  font-size: 10px;
  margin-right: 25px;
  vertical-align: middle;
}
.event-list .event .event-relative-time {
  color: #bbb;
  display: inline-block;
  font-size: 12px;
  font-weight: 400;
  padding-left: 12px;
}
.event-list .event .event-details {
  color: #fff;
  display: block;
  line-height: 18px;
  margin-left: 56px;
  padding-bottom: 6px;
  padding-top: 3px;
  text-indent: -24px;
}
.event-list .event .event-details::before {
  color: #fff;
  display: inline-block;
  font-family: 'FontAwesome';
  margin-right: 9px;
  text-align: center;
  text-indent: 0;
  width: 14px;
}
.event-list .event .event-details.event-location::before {
  content: '\f041';
}
.event-list .event .event-details.event-duration::before {
  content: '\f017';
}
.event-list .event-past {
  background: #f5f5f5;
}
.event-list .event-past .event-summary,
.event-list .event-past .event-details {
  color: #bbb;
  opacity: 0.9;
}
.event-list .event-past .event-summary::before,
.event-list .event-past .event-details::before {
  animation: none;
  color: #bbb;
}
@-moz-keyframes dot-flash {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}
@-webkit-keyframes dot-flash {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}
@-o-keyframes dot-flash {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}
@keyframes dot-flash {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}
ul.breadcrumb {
  font-size: 0.75em;
  list-style: none;
  margin: 1em 0;
  padding: 0 2em;
  text-align: center;
}
ul.breadcrumb li {
  display: inline;
}
ul.breadcrumb li + li::before {
  content: '/\00a0';
  font-weight: normal;
  padding: 0.5em;
}
ul.breadcrumb li + li:last-child {
  font-weight: bold;
}
.tag-cloud {
  text-align: center;
}
.tag-cloud a {
  display: inline-block;
  margin: 10px;
}
.tag-cloud a:hover {
  color: #222 !important;
}
.search-pop-overlay {
  background: rgba(0,0,0,0.3);
  display: none;
  height: 100%;
  left: 0;
  overflow: hidden;
  position: fixed;
  top: 0;
  width: 100%;
  z-index: 1400;
}
.search-popup {
  background: #fff;
  border-radius: 5px;
  color: #333;
  display: none;
  height: 80%;
  left: 50%;
  margin-left: -350px;
  padding: 0;
  position: fixed;
  top: 10%;
  width: 700px;
  z-index: 1500;
}
@media (max-width: 767px) {
  .search-popup {
    border-radius: 0;
    height: 100%;
    left: 0;
    margin: 0;
    padding: 0;
    top: 0;
    width: 100%;
  }
}
.search-popup .search-icon,
.search-popup .popup-btn-close {
  color: #999;
  display: inline-block;
  font-size: 18px;
  height: 36px;
  padding-left: 10px;
  padding-right: 10px;
  width: 18px;
}
.search-popup .popup-btn-close {
  border-left: 1px solid #eee;
  cursor: pointer;
  float: right;
}
.search-popup .popup-btn-close:hover .fa {
  color: #222;
}
.search-popup .search-header {
  background: #f5f5f5;
  border-top-left-radius: 5px;
  border-top-right-radius: 5px;
  padding: 5px;
}
.search-loading-icon {
  margin: 20% auto 0 auto;
  text-align: center;
}
.search-popup ul.search-result-list {
  margin: 0 5px;
  padding: 0;
}
.search-popup p.search-result {
  border-bottom: 1px dashed #ccc;
  padding: 5px 0;
}
.search-popup a.search-result-title {
  font-weight: bold;
}
.search-popup .search-keyword {
  border-bottom: 1px dashed #ff2a2a;
  color: #ff2a2a;
  font-weight: bold;
}
.search-popup #search-result {
  height: calc(100% - 55px);
  overflow: auto;
  padding: 5px 25px;
  position: relative;
}
.search-popup .search-input-container {
  display: inline-block;
  height: 36px;
  line-height: 36px;
  padding: 0 5px;
  position: absolute;
  width: calc(100% - 90px);
}
.search-popup .search-input-container input {
  background: transparent;
  border: 0;
  display: block;
  height: 20px;
  outline: 0;
  padding: 8px 0;
  vertical-align: middle;
  width: 100%;
}
.search-popup #no-result {
  color: #ccc;
  left: 50%;
  position: absolute;
  top: 50%;
  transform: translate(-50%, -50%);
}
body {
  overscroll-behavior: none;
}
@media screen and (-webkit-min-device-pixel-ratio: 0) {
  body::before {
    animation: rainbow 15s ease infinite;
    background: linear-gradient(124deg, #f00, #ff7f00, #ff0, #7fff00, #0f0, #00ff7f, #0ff, #007fff, #00f, #7f00ff, #f0f, #ff007f, #f00);
    background-size: 1000% 1000%;
    content: '';
    display: block;
    height: 100px;
    left: 0;
    position: fixed;
    right: 0;
    top: 0;
    transform: translateY(-99.99px);
    z-index: 1500;
  }
}
@-moz-keyframes rainbow {
  0% {
    background-position: 0 80%;
  }
  50% {
    background-position: 100% 20%;
  }
  100% {
    background-position: 0 80%;
  }
}
@-webkit-keyframes rainbow {
  0% {
    background-position: 0 80%;
  }
  50% {
    background-position: 100% 20%;
  }
  100% {
    background-position: 0 80%;
  }
}
@-o-keyframes rainbow {
  0% {
    background-position: 0 80%;
  }
  50% {
    background-position: 100% 20%;
  }
  100% {
    background-position: 0 80%;
  }
}
@keyframes rainbow {
  0% {
    background-position: 0 80%;
  }
  50% {
    background-position: 100% 20%;
  }
  100% {
    background-position: 0 80%;
  }
}
.header {
  margin: 0 auto;
  position: relative;
  width: calc(100% - 20px);
}
@media (min-width: 1200px) {
  .header {
    width: 1160px;
  }
}
@media (min-width: 1600px) {
  .header {
    width: 73%;
  }
}
@media (max-width: 991px) {
  .header {
    width: auto;
  }
}
.header-inner {
  background: #fff;
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);
  overflow: hidden;
  padding: 0;
  position: absolute;
  top: 0;
  width: 240px;
}
@media (min-width: 1200px) {
  .header-inner {
    width: 240px;
  }
}
@media (max-width: 991px) {
  .header-inner {
    border-radius: initial;
    position: relative;
    width: auto;
  }
}
.main::before,
.main::after {
  content: ' ';
  display: table;
}
.main::after {
  clear: both;
}
@media (max-width: 991px) {
  .main-inner {
    width: auto;
  }
}
.content-wrap {
  background: #fff;
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);
  box-sizing: border-box;
  float: right;
  padding: 40px;
  width: calc(100% - 252px);
}
@media (max-width: 991px) {
  .content-wrap {
    border-radius: initial;
    padding: 20px;
    width: 100%;
  }
}
.sidebar {
  background: #eee;
  box-shadow: none;
  float: left;
  position: static;
  width: 240px;
}
@media (max-width: 991px) {
  .sidebar {
    display: none;
  }
}
.sidebar-toggle {
  display: none;
}
.footer-inner {
  padding-left: 260px;
}
.back-to-top {
  left: auto;
  right: 30px;
}
@media (max-width: 991px) {
  .back-to-top {
    right: 20px;
  }
}
@media (max-width: 991px) {
  .footer-inner {
    padding-left: 0;
    padding-right: 0;
    width: auto;
  }
}
.site-brand-container {
  position: relative;
}
.site-meta {
  background: #222;
  color: #fff;
  padding: 20px 0;
}
@media (max-width: 991px) {
  .site-meta {
    box-shadow: 0 0 16px rgba(0,0,0,0.5);
  }
}
.brand {
  background: none;
  padding: 0;
}
.brand:hover {
  color: #fff;
}
.site-subtitle {
  font-weight: initial;
  margin: 10px 10px 0;
}
.custom-logo-image {
  margin-top: 20px;
}
@media (max-width: 991px) {
  .custom-logo-image {
    display: none;
  }
}
.site-nav-toggle {
  left: 20px;
  top: 50%;
  transform: translateY(-50%);
}
@media (min-width: 768px) and (max-width: 991px) {
  .site-nav-toggle {
    display: block;
  }
}
.site-nav-toggle .toggle .toggle-line {
  background: #fff;
}
.site-nav {
  border-top: none;
}
@media (min-width: 768px) and (max-width: 991px) {
  .site-nav {
    display: none;
  }
}
.menu-item-active a,
.menu .menu-item a:hover,
.menu .menu-item span.exturl:hover {
  background: #f5f5f5;
}
.menu-item-active a::after,
.menu .menu-item a:hover::after,
.menu .menu-item span.exturl:hover::after {
  background: #bbb;
  border-radius: 50%;
  content: ' ';
  height: 6px;
  margin-top: -3px;
  position: absolute;
  right: 15px;
  top: 50%;
  width: 6px;
}
.menu .menu-item {
  display: block;
  margin: 0;
}
.menu .menu-item a,
.menu .menu-item span.exturl {
  padding: 5px 20px;
  position: relative;
  text-align: left;
  transition-property: background-color;
}
.menu .menu-item .badge {
  background: #ccc;
  border-radius: 10px;
  color: #fff;
  float: right;
  padding: 2px 5px;
  text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
  vertical-align: middle;
}
.sub-menu {
  background: #fff;
  border-bottom: 1px solid #ddd;
  margin: 0;
  padding: 6px 0;
}
.sub-menu .menu-item {
  display: inline-block;
}
.sub-menu .menu-item a,
.sub-menu .menu-item span.exturl {
  margin: 5px 10px;
  padding: initial;
}
.sub-menu .menu-item a:hover,
.sub-menu .menu-item span.exturl:hover {
  background: initial;
  color: #fc6423;
}
.sub-menu .menu-item a::after,
.sub-menu .menu-item span.exturl::after {
  content: initial !important;
}
.sub-menu .menu-item-active a {
  background: #fff;
  border-bottom-color: #fc6423;
  color: #fc6423;
}
.sub-menu .menu-item-active a:hover {
  background: #fff;
  border-bottom-color: #fc6423;
}
.sidebar {
  bottom: auto;
  right: auto;
}
.sidebar a,
.sidebar span.exturl {
  color: #555;
}
.sidebar a:hover,
.sidebar span.exturl:hover {
  border-bottom-color: #222;
  color: #222;
}
.sidebar-inner {
  background: #fff;
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
  box-sizing: border-box;
  color: #555;
  width: 240px;
  opacity: 0;
}
.sidebar-inner.affix {
  position: fixed;
  top: 12px;
}
.sidebar-inner.affix-bottom {
  position: absolute;
}
.site-state-item {
  padding: 0 10px;
}
.feed-link,
.chat {
  border-bottom: 1px dotted #ccc;
  border-top: 1px dotted #ccc;
  margin-top: 10px;
  text-align: center;
}
.feed-link a,
.chat a {
  border: 0;
  color: #fc6423;
  display: block;
}
.feed-link a:hover,
.chat a:hover {
  background: none;
  border: 0;
  color: #e34603;
}
.feed-link a:hover .fa,
.chat a:hover .fa {
  color: #e34603;
}
.links-of-author {
  display: flex;
  flex-wrap: wrap;
  margin-top: 10px;
  justify-content: center;
}
.links-of-author-item {
  margin: 5px 0 0;
}
.links-of-author-item a,
.links-of-author-item span.exturl {
  box-sizing: border-box;
  display: inline-block;
  margin-bottom: 0;
  margin-right: 0;
  max-width: 216px;
  overflow: hidden;
  padding: 0 5px;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.links-of-author-item a,
.links-of-author-item span.exturl {
  border-bottom: none;
  display: block;
  text-decoration: none;
}
.links-of-author-item a::before,
.links-of-author-item span.exturl::before {
  display: none;
}
.links-of-author-item a:hover,
.links-of-author-item span.exturl:hover {
  background: #eee;
  border-radius: 4px;
}
.links-of-author-item .fa {
  margin-right: 2px;
}
.links-of-blogroll-item {
  padding: 0;
}
.content-wrap {
  background: initial;
  box-shadow: initial;
  padding: initial;
}
.post-block {
  background: #fff;
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);
  padding: 40px;
}
.post-block + .post-block {
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
  margin-top: 12px;
}
.comments {
  background: #fff;
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
  margin: auto;
  margin-top: 12px;
  padding: 40px;
}
.tabs-comment {
  margin-top: 1em;
}
.posts-expand {
  padding-top: initial;
}
.post-nav-divider {
  width: 4%;
}
.post-nav-item {
  width: 48%;
}
.post-eof {
  display: none;
}
.pagination {
  background: #fff;
  border-radius: initial;
  border-top: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
  margin: 12px 0 0;
  padding: 10px 0 10px;
}
.pagination .prev,
.pagination .next,
.pagination .page-number {
  margin-bottom: initial;
  top: initial;
}
.main {
  padding-bottom: initial;
}
.footer {
  bottom: auto;
}
.sub-menu {
  border-bottom: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);
}
.sub-menu + .content .post-block {
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
  margin-top: 12px;
}
@media (min-width: 768px) and (max-width: 991px) {
  .sub-menu + .content .post-block {
    margin-top: 10px;
  }
}
@media (max-width: 767px) {
  .sub-menu + .content .post-block {
    margin-top: 8px;
  }
}
.post-body h1,
.post-body h2 {
  border-bottom: 1px solid #eee;
}
.post-body h3 {
  border-bottom: 1px solid #eee;
}
.post-body h4 {
  border-bottom: 1px dotted #eee;
}
@media (min-width: 768px) and (max-width: 991px) {
  .content-wrap {
    padding: 10px;
  }
  .posts-expand {
    margin: initial;
  }
  .posts-expand .post-button {
    margin-top: 20px;
  }
  .post-block {
    border-radius: initial;
    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
    padding: 20px;
  }
  .post-block + .post-block {
    margin-top: 10px;
  }
  .comments {
    margin-top: 10px;
    padding: 10px 20px;
  }
  .pagination {
    margin: 10px 0 0;
  }
}
@media (max-width: 767px) {
  .content-wrap {
    padding: 8px;
  }
  .posts-expand {
    margin: initial;
  }
  .posts-expand .post-button {
    margin: 12px 0;
  }
  .post-block {
    border-radius: initial;
    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
    min-height: auto;
    padding: 12px;
  }
  .post-block + .post-block {
    margin-top: 8px;
  }
  .comments {
    margin-top: 8px;
    padding: 10px 12px;
  }
  .pagination {
    margin: 8px 0 0;
  }
}
</style><noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script type="text/javascript">
    var host = "blog.shixinyu.space";
    if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location.protocol = "https";
</script>
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('//fonts.googleapis.com/css?family=Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext');loadCss('//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css');loadCss('https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css');</script><noscript><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xinyu's Space</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">七窍通了六窍</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-todo">

    <a href="/todo/" rel="section"><i class="fa fa-fw fa-list"></i>Todo</a>

  </li>
        <li class="menu-item menu-item-ascii">

    <a href="/ASCII/" rel="section"><i class="fa fa-fw fa-globe"></i>ASCII</a>

  </li>
        <li class="menu-item menu-item-collection">

    <a href="/collection/" rel="section"><i class="fa fa-fw fa-heart"></i>Collection</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/palemoky" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.shixinyu.space/post/redis-devops/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006tNbRwly1g9hf0u8313j305o05p3ye.jpg">
      <meta itemprop="name" content="Shi Xinyu">
      <meta itemprop="description" content="Learn by doing !">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xinyu's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          《Redis开发与运维》
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 10:31:49" itemprop="dateCreated datePublished" datetime="2019-11-09T10:31:49+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-18 17:09:34" itemprop="dateModified" datetime="2020-03-18T17:09:34+08:00">2020-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/post/redis-devops/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/redis-devops/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8ronsawmbj30ku0aft9d.jpg" alt=""></p>
<a id="more"></a>

<h1 id="第-1-章-初识-Redis"><a href="#第-1-章-初识-Redis" class="headerlink" title="第 1 章 初识 Redis"></a>第 1 章 初识 Redis</h1><p>对于大部分数据库来说，插入行操作的执行速度非常快（插入行只会在硬盘文件末尾进行写入）。不过，对表里面的行进行更新却是一个速度相当慢的操作，因为这种更新除了会引起一次随机读之外，还可能会引起一次随机写。</p>
<h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><ul>
<li>string(Bitmaps &amp; HyperLogLog)</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>zset</li>
</ul>
<h2 id="Redis-提供的功能"><a href="#Redis-提供的功能" class="headerlink" title="Redis 提供的功能"></a>Redis 提供的功能</h2><ul>
<li>键过期</li>
<li>发布订阅（消息系统）</li>
<li>事务</li>
<li>流水线（一批命令一次发送到 Redis，避免网络开销）</li>
<li>Lua 脚本</li>
</ul>
<h2 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h2><ul>
<li>缓存</li>
<li>排行榜</li>
<li>计数器（视频播放数，商品浏览量）</li>
<li>社交（共同好友、粉丝、点赞）</li>
<li>消息队列</li>
<li>共享 Session</li>
<li>限速（如，60s 获取一次手机验证码：<code>redis.set(phoneNum, 1, "EX 60", "NX")</code>）</li>
<li>使用哈希类型模拟关系型数据库（优点：用户信息内聚性较强，占用的键较少；缺点：哈希类型是稀疏的，难以做复杂的关系查询。注意：要控制哈希在 ziplist 和 hashtable 两种内部编码的转换，hashtable 会消耗更多的内存）</li>
</ul>
<h2 id="为什么-Redis-很快？"><a href="#为什么-Redis-很快？" class="headerlink" title="为什么 Redis 很快？"></a>为什么 Redis 很快？</h2><ul>
<li>内存访问</li>
<li>C 语言实现</li>
<li>单线程架构，避免线程切换与竞态产生的消耗</li>
<li>I/O 多路复用模型（epoll）</li>
</ul>
<p>安装软件时，为软件建立软连接是一种好习惯，避免将软件固定在指定版本上，有利于未来软件的版本升级。</p>
<p>Redis 借鉴了 Linux 对于版本号的命名规则：版本号第二位如果是奇数，则为非稳定版本（如 2.7、2.9、3.1），否则为稳定版本（如 2.6、2.8、3.0）</p>
<h2 id="Redis-可执行文件说明"><a href="#Redis-可执行文件说明" class="headerlink" title="Redis 可执行文件说明"></a>Redis 可执行文件说明</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>redis-server</code></td>
<td>启动 Redis</td>
</tr>
<tr>
<td><code>redis-cli</code></td>
<td>Redis 命令行客户端</td>
</tr>
<tr>
<td><code>redis-cli shutdown</code></td>
<td>关闭 Redis</td>
</tr>
<tr>
<td><code>redis-benchmark</code></td>
<td>Redis 基准测试工具</td>
</tr>
<tr>
<td><code>redis-check-of</code></td>
<td>Redis AOF 持久化文件检测与修复工具</td>
</tr>
<tr>
<td><code>redis-check-dump</code></td>
<td>Redis RDB 持久化文件检测与修复工具</td>
</tr>
<tr>
<td><code>redis-sentinel</code></td>
<td>启动 Redis Sentinel</td>
</tr>
</tbody></table>
<h2 id="启动-Redis-的3种方式"><a href="#启动-Redis-的3种方式" class="headerlink" title="启动 Redis 的3种方式"></a>启动 Redis 的3种方式</h2><ol>
<li>默认配置(<code>redis-server</code>)</li>
<li>运行配置(<code>redis-server --port 6380</code>)</li>
<li>配置文件(<code>redis-server /opt/redis/redis.conf</code>)</li>
</ol>
<p>python 的 redis 高性能扩展是 hiredis，PHP 则是 phpredis。</p>
<h1 id="第-2-章-API-的理解和使用"><a href="#第-2-章-API-的理解和使用" class="headerlink" title="第 2 章 API 的理解和使用"></a>第 2 章 API 的理解和使用</h1><table>
<thead>
<tr>
<th>命令</th>
<th>选项</th>
<th>返回值</th>
<th>含义</th>
<th>复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>keys pattern</code></td>
<td>pattern 使用的是 glob 风格的通配符</td>
<td></td>
<td>查看所有键</td>
<td>$O(n)$</td>
<td>大量键时禁止使用</td>
</tr>
<tr>
<td><code>dbsize</code></td>
<td></td>
<td>int（&gt;=0）</td>
<td>键总数</td>
<td>$O(1)$</td>
<td>不遍历键，直接读取内置键总数</td>
</tr>
<tr>
<td><code>exists key</code></td>
<td></td>
<td>intbool（存在为 1，否则为 0）</td>
<td>检查键是否存在</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>del key [key ...]</code></td>
<td></td>
<td>int（成功删除的个数，若删除不存在的键，返回 0）</td>
<td>删除键</td>
<td>$O(k)$，𝑘为键的个数</td>
<td></td>
</tr>
<tr>
<td><code>expire key seconds</code><br><br><code>expireat key timestamp</code><br><br><code>pexpire key milliseconds</code><br><br><code>pexpireat key milliseconds-timestamp</code></td>
<td></td>
<td>boolint（成功为 1，key 不存在或无法设置为 0）</td>
<td>键过期</td>
<td></td>
<td>1. 无论使用哪种形式，在 Redis 内部最终使用的都是<code>pexpireat</code>；<br>2. 如果<code>expire key</code>的键不存在，返回 0;<br>3. 如果过期时间为负值，键会被立即删除，犹如使用了<code>del</code>;<br>4. <code>persist key</code>可以将键的过期时间清除；<br>5. <strong>对于字符串类型键，执行<code>set</code>命令会去掉过期时间</strong>;<br>6. Redis 不支持二级数据结构（哈希、列表）内部元素的过期功能，如不能对列表类型的一个元素做过期时间设置；<br>7. <code>setex</code>作为<code>set</code>+<code>expire</code>的组合，不但是原子执行，同时减少了一次网络通讯的时间</td>
</tr>
<tr>
<td><code>ttl key</code><br><code>pttl key</code></td>
<td></td>
<td>int（&gt;=0：键剩余过期时间；-1：键未设置过期时间；-2：键不存在）</td>
<td>查看键剩余存活时间（秒/毫秒）</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>type key</code></td>
<td></td>
<td>键存在返回数据类型，不存在返回 none</td>
<td>查看键的数据类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>rename key newkey</code><br><code>renamenx key newkey</code></td>
<td></td>
<td>成功返回<code>OK</code>,失败为 0</td>
<td>键重命名</td>
<td></td>
<td>1. 如果在重命名之前，键值已经存在，则值会被覆盖；<br>2. 由于重命名键期间会执行<code>del</code>删除旧键，如果键对应的值较大，可能会被阻塞</td>
</tr>
<tr>
<td><code>randomkey</code></td>
<td></td>
<td></td>
<td>随机返回一个键</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>move key db</code><br><br><code>dump key</code> + <code>restore key ttl value</code><br><br><code>migrate host port key|"" destination-db timeout [copy] [replace] [keys key [key ...]]</code></td>
<td><code>ttl</code>为 0 时表示无过期时间<br><code>host</code>:目标主机<br><code>port</code>:目标端口<br><code>key|""</code>:迁移单个键指定键名，多个键则为空字符串<br><code>destination-db</code>:目标 db 索引<br><code>timeout</code>:迁移的超时时间（毫秒）<br><code>copy</code>:不删除源键<br><code>replace</code>:对目标 Redis 覆写操作。若未指定，源 Redis 和目标 Redis 存在同名键会报错<br><code>keys key [key ...]</code>:迁移的键名</td>
<td></td>
<td>迁移键</td>
<td></td>
<td>方式二中，<code>dump</code>会将键值序列化，格式采用 RDB 格式，在目标 Redis 上，<code>restore</code>再将序列化的值复原<br><br><code>migrate</code>实质上是<code>dump</code>、<code>restore</code>、<code>del</code>三个命令的组合。<code>migrate</code>具有原子性，只需在源 Redis 上执行即可，目标 Redis 完成<code>restore</code>后返回 OK，源 Redis 再根据<code>migrate</code>的对应选项决定是否在源 Redis 上删除对应的键</td>
</tr>
<tr>
<td><code>scan cursor [match pattern] [count number]</code></td>
<td><code>cursor</code>：游标，第一次遍历从0开始，每次<code>scan</code>遍历完都会返回当前游标的值，直到游标值为0，表示遍历结束<br><code>·match pattern</code>：模式匹配<br><code>count number</code>：明每次要遍历的键个数，默认值是10，此参数可以适当增大</td>
<td></td>
<td>渐进式遍历</td>
<td></td>
<td>如果在遍历过程中键发生了变化，则结果可能是不准确的；<br><code>hscan</code> 解决 <code>hgetall</code> 的阻塞<br><code>sscan</code>解决<code>smembers</code> 的阻塞<br><code>zscan</code>解决<code>zrange</code> 的阻塞</td>
</tr>
<tr>
<td><code>select dbIndex</code></td>
<td></td>
<td></td>
<td>切换数据库</td>
<td></td>
<td>默认 16 个数据库(0~15)，未指定数据库时，默认为 0 数据库;<br>建议只使用 0 号数据库，避免多数据库的切换错误，以及故障排查困难。如果需要使用多数据库，可以在单机部署多个 Redis 实例，通过端口区分不同数据库</td>
</tr>
<tr>
<td><code>flushdb</code><br><code>flushall</code></td>
<td></td>
<td></td>
<td>清空当前/所有数据库</td>
<td></td>
<td>若数据库键值较多，可能引发阻塞</td>
</tr>
<tr>
<td><strong>字符串 String</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>set key value [ex seconds] [px milliseconds] [nx|xx]</code></td>
<td>ex：设置秒级过期时间<br>px：设置毫秒级过期时间<br>nx：键不存在才能设置成功，用于添加<br>xx：键存在才能设置成功，用于更新</td>
<td>成功返回 OK，失败返回 0</td>
<td>设置值</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>setex key seconds value</code></td>
<td></td>
<td>成功返回 OK，失败返回 0</td>
<td>设定的值存在才会成功</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>setnx key value</code></td>
<td></td>
<td>成功返回 OK，失败返回 0</td>
<td>设定的值不存在才会成功</td>
<td></td>
<td>常用于分布式锁</td>
</tr>
<tr>
<td><code>get key</code></td>
<td></td>
<td>键存在时返回值，不存在返回 nil</td>
<td>获取值</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>mset key value [key value ...]</code></td>
<td></td>
<td>成功返回 OK，失败返回 0</td>
<td>批量设置值</td>
<td>$O(k)$，𝑘为键的个数</td>
<td></td>
</tr>
<tr>
<td><code>mget key [key ...]</code></td>
<td></td>
<td>键存在时返回值，不存在返回 nil。结果按照传入键的顺序返回</td>
<td>批量获取值</td>
<td>$O(k)$，𝑘为键的个数</td>
<td></td>
</tr>
<tr>
<td><code>incr key</code></td>
<td></td>
<td>值不是整数，返回错误<br>值是整数，返回自增后结果<br>键不存在，按照值为 0 自增，返回结果为 1</td>
<td>值自增</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>decr key</code></td>
<td></td>
<td>int</td>
<td>值自减</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>incrby key increment</code></td>
<td></td>
<td>int</td>
<td>自增指定数字</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>decrby key decrement</code></td>
<td></td>
<td>int</td>
<td>自减指定数字</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>incrbyfloat key increment</code></td>
<td></td>
<td>float</td>
<td>自增浮点数</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>append key value</code></td>
<td></td>
<td>int（返回追加后的字符长度）</td>
<td>向字符串尾部追加值</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>strlen key</code></td>
<td></td>
<td>int（根据不同编码返回字符长度，如 UTF8 的“中国”返回值为 6）</td>
<td>字符串长度</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>getset key value</code></td>
<td></td>
<td></td>
<td>设置并返回值</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>setrange key offeset value</code></td>
<td></td>
<td>int（返回字符长度）</td>
<td>设置指定位置的字符</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>getrange key start end</code></td>
<td></td>
<td>返回截取的字符内容</td>
<td>获取部分字符串</td>
<td>$O(n)$，𝑛 为字符串长度，由于获取字符串非常快，若字符串不是很长，可以视为$O(1)$</td>
<td></td>
</tr>
<tr>
<td><strong>哈希 Hash</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>hset key field value</code><br><code>hget key field</code></td>
<td></td>
<td></td>
<td>设置值<br>获取值</td>
<td>$O(1)$<br>$O(1)$</td>
<td>在 Redis 中，哈希类型是指键值本身又是一个键值对结构（形如 JSON）。哈希类型中的映射关系叫作field-value，注意这里的value是指field对应的值，不是键对应的值，请注意value在不同上下文的作用。</td>
</tr>
<tr>
<td><code>hdel key field [field ...]</code></td>
<td></td>
<td>int （成功为删除的个数）</td>
<td>删除 field</td>
<td>$O(k)$ ，𝑘是field个数</td>
<td></td>
</tr>
<tr>
<td><code>hlen key</code></td>
<td></td>
<td>int</td>
<td>计算 field 个数</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>hmset key field value [field value ...]</code><br><code>hmget key field [field ...]</code></td>
<td></td>
<td></td>
<td>批量设置或获取field-value</td>
<td>$O(k)$ ，𝑘是field个数<br>$O(k)$ ，𝑘是field个数</td>
<td></td>
</tr>
<tr>
<td><code>hexists key field</code></td>
<td></td>
<td>存在为 1，否则为 0</td>
<td>判断field是否存在</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>hsetnx key field value</code></td>
<td></td>
<td></td>
<td></td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>hkeys key</code></td>
<td></td>
<td></td>
<td>获取所有field</td>
<td>$O(n)$ ，𝑛 是field个数</td>
<td><code>hkeys</code> 叫 <code>hfields</code>更恰当</td>
</tr>
<tr>
<td><code>hvals key</code></td>
<td></td>
<td></td>
<td>获取所有value</td>
<td>$O(n)$ ，𝑛 是field个数</td>
<td></td>
</tr>
<tr>
<td><code>hgetall key</code></td>
<td></td>
<td></td>
<td>获取所有的field-value</td>
<td>$O(n)$ ，𝑛 是field个数</td>
<td>在使用<code>hgetall</code>时，如果哈希元素个数比较多，可能会阻塞Redis。如果开发人员只需要获取部分field，可以使用<code>hmget</code>，如果一定要获取全部field-value，可以使用<code>hscan</code>命令，该命令会渐进式遍历哈希类型。</td>
</tr>
<tr>
<td><code>hincrby key field</code><br><code>hincrbyfloat key field</code></td>
<td></td>
<td></td>
<td>按指定值递增</td>
<td>$O(1)$<br>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>hstrlen key field</code></td>
<td></td>
<td></td>
<td>计算value的字符串长度</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td>列表 List</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lpush key value [value ...]</code><br><code>rpush key value [value ...]</code></td>
<td></td>
<td>int（成功插入元素个数）</td>
<td>从左/右侧插入元素</td>
<td>$O(k)$，𝑘 为元素个数</td>
<td>列表类型的两个特点：第一，列表中的元素是有序的（即，可以通过索引下标获取元素）；第二，列表中的元素可以是重复的</td>
</tr>
<tr>
<td><code>lpop key</code><br><code>rpop key</code></td>
<td></td>
<td></td>
<td>从列表左/右侧弹出元素</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>linsert key before|after pivot value</code></td>
<td></td>
<td>int（返回当前列表长度）</td>
<td>向某个元素前或者后插入元素</td>
<td>$O(n)$，𝑛 是 pivot 距离列表头或尾的距离</td>
<td></td>
</tr>
<tr>
<td><code>lrange key start end</code></td>
<td></td>
<td></td>
<td>获取指定范围内的元素列表</td>
<td>$O(s+n)$，𝑠 是 start 偏移量，𝑛 是start 到 end 的范围</td>
<td>1. <code>lrange 0 -1</code> 可获取列表所有元素<br>2. end 包含了自身</td>
</tr>
<tr>
<td><code>lindex key index</code></td>
<td></td>
<td></td>
<td>获取列表指定索引下标的元素</td>
<td>$O(n)$，𝑛 是索引的偏移量</td>
<td></td>
</tr>
<tr>
<td><code>llen key</code></td>
<td></td>
<td>int</td>
<td>获取列表长度</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>lrem key count value</code></td>
<td></td>
<td>count &gt; 0，从左到右，删除最多 count 个元素<br>count &lt; 0，从右到左，删除最多 count 绝对值个元素<br>count = 0，删除所有</td>
<td>删除指定元素</td>
<td>$O(n)$，𝑛 是列表长度</td>
<td></td>
</tr>
<tr>
<td><code>ltrim key start end</code></td>
<td></td>
<td></td>
<td>按照索引范围修剪列表</td>
<td>$O(n)$，𝑛 是要裁剪的元素总数</td>
<td></td>
</tr>
<tr>
<td><code>lset key index newValue</code></td>
<td></td>
<td></td>
<td>修改指定索引下标的元素</td>
<td>$O(n)$，𝑛 是索引的偏移量</td>
<td></td>
</tr>
<tr>
<td><code>blpop key [key ...] timeout</code><br><code>brpop key [key ...] timeout</code></td>
<td><code>timeout</code> 为阻塞时间</td>
<td></td>
<td>阻塞式弹出</td>
<td>$O(1)$</td>
<td>如果有多个键，那么<code>brpop</code>会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回</td>
</tr>
<tr>
<td><strong>集合(Set)</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>sadd key element [element ...]</code></td>
<td></td>
<td>int（返回添加成功元素的个数）</td>
<td>添加元素</td>
<td>$O(k)$，𝑘是元素个数</td>
<td></td>
</tr>
<tr>
<td><code>srem key element [element ...]</code></td>
<td></td>
<td>int（返回删除成功元素的个数）</td>
<td>删除元素</td>
<td>$O(k)$，𝑘是元素个数</td>
<td></td>
</tr>
<tr>
<td><code>scard key</code></td>
<td></td>
<td></td>
<td>计算元素个数</td>
<td>$O(1)$</td>
<td>同<code>dbsize</code>类似，直接读取内置变量</td>
</tr>
<tr>
<td><code>sismember key element</code></td>
<td></td>
<td>int（存在返回 1，否则为 0）</td>
<td>判断元素是否在集合中</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>srandmember key [count]</code></td>
<td></td>
<td></td>
<td>随机从集合返回指定个数元素</td>
<td>$O(count)$</td>
<td></td>
</tr>
<tr>
<td><code>spop key</code></td>
<td></td>
<td></td>
<td>从集合随机弹出元素</td>
<td>$O(1)$</td>
<td><code>srandmember</code>和<code>spop</code>都是随机从集合选出元素，两者不同的是<code>spop</code>命令执行后，元素会从集合中删除，而<code>srandmember</code>不会。</td>
</tr>
<tr>
<td><code>smembers key</code></td>
<td></td>
<td></td>
<td>获取所有元素，结果是无序的</td>
<td>$O(n)$，𝑛是元素总数</td>
<td><code>smembers</code>和<code>lrange</code>、<code>hgetall</code>都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，这时候可以使用<code>sscan</code>来完成</td>
</tr>
<tr>
<td><code>sinter key [key ...]</code></td>
<td></td>
<td></td>
<td>取交集</td>
<td>$O(m*k)$，𝑘是多个集合元素最少的个数，𝑚是键个数</td>
<td></td>
</tr>
<tr>
<td><code>suinon key [key ...]</code></td>
<td></td>
<td></td>
<td>取并集</td>
<td>$O(k)$，𝑘是多个集合元素个数和</td>
<td></td>
</tr>
<tr>
<td><code>sdiff key [key ...]</code></td>
<td></td>
<td></td>
<td>取差集</td>
<td>$O(k)$，𝑘是多个集合元素个数和</td>
<td></td>
</tr>
<tr>
<td><code>sinterstore destination key [key ...]</code><br><code>suionstore destination key [key ...]</code><br><code>sdiffstore destination key [key ...]</code></td>
<td></td>
<td></td>
<td>）将交集、并集、差集的结果保存</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>有序集合（Zset）</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>zadd key score member [score member ...]</code></td>
<td></td>
<td></td>
<td>添加成员</td>
<td>$O(k*log(n))$，𝑘是添加成员的个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zcard key</code></td>
<td></td>
<td>int</td>
<td>计算成员个数</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>zscore key member</code></td>
<td></td>
<td>int（成员不存在返回 nil）</td>
<td>计算某个成员的分数</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>zrank key member</code><br><code>zrevrank key member</code></td>
<td></td>
<td>返回分数从低到高/从高到低的排名</td>
<td>计算成员的排名</td>
<td>$O(log(n))$，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zrem key member [member ...]</code></td>
<td></td>
<td>返回删除成员的个数</td>
<td>删除成员</td>
<td>$O(k*log(n))$，𝑘是删除成员的个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zincrby key increment member</code></td>
<td></td>
<td></td>
<td>增加成员的分数</td>
<td>$O(log(n))$，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zrange key start end [withscores]</code><br><code>zrevrange key start end [withscores]</code></td>
<td><code>withscores</code>会同时返回成员分数</td>
<td>返回分数从低到高/从高到低的排名</td>
<td>返回指定排名范围的成员</td>
<td>$O(log(n)+k)$，𝑘是要获取的成员个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zrangebyscore key min max [withscores] [limit offset count]</code><br><code>zrevrangebyscore key max min [withscores] [limit offset count]</code></td>
<td><code>min</code>和<code>max</code>还支持开区间（小括号）和闭区间（中括号），<code>-inf</code>和<code>+inf</code>分别代表无限小和无限大</td>
<td></td>
<td>返回指定分数范围的成员</td>
<td>$O(log(n)+k)$，𝑘是要获取的成员个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zcount key min max</code></td>
<td></td>
<td></td>
<td>返回指定分数范围成员个数</td>
<td>$O(log(n))$，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zremrangebyrank key start end</code></td>
<td></td>
<td></td>
<td>删除指定排名内的升序元素</td>
<td>$O(log(n)+k)$，𝑘是要删除的成员个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zremrangebyscore key min max</code></td>
<td></td>
<td></td>
<td>删除指定分数范围的成员</td>
<td>$O(log(n)+k)$，𝑘是要删除的成员个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></td>
<td><code>destination</code>：交集计算结果保存到这个键；<br><code>numkeys</code>：需要做交集计算键的个数；<br><code>key [key...]</code>：需要做交集计算的键；<br><code>weights weight[weight...]</code>：每个键的权重，在做交集计算时，每个键中的每个 member 会将自己分数乘以这个权重，每个键的权重默认是1；<br><code>aggregate sum|min|max</code>：计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是sum</td>
<td></td>
<td>取交集</td>
<td>$O(n * k)+O(m*log(m))$，𝑛是成员数最小的有序集合成员个数，𝑘是有序集合的个数，𝑚是结果集中成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></td>
<td></td>
<td></td>
<td>取并集</td>
<td>$O(n)+O(m*log(m))$，𝑛是所有有序集合成员个数和，𝑚是结果集中成员个数</td>
<td></td>
</tr>
</tbody></table>
<h2 id="判断键不存在的方法"><a href="#判断键不存在的方法" class="headerlink" title="判断键不存在的方法"></a>判断键不存在的方法</h2><ol>
<li><code>exists</code> 返回 0</li>
<li><code>del</code> 返回 0</li>
<li><code>ttl</code> 返回 -2</li>
<li><code>type</code> 返回 <code>none</code></li>
<li><code>get</code> 返回 <code>nil</code></li>
</ol>
<p>设计合理的键名，有助于防止键冲突和项目的可维护性，比较推荐的方式是使用“业务名:对象名:id:[属性]”作为键名。如果键名较长，可以在能描述键含义的前提下适当减少键的长度，从而减少由于键名过长而导致的内存浪费。</p>
<h2 id="列表的四种操作类型"><a href="#列表的四种操作类型" class="headerlink" title="列表的四种操作类型"></a>列表的四种操作类型</h2><table>
<thead>
<tr>
<th>操作类型</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td><code>rpush</code> <code>lpush</code> <code>linsert</code></td>
</tr>
<tr>
<td>查</td>
<td><code>lrange</code> <code>lindex</code> <code>llen</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>lpop</code> <code>rpop</code> <code>lrem</code> <code>ltrim</code></td>
</tr>
<tr>
<td>修改</td>
<td><code>lset</code></td>
</tr>
<tr>
<td>阻塞操作</td>
<td><code>blpop</code> <code>brpop</code></td>
</tr>
</tbody></table>
<h2 id="列表的使用场景"><a href="#列表的使用场景" class="headerlink" title="列表的使用场景"></a>列表的使用场景</h2><ul>
<li><code>lpush</code> + <code>lpop</code> = Stack（栈）</li>
<li><code>lpush</code> + <code>rpop</code> = Queue（队列）</li>
<li><code>lpush</code> + <code>ltrim</code> = Capped Collection（有限集合）</li>
<li><code>lpush</code> + <code>brpop</code> = Message Queue（消息队列）</li>
</ul>
<h2 id="集合的使用场景"><a href="#集合的使用场景" class="headerlink" title="集合的使用场景"></a>集合的使用场景</h2><ul>
<li><code>sadd</code> = Tagging（标签）</li>
<li><code>spop/srandmember</code> = Random item（生成随机数，比如抽奖）</li>
<li><code>sadd</code> + <code>sinter</code>= Social Graph（社交需求）</li>
</ul>
<h2 id="列表、集合、有序集合的异同点"><a href="#列表、集合、有序集合的异同点" class="headerlink" title="列表、集合、有序集合的异同点"></a>列表、集合、有序集合的异同点</h2><table>
<thead>
<tr>
<th>数据结构</th>
<th align="center">是否允许重复元素</th>
<th align="center">是否有序</th>
<th>有序实现方式</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>列表</td>
<td align="center">是</td>
<td align="center">是</td>
<td>索引下标</td>
<td>时间轴、消息队列等</td>
</tr>
<tr>
<td>集合</td>
<td align="center">否</td>
<td align="center">否</td>
<td>无</td>
<td>标签、社交等</td>
</tr>
<tr>
<td>有序集合</td>
<td align="center">否</td>
<td align="center">是</td>
<td>分值</td>
<td>排行榜、社交等</td>
</tr>
</tbody></table>
<h2 id="Redis-数据结构与内部编码"><a href="#Redis-数据结构与内部编码" class="headerlink" title="Redis 数据结构与内部编码"></a>Redis 数据结构与内部编码</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8rmou0bzdj30hx0kb0xe.jpg" alt="Redis数据结构与内部编码"></p>
<ul>
<li>字符串<ul>
<li>int: 8个字节的长整型</li>
<li>embstr: &lt;=39 Byte 的字符串</li>
<li>raw: &gt;39 Byte 的字符串</li>
</ul>
</li>
<li>哈希<ul>
<li>ziplist: 当哈希类型元素个数小于 <code>hash-max-ziplist-entries</code> 配置（默认512个）、同时所有值都小于 <code>hash-max-ziplist-value</code> 配置（默认64字节）时，Redis 会使用 ziplist 作为哈希的内部实现，ziplist 使用更加紧凑的结构实现多个元素的连续存储，所以在<strong>节省内存方面比 hashtable 更加优秀</strong>。</li>
<li>hashtable: 当哈希类型无法满足 ziplist 的条件时，Redis 会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度为$O(1)$</li>
</ul>
</li>
<li>列表<ul>
<li>ziplist: 当列表元素个数小于 <code>list-max-ziplist-entries</code> 配置（默认512个）、同时每个元素值都小于 <code>list-max-ziplist-value</code> 配置（默认64字节）时，Redis 会使用 ziplist 来作为列表的内部实现来减少内存</li>
<li>linkedlist: 当无法满足ziplist条件时</li>
</ul>
</li>
<li>集合<ul>
<li>intset: 当集合中的元素都是整数且元素个数小于<code>set-maxintset-entries</code>配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</li>
<li>hashtable: 无法满足intset时</li>
</ul>
</li>
<li>有序集合<ul>
<li>ziplist: 当有序集合的元素个数小于<code>zset-max-ziplistentries</code>配置（默认128个），同时每个元素的值都小于<code>zset-max-ziplist-value</code>配置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现来减少内存</li>
<li>skiplist: 当无法满足ziplist条件时</li>
</ul>
</li>
</ul>
<p>Redis 设计内部编码与外部结构有两个好处</p>
<ol>
<li>改进内部编码而对外部数据结构和命令没有影响</li>
<li>多种内部编码实现可以在不同场景下发挥各自的优势，如 ziplist 比较节省内存，但在列表元素较多的情况下，性能会有所下降，此时 Redis 会根据配置选项将列表类型的内部实现转换为 linkedlist。</li>
</ol>
<p>可以通过<code>object encoding key</code>命令查询内部编码。</p>
<h1 id="第-3-章-小功能大用处"><a href="#第-3-章-小功能大用处" class="headerlink" title="第 3 章 小功能大用处"></a>第 3 章 小功能大用处</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><h3 id="慢查询配置"><a href="#慢查询配置" class="headerlink" title="慢查询配置"></a>慢查询配置</h3><ul>
<li><code>slowlog-log-slower-than</code> 执行时间阈值<ul>
<li>单位为微秒，默认 10,000，为 0 表示记录所有命令，&lt;0 不记录任何命令</li>
<li>在高并发场景下，需要将该值向下调整</li>
</ul>
</li>
<li><code>slowlog-max-len</code><ul>
<li>Redis 使用列表结构存储慢查询日志，该参数为列表最大长度</li>
<li>当列表达最大长度时，最早插入的命令会被从列表中移出</li>
<li>可定时将慢查询日志持久化处理，便于排查故障</li>
</ul>
</li>
</ul>
<h3 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>slowlog get [n]</code></td>
<td><code>n</code>: 指定条数</td>
<td></td>
</tr>
<tr>
<td><code>slowlog len</code></td>
<td></td>
<td>获取当前慢查询列表长度</td>
</tr>
<tr>
<td><code>slowlog reset</code></td>
<td></td>
<td>重置日志，即清理慢查询列表</td>
</tr>
</tbody></table>
<h3 id="慢查询日志结构"><a href="#慢查询日志结构" class="headerlink" title="慢查询日志结构"></a>慢查询日志结构</h3><p>由 4 个属性组成</p>
<ol>
<li>日志标识 ID</li>
<li>时间戳</li>
<li>命令耗时</li>
<li>执行命令和参数<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; slowlog get</span><br><span class="line">1) 1) (integer) 666</span><br><span class="line">   2) (integer) 1456786500</span><br><span class="line">   3) (integer) 11615</span><br><span class="line">   4) 1) "BGREWRITEAOF"</span><br><span class="line">2) 1) (integer) 665</span><br><span class="line">   2) (integer) 1456718400</span><br><span class="line">   3) (integer) 12006</span><br><span class="line">   4) 1) "SETEX"</span><br><span class="line">      2) "video_info_200"</span><br><span class="line">      3) "300"</span><br><span class="line">      4) "2"</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h2 id="Redis-Shell"><a href="#Redis-Shell" class="headerlink" title="Redis Shell"></a>Redis Shell</h2><h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a><code>redis-cli</code></h3><table>
<thead>
<tr>
<th>示例</th>
<th>选项</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>redis-cli -r 3 ping</code></td>
<td><code>-r</code>(repeat)：指定命令执行次数</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli -r 5 -i 1 ping</code></td>
<td><code>-i</code>(interval)：执行命令间隔时间，单位秒</td>
<td><code>-i</code>必须与<code>-r</code>一同使用<br>该选项不支持毫秒为单位，若想以 10ms 为间隔，可以使用<code>-i 0.01</code></td>
</tr>
<tr>
<td><code>echo "world" | redis-cli -x set hello</code></td>
<td><code>-x</code>: 从 stdin 读取数据作为 <code>redis-cli</code>的最后一个参数</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>-c</code>(cluster): 连接 Redis cluster 时使用，可以防止 <code>moved</code> 和 <code>ask</code> 异常</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>-a</code>(auth): 密码认证</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli --scan --pattern "app*"</code></td>
<td><code>--scan</code> &amp; <code>--pattern</code>: 于扫描指定模式的键</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli --slave</code></td>
<td><code>--slave</code>选项是把当前客户端模拟成当前 Redis 节点的从节点，可以用来获取当前 Redis 节点的更新操作</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>--rdb</code>: 将 Redis 实例持久化</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>--pipe</code>: 将命令封装成Redis通信协议定义的数据格式，批量发送给Redis执行</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli --bigkeys</code></td>
<td><code>--bigkeys</code>: 使用scan命令对Redis的键进行采样，从中找到内存占用比较大的键值，这些键可能是系统的瓶颈</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>--eval</code>: 指定 Lua 脚本</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli -h {machineB} --latency</code><br><code>redis-cli -h {machineB} --latency-history</code><br><code>redis-cli -h {machineB} --latency-dist</code></td>
<td><code>--latency</code>: 测试目标 Redis 网络延时。仅返回一条结果<br><code>--latency-history</code>: 每间隔一定时间（可通过<code>-i</code>设定）返回结果<br><code>--latency-dist</code>: 以统计图表的方式输出统计信息</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli --stat</code></td>
<td><code>--stat</code>: 实时获取 Redis 统计信息</td>
<td><code>redis-cli info</code>也能查看系统信息</td>
</tr>
<tr>
<td><code>redis-cli --no-raw get apple</code></td>
<td><code>--raw</code> &amp; <code>--no-raw</code>: 是否格式化输出</td>
<td></td>
</tr>
</tbody></table>
<h3 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a><code>redis-server</code></h3><p><code>redis-server --test-memory 1024</code> 可用于检测当前 OS 是否能稳定分配指定容量内存给 Redis，该命令通常用于压测。</p>
<h3 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a><code>redis-benchmark</code></h3><p>该命令会对各类数据结构的命令进行测试，并给出性能指标。</p>
<ul>
<li><code>-c</code>(client) 可指定客户端并发数（默认 50）</li>
<li><code>-n</code> 指定客户端请求总量（默认 100,000）</li>
<li><code>-q</code> 仅显示每秒接收请求数</li>
<li><code>-r</code>(random) 随机插入键，以进行基准测试</li>
<li><code>-P</code> 每个请求 pipeline 的数据量（默认为 1）</li>
<li><code>-k</code> 客户端是否使用<code>keepalive</code>，1 为使用，0 为不使用，默认为 1</li>
<li><code>-t</code> 对指定命令进行基准测试，如<code>redis-benchmark -t get,set -q</code></li>
<li><code>--csv</code> 将结果按照 csv 格式输出</li>
</ul>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>由于 Redis 是单线程机制，当需要执行多条命令时，网络 I/O 成为了瓶颈，因此 pipeline 可将待执行命令“打包”，通过一次往返即可完成。</p>
<p>需要注意的是，如果 pipeline 数据量过大，将会导致网络阻塞。</p>
<h2 id="事务与-Lua"><a href="#事务与-Lua" class="headerlink" title="事务与 Lua"></a>事务与 Lua</h2><p>Redis 中，将一组需要一起执行的事务命令放到<code>multi</code>(开始)和<code>exec</code>(结束)之间即可，如果要停止事务，可以使用<code>discard</code>。需要注意的是，Redis 不支持事务的回滚操作，但可以通过 Lua 来实现回滚。</p>
<p>有些应用场景需要在事务之前，确保事务中的<code>key</code>没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁）。Redis提供了<code>watch</code>命令来解决这类问题。</p>
<p>Lua 的数据类型：</p>
<ol>
<li>booleans(布尔)</li>
<li>numbers(数值)</li>
<li>strings(字符串)</li>
<li>tables(表格)</li>
</ol>
<h3 id="在-Redis-中执行-Lua-的方法"><a href="#在-Redis-中执行-Lua-的方法" class="headerlink" title="在 Redis 中执行 Lua 的方法"></a>在 Redis 中执行 Lua 的方法</h3><p>方式一<br><code>eval 脚本内容 key个数 key列表 参数列表</code></p>
<p>方式二<br>先将 Lua 脚本加载入 Redis，得到该脚本的 SHA1，<code>evalsha</code>使用<code>SHA1</code>执行对应的脚本。这样可以重复批处理。</p>
<ul>
<li>加载脚本：<code>redis-cli script load "$(cat lua_get.lua)"</code></li>
<li>执行脚本：<code>evalsha 脚本SHA1值 key个数 key列表 参数列表</code></li>
<li>判断脚本是否已经被加载：<code>scripts exists sha1 [sha1 …]</code>，返回存在的脚本个数</li>
<li>清除所有脚本：<code>script flush</code></li>
<li>强制终止脚本：<code>script kill</code>。如果当前脚本正在写入，则该命令不会生效，此时要么等待脚本执行结束，要么使用<code>shutdown save</code>停止 Redis 服务</li>
</ul>
<blockquote>
<p>Lua 脚本在 Redis 中是原子执行的，执行过程中不会插入其它命令。</p>
</blockquote>
<h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p>Bitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>setbit key offset value</code></td>
<td>设置值</td>
<td>很多应用的用户id以一个指定数字（例如10000）开头，直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费，通常的做法是每次做 <code>setbit</code> 操作时将用户id减去这个指定数字。在第一次初始化 Bitmaps 时，假如偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成Redis的阻塞</td>
</tr>
<tr>
<td><code>gitbit key offset</code></td>
<td>获取值</td>
<td></td>
</tr>
<tr>
<td><code>bitcount key [start][end]</code></td>
<td>获取Bitmaps指定范围值为1的个数</td>
<td></td>
</tr>
<tr>
<td><code>bitop operator destkey key[key....]</code></td>
<td>Bitmaps间的运算</td>
<td><code>bitop</code>是一个复合操作，它可以做多个Bitmaps的<code>and</code>、<code>or</code>、<code>not</code>、<code>xor</code>操作并将结果保存在<code>destkey</code>中</td>
</tr>
<tr>
<td><code>bitpos key targetBit [start] [end]</code></td>
<td>计算Bitmaps中第一个值为targetBit的偏移量</td>
<td></td>
</tr>
</tbody></table>
<p>当用户量很大时，使用 bitmaps 存储用户的活跃情况是非常好的一种方案，但活跃用户量较少时则不合理，大多数位都是 0。</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>HyperLogLog并不是一种新的数据结构（实际类型为字符串类型），通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>pfadd key element [element …]</code></td>
<td>添加，成功返回 1</td>
<td></td>
</tr>
<tr>
<td><code>pfcount key [key …]</code></td>
<td>计算独立用户</td>
<td></td>
</tr>
<tr>
<td><code>pfmerge destkey sourcekey [sourcekey ...]</code></td>
<td>合并</td>
<td></td>
</tr>
</tbody></table>
<p>相比于集合类型，HyperLogLog 内存占用量非常小，但是存在错误率，因此，在数据结构选型时，需要平衡误差与空间占用率。</p>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>publish channel message</code></td>
<td>发布消息，返回订阅者个数</td>
<td></td>
</tr>
<tr>
<td><code>subscribe channel [channel ...]</code></td>
<td>订阅消息</td>
<td>客户端在执行订阅命令之后进入了订阅状态，只能接收<code>subscribe</code>、<code>psubscribe</code>、<code>unsubscribe</code>、<code>punsubscribe</code>的四个命令<br>新开启的订阅客户端，无法收到该频道之前的消息，因为Redis不会对发布的消息进行持久化</td>
</tr>
<tr>
<td><code>unsubscribe [channel [channel ...]]</code></td>
<td>取消订阅</td>
<td></td>
</tr>
<tr>
<td><code>psubscribe pattern [pattern...]</code><br><code>punsubscribe [pattern [pattern ...]]</code></td>
<td>按照模式订阅和取消订阅</td>
<td></td>
</tr>
<tr>
<td><code>pubsub channels [pattern]</code></td>
<td>查看活跃的频道</td>
<td></td>
</tr>
<tr>
<td><code>pubsub numsub [channel ...]</code></td>
<td>查看频道订阅数</td>
<td></td>
</tr>
<tr>
<td><code>pubsub numpat</code></td>
<td>查看模式订阅数</td>
<td></td>
</tr>
</tbody></table>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p>GEO底层由 zset 实现。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>geoadd key longitude latitude member [longitude latitude member ...]</code></td>
<td>增加地理位置信息。返回成功添加的个数</td>
<td>更新地理位置信息仍然可以使用该命令，但返回为 0。该命令同时支持多个地理位置添加</td>
</tr>
<tr>
<td><code>geopos key member [member ...]</code></td>
<td>获取地理位置信息</td>
<td></td>
</tr>
<tr>
<td><code>geodist key member1 member2 [unit]</code></td>
<td>获取两个地理位置的距离</td>
<td><code>unit</code>为单位，分别为<code>m</code>(米)，<code>km</code>(公里)，<code>mi</code>(英里)，<code>ft</code>(尺)</td>
</tr>
<tr>
<td><code>georadius key longitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</code><br><br><code>georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</code></td>
<td>获取指定位置范围内的地理信息位置集合</td>
<td><code>georadius</code>和<code>georadiusbymember</code>两个命令的作用是一样的，都是以一个地理位置为中心算出指定半径内的其他地理信息位置，不同的是<code>georadius</code>命令的中心位置给出了具体的经纬度，<code>georadiusbymember</code>只需给出成员即可。其中<code>radiusm|km|ft|mi</code>是必需参数，指定了半径<br><code>withcoord</code>:返回经纬度；<br><code>withdist</code>:返回离中心节点位置的距离；<br><code>withhash</code>:返回<code>geohash</code>；<br><code>COUNT count</code>:返回指定结果数量；<br><code>asc|desc</code>:按距中心节点距离升序或降序；<br><code>store key</code>:将结果保存到指定键；<br><code>storedist key</code>:将距中心节点距离保存到指定键</td>
</tr>
<tr>
<td><code>geohash key member [member ...]</code></td>
<td>获取geohash</td>
<td>Redis将所有地理位置信息的<code>geohash</code>存放在<code>zset</code>中，字符串越长，表示的位置更精确</td>
</tr>
<tr>
<td><code>zrem key member</code></td>
<td>删除地理位置信息</td>
<td></td>
</tr>
</tbody></table>
<h1 id="第-4-章-客户端"><a href="#第-4-章-客户端" class="headerlink" title="第 4 章 客户端"></a>第 4 章 客户端</h1><h2 id="客户端常见异常"><a href="#客户端常见异常" class="headerlink" title="客户端常见异常"></a>客户端常见异常</h2><ol>
<li>无法从连接池获取到连接<ol>
<li>连接池设置过小，默认为 8</li>
<li>客户端未正确使用连接池，如没有进行释放</li>
<li>存在慢查询操作</li>
<li>Redis 服务造成命令执行过程阻塞</li>
</ol>
</li>
<li>客户端读写超时<ol>
<li>读写时间设置过短</li>
<li>命令执行时间较长</li>
<li>网路异常</li>
<li>Redis 自身发生阻塞</li>
</ol>
</li>
<li>客户端连接超时<ol>
<li>超时时间过短</li>
<li>Redis 发生阻塞，<code>tcp-backlog</code>已满，造成新的连接失败</li>
<li>网络异常</li>
</ol>
</li>
<li>客户端缓冲区异常<ol>
<li>输出缓冲区满</li>
<li>长时间闲置连接被服务端主动断开</li>
<li>不正常并发读写</li>
</ol>
</li>
<li>Lua 脚本正在执行<ol>
<li>脚本正在执行，且执行时间超过了<code>lua-time-limit</code>，需等待脚本执行完成，或者使用<code>shutdown save</code>关闭 Redis 服务</li>
</ol>
</li>
<li>Redis 正在加载持久化文件</li>
<li>Redis 使用的内存超过<code>maxmemory</code>配置</li>
<li>客户端连接数过大<ol>
<li>客户端：如果<code>maxclients</code>参数不是很小的话，应用方的客户端连接数基本不会超过<code>maxclients</code>，通常来看是由于应用方对于Redis客户端使用不当造成的。此时如果应用方是分布式结构的话，可以通过下线部分应用节点（例如占用连接较多的节点），使得Redis的连接数先降下来。从而让绝大部分节点可以正常运行，此时再通过查找程序bug或者调整<code>maxclients</code>进行问题的修复。</li>
<li>服务端：如果此时客户端无法处理，而当前Redis为高可用模式（例如Redis Sentinel和Redis Cluster），可以考虑将当前Redis做故障转移。</li>
</ol>
</li>
</ol>
<h2 id="客户端案例分析"><a href="#客户端案例分析" class="headerlink" title="客户端案例分析"></a>客户端案例分析</h2><h3 id="Redis内存陡增"><a href="#Redis内存陡增" class="headerlink" title="Redis内存陡增"></a>Redis内存陡增</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>服务端现象：Redis主节点内存陡增，几乎用满<code>maxmemory</code>，而从节点内存并没有变化<br>客户端现象：客户端产生了OOM异常，无法写入新的数据</p>
<h4 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h4><p>从现象看，可能的原因有两个</p>
<ol>
<li>确实有大量写入，但是主从复制出现问题：用<code>dbsize</code>查询Redis复制的相关信息，复制是正常的，主从数据基本一致。</li>
<li>其他原因造成主节点内存使用过大：排查是否由客户端缓冲区造成主节点内存陡增，使用<code>info clients</code>命令查询，发现输出缓冲区不太正常，进一步通过<code>client list</code>命令找到<code>omem</code>不正常的连接，一般来说大部分客户端的<code>omem</code>为0（因为处理速度会足够快），于是通过<code>redis-cli client list | grep -v "omem=0"</code>找到<code>omem</code>非零的客户端连接。</li>
</ol>
<h3 id="客户端周期性的超时"><a href="#客户端周期性的超时" class="headerlink" title="客户端周期性的超时"></a>客户端周期性的超时</h3><h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h4><p>客户端现象：客户端出现大量周期性超时<br>服务端现象：服务端并没有明显的异常，只是有一些慢查询操作</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>网络：查看网络连接正常</li>
<li>Redis：查看 Redis 日志统计，未发现异常</li>
<li>客户端：慢查询与超时发生时间点吻合，推断由慢查询引起</li>
</ul>
<h1 id="第-5-章-持久化"><a href="#第-5-章-持久化" class="headerlink" title="第 5 章 持久化"></a>第 5 章 持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ul>
<li><code>save</code>命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</li>
<li><code>bgsave</code>命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8tfeooj3zj30k60hptbk.jpg" alt="bgsave workflow"></p>
<p>自动触发场景：</p>
<ol>
<li>使用save相关配置，如<code>save m n</code>。表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave</li>
<li>如果从节点执行全量复制操作，主节点自动执行 bgsave 生成RDB文件并发送给从节点</li>
<li>执行<code>debug reload</code>命令重新加载Redis时，也会自动触发 save 操作</li>
<li>默认情况下执行<code>shutdown</code>命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave</li>
</ol>
<p>如果Redis加载损坏的RDB文件时拒绝启动，此时可以使用Redis提供的<code>redis-check-dump</code>工具检测 RDB 文件并获取对应的错误报告。</p>
<h3 id="RDB-的优缺点"><a href="#RDB-的优缺点" class="headerlink" title="RDB 的优缺点"></a>RDB 的优缺点</h3><p>RDB的优点：</p>
<ul>
<li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。<strong>非常适用于备份，全量复制等场景</strong>。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</li>
<li>Redis加载RDB恢复数据远远快于AOF的方式。</li>
</ul>
<p>RDB的缺点：</p>
<ul>
<li>RDB方式数据<strong>无法做到实时持久化/秒级持久化</strong>。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li>
<li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令(类似于 MySQL 的 Binlog)，重启时再重新执行AOF文件中的命令达到恢复数据的目的。目前已经是Redis持久化的主流方式。</p>
<p>开启AOF功能需要设置配置：<code>appendonly yes</code>，默认不开启。AOF文件名通过<code>appendfilename</code>配置设置，默认文件名是<code>appendonly.aof</code>。保存路径同 RDB 持久化方式一致，通过<code>dir</code>配置指定。<br><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8u1rzsipij30n811un3c.jpg" alt="AOF workflow"></p>
<p>AOF缓冲区同步文件策略(参数<code>appendfsync</code>)</p>
<table>
<thead>
<tr>
<th>可配置值</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>always</code></td>
<td>命令写入<code>aof_buf</code>后调用系统<code>fsync</code>操作同步到 AOF 文件，<code>fsync</code> 完成后线程返回</td>
<td>不建议</td>
</tr>
<tr>
<td><code>everysec</code></td>
<td>命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，<code>write</code>完成后线程返回。<code>fsync</code>同步文件操作由专门线程每秒调用一次。</td>
<td>建议，为默认选项</td>
</tr>
<tr>
<td><code>no</code></td>
<td>命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，不对 AOF 文件做<code>fsync</code>同步，同步硬盘操作由 OS 负责，通常同步周期最长 30s</td>
<td>数据安全无法得到保证</td>
</tr>
</tbody></table>
<p>aof 重写过程可通过手动与自动方式触发。手动通过直接调用<code>bgrewriteaof</code>命令，自动方式则根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>的参数确定触发时机。<br><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8u27kw8tmj30u00ws7ff.jpg" alt="AOF rewrite workflow"></p>
<h2 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h2><p>Redis 启动时会优先加载 AOF 文件，如果 AOF 不可加载，然后再加载 RDB 文件。其文件加载流程如下：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91c1tnqngj30ky0m3djy.jpg" alt=""></p>
<p>如果在加载 AOF 文件时发生错误，可以先进行备份，然后采用<code>redis-check-aof --fix</code>命令进行修复，修复后使用<code>diff -u</code>对比数据的差异，找出丢失的数据，有些可以人工修改补全。</p>
<p>AOF文件可能存在结尾不完整的情况，比如机器突然掉电导致AOF尾部文件命令写入不全。Redis为我们提供了<code>aof-load-truncated</code>配置来兼容这种情况，默认开启。加载AOF时，当遇到此问题时会忽略并继续启动，同时打印如下警告日志：</p>
<figure class="highlight erlang-repl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># !!! Warning: short read while loading the AOF file !!!</span><br><span class="line"># !!! Truncating the AOF at offset <span class="number">397856725</span> !!!</span><br><span class="line"># AOF loaded anyway because aof-load-truncated is enabled</span><br></pre></td></tr></tbody></table></figure>

<h2 id="问题定位与优化"><a href="#问题定位与优化" class="headerlink" title="问题定位与优化"></a>问题定位与优化</h2><h3 id="fork-操作"><a href="#fork-操作" class="headerlink" title="fork 操作"></a>fork 操作</h3><p>当 Redis 做 RDB 或 AOF 重写时，对于大多数操作系统来说 fork 是个重量级错误。fork操作耗时跟进程总内存量息息相关，如果使用虚拟化技术，特别是 Xen 虚拟机，fork 操作会更耗时。</p>
<p>对于高并发 Redis 实例，如果fork操作耗时在秒级别将拖慢 Redis 几万条命令执行，对线上应用延迟影响非常明显。正常情况下 fork 耗时应该是每 GB 消耗20毫秒左右。可以在<code>info stats</code>统计中查<code>latest_fork_usec</code>指标获取最近一次 fork 操作耗时，单位微秒。</p>
<p>改善fork操作的耗时：</p>
<ol>
<li>优先使用物理机或者高效支持fork操作的虚拟化技术，避免使用Xen。</li>
<li>控制 Redis 实例最大可用内存，fork 耗时跟内存量成正比，线上建议每个 Redis 实例内存控制在 10GB 以内。</li>
<li>合理配置 Linux 内存分配策略，避免物理内存不足导致 fork 失败。</li>
<li>降低 fork 操作的频率，如适度放宽 AOF 自动触发时机，避免不必要的全量复制等。</li>
</ol>
<h3 id="子进程开销监控和优化"><a href="#子进程开销监控和优化" class="headerlink" title="子进程开销监控和优化"></a>子进程开销监控和优化</h3><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul>
<li>CPU开销分析。子进程负责把进程内的数据分批写入文件，这个过程属于CPU密集操作，通常子进程对单核CPU利用率接近90%.</li>
<li>CPU消耗优化。Redis是CPU密集型服务，不要做绑定单核CPU操作。由于子进程非常消耗CPU，会和父进程产生单核资源竞争。</li>
<li>不要和其他CPU密集型服务部署在一起，造成CPU过度竞争。</li>
<li>如果部署多个Redis实例，尽量保证同一时刻只有一个子进程执行重写工作。</li>
</ul>
<h4 id="硬盘开销"><a href="#硬盘开销" class="headerlink" title="硬盘开销"></a>硬盘开销</h4><ul>
<li>不要和其他高硬盘负载的服务部署在一起。如：存储服务、消息队列服务等。</li>
<li>AOF重写时会消耗大量硬盘IO，可以开启配置<code>no-appendfsync-on-rewrite</code>，默认关闭。表示在AOF重写期间不做<code>fsync</code>操作。</li>
<li>当开启 AOF 功能的 Redis 用于高流量写入场景时，如果使用普通机械磁盘，写入吞吐一般在100MB/s左右，这时 Redis 实例的瓶颈主要在 AOF 同步硬盘上。</li>
<li>对于单机配置多个 Redis 实例的情况，可以配置不同实例分盘存储 AOF 文件，分摊硬盘写入压力。</li>
</ul>
<blockquote>
<p>⚠️ 配置<code>no-appendfsync-on-rewrite=yes</code>时，在极端情况下可能丢失整个AOF重写期间的数据，需要根据数据安全性决定是否配置。</p>
</blockquote>
<h3 id="AOF-追加阻塞"><a href="#AOF-追加阻塞" class="headerlink" title="AOF 追加阻塞"></a>AOF 追加阻塞</h3><p>当 Redis 执行 <code>fsync</code> 同步时，如果系统硬盘繁忙，会造成 Redis 主线程的阻塞。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91co0mb8fj30g40hz770.jpg" alt=""></p>
<p>每当发生 AOF 追加阻塞事件发生时，在<code>info Persistence</code>统计中，<code>aof_delayed_fsync</code>指标会累加，查看这个指标方便定位 AOF 阻塞问题。AOF同步最多允许2秒的延迟，当延迟发生时说明硬盘存在高负载问题，可以通过监控工具如<code>iotop</code>，定位消耗硬盘IO资源的进程。</p>
<h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><ul>
<li>RDB使用一次性生成内存快照的方式，产生的文件紧凑压缩比更高，因此读取RDB恢复速度更快。由于每次生成RDB开销较大，<strong>无法做到实时持久化，一般用于数据冷备和复制传输</strong>。</li>
<li>AOF通过追加写命令到文件实现持久化，通过<code>appendfsync</code>参数可以控制实时/秒级持久化。因为需要不断追加写命令，所以AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积。</li>
<li>AOF重写可以通过<code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewritepercentage</code>参数控制自动触发，也可以使用<code>bgrewriteaof</code>命令手动触发。</li>
<li>子进程执行期间使用<code>copy-on-write</code>机制与父进程共享内存，避免内存消耗翻倍。AOF重写期间还需要维护重写缓冲区，保存新的写入命令避免数据丢失。</li>
</ul>
<h1 id="第-6-章-复制"><a href="#第-6-章-复制" class="headerlink" title="第 6 章 复制"></a>第 6 章 复制</h1><h2 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h2><p>配置复制的三种方式</p>
<ol>
<li>在配置文件中加入<code>slaveof {masterHost} {masterPort}</code> 随Redis启动生效。</li>
<li>在<code>redis-server</code>启动命令后加入<code>--slaveof {masterHost} {masterPort}</code> 生效。</li>
<li>直接使用命令<code>slaveof {masterHost} {masterPort}</code>生效。</li>
</ol>
<p>主从节点复制成功建立后，可以使用<code>info replication</code>命令查看复制相关状态。</p>
<h2 id="断开复制"><a href="#断开复制" class="headerlink" title="断开复制"></a>断开复制</h2><p><code>slaveof</code>命令不但可以建立复制，还可以在从节点执行<code>slaveof no one</code>来断开与主节点复制关系。同时，<code>slaveof {newMasterIp} {newMasterPort}</code>还可以实现切主操作，更换主节点。</p>
<blockquote>
<p>⚠️ 切主后从节点会清空之前所有的数据，线上人工操作时小心<code>slaveof</code>在错误的节点上执行或者指向错误的主节点。</p>
</blockquote>
<p>对于数据比较重要的节点，主节点会通过设置<code>requirepass</code>参数进行密码验证，这时所有的客户端访问必须使用<code>auth</code>命令实行校验。</p>
<p>默认情况下，从节点使用<code>slave-read-only=yes</code>配置为只读模式。由于复制只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，修改从节点会造成主从数据不一致。因此建议线上不要修改从节点的只读模式。</p>
<p>Redis为我们提供了<code>repl-disable-tcp-nodelay</code>参数用于控制是否关闭<code>TCP_NODELAY</code>，默认关闭，说明如下：</p>
<ul>
<li>当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延迟会变小，但增加了网络带宽的消耗。适用于主从之间的网络环境良好的场景，如同机架或同机房部署。</li>
<li>当开启时，主节点会合并较小的TCP数据包从而节省带宽。默认发送时间间隔取决于Linux的内核，一般默认为40毫秒。这种配置节省了带宽但增大主从之间的延迟。适用于主从网络环境复杂或带宽紧张的场景，如跨机房部署。</li>
</ul>
<h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><p>根据拓扑的复杂性，可分为三种：一主一从、一主多从、树状主从结构。</p>
<h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><p>当应用写命令并发量较高且需要持久化时，可以只在从节点上开启AOF，这样既保证数据安全性同时也避免了持久化对主节点的性能干扰。但需要注意的是，当主节点关闭持久化功能时，如果主节点脱机要避免自动重启操作。因为主节点之前没有开启持久化功能自动重启后数据集为空，这时从节点如果继续复制主节点会导致从节点数据也被清空的情况，丧失了持久化的意义。安全的做法是在从节点上执行<code>slaveof no one</code>断开与主节点的复制关系，再重启主节点从而避免这一问题。</p>
<h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><p>对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性。</p>
<h3 id="树状主从结构"><a href="#树状主从结构" class="headerlink" title="树状主从结构"></a>树状主从结构</h3><p>当主节点需要挂载多个从节点时为了避免对主节点的性能干扰，可以采用树状主从结构降低主节点压力。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91e0yu7flj30if0o442t.jpg" alt=""></p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>Redis 在初次复制时，会进行全量复制，之后便会根据主从节点的复制偏移量进行<code>psync</code>增量复制。</p>
<p><code>psync</code>命令运行需要以下组件支持：</p>
<ul>
<li>主从节点各自复制偏移量。</li>
<li>主节点复制积压缓冲区。</li>
<li>主节点运行id。</li>
</ul>
<h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>参与复制的主从节点都会维护自身复制偏移量。主节点在理完写入命令后，会把命令的字节长度做累加记录，统计信息在<code>info relication</code>中的<code>master_repl_offset</code>指标中，从节点会每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。统计信息在<code>info relication</code>中的<code>slave_repl_offset</code>指标中。</p>
<p>可以通过主节点的统计信息，计算出<code>master_repl_offset_slave_offset</code>字节量，判断主从节点复制相差的数据量，根据这个差值判定当前复制的健康度。如果主从之间复制偏移量相差较大，则可能是网络延迟或命令阻塞等原因引起。</p>
<h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91vyy7e25j30h909875n.jpg" alt=""></p>
<p>主节点响应从节点的同步时，不但会把命令发送给从节点，还会写入复制积压缓冲区。由于缓冲区本质上是先进先出的定长队列，所以能实现保存最近已复制数据的功能，用于部分复制和复制命令丢失的数据补救。复制缓冲区相关统计信息保存在主节点的<code>info replication</code>中。</p>
<h4 id="主节点运行ID"><a href="#主节点运行ID" class="headerlink" title="主节点运行ID"></a>主节点运行ID</h4><p>每个Redis节点启动后都会动态分配一个40位的十六进制字符串作为运行ID。运行ID的主要作用是用来唯一识别Redis节点，比如从节点保存主节点的运行ID识别自己正在复制的是哪个主节点。如果只使用ip+port的方式识别主节点，那么主节点重启变更了整体数据集（如替换RDB/AOF文件），从节点再基于偏移量复制数据将是不安全的，因此当运行ID变化后从节点将做全量复制。可以运行<code>info server</code>命令查看当前节点的运行ID。</p>
<p>当需要调优一些内存相关配置，例如：<code>hash-max-ziplist-value</code>等，这些配置需要Redis重新加载才能优化已存在的数据，这时可以使用<code>debug reload</code>命令重新加载 RDB 并保持运行 ID 不变，从而有效避免不必要的全量复制。</p>
<blockquote>
<p><code>debug reload</code>命令会阻塞当前Redis节点主线程，阻塞期间会生成本地RDB快照并清空数据之后再加载RDB文件。因此对于大数据量的主节点和无法容忍阻塞的应用场景，谨慎使用。</p>
</blockquote>
<h4 id="psync-命令"><a href="#psync-命令" class="headerlink" title="psync 命令"></a>psync 命令</h4><p>从节点使用<code>psync</code>命令完成部分复制和全量复制功能，命令格式：<code>psync {runId} {offset}</code></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xk5bba1j30jh0hejtq.jpg" alt=""></p>
<p>主节点回复<code>+FULLRESYNC {runId} {offset}</code>会触发全量复制，<code>+CONTINUE</code>则触发增量复制。</p>
<h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xn7bm5rj30j30lqgp7.jpg" alt=""></p>
<p>对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。如果 RDB 文件过大，超过预设的 timeout，则会终止全量同步，并清除已下载临时文件。如果在高并发写的场景，主节点的缓冲区被写满，同样会导致同步的失败。</p>
<p>全量复制的主要时间开销在：</p>
<ul>
<li>主节点 <code>bgsave</code> 时间</li>
<li>RDB 文件网络传输时间</li>
<li>从节点清空数据时间</li>
<li>从节点加载 RDB 时间</li>
<li>可能的 AOF 重写时间</li>
</ul>
<h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xwacukej30hu0d8gnx.jpg" alt=""></p>
<h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><p>主从心跳判断机制：</p>
<ul>
<li>通过<code>client list</code>命令查看复制相关客户端信息，主节点的连接状态为<code>flags=M</code>，从节点连接状态为<code>flags=S</code>。</li>
<li>主节点默认每隔10秒对从节点发送<code>ping</code>命令，判断从节点的存活性和连接状态。可通过参数<code>repl-ping-slave-period</code>控制发送频率。</li>
<li>从节点在主线程中每隔1秒发送<code>replconf ack{offset}</code>命令，给主节点上报自身当前的复制偏移量。<code>replconf</code>命令主要作用如下：<ul>
<li>实时监测主从节点网络状态</li>
<li>上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据</li>
<li>实现保证从节点的数量和延迟性功能，通过min-slaves-to-write、minslaves-max-lag参数配置定义</li>
</ul>
</li>
</ul>
<blockquote>
<p>我们经常会遇到数据同步的问题，但如何在消耗最少的资源下保证数据的一致性是我们一直会遇到的问题，好在，很多成熟的 软件已经为我们提供了借鉴的方案，如 Git 的 hash chain，Redis 的 <code>psync</code> 偏移量增量复制与缓冲区，以及 MySQL 的<code>binlog</code>。没有最好的方案，只有最合适的方案，或许我们能从中得到启发，找到最适合自己的增量同步方式。</p>
</blockquote>
<h2 id="开发与运维中的问题"><a href="#开发与运维中的问题" class="headerlink" title="开发与运维中的问题"></a>开发与运维中的问题</h2><h3 id="数据延时"><a href="#数据延时" class="headerlink" title="数据延时"></a>数据延时</h3><p>Redis复制数据的延迟由于异步复制特性是无法避免的，延迟取决于网络带宽和命令阻塞情况。需要业务场景允许短时间内的数据延迟。对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点。</p>
<h3 id="读到过期数据"><a href="#读到过期数据" class="headerlink" title="读到过期数据"></a>读到过期数据</h3><p>惰性删除：主节点将过期的键同步给从节点<br>定时删除：主节点轮询采样一定数量的键，当采样的键过期后，同步给从节点。<br>Redis 3.2+ 在从节点读取键时会校验是否过期以判断是否返回数据。</p>
<h3 id="从节点故障"><a href="#从节点故障" class="headerlink" title="从节点故障"></a>从节点故障</h3><p>下线故障节点。</p>
<blockquote>
<p>当主节点优化空间不大时再考虑扩展。笔者建议大家在做读写分离之前，可以考虑使用Redis Cluster等分布式解决方案，这样不止扩展了读性能还可以扩展写性能和可支撑数据规模，并且一致性和故障转移也可以得到保证，对于客户端的维护逻辑也相对容易。</p>
</blockquote>
<h3 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h3><ul>
<li>第一次建立复制：由于是第一次建立复制，从节点不包含任何主节点数据，因此必须进行全量复制才能完成数据同步。对于这种情况全量复制无法避免。当对数据量较大且流量较高的主节点添加从节点时，建议在低峰时进行操作，或者尽量规避使用大数据量的Redis节点。</li>
<li>节点运行ID不匹配：当主从复制关系建立后，从节点会保存主节点的运行ID，如果此时主节点因故障重启，那么它的运行ID会改变，从节点发现主节点运行ID不匹配时，会认为自己复制的是一个新的主节点从而进行全量复制。对于这种情况应该从架构上规避，比如提供故障转移功能。当主节点发生故障后，手动提升从节点为主节点或者采用支持自动故障转移的哨兵或集群方案。</li>
<li>复制积压缓冲区不足：当主从节点网络中断后，从节点再次连上主节点时会发送<code>psync {offset} {runId}</code>命令请求部分复制，<strong>如果请求的偏移量不在主节点的积压缓冲区内，则无法提供给从节点数据，因此部分复制会退化为全量复制</strong>。此时需要保证<code>repl_backlog_size &gt; net_break_time*write_size_per_minute</code>以避免缓冲区不足引发的全量复制。</li>
</ul>
<h3 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h3><h4 id="单主节点复制风暴"><a href="#单主节点复制风暴" class="headerlink" title="单主节点复制风暴"></a>单主节点复制风暴</h4><p>一般发生在主节点挂载多个从节点的场景。当主节点重启恢复后，从节点会发起全量复制流程，这时主节点就会为从节点创建RDB快照，如果在快照创建完毕之前，有多个从节点都尝试与主节点进行全量同步，那么其他从节点将共享这份RDB快照，同时向多个从节点发送RDB快照，可能使主节点的网络带宽消耗严重，造成主节点的延迟变大，极端情况会发生主从节点连接断开，导致复制失败。<br>解决方案可以减少主节点挂载的从节点数量，或者采用树形复制结构(这种树状结构也带来了运维的复杂性，增加了手动和自动处理故障转移的难度)。</p>
<h4 id="单机器复制风暴"><a href="#单机器复制风暴" class="headerlink" title="单机器复制风暴"></a>单机器复制风暴</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91z58ncm8j30iv0frgpv.jpg" alt=""></p>
<ul>
<li>应该把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点。</li>
<li>当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制。</li>
</ul>
<h1 id="第-7-章-阻塞"><a href="#第-7-章-阻塞" class="headerlink" title="第 7 章 阻塞"></a>第 7 章 阻塞</h1><p>发生阻塞会有内在与外在原因<br>内在原因：不合理地使用API或数据结构、CPU饱和、持久化阻塞等<br>外在原因：CPU竞争、内存交换、网络问题等</p>
<h2 id="内因"><a href="#内因" class="headerlink" title="内因"></a>内因</h2><h3 id="如何发现慢查询"><a href="#如何发现慢查询" class="headerlink" title="如何发现慢查询"></a>如何发现慢查询</h3><p>执行<code>slowlog get {n}</code>获取最近的 n 条慢查询命令，线上实例建议设置为1毫秒便于及时发现毫秒级以上的命令。如果命令执行时间在毫秒级，则实例实际OPS只有1000左右。慢查询队列长度默认128，可适当调大。慢查询本身只记录了命令执行时间，不包括数据网络传输时间和命令排队时间，因此客户端发生阻塞异常后，可能不是当前命令缓慢，而是在等待其他命令执行。需要重点比对异常和慢查询发生的时间点，确认是否有慢查询造成的命令阻塞排队。</p>
<p>解决慢查询</p>
<ul>
<li>修改为低算法度的命令，如<code>hgetall</code>改为<code>hmget</code>等，禁用<code>keys</code>、<code>sort</code>等命令。</li>
<li>调整大对象：缩减大对象数据或把大对象拆分为多个小对象，防止一次命令操作过多的数据。大对象拆分过程需要具体的业务决定，如用户好友集合存储在Redis中，有些热点用户会关注大量好友，这时可以按时间或其他维度拆分到多个集合中。</li>
</ul>
<h3 id="如何发现大对象"><a href="#如何发现大对象" class="headerlink" title="如何发现大对象"></a>如何发现大对象</h3><p>Redis本身提供发现大对象的工具<code>redis-cli -h{ip} -p{port} bigkeys</code>。内部原理采用分段进行<code>scan</code>操作，把历史扫描过的最大对象统计出来便于分析优化，</p>
<h3 id="CPU饱和"><a href="#CPU饱和" class="headerlink" title="CPU饱和"></a>CPU饱和</h3><p>使用<code>top</code>命令很容易识别出对应Redis进程的CPU使用率。CPU饱和是非常危险的，将导致Redis无法处理更多的命令，严重影响吞吐量和应用方的稳定性。对于这种情况，首先判断当前Redis的并发量是否达到极限，建议使用统计命令<code>redis-cli -h{ip} -p{port} --stat</code>获取当前Redis使用情况，该命令每秒输出一行统计信息。</p>
<h3 id="持久化阻塞"><a href="#持久化阻塞" class="headerlink" title="持久化阻塞"></a>持久化阻塞</h3><p>持久化引起主线程阻塞的操作主要有：fork阻塞、AOF刷盘阻塞、HugePage写操作阻塞。</p>
<p>fork 阻塞可以执行<code>info stats</code>命令获取到<code>latest_fork_usec</code>指标，表示Redis最近一次fork操作耗时，如果耗时很大，比如超过1秒，则需要做出优化调整，如避免使用过大的内存实例和规避fork缓慢的操作系统等。</p>
<p>AOF刷盘阻塞主要是硬盘压力引起，可以查看Redis日志识别出这种情况。硬盘压力可能是Redis进程引起的，也可能是其他进程引起的，可以使用iotop查看具体是哪个进程消耗过多的硬盘资源。</p>
<p>HugePage写操作阻塞。子进程在执行重写期间利用Linux写时复制技术降低内存开销，因此只有写操作时Redis才复制要修改的内存页。对于开启Transparent HugePages的操作系统，每次写命令引起的复制内存页单位由4K变为2MB，放大了512倍，会拖慢写操作的执行时间，导致大量写操作慢查询。例如简单的incr命令也会出现在慢查询中。关于Transparent HugePages的细节见第12章的12.1节“Linux配置优化”。</p>
<blockquote>
<p>Redis 对阻塞问题的说明：<a href="https://redis.io/topics/latency" target="_blank" rel="noopener">https://redis.io/topics/latency</a></p>
</blockquote>
<h2 id="外因"><a href="#外因" class="headerlink" title="外因"></a>外因</h2><h3 id="CPU-竞争"><a href="#CPU-竞争" class="headerlink" title="CPU 竞争"></a>CPU 竞争</h3><p>进程竞争：Redis是典型的CPU密集型应用，不建议和其他多核CPU密集型服务部署在一起。当其他进程过度消耗CPU时，将严重影响Redis吞吐量。可以通过<code>top</code>、<code>sar</code>等命令定位到CPU消耗的时间点和具体进程，这个问题比较容易发现，需要调整服务之间部署结构。<br>绑定CPU：部署Redis时为了充分利用多核CPU，通常一台机器部署多个实例。常见的一种优化是把Redis进程绑定到CPU上，用于降低CPU频繁上下文切换的开销。但当Redis父进程创建子进程进行RDB/AOF重写时，如果做了CPU绑定，会与父进程共享使用一个CPU。子进程重写时对单核CPU使用率通常在90%以上，父进程与子进程将产生激烈CPU竞争，极大影响Redis稳定性。因此对于开启了持久化或参与复制的主节点不建议绑定CPU。</p>
<h3 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h3><p>内存交换（swap）对于Redis来说是非常致命的，Redis保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把Redis使用的部分内存换出到硬盘，由于内存与硬盘读写速度差几个数量级，会导致发生交换后的Redis性能急剧下降。</p>
<p>判断 Redis 是否内存交换的方法：</p>
<ol>
<li>查询 Redis 的进程号：<code># redis-cli -p 6379 info server | grep process_id</code> // process_id:4476</li>
<li>根据进程号查询内存交换信息：<code># cat /proc/4476/smaps | grep Swap</code><br>如果交换量都是0KB或者个别的是4KB，则是正常现象，说明Redis进程内存没有被交换。</li>
</ol>
<p>预防 Redis 的内存交换</p>
<ul>
<li>保证机器可用内存充足</li>
<li>确保所有 Redis 实例设置最大可用内存(maxmemory)</li>
<li>降低系统使用swap优先级，如<code>echo10&gt;/proc/sys/vm/swappiness</code></li>
</ul>
<h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>Redis连接拒绝：Redis通过maxclients参数控制客户端最大连接数，默认10000。当Redis连接数大于<code>maxclients</code>时会拒绝新的连接进入，<code>info stats</code>的<code>rejected_connections</code>统计指标记录所有被拒绝连接的数量。客户端访问Redis时尽量采用NIO长连接或者连接池的方式。Redis 默认不会主动关闭长时间闲置连接或检查关闭无效的TCP连接，因此会导致Redis连接数快速消耗且无法释放的问题，此时可设置<code>tcp-keepalive</code>和<code>timeout</code>参数让Redis主动检查和关闭无效连接。</p>
<p>连接溢出：OS 一般会对进程使用的资源做限制，其中一项是对进程可打开最大文件数控制，默认 1024，对需要支撑高并发的 Redis 需要调大该限制。</p>
<p>常见的物理拓扑按网络延迟由快到慢可分为：同物理机&gt;同机架&gt;跨机架&gt;同机房&gt;同城机房&gt;异地机房。但它们容灾性正好相反。</p>
<h1 id="第-8-章-理解内存"><a href="#第-8-章-理解内存" class="headerlink" title="第 8 章 理解内存"></a>第 8 章 理解内存</h1><p>内存消耗可以分为进程自身消耗和子进程消耗。</p>
<h2 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h2><h3 id="内存消耗统计"><a href="#内存消耗统计" class="headerlink" title="内存消耗统计"></a>内存消耗统计</h3><p>通过<code>info memory</code>命令获取内存相关指标，指标说明如下表：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>used_memory</code></td>
<td>Redis分配器分配的内存总量，也就是内部存储的所有数据内存占用量</td>
</tr>
<tr>
<td><code>used_memory_human</code></td>
<td>以可读的格式返回<code>used memory</code></td>
</tr>
<tr>
<td><code>used_memory_rss</code></td>
<td>从操作系统的角度显示Redis进程占用的物理内存总量</td>
</tr>
<tr>
<td><code>used_memory_peak</code></td>
<td>内存使用的最大值，表示<code>used memory</code>的峰值</td>
</tr>
<tr>
<td><code>used_memory_peak_human</code></td>
<td>以可读的格式返回<code>used_memory_peak</code></td>
</tr>
<tr>
<td><code>used_memory_lua</code></td>
<td>Lua 引擎所消耗的内存大小</td>
</tr>
<tr>
<td><code>mem_fragmentation_ratio</code></td>
<td><code>used_memory_rss/used_memory</code>比值，表示内存碎片率</td>
</tr>
<tr>
<td><code>mem_allocator</code></td>
<td>Redis 所使用的内存分配器，默认为 jemalloc</td>
</tr>
</tbody></table>
<p>当<code>mem_fragmentation_ratio &gt; 1</code>时，说明<code>used_memory_rss-used_memory</code>多出的部分内存并没有用于数据存储，而是被内存碎片所消耗，如果两者相差很大，说明碎片率严重。<br>当<code>mem_fragmentation_ratio &lt; 1</code>时，这种情况一般出现在操作系统把Redis内存交换（Swap）到硬盘导致，出现这种情况时要格外关注，由于硬盘速度远远慢于内存，Redis性能会变得很差，甚至僵死。</p>
<h3 id="内存消耗划分"><a href="#内存消耗划分" class="headerlink" title="内存消耗划分"></a>内存消耗划分</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g94c4oj8s0j30y20mmtfb.jpg" alt=""></p>
<p>内存碎片问题虽然是所有内存服务的通病，但是jemalloc针对碎片化问题专门做了优化，一般不会存在过度碎片化的问题，正常的碎片率（<code>mem_fragmentation_ratio</code>）在1.03左右。但是当存储的数据长短差异较大时，以下场景容易出现高内存碎片问题：</p>
<ul>
<li>频繁做更新操作，例如频繁对已存在的键执行<code>append</code>、<code>setrange</code>等更新操作。</li>
<li>大量过期键删除，键对象过期删除后，释放的空间无法得到充分利用，导致碎片率上升。</li>
</ul>
<p>出现高内存碎片问题时常见的解决方式如下：</p>
<ul>
<li>数据对齐：在条件允许的情况下尽量做数据对齐，比如数据尽量采用数字类型或者固定长度字符串等，但是这要视具体的业务而定，有些场景无法做到。</li>
<li>安全重启：重启节点可以做到内存碎片重新整理，因此可以利用高可用架构，如Sentinel或Cluster，将碎片率过高的主节点转换为从节点，进行安全重启。</li>
</ul>
<h3 id="子进程内存消耗"><a href="#子进程内存消耗" class="headerlink" title="子进程内存消耗"></a>子进程内存消耗</h3><ul>
<li>Redis产生的子进程并不需要消耗1倍的父进程内存，实际消耗根据期间写入命令量决定，但是依然要预留出一些内存防止溢出。</li>
<li>需要设置<code>sysctl vm.overcommit_memory = 1</code>允许内核可以分配所有的物理内存，防止Redis进程执行fork时因系统剩余内存不足而失败。</li>
<li>排查当前系统是否支持并开启THP，如果开启，建议关闭，防止<code>copy-onwrite</code>期间内存过度消耗。如果在高并发写的场景下开启THP，子进程内存消耗可能是父进程的数倍，极易造成机器物理内存溢出，从而触发SWAP或OOM killer。</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>Redis主要通过控制内存上限和回收策略实现内存管理。</p>
<h3 id="设置内存上限"><a href="#设置内存上限" class="headerlink" title="设置内存上限"></a>设置内存上限</h3><p>Redis使用<code>maxmemory</code>参数限制最大可用内存。需要注意，<code>maxmemory</code>限制的是Redis实际使用的内存量，也就是<code>used_memory</code>统计项对应的内存。由于内存碎片率的存在，实际消耗的内存可能会比<code>maxmemory</code>设置的更大，实际使用时要小心这部分内存溢出。通过设置内存上限可以非常方便地实现一台服务器部署多个Redis进程的内存控制。比如一台24GB内存的服务器，为系统预留4GB内存，预留4GB空闲内存给其他进程或Redis fork进程，留给Redis16GB内存，这样可以部署4个<code>maxmemory=4GB</code>的Redis进程。得益于Redis单线程架构和内存限制机制，即使没有采用虚拟化，不同的Redis进程之间也可以很好地实现CPU和内存的隔离性，</p>
<h3 id="动态调整内存上限"><a href="#动态调整内存上限" class="headerlink" title="动态调整内存上限"></a>动态调整内存上限</h3><p>Redis的内存上限可以通过<code>config set maxmemory</code>进行动态修改。该方式过于简单，推荐使用哨兵或者集群来处理。</p>
<p>Redis默认无限使用服务器内存，为防止极端情况下导致系统内存耗尽，建议所有的Redis进程都要配置<code>maxmemory</code>。</p>
<h3 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h3><p>Redis的内存回收机制分为删除过期的键对象，与内存使用达到maxmemory上限时触发内存溢出控制策略。</p>
<p>Redis所有的键都可以设置过期属性，内部保存在过期字典中。由于进程内保存大量的键，维护每个键精准的过期删除机制会导致消耗大量的CPU，对于单线程的Redis来说成本过高，因此Redis采用惰性删除和定时任务删除机制实现过期键的内存回收。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g94i0a1qirj30u00wg49h.jpg" alt=""></p>
<p>Redis 的内存溢出有 6 种控制策略，可通过<code>config set maxmemory-policy {policy}</code>配置</p>
<ol>
<li>noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息（error）OOM command not allowed when used memory，此时Redis只响应读操作。</li>
<li>volatile-lru：根据LRU算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。</li>
<li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li>
<li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li>
<li>volatile-random：随机删除过期键，直到腾出足够空间为止。</li>
<li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li>
</ol>
<p>频繁执行回收内存成本很高，会导致 Redis 的性能下降，如果当前Redis有从节点，回收内存操作对应的删除命令会同步到从节点，导致写放大的问题。</p>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><h3 id="redisObject对象"><a href="#redisObject对象" class="headerlink" title="redisObject对象"></a>redisObject对象</h3><p>Redis存储的所有值对象在内部定义为redisObject结构体，内部结构如图<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g94ig5abpxj30zi0u0tkp.jpg" alt=""></p>
<p>type字段：表示当前对象使用的数据类型，可以使用<code>type {key}</code>命令查看对象所属类型<br>encoding 字段：Redis内部编码类型<br>lru 字段：记录对象最后一次被访问的时间，当配置了<code>maxmemory</code>和<code>maxmemory-policy=volatile-lru</code>或者<code>allkeys-lru</code>时，用于辅助LRU算法删除键数据。可以使用<code>object idletime {key}</code>命令在不更新lru字段情况下查看当前键的空闲时间。<br>refcount字段：记录当前对象被引用的次数，用于通过引用次数回收内存，当<code>refcount=0</code>时，可以安全回收当前对象空间。<br><code>*ptr</code>字段：与对象的数据内容相关，如果是整数，直接存储数据；否则表示指向数据的指针。Redis在3.0之后对值对象是字符串且长度&lt;=39字节的数据，内部编码为<code>embstr</code>类型，字符串<code>sds</code>和r<code>edisObject</code>一起分配，从而<strong>只要一次内存操作即可</strong>。</p>
<h3 id="缩减键值对象"><a href="#缩减键值对象" class="headerlink" title="缩减键值对象"></a>缩减键值对象</h3><p>降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。</p>
<ul>
<li>key长度：如在设计键时，在完整描述业务情况下，键值越短越好。如<code>user：{uid}：friends：notify：{fid}</code>可以简化为<code>u：{uid}：fs：nt：{fid}</code></li>
<li>value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该<strong>在业务上精简业务对象，去掉不必要的属性避免存储无效数据</strong>。其次在序列化工具选择上，应该<strong>选择更高效的序列化工具来降低字节数组大小</strong>。值对象除了存储二进制数据之外，通常还会使用通用格式存储数据比如：json、xml等作为字符串存储在Redis中。这种方式优点是方便调试和跨语言，但是同样的数据相比字节数组所需的空间更大，在内存紧张的情况下，可以使用通用压缩算法压缩json、xml后再存入Redis，从而降低内存占用，例如使用GZIP压缩后的json可降低约60%的空间。（当频繁压缩解压json等文本数据时，开发人员需要考虑压缩速度和计算开销成本，这里推荐使用Google的Snappy压缩工具，在特定的压缩率情况下效率远远高于GZIP等传统压缩工具，且支持所有主流语言环境。）</li>
</ul>
<h3 id="字符串优化"><a href="#字符串优化" class="headerlink" title="字符串优化"></a>字符串优化</h3><p>Redis没有采用原生C语言的字符串类型而是自己实现了字符串结构，内部简单动态字符串（simple dynamic string，SDS）。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97yccw87dj30kt0dq0w8.jpg" alt=""></p>
<p>Redis自身实现的字符串结构有如下特点：</p>
<ul>
<li>$O(1)$时间复杂度获取：字符串长度、已用长度、未用长度。</li>
<li>可用于保存字节数组，支持安全的二进制数据存储。</li>
<li>内部实现空间预分配机制，降低内存再分配次数。</li>
<li>惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。</li>
</ul>
<p>字符串之所以采用预分配的方式是防止修改操作需要不断重分配内存和字节数据拷贝。但同样也会造成内存的浪费。我们需要尽量减少字符串频繁修改操作如<code>append</code>、<code>setrange</code>可能导致的预分配容量翻倍（内存碎片率上升）的问题。</p>
<p>字符串重构：指<strong>不一定把每份数据作为字符串整体存储，像json这样的数据可以使用hash结构，使用二级结构存储也能帮我们节省内存</strong>。同时可以使用<code>hmget</code>、<code>hmset</code>命令支持字段的部分读取修改，而不用每次整体存取。如下面的json数据：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"vid"</span>: <span class="string">"413368768"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"搜狐屌丝男士"</span>,</span><br><span class="line">    <span class="attr">"videoAlbumPic"</span>:<span class="string">"http://photocdn.sohu.com/60160518/vrsa_ver8400079_ae433_pic26.jpg"</span>,</span><br><span class="line">    <span class="attr">"pid"</span>: <span class="string">"6494271"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"1024"</span>,</span><br><span class="line">    <span class="attr">"playlist"</span>: <span class="string">"6494271"</span>,</span><br><span class="line">    <span class="attr">"playTime"</span>: <span class="string">"468"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<center>测试内存表现</center>

<table>
<thead>
<tr>
<th align="center">数据量</th>
<th align="center">key</th>
<th align="left">存储类型</th>
<th align="center">value</th>
<th align="center">配置</th>
<th align="center">used_mem</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200w</td>
<td align="center">20字节</td>
<td align="left">string</td>
<td align="center">json 字符串</td>
<td align="center">默认</td>
<td align="center">612.2M</td>
</tr>
<tr>
<td align="center">200w</td>
<td align="center">20字节</td>
<td align="left">hash</td>
<td align="center">key-value 对</td>
<td align="center">默认</td>
<td align="center">1.88G</td>
</tr>
<tr>
<td align="center">200w</td>
<td align="center">20字节</td>
<td align="left">hash</td>
<td align="center">key-value 对</td>
<td align="center">hash-max-ziplist-value:66</td>
<td align="center">535.60M</td>
</tr>
</tbody></table>
<p>根据测试结构，第一次默认配置下使用hash类型，内存消耗不但没有降低反而比字符串存储多出2倍，而调整<code>hash-max-ziplist-value=66</code>之后内存降低为535.60M。因为json的<code>videoAlbumPic</code>属性长度是65，而<code>hash-max-ziplist-value</code>默认值是64，Redis采用<code>hashtable</code>编码方式，反而消耗了大量内存。调整配置后hash类型内部编码方式变为<code>ziplist</code>，相比字符串更省内存且支持属性的部分操作。</p>
<h3 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h3><table>
<thead>
<tr>
<th>类型</th>
<th>编码方式</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>raw</td>
<td>动态字符串编码</td>
</tr>
<tr>
<td></td>
<td>embstr</td>
<td>优化内存分配的字符串编码</td>
</tr>
<tr>
<td></td>
<td>int</td>
<td>整数编码</td>
</tr>
<tr>
<td>hash</td>
<td>hashtable</td>
<td>散列表编码</td>
</tr>
<tr>
<td></td>
<td>ziplist</td>
<td>压缩列表编码</td>
</tr>
<tr>
<td>list</td>
<td>linkedlist</td>
<td>双向链表编码</td>
</tr>
<tr>
<td></td>
<td>ziplist</td>
<td>压缩列表编码</td>
</tr>
<tr>
<td></td>
<td>quicklist</td>
<td></td>
</tr>
<tr>
<td>set</td>
<td>hashtable</td>
<td>散列表编码</td>
</tr>
<tr>
<td></td>
<td>intset</td>
<td>整数集合编码</td>
</tr>
<tr>
<td>zset</td>
<td>skiplist</td>
<td>跳跃表编码</td>
</tr>
<tr>
<td></td>
<td>ziplist</td>
<td>压缩列表编码</td>
</tr>
</tbody></table>
<p>Redis 对一种数据结构实现多种编码方式主要原因是Redis作者想通过不同编码实现效率和空间的平衡。比如当我们的存储只有10个元素的列表，当使用双向链表数据结构时，必然需要维护大量的内部字段如每个元素需要：前置指针，后置指针，数据指针等，造成空间浪费，如果采用连续内存结构的压缩列表（ziplist），将会节省大量内存，而由于数据长度较小，存取操作时间复杂度即使为$O(n^2)$性能也可满足需求。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>决定条件</th>
</tr>
</thead>
<tbody><tr>
<td>hash</td>
<td>ziplist</td>
<td>满足所有条件：<br>value 最大空间（字节）&lt;= hash-max-ziplist-value<br>field 个数 &lt;= hash-max-ziplist-entries</td>
</tr>
<tr>
<td></td>
<td>hashtable</td>
<td>满足任意条件：<br>value 最大空间（字节）&gt; hash-max-ziplist-value<br>field 个数 &gt; hash-max-ziplist-entries</td>
</tr>
<tr>
<td>list</td>
<td>ziplist</td>
<td>满足所有条件：<br>value 最大空间（字节）&lt;= list-max-ziplist-value<br>链表长度 &lt;= list-max-ziplist-entries</td>
</tr>
<tr>
<td></td>
<td>linkedlist</td>
<td>满足任意条件：<br>value 最大空间（字节）&gt; list-max-ziplist-value<br>链表长度 &gt; list-max-ziplist-entries</td>
</tr>
<tr>
<td></td>
<td>quicklist</td>
<td>list-max-ziplist-size：表示最大压缩空间或长度<br>最大空间使用[-5-1]范围配置，默认-2 表示 8KB<br>正整数表示最大压缩长度<br>list-compress-depth：表示最大压缩深度，默认为 0 表示不压缩</td>
</tr>
<tr>
<td>set</td>
<td>intset</td>
<td>满足所有条件：<br>元素必须为整数<br>集合长度 &lt;= set-max-intset-entries</td>
</tr>
<tr>
<td></td>
<td>hashtable</td>
<td>满足任意条件：<br>元素非整数类型<br>集合长度 &gt; set-max-ziplist-entries</td>
</tr>
<tr>
<td>zset</td>
<td>ziplist</td>
<td>满足所有条件：<br>value 最大空间（字节）&lt;= zset-max-ziplist-value<br>有序集合长度 &lt;= zset-max-ziplist-entries</td>
</tr>
<tr>
<td></td>
<td>skiplist</td>
<td>满足任意条件：<br>value 最大空间（字节）&gt; zset-max-ziplist-value<br>有序集合长度 &gt; zset-max-ziplist-entries</td>
</tr>
</tbody></table>
<p>ziplist编码主要目的是为了节约内存，因此所有数据都是采用线性连续的内存结构。ziplist编码是应用范围最广的一种，可以分别作为hash、list、zset类型的底层数据结构实现。其内部结构如图：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g982kp4di3j30lh0fadim.jpg" alt=""></p>
<p>ziplist特点如下：</p>
<ul>
<li>内部表现为数据紧凑排列的一块连续内存数组。</li>
<li>可以模拟双向链表结构，以$O(1)$时间复杂度入队和出队。</li>
<li>新增删除操作涉及内存重新分配或释放，加大了操作的复杂性。(<strong>ziplist压缩编码的原则：追求空间和时间的平衡</strong>)</li>
<li>读写操作涉及复杂的指针移动，最坏时间复杂度为$O(n^2)$。</li>
<li><strong>适合存储小对象和长度有限的数据</strong>。</li>
</ul>
<blockquote>
<p>我们可以看到，Redis 通过多种手段来保障性能，如单线程、epoll、基于内存操作、内存预分配、自动切换合理的数据结构等，作者在这方便做了很多的努力，所以才会有很多$O(1)$复杂度方法，日后才能大行其道，这其中我们可以借鉴的经验俯拾皆是，足见作者是一个有追求的 coder，相信 Redis 的源码会给与我们更多的启发。</p>
</blockquote>
<h3 id="控制键的数量"><a href="#控制键的数量" class="headerlink" title="控制键的数量"></a>控制键的数量</h3><p>对于存储相同的数据内容利用Redis的数据结构(如hash)降低外层键的数量，也可以节省大量内存。</p>
<p>建议使用Redis存储大量数据时，把内存优化环节加入到前期设计阶段，否则数据大幅增长后，开发人员需要面对重新优化内存所带来开发和数据迁移的双重成本。<strong>当Redis内存不足时，首先考虑的问题不是加机器做水平扩展，应该先尝试做内存优化，当遇到瓶颈时，再去考虑水平扩展</strong>。即使对于集群化方案，垂直层面优化也同样重要，避免不必要的资源浪费和集群化后的管理成本。</p>
<h2 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h2><p>内存是相对宝贵的资源，通过合理的优化可以有效地降低内存的使用量，内存优化的思路包括</p>
<ul>
<li>精简键值对大小，使用高效二进制序列化工具。</li>
<li>使用对象共享池优化小整数对象。</li>
<li>数据优先使用整数，比字符串类型更节省空间。</li>
<li>优化字符串使用，避免预分配造成的内存浪费。</li>
<li>使用<code>ziplist</code>压缩编码优化<code>hash</code>、<code>list</code>等结构，注重效率和空间的平衡。</li>
<li>使用<code>intset</code>编码优化整数集合。</li>
<li>使用<code>ziplist</code>编码的<code>hash</code>结构降低小对象链规模。</li>
</ul>
<h1 id="第-9-章-哨兵"><a href="#第-9-章-哨兵" class="headerlink" title="第 9 章 哨兵"></a>第 9 章 哨兵</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>主从模式下存在的问题：</p>
<ol>
<li>主节点宕机的故障转移需要人工介入恢复（👉 哨兵）</li>
<li>主节点的写能力与存储能力受到单机的限制（👉 集群）</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g994eh8oswj30lt0fr41y.jpg" alt=""></p>
<p>Redis Sentinel 具有以下几个功能：</p>
<ul>
<li>监控：Sentinel节点会定期检测Redis数据节点、其余Sentinel节点是否可达。</li>
<li>通知：Sentinel节点会将故障转移的结果通知给应用方。</li>
<li>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系。</li>
<li>配置提供者：在Redis Sentinel结构中，客户端在初始化的时候连接的是Sentinel节点集合，从中获取主节点信息。</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>从节点的部署与主节点的基本一致，只是添加了<code>slaveof</code>配置。<br>可通过<code>info replication</code>命令查看从节点或所属主节点。</p>
<p>哨兵节点配置信息如下：</p>
<figure class="highlight lsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel<span class="number">-26379.</span>conf</span><br><span class="line">port <span class="number">26379</span>                                                      <span class="comment">// 哨兵默认端口</span></span><br><span class="line">daemonize yes</span><br><span class="line">logfile <span class="string">"26379.log"</span>                                             <span class="comment">// 日志文件</span></span><br><span class="line">dir /opt/soft/redis/data</span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span>                      <span class="comment">// 该哨兵监控 mymaster 127.0.0.1 6379 的主节点，同时需要 2 个哨兵判断故障才会进行故障转移。故障判定参数 quorum 建议设置为**哨兵节点数量的一般加 1**，同时该参数还与哨兵节点的领导者选举有关，至少需要有 `max(quorum, num(sentinels)/2 + 1)`个节点参与选举，才能选出哨兵领导者</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span>                 <span class="comment">// 监控节点的超时时间</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span>                              <span class="comment">// 用于限制一次故障转移后，每次向新的主节点发起复制操作的从节点个数。同时向主节点发起复制，必然会对主机诶单所在机器造成网络与磁盘开销</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span>                       <span class="comment">// 故障转移超时时间</span></span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;                   </span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;      <span class="comment">// 在故障**转移期间**的告警事件脚本</span></span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;   <span class="comment">// 在故障**转移结束后**的事件脚本</span></span><br></pre></td></tr></tbody></table></figure>

<p>启动Sentinel节点的命令：<code>redis-sentinel</code>或<code>redis-server redis-sentinel-26379.conf --sentinel</code>。<br>可通过<code>info sentinel</code>命令查看哨兵节点信息<br>哨兵节点会通过主节点发现从节点以及其它哨兵节点，从而实现对所有节点的监控。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bsaxy49ij30kq0eetcb.jpg" alt=""></p>
<p>部署技巧</p>
<ul>
<li>哨兵节点不应该部署在同一台物理机上</li>
<li>部署至少三个且奇数个哨兵节点</li>
<li>如果哨兵节点集合监控的是同一个业务的多个主节点集合，那么采用一套哨兵节点监控多个主从节点，否则采用多个哨兵节点监控多个主从节点的方案。</li>
</ul>
<h2 id="哨兵节点的-API"><a href="#哨兵节点的-API" class="headerlink" title="哨兵节点的 API"></a>哨兵节点的 API</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>sentinel masters</code></td>
<td>展示所有被监控的主节点状态以及相关统计信息</td>
</tr>
<tr>
<td><code>sentinel master &lt;master name&gt;</code></td>
<td>展示指定<code>&lt;master name&gt;</code>的主节点状态以及相关的统计信息</td>
</tr>
<tr>
<td><code>sentinel slaves &lt;master name&gt;</code></td>
<td>展示指定<code>&lt;master name&gt;</code>的从节点状态以及相关的统计信息</td>
</tr>
<tr>
<td><code>sentinel sentinels &lt;master name&gt;</code></td>
<td>展示指定<code>&lt;master name&gt;</code>的Sentinel节点集合（不包含当前Sentinel节点）</td>
</tr>
<tr>
<td><code>sentinel get-master-addr-by-name &lt;master name&gt;</code></td>
<td>返回指定<code>&lt;master name&gt;</code>主节点的IP地址和端口</td>
</tr>
<tr>
<td><code>sentinel reset &lt;pattern&gt;</code></td>
<td>当前Sentinel节点对符合<code>&lt;pattern&gt;</code>（通配符风格）主节点的配置进行重置，包含清除主节点的相关状态（例如故障转移），重新发现从节点和Sentinel节点。</td>
</tr>
<tr>
<td><code>sentinel failover &lt;master name&gt;</code></td>
<td>对指定<code>&lt;master name&gt;</code>主节点进行强制故障转移（没有和其他Sentinel节点“协商”），当故障转移完成后，其他Sentinel节点按照故障转移的结果更新自身配置，这个命令在Redis Sentinel的日常运维中非常有用。</td>
</tr>
<tr>
<td><code>sentinel ckquorum &lt;master name&gt;</code></td>
<td>检测当前可达的Sentinel节点总数是否达到<code>&lt;quorum&gt;</code>的个数</td>
</tr>
<tr>
<td><code>sentinel flushconfig</code></td>
<td>将Sentinel节点的配置强制刷到磁盘上，这个命令Sentinel节点自身用得比较多，对于开发和运维人员只有当外部原因（例如磁盘损坏）造成配置文件损坏或者丢失时，这个命令是很有用的。</td>
</tr>
<tr>
<td><code>sentinel remove &lt;master name&gt;</code></td>
<td>取消当前Sentinel节点对于指定<code>&lt;master name&gt;</code>主节点的监控。</td>
</tr>
<tr>
<td><code>sentinel monitor &lt;master name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</code></td>
<td>与配置文件中的含义是完全一样</td>
</tr>
<tr>
<td><code>sentinel set &lt;master name&gt;</code></td>
<td>动态修改Sentinel节点配置选项。注意：该命令只会对当前节点有效，且修改成功后会立即生效</td>
</tr>
<tr>
<td><code>sentinel is-master-down-by-addr</code></td>
<td>Sentinel节点之间用来交换对主节点是否下线的判断，根据参数的不同，还可以作为Sentinel领导者选举的通信方式</td>
</tr>
</tbody></table>
<p>Redis Sentinel 客户端基本实现原理</p>
<ol>
<li>遍历Sentinel节点集合获取一个可用的Sentinel节点(Sentinel节点之间可以共享数据)，所以可以从任意一个Sentinel节点获取主节点信息</li>
<li>通过<code>sentinel get-master-addr-by-name master-name</code>这个API来获取对应主节点的相关信息</li>
<li>验证当前获取的“主节点”是真正的主节点(通过 <code>role</code> 或者 <code>info replication</code> 判定)，这样做的目的是为了防止故障转移期间主节点的变化</li>
<li>保持和Sentinel节点集合的“联系”，时刻获取关于主节点的相关“信息”</li>
</ol>
<h2 id="Redis-Sentinel-的实现原理"><a href="#Redis-Sentinel-的实现原理" class="headerlink" title="Redis Sentinel 的实现原理"></a>Redis Sentinel 的实现原理</h2><h3 id="三个定时监控任务"><a href="#三个定时监控任务" class="headerlink" title="三个定时监控任务"></a>三个定时监控任务</h3><ol>
<li>每隔10秒，每个Sentinel节点会向主节点和从节点发送<code>info</code>命令获取最新的拓扑结构。该任务的作用表现在：<ol>
<li>通过向主节点执行<code>info</code>命令，获取从节点的信息</li>
<li>当有新的从节点加入时都可以立刻感知出来</li>
<li>节点不可达或者故障转移后，可以通过<code>info</code>命令实时更新节点拓扑信息。</li>
</ol>
</li>
<li>每隔2秒，每个Sentinel节点会向Redis数据节点的<code>__sentinel__：hello</code>频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断，所以这个定时任务可以完成以下两个工作：<ol>
<li>发现新的Sentinel节点：通过订阅主节点的<code>__sentinel__：hello</code>了解其他的Sentinel节点信息，如果是新加入的Sentinel节点，将该Sentinel节点信息保存起来，并与该Sentinel节点创建连接。</li>
<li>Sentinel节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。Sentinel节点publish的消息格式：<code>&lt;Sentinel节点IP&gt; &lt;Sentinel节点端口&gt; &lt;Sentinel节点runId&gt; &lt;Sentinel节点配置版本&gt; &lt;主节点名字&gt; &lt;主节点Ip&gt; &lt;主节点端口&gt; &lt;主节点配置版本&gt;</code></li>
</ol>
</li>
<li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。这个定时任务是节点失败判定的重要依据。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9chovnyqwj30lm0ls77d.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9chuf4cjdj30ld0hogp4.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9chunrge9j30mh0hbtbn.jpg" alt=""></p>
<h3 id="主观下线与客观下线"><a href="#主观下线与客观下线" class="headerlink" title="主观下线与客观下线"></a>主观下线与客观下线</h3><p>主观下线：单个哨兵节点判断主节点超过<code>down-after-milliseconds</code>时，该哨兵节点即认为该主节点已下线<br>客观下线：为了防止主观下线的误判，因此还需要发送<code>过sentinel ismaster-down-by-addr</code>命令向其他Sentinel节点询问对主节点的判断，当超过<code>&lt;quorum&gt;</code>个数，即判定该主节点确实已下线</p>
<h3 id="领导者-Sentinel-节点选举"><a href="#领导者-Sentinel-节点选举" class="headerlink" title="领导者 Sentinel 节点选举"></a>领导者 Sentinel 节点选举</h3><p><strong>Redis 使用了 <a href="https://raft.github.io/" target="_blank" rel="noopener">Raft 算法</a> 实现领导者选举</strong>。该算法的思路为：每个节点均有选举与被选举资格，且每个节点有且只有 1 票。当哨兵节点完成主观下线后，向其它哨兵节点询问客观下线时，会提议自身作为哨兵领导者，若被询问者尚未投票，则取得该被询问者的票数，如果询问者的票数大于等于<code>max(quorum, num(sentinels)/2 + 1)</code>，则该询问者成为领导，选举结束，同时终止其它节点的询问。</p>
<p>Raft 作为一致性协议，提供了以下几个重要的功能：</p>
<ol>
<li>Leader 选举</li>
<li>成员变更</li>
<li>日志复制</li>
</ol>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>故障转移的具体步骤如下：</p>
<ol>
<li>在从节点列表中选出一个节点作为新的主节点，选择方法如下<ol>
<li>过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过<code>down-after-milliseconds * 10</code>秒。</li>
<li>选择<code>slave-priority</code>（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。</li>
<li>选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续。</li>
<li>选择runid最小的从节点。</li>
</ol>
</li>
<li>Sentinel领导者节点会对第一步选出来的从节点执行<code>slaveof no one命</code>令让其成为主节点</li>
<li>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和<code>parallel-syncs</code>参数有关</li>
<li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cieyqdx2j30je0riwj1.jpg" alt=""></p>
<h2 id="开发与运维问题"><a href="#开发与运维问题" class="headerlink" title="开发与运维问题"></a>开发与运维问题</h2><p>模拟故障的方式：</p>
<ul>
<li>方法一，强制杀掉对应节点的进程号，这样可以模拟出宕机的效果。</li>
<li>方法二，使用Redis的<code>debug sleep</code>命令，让节点进入睡眠状态，这样可以模拟阻塞的效果。</li>
<li>方法三，使用Redis的<code>shutdown</code>命令，模拟正常的停掉Redis。</li>
</ul>
<p>Sentinel节点只支持如下命令：<code>ping</code>、<code>sentinel</code>、<code>subscribe</code>、<code>unsubscribe</code>、<code>psubscribe</code>、<code>punsubscribe</code>、<code>publish</code>、<code>info</code>、<code>role</code>、<code>client</code>、<code>shutdown</code>。</p>
<h1 id="第-10-章-集群"><a href="#第-10-章-集群" class="headerlink" title="第 10 章 集群"></a>第 10 章 集群</h1><h2 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h2><p>常见的分区规则有哈希分区与顺序分区两种。Redis 集群采用了哈希分区。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9e35sce95j30m505ywfm.jpg" alt=""></p>
<h3 id="常见的哈希分区规则"><a href="#常见的哈希分区规则" class="headerlink" title="常见的哈希分区规则"></a>常见的哈希分区规则</h3><ul>
<li>节点取余<ul>
<li>使用特定的数据，如Redis的键或用户ID，再根据节点数量N使用公式：<code>hash(key)%N</code>计算出哈希值，用来决定数据映射到哪一个节点上。这种方案存在一个问题：当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。常用于数据库的分库分表规则，一般采用预分区的方式，提前根据数据量规划好分区数。</li>
</ul>
</li>
<li>一致性哈希分区<ul>
<li>一致性哈希分区（Distributed Hash Table）实现思路是为系统中每个节点分配一个token，范围一般在0~$2^{32}$，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点</li>
<li>一致性哈希分区存在几个问题：①加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此<strong>一致性哈希常用于缓存场景</strong>②当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式<strong>不适合少量数据节点的分布式方案</strong>③普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡。</li>
</ul>
</li>
<li>虚拟分区槽<ul>
<li>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot），计算公式为<code>slot=CRC16(key)&amp;16383</code>。如Redis Cluster槽范围是0~16383。<strong>槽是集群内数据管理和迁移的基本单位</strong>。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽</li>
</ul>
</li>
</ul>
<p>Redis 虚拟槽分区的特点：</p>
<ul>
<li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li>
<li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li>
<li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li>
</ul>
<h3 id="集群功能限制"><a href="#集群功能限制" class="headerlink" title="集群功能限制"></a>集群功能限制</h3><ol>
<li>key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于执行mget、mget等操作可能存在于多个节点上因此不被支持。</li>
<li>key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。</li>
<li>key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash、list等映射到不同的节点。</li>
<li>不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即db0。</li>
<li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li>
</ol>
<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><p>搭建集群需要三个步骤：</p>
<ol>
<li>准备节点<ul>
<li>Redis集群一般由多个节点组成，<strong>节点数量至少为6个才能保证组成完整高可用的集群</strong>。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、data、log，分别存放配置、数据和日志相关文件。</li>
<li>节点 ID 用于唯一标识集群内一个节点，之后很多集群操作都要借助于节点ID来完成。需要注意是，节点ID不同于运行ID。节点ID在集群初始化时只创建一次，节点重启时会加载集群配置文件进行重用，而Redis的运行ID每次重启都会变化。在节点6380执行<code>cluster nodes</code>命令获取集群节点状态。</li>
<li>Redis 自动维护集群配置文件，不要手动修改，防止节点重启时产生集群信息错误。</li>
</ul>
</li>
<li>节点握手<ul>
<li>由客服端发起命令<code>cluster meet {ip} {port}</code>建立连接，该命令为异步命令。</li>
<li>节点建立握手后，集群此时处于下线状态，所有的数据读写都被禁止。可以通过<code>cluster info</code>查看当前集群状态。</li>
</ul>
</li>
<li>分配槽<ul>
<li>通过<code>cluster addslots</code>命令为节点分配槽。作为一个完整的集群，每个负责处理槽的节点应该具有从节点，保证当它出现故障时可以自动进行故障转移。集群模式下，Reids节点角色分为主节点和从节点。首次启动的节点和被分配槽的节点都是主节点，从节点负责复制主节点槽信息和相关的数据。使用<code>cluster replicate{nodeId}</code>命令让一个节点成为从节点。</li>
</ul>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9i5gd6qalj30n80nowkd.jpg" alt="集群完整结构"></p>
<p>由于手动创建集群过于繁琐，且随着集群规模的扩大会加大复杂度与运维成本，因此可以通过<code>redis-trib.rb</code>来搭建集群，该工具支持集群创建、检查、修复、均衡等命令行工具。</p>
<p>当集群创建完成后，我们还需要进行完整性检查。集群完整性指所有的槽都分配到存活的主节点上，只要16384个槽中有一个没有分配给节点则表示集群不完整。可以使用<code>redis-trib.rb check</code>命令检测之前创建的两个集群是否成功，<code>check</code>命令只需要给出集群中任意一个节点地址就可以完成整个集群的检查工作。当持有槽的主节点下线时，从故障发现到自动完成转移期间整个集群是不可用状态，对于大多数业务无法容忍这种情况，因此建议将参数<code>cluster-require-full-coverage</code>配置为no，当主节点故障时只影响它负责槽的相关命令执行，不会影响其他主节点的可用性。</p>
<h2 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h2><p>常见的元数据维护方式分为：集中式和P2P方式。Redis集群采用P2P的Gossip（流言）协议，Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播。其通信过程如下：</p>
<ol>
<li>集群中的每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000。</li>
<li>每个节点在固定周期内通过特定规则选择几个节点发送ping消息。</li>
<li>接收到ping消息的节点用pong消息作为响应。</li>
</ol>
<blockquote>
<p>我们经常在网络中使用 ping 作为探活命令，使用 pong 作为响应，这个两个词在一次正好为 ping-pong 乒乓球，可以理解为发送方发出去的球得到响应才认为对方存活。不知道创建这一对命令的人是否也是基于这个理念创建的。</p>
</blockquote>
<p>常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息等。</p>
<ul>
<li>meet 消息：用于通知新节点加入</li>
<li>ping 消息：用于检测节点是否在线和交换彼此状态信息。ping 消息发送封装了自身节点和部分其他节点的状态数据。</li>
<li>pong 消息：作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。</li>
<li>fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</li>
</ul>
<p>所有消息格式划分为消息头和消息体。消息头包含发送节点自身状态数据（如节点id、槽映射、节点标识（主从角色，是否下线）等），接收节点根据消息头就可以获取到发送节点的相关数据；消息体则包含了发送节点所了解的其他节点信息。消息的类型则根据消息头的 type 属性区分。</p>
<p>消息头结构 clusterMsg 如下</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">4</span>]; <span class="comment">/* 信号标示 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> totlen; <span class="comment">/* 消息总长度 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ver; <span class="comment">/* 协议版本*/</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type; <span class="comment">/* 消息类型,用于区分meet,ping,pong等消息 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> count; <span class="comment">/* 消息体包含的节点数量，仅用于meet,ping,ping消息类型*/</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch; <span class="comment">/* 当前发送节点的配置纪元 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch; <span class="comment">/* 主节点/从节点的主节点配置纪元 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> offset; <span class="comment">/* 复制偏移量 */</span></span><br><span class="line">    <span class="keyword">char</span> sender[CLUSTER_NAMELEN]; <span class="comment">/* 发送节点的nodeId */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> myslots[CLUSTER_SLOTS/<span class="number">8</span>]; <span class="comment">/* 发送节点负责的槽信息 */</span></span><br><span class="line">    <span class="keyword">char</span> slaveof[CLUSTER_NAMELEN]; <span class="comment">/* 如果发送节点是从节点，记录对应主节点的nodeId */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port; <span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags; <span class="comment">/* 发送节点标识,区分主从角色，是否下线等 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> state; <span class="comment">/* 发送节点所处的集群状态 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mflags[<span class="number">3</span>]; <span class="comment">/* 消息标识 */</span></span><br><span class="line">    <span class="keyword">union</span> clusterMsgData data <span class="comment">/* 消息正文 */</span>;</span><br><span class="line">} clusterMsg;</span><br></pre></td></tr></tbody></table></figure>

<p>消息体 clusterMsgData 结构如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">char</span> nodename[CLUSTER_NAMELEN]; <span class="comment">/* 节点的nodeId */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_sent; <span class="comment">/* 最后一次向该节点发送ping消息时间 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pong_received; <span class="comment">/* 最后一次接收该节点pong消息时间 */</span></span><br><span class="line">    <span class="keyword">char</span> ip[NET_IP_STR_LEN]; <span class="comment">/* IP */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port; <span class="comment">/* port*/</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags; <span class="comment">/* 该节点标识, */</span></span><br><span class="line">} clusterMsgDataGossip;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ic768uakj30ho0m8jve.jpg" alt=""></p>
<p>如果节点间频繁通信，则会加重带宽和计算的负担，过慢又会导致信息更新不及时，因此此Redis集群的Gossip协议需要兼顾信息交换实时性和成本开销。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9icdly6hpj30j30ebq5o.jpg" alt=""></p>
<p>从Gossip的通信机制中我们看到，影响带宽的主要因素在于通信的节点数与发送的消息数据量，因此，我们从这两方面进行优化：</p>
<ul>
<li>选择发送消息的节点数量：集群内每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个节点找出最久没有通信的节点发送ping消息，用于保证Gossip信息交换的随机性。每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于<code>cluster_node_timeout/2</code>，则立刻发送ping消息，防止该节点信息太长时间未更新。根据以上规则得出每个节点每秒需要发送ping消息的数量<code>=1+10*num（node.pong_received&gt;cluster_node_timeout/2</code>，因此<code>cluster_node_timeout</code>参数对消息发送的节点数量影响非常大。当我们的带宽资源紧张时，可以适当调大这个参数。</li>
<li>消息数据量：消息头主要占用空间的字段是<code>myslots[CLUSTER_SLOTS/8]</code>，占用2KB，这块空间占用相对固定。消息体携带数据量跟集群的节点数息息相关，更大的集群每次消息通信的成本也就更高，因此对于Redis集群来说并不是大而全的集群更好。</li>
</ul>
<h2 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h2><p>集群的水平伸缩的上层原理：<strong>集群伸缩 = 槽和数据在节点之间的移动</strong>。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9icgp2fv1j30ju0gwtcv.jpg" alt=""></p>
<h3 id="扩容集群"><a href="#扩容集群" class="headerlink" title="扩容集群"></a>扩容集群</h3><p>槽迁移数据流程如下：</p>
<ol>
<li>对目标节点发送<code>cluster setslot {slot} importing {sourceNodeId}</code>命令，让目标节点准备导入槽的数据。</li>
<li>对源节点发送<code>cluster setslot {slot} migrating {targetNodeId}</code>命令，让源节点准备迁出槽的数据。</li>
<li>源节点循环执行<code>cluster getkeysinslot {slot} {count}</code>命令，获取count个属于槽{slot}的键。</li>
<li>在源节点上执行<code>migrate {targetIp} {targetPort} "" 0 {timeout} keys {keys...}</code>命令，把获取的键通过流水线机制批量迁移到目标节点。</li>
<li>重复执行步骤3和步骤4直到槽下所有的键值数据迁移到目标节点。</li>
<li>向集群内所有主节点发送<code>cluster setslot {slot} node {targetNodeId}</code>命令，通知槽分配给目标节点。为了保证槽节点映射变更及时传播，需要遍历发送给所有主节点更新被迁移的槽指向新节点。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jh857qqpj30ji0ehq6u.jpg" alt=""></p>
<p><code>redis-trib</code>槽重分片功能命令如下：<code>redis-trib.rb reshard host:port --from &lt;arg&gt; --to &lt;arg&gt; --slots &lt;arg&gt; --yes --timeout &lt;arg&gt; --pipeline &lt;arg&gt;</code></p>
<ul>
<li><code>host:port</code>：必传参数，集群内任意节点地址，用来获取整个集群信息。</li>
<li><code>--from</code>：制定源节点的id，如果有多个源节点，使用逗号分隔，如果是all源节点变为集群内所有主节点，在迁移过程中提示用户输入。</li>
<li><code>--to</code>：需要迁移的目标节点的id，目标节点只能填写一个，在迁移过程中提示用户输入。</li>
<li><code>--slots</code>：需要迁移槽的总数量，在迁移过程中提示用户输入。</li>
<li><code>--yes</code>：当打印出reshard执行计划时，是否需要用户输入yes确认后再执行<code>reshard</code>。</li>
<li><code>--timeout</code>：控制每次migrate操作的超时时间，默认为60000毫秒。</li>
<li><code>--pipeline</code>：控制每次批量迁移键的数量，默认为10。</li>
</ul>
<p>迁移之后建议使用<code>redis-trib.rb rebalance</code>命令检查节点之间槽的均衡性。</p>
<h3 id="收缩集群"><a href="#收缩集群" class="headerlink" title="收缩集群"></a>收缩集群</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jhell5zkj30gy0hc417.jpg" alt=""></p>
<ol>
<li>首先需要确定下线节点是否有负责的槽，如果是，需要把槽迁移到其他节点，保证节点下线后整个集群槽节点映射的完整性。</li>
<li>当下线节点不再负责槽或者本身是从节点时，就可以通知集群内其他节点忘记下线节点，当所有的节点忘记该节点后可以正常关闭。</li>
</ol>
<p>下线节点需要把自己负责的槽迁移到其他节点，原理与之前节点扩容的迁移槽过程一致。在此不做赘述。</p>
<p>由于集群内的节点不停地通过Gossip消息彼此交换节点状态，因此需要通过一种健壮的机制让集群内所有节点忘记下线的节点。也就是说让其他节点不再与要下线节点进行Gossip消息交换。Redis提供了<code>cluster forget{downNodeId}</code>命令实现该功能，（此处的Gossip对忘记节点造成了阻碍）</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jhkc00w3j30he0b3q5k.jpg" alt=""></p>
<p>当节点接收到<code>cluster forget{down NodeId}</code>命令后，会把nodeId指定的节点加入到禁用列表中，在禁用列表内的节点不再发送Gossip消息。禁用列表有效期是60秒，超过60秒节点会再次参与消息交换。也就是说当第一次forget命令发出后，我们有60秒的时间让集群内的所有节点忘记下线节点。线上操作不建议直接使用<code>cluster forget</code>命令下线节点，需要跟大量节点命令交互，实际操作起来过于繁琐并且容易遗漏forget节点。建议使用<code>redistrib.rb del-node{host:port}{downNodeId}</code>命令，内部实现的伪代码如下：</p>
<figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def delnode_cluster_cmd(downNode):</span><br><span class="line">    <span class="comment"># 下线节点不允许包含slots</span></span><br><span class="line">    <span class="keyword">if</span> downNode.slots.length != <span class="number">0</span></span><br><span class="line">        <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">    end</span><br><span class="line">    <span class="comment"># 向集群内节点发送cluster forget</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nodes:</span><br><span class="line">        <span class="keyword">if</span> n.id == downNode.id:</span><br><span class="line">            <span class="comment"># 不能对自己做forget操作</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment"># 如果下线节点有从节点则把从节点指向其他主节点</span></span><br><span class="line">        <span class="keyword">if</span> n.replicate &amp;&amp; n.replicate.nodeId == downNode.id :</span><br><span class="line">            <span class="comment"># 指向拥有最少从节点的主节点</span></span><br><span class="line">            master = get_master_with_least_replicas();</span><br><span class="line">            n.cluster(<span class="string">"replicate"</span>,master.nodeId);</span><br><span class="line">        <span class="comment">#发送忘记节点命令</span></span><br><span class="line">        n.cluster(<span class="string">'forget'</span>,downNode.id)</span><br><span class="line"><span class="comment"># 节点关闭</span></span><br><span class="line">downNode.shutdown();</span><br></pre></td></tr></tbody></table></figure>

<p>当下线主节点具有从节点时需要把该从节点指向到其他主节点，因此对于主从节点都下线的情况，建议先下线从节点再下线主节点，防止不必要的全量复制。</p>
<h2 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h2><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p>在集群模式下，Redis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，通知客户端请求正确的节点。这个过程称为MOVED重定向。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jhv81y3pj30j00jrwhp.jpg" alt=""></p>
<p>可以通过<code>cluster keyslot{key}</code>命令返回key所对应的槽，该命令采用<code>key_hash_slot()</code>函数实现。<br>使用<code>redis-cli</code>命令时，可以加入<code>-c</code>参数支持自动重定向，简化手动发起重定向操作。</p>
<p>键命令执行步骤主要分两步：计算槽，查找槽所对应的节点。</p>
<ol>
<li>Redis首先需要计算键所对应的槽。根据键的有效部分使用CRC16函数计算出散列值，再取对16383的余数，使每个键都可以映射到0~16383槽范围内。</li>
<li>节点对于判定键命令是执行还是MOVED重定向，都是借助<code>slots [CLUSTER_SLOTS]</code>数组实现。根据MOVED重定向机制，客户端可以随机连接集群内任一Redis获取键所在节点，这种客户端又叫Dummy（傀儡）客户端，它优点是代码实现简单，对客户端协议影响较小，只需要根据重定向信息再次发送请求即可。但是它的弊端很明显，每次执行键命令前都要到Redis上进行重定向才能找到要执行命令的节点，额外增加了IO开销，这不是Redis集群高效的使用方式。正因为如此通常集群客户端都采用另一种实现：Smart（智能）客户端。Smart客户端通过在内部维护slot→node的映射关系，本地就可实现键到节点的查找，从而保证IO效率的最大化，而MOVED重定向负责协助Smart客户端更新slot→node映射。</li>
</ol>
<h4 id="hash-tag"><a href="#hash-tag" class="headerlink" title="hash_tag"></a>hash_tag</h4><p>hash_tag 允许用 key 的部分字符串来计算 hash。当一个 key 包含 {} 的时候，就不对整个 key 做 hash，而仅对 {} 包括的字符串做 hash。</p>
<p>在集群模式下使用mget等命令优化批量调用时，键列表必须具有相同的slot，否则会报错。这时可以利用hash_tag让不同的键具有相同的slot达到优化的目的。命令如下：</p>
<figure class="highlight pf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6385</span>&gt; mget <span class="keyword">user</span>:<span class="number">10086</span>:frends <span class="keyword">user</span>:<span class="number">10086</span>:videos</span><br><span class="line">(error) CROSSSLOT Keys <span class="keyword">in</span> request don't hash <span class="keyword">to</span> the same slot</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6385</span>&gt; mget <span class="keyword">user</span>:{<span class="number">10086</span>}:friends <span class="keyword">user</span>:{<span class="number">10086</span>}:videos</span><br><span class="line"><span class="number">1</span>) <span class="string">"friends"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"videos"</span></span><br></pre></td></tr></tbody></table></figure>
<p>Pipeline同样可以受益于hash_tag，由于Pipeline只能向一个节点批量发送执行命令，而相同slot必然会对应到唯一的节点，降低了集群使用Pipeline的门槛。</p>
<h3 id="ASK-重定向"><a href="#ASK-重定向" class="headerlink" title="ASK 重定向"></a>ASK 重定向</h3><p>当slot对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。例如当一个slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qoovqnpwj30u00vlk0z.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qop67mnjj311m0ti0z1.jpg" alt=""></p>
<p>ASK与MOVED虽然都是对客户端的重定向控制，但是有着本质区别。ASK重定向说明集群正在进行slot数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新slots缓存。但是MOVED重定向说明键对应的槽已经明确指定到新的节点，因此需要更新slots缓存。</p>
<p>为了支持ASK重定向，源节点和目标节点在内部的clusterState结构中维护当前正在迁移的槽信息，用于识别槽迁移情况。</p>
<ul>
<li>如果键所在的槽由当前节点负责，但键不存在则查找<code>migrating_slots_to</code>数组查看槽是否正在迁出，如果是返回ASK重定向。</li>
<li>如果客户端发送<code>asking</code>命令打开了<code>CLIENT_ASKING</code>标识，则该客户端下次发送键命令时查找<code>importing_slots_from</code>数组获取<code>clusterNode</code>，如果指向自身则执行命令。<ul>
<li>需要注意的是，asking命令是一次性命令，每次执行完后客户端标识都会修改回原状态，因此每次客户端接收到ASK重定向后都需要发送asking命令。</li>
</ul>
</li>
<li>ASK重定向对单键命令支持得很完善。当槽处于迁移状态时，批量操作会受到影响。</li>
</ul>
<p>使用smart客户端批量操作集群时，需要评估<code>mget/mset</code>、Pipeline等方式在slot迁移场景下的容错性，防止集群迁移造成大量错误和数据丢失的情况。</p>
<p>集群环境下对于使用批量操作的场景，建议优先使用Pipeline方式，在客户端实现对ASK重定向的正确处理，这样既可以受益于批量操作的IO优化，又可以兼容slot迁移场景。</p>
<h2 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h2><p>当某个节点被主观下线后，ping/pong消息的消息体会携带集群1/10的其他节点状态数据在集群内传播。当半数以上持有槽的主节点都标记某个节点是主观下线时，触发客观下线流程。</p>
<p>每个下线报告都存在有效期(<code>cluster-node-time*2</code>)，每次在尝试触发客观下线时，都会检测下线报告是否过期，对于过期的下线报告将被删除。</p>
<p>如果在<code>cluster-node-time*2</code>时间内无法收集到一半以上槽节点的下线报告，那么之前的下线报告将会过期，也就是说主观下线上报的速度追赶不上下线报告过期的速度，那么故障节点将永远无法被标记为客观下线从而导致故障转移失败。因此不建议将<code>cluster-node-time</code>设置得过小。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qp56c761j30u010847e.jpg" alt=""></p>
<p>故障恢复流程：</p>
<ol>
<li>资格检查</li>
<li>准备选举时间</li>
<li>发起选举</li>
<li>选举投票</li>
<li>替换主节点</li>
</ol>
<p>投票作废：每个配置纪元代表了一次选举周期，如果在开始投票之后的<code>cluster-node-timeout*2</code>时间内从节点没有获取足够数量的投票，则本次选举作废。从节点对配置纪元自增并发起下一轮投票，直到选举成功为止。</p>
<p>故障转移时间：<code>failover-time(毫秒) ≤ cluster-node-timeout + cluster-node-timeout/2 + 1000</code></p>
<h2 id="集群运维"><a href="#集群运维" class="headerlink" title="集群运维"></a>集群运维</h2><p>集群倾斜</p>
<ul>
<li>数据倾斜<ul>
<li>节点和槽分配严重不均。可以使用<code>redis-trib.rb info{host:ip}</code>进行定位</li>
<li>不同槽对应键数量差异过大。键通过CRC16哈希函数映射到槽上，正常情况下槽内键数量会相对均匀。但当大量使用hash_tag时，会产生不同的键映射到同一个槽的情况。特别是选择作为hash_tag的数据离散度较差时，将加速槽内键数量倾斜情况。通过命令<code>cluster countkeysinslot{slot}</code>可以获取槽对应的键数量，识别出哪些槽映射了过多的键。再通过命令<code>clustergetkeysinslot{slot}{count}</code>循环迭代出槽下所有的键。从而发现过度使用hash_tag的键。</li>
<li>集合对象包含大量元素。</li>
<li>内存相关配置不一致。</li>
</ul>
</li>
<li>请求倾斜<ul>
<li>合理设计键，热点大集合对象做拆分或使用hmget替代hgetall避免整体读取。</li>
<li>不要使用热键作为hash_tag，避免映射到同一槽。</li>
<li>对于一致性要求不高的场景，客户端可使用本地缓存减少热键调用。</li>
</ul>
</li>
</ul>
<p>集群模式下从节点不接受任何读写请求，发送过来的键命令会重定向到负责槽的主节点上。当需要使用从节点分担主节点读压力时，可以使用<code>readonly</code>命令打开客户端连接只读状态。<code>readonly</code>命令是连接级别生效，因此每次新建连接时都需要执行<code>readonly</code>开启只读状态。执行<code>readwrite</code>命令可以关闭连接只读状态。</p>
<h1 id="第-11-章-缓存设计"><a href="#第-11-章-缓存设计" class="headerlink" title="第 11 章 缓存设计"></a>第 11 章 缓存设计</h1><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><h3 id="LRU-LFU-FIFO-算法剔除"><a href="#LRU-LFU-FIFO-算法剔除" class="headerlink" title="LRU/LFU/FIFO 算法剔除"></a>LRU/LFU/FIFO 算法剔除</h3><p>使用场景：剔除算法通常用于缓存使用量超过了预设的最大值时候，如何对现有的数据进行剔除。<br>一致性：要清理哪些数据是由具体算法决定，开发人员只能决定使用哪种算法，所以数据的一致性是最差的。<br>维护成本：算法不需要开发人员自己来实现，通常只需要配置最大<code>maxmemory</code>和对应的策略即可。开发人员只需要知道每种算法的含义，选择适合自己的算法即可。</p>
<h3 id="超时剔除"><a href="#超时剔除" class="headerlink" title="超时剔除"></a>超时剔除</h3><p>使用场景：如果业务可以容忍一段时间内，缓存层数据和存储层数据不一致，那么可以为其设置过期时间。如一个视频的描述信息，可以容忍几分钟内数据不一致，但是涉及交易方面的业务则不适用。<br>一致性：一段时间窗口内存在一致性问题。<br>维护成本：只需设置<code>expire</code>过期时间即可，维护成本较低。</p>
<h3 id="主动更新"><a href="#主动更新" class="headerlink" title="主动更新"></a>主动更新</h3><p>使用场景：应用方对于数据的一致性要求高，需要在真实数据更新后，立即更新缓存数据。<br>一致性：一致性最高，但如果主动更新发生了问题，那么这条数据很可能很长时间不会更新，所以<strong>建议结合超时剔除一起使用效果会更好</strong>。<br>维护成本：维护成本较高，开发者需要自己来完成更新，并保证更新操作的正确性。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li>低一致性业务建议配置最大内存和淘汰策略的方式使用。</li>
<li>高一致性业务可以结合使用超时剔除和主动更新，这样即使主动更新出了问题，也能保证数据过期时间后删除脏数据。</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中。造成缓存穿透的基本原因有两个。第一，自身业务代码或者数据出现问题，第二，一些恶意攻击、爬虫等造成大量空命中。</p>
<h3 id="缓存穿透的解决方案"><a href="#缓存穿透的解决方案" class="headerlink" title="缓存穿透的解决方案"></a>缓存穿透的解决方案</h3><h4 id="1-缓存空对象"><a href="#1-缓存空对象" class="headerlink" title="1. 缓存空对象"></a>1. 缓存空对象</h4><p>缓存空对象会有两个问题：第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>{</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) {</span><br><span class="line">        <span class="comment">// 从存储中获取</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) {</span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 缓存非空</span></span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enly0i2dj30g10i1ac8.jpg" alt=""></p>
<h4 id="2-布隆过滤器拦截"><a href="#2-布隆过滤器拦截" class="headerlink" title="2. 布隆过滤器拦截"></a>2. 布隆过滤器拦截</h4><p>如图所示，在访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截。例如：一个推荐系统有4亿个用户id，每个小时算法工程师会根据每个用户之前历史行为计算出推荐数据放到存储层中，但是最新的用户由于没有历史行为，就会发生缓存穿透的行为，为此可以将所有推荐数据的用户做成布隆过滤器。如果布隆过滤器认为该用户id不存在，那么就不会访问存储层，在一定程度保护了存储层。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enotipdrj30in0hvq5t.jpg" alt=""></p>
<blockquote>
<p>可以利用 Redis 的 Bitmaps 实现布隆过滤器。类似开源方案可查看 <a href="https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter" target="_blank" rel="noopener">https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter</a></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9ens6v1czj30md068q4q.jpg" alt=""></p>
<h2 id="无底洞优化"><a href="#无底洞优化" class="headerlink" title="无底洞优化"></a>无底洞优化</h2><p>无底洞是指，采用分布式提升缓存的能力，但分布式架构又引发了<code>mget</code>等批量操作命令的多次网络连接造成的性能下降。因此，更多的节点不代表更高的性能，所谓“无底<br>洞”就是说投入越多不一定产出越多。但是分布式又是不可以避免的，因为访问量和数据量越来越大，一个节点根本抗不住，所以如何高效地在分布式缓存中批量操作是一个难点。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enykatrkj30lu0m9tf4.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enz0x9eaj30mh0jsgr7.jpg" alt=""></p>
<p>无底洞问题的优化方案：</p>
<ul>
<li><p>命令本身的优化，例如优化SQL语句等。</p>
</li>
<li><p>减少网络通信次数。</p>
<ul>
<li>客户端n次get(串行执行)：n次网络+n次get命令本身。<ul>
<li>即逐次执行n个get命令，这种操作时间复杂度较高，但实现也最简单。</li>
</ul>
</li>
<li>客户端1次pipeline get(串行I/O)：1次网络+n次get命令本身。<ul>
<li>Redis Cluster使用CRC16算法计算出散列值，再取对16383的余数就可以算出slot值，同时Smart客户端会保存slot和节点的对应关系，有了这两个数据就可以将属于同一个节点的key进行归档，得到每个节点的key子列表，之后对每个节点执行mget或者Pipeline操作，它的操作时间=node次网络时间+n次命令时间，网络次数是node的个数，很明显这种方案比第一种要好很多，但是如果节点数太多，还是有一定的性能问题。</li>
</ul>
</li>
<li>客户端1次mget(并行I/O)：1次网络+1次mget命令本身。<ul>
<li>此方案是将方案2中的最后一步改为多线程执行，网络次数虽然还是节点个数，但由于使用多线程网络时间变为$O(1)$，这种方案会增加编程的复杂度。其操作时间为：<code>max_slow(node网络时间)+n次命令时间</code></li>
</ul>
</li>
<li>Redis Cluster的<code>hash_tag</code>可以将多个key强制分配到一个节点上，它的操作时间=1次网络时间+n次命令时间。</li>
</ul>
</li>
<li><p>降低接入成本，例如客户端使用长连/连接池、NIO(Non-blocking I/O)等。</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eoakg0wrj30md0g0jty.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eo4ku5pyj30mg095acq.jpg" alt=""></p>
<h2 id="雪崩优化"><a href="#雪崩优化" class="headerlink" title="雪崩优化"></a>雪崩优化</h2><p>缓存雪崩：如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eobx2323j30m20ed0vb.jpg" alt=""></p>
<p>优化方案如下：</p>
<ol>
<li>保证缓存层服务高可用性。Redis Sentinel和Redis Cluster都实现了高可用。</li>
<li>依赖隔离组件为后端限流并降级。作为并发量较大的系统，假如有一个资源不可用，可能会造成线程全部阻塞在这个资源上，造成整个系统不可用。降级机制在高并发系统中是非常普遍的：比如推荐服务中，如果个性化推荐服务不可用，可以降级补充热点数据，不至于造成前端页面是开天窗。在实际项目中，我们需要对重要的资源（例如Redis、MySQL、HBase、外部接口）都进行隔离，让每种资源都单独运行在自己的线程池中，即使个别资源出现了问题，对其他服务没有影响。</li>
<li>提前演练。在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。</li>
</ol>
<h2 id="热点key重建优化"><a href="#热点key重建优化" class="headerlink" title="热点key重建优化"></a>热点key重建优化</h2><p>在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。</p>
<p>解决热点 key 重建的思路：</p>
<ul>
<li>减少重建缓存的次数。</li>
<li>数据尽可能一致。</li>
<li>较少的潜在危险。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="互斥锁-mutex-key"><a href="#互斥锁-mutex-key" class="headerlink" title="互斥锁(mutex key)"></a>互斥锁(mutex key)</h4><p>此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>{</span><br><span class="line">    <span class="comment">// 从Redis中获取数据</span></span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="comment">// 如果value为空，则开始重构缓存</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 只允许一个线程重构缓存，使用nx，并设置过期时间ex</span></span><br><span class="line">        String mutexKey = <span class="string">"mutext:key:"</span> + key;</span><br><span class="line">        <span class="keyword">if</span> (redis.set(mutexKey, <span class="string">"1"</span>, <span class="string">"ex 180"</span>, <span class="string">"nx"</span>)) {</span><br><span class="line">            <span class="comment">// 从数据源获取数据</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            <span class="comment">// 回写Redis，并设置过期时间</span></span><br><span class="line">            redis.setex(key, timeout, value);</span><br><span class="line">            <span class="comment">// 删除key_mutex</span></span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 其他线程休息50毫秒后重试</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="永不过期"><a href="#永不过期" class="headerlink" title="永不过期"></a>永不过期</h4><p>永不过期包含两层含义：</p>
<ul>
<li>从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。</li>
<li>从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eomw75jpj30lp0lt43y.jpg" alt=""></p>
<p>作为一个并发量较大的应用，在使用缓存时有三个目标：第一，加快用户访问速度，提高用户体验。第二，降低后端负载，减少潜在的风险，保证系统平稳。第三，保证数据“尽可能”及时更新。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eol3rlkmj30mz07fq4l.jpg" alt=""></p>
<h1 id="第-12-章-Devops-的陷阱"><a href="#第-12-章-Devops-的陷阱" class="headerlink" title="第 12 章 Devops 的陷阱"></a>第 12 章 Devops 的陷阱</h1><h2 id="Redis-攻击"><a href="#Redis-攻击" class="headerlink" title="Redis 攻击"></a>Redis 攻击</h2><p>攻击者充分利用Redis的dir和<code>dbfilename</code>两个配置可以使用<code>config set</code>动态设置，以及RDB持久化的特性，将自己的公钥写入到目标机器的<code>/root/.ssh/authotrized_keys</code>文件中，从而实现了对目标机器的攻陷。攻击过程如图。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qrmwcp5ij30il0black.jpg" alt=""></p>
<h2 id="命令重写"><a href="#命令重写" class="headerlink" title="命令重写"></a>命令重写</h2><p>Redis 中提供了<code>rename-command</code>命令来重命名命令，我们可以通过该命令将一些危险命令改写，如<code>keys</code>、<code>flushall/flushdb</code>、<code>save</code>、<code>debug</code>(<code>debug reload</code>会重启 Redis)、<code>config</code>、<code>shutdown</code>。同时，<code>rename-command</code>不支持<code>config set</code>，如果AOF和RDB文件包含了rename-command之前的命令，Redis将无法启动。</p>
<p><code>rename-command</code>的最佳实践：</p>
<ul>
<li>对于一些危险的命令（例如flushall），不管是内网还是外网，一律使用<code>rename-command</code>配置</li>
<li>建议第一次配置Redis时，就应该配置<code>rename-command</code>，因为<code>renamecommand</code>不支持<code>config set</code>。</li>
<li>如果涉及主从关系，一定要保持主从节点配置的一致性，否则存在主从数据不一致的可能性。</li>
</ul>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>可以使用防火墙限制输入和输出的IP或者IP范围、端口或者端口范围。</p>
<p>很多开发者在一开始看到bind的这个配置时都是这么认为的：指定Redis只接收来自于某个网段IP的客户端请求，但<strong>事实上bind指定的是Redis和哪个网卡进行绑定</strong>，和客户端是什么网段没有关系。</p>
<ul>
<li>如果机器有外网IP，但部署的Redis是给内部使用的，建议去掉外网网卡或者使用bind配置限制流量从外网进入。</li>
<li>如果客户端和Redis部署在一台服务器上，可以使用回环地址（127.0.0.1）。</li>
<li>bind配置不支持<code>config set</code>，所以尽可能在第一次启动前配置好</li>
</ul>
<h2 id="bigkey"><a href="#bigkey" class="headerlink" title="bigkey"></a>bigkey</h2><p>危害：</p>
<ul>
<li>内存空间不均匀</li>
<li>超时阻塞</li>
<li>网络拥塞</li>
</ul>
<p>bigkey的存在并不是完全致命的，如果这个bigkey存在但是几乎不被访问，那么只有内存空间不均匀的问题存在，相对于另外两个问题没有那么重要紧急，但是如果bigkey是一个热点key（频繁访问），那么其带来的危害不可想象，所以在实际开发和运维时一定要密切关注bigkey的存在。</p>
<h2 id="查找热点-Key"><a href="#查找热点-Key" class="headerlink" title="查找热点 Key"></a>查找热点 Key</h2><table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>实现简单</td>
<td>· 内存泄露隐患<br>· 维护成本高<br>· 只能统计单个客户端</td>
</tr>
<tr>
<td>代理</td>
<td>代理是客户端和服务端的桥梁，实现最方便最系统</td>
<td>增加代理端的成本部署开发</td>
</tr>
<tr>
<td>服务端</td>
<td>实现简单</td>
<td>· monitor 本身的使用成本和危害，只能短时间使用<br>· 只能统计单个 Redis 节点</td>
</tr>
<tr>
<td>机器</td>
<td>对于客户端和服务端无侵入和影响</td>
<td>需要专业的运维团队开发，并且增加了机器的部署成本</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>读后感：Redis 是一款强有力的生产力工具，像一把瑞士军刀，只有你熟悉自己使用的工具，才能构建出一座坚固漂亮的大厦。使用什么工具决定了你的下限，但怎么使用工具决定了你的上限，你可以用 Redis 来做缓存，也可以用于流量削峰，年会抽奖，社交推荐。所有工具的背后都取决于人，创新产生价值。</p>
</blockquote>
<p>Redis 中值得我们关注的地方：</p>
<ul>
<li>基础数据类型</li>
<li>主从复制</li>
<li>哨兵</li>
<li>集群</li>
<li>如何做到高性能、低复杂度</li>
<li>如何保障主从、哨兵、集群的数据一致性</li>
</ul>

    </div>

    
    
    
      
        <div class="reward-container">
  <div>因为热爱，所以执着。</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat.png" alt="Shi Xinyu WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Shi Xinyu Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"><i class="fa fa-tag"></i> redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-prev post-nav-item">
                <a href="/post/Wall-of-Shame/" rel="prev" title="挂南墙">
                  <i class="fa fa-chevron-left"></i> 挂南墙
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-next post-nav-item">
                <a href="/post/get-bank-info-by-unionpay/" rel="next" title="银联查询银行卡信息">
                  银联查询银行卡信息 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第-1-章-初识-Redis"><span class="nav-text">第 1 章 初识 Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-数据类型"><span class="nav-text">Redis 数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-提供的功能"><span class="nav-text">Redis 提供的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-使用场景"><span class="nav-text">Redis 使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么-Redis-很快？"><span class="nav-text">为什么 Redis 很快？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-可执行文件说明"><span class="nav-text">Redis 可执行文件说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动-Redis-的3种方式"><span class="nav-text">启动 Redis 的3种方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-2-章-API-的理解和使用"><span class="nav-text">第 2 章 API 的理解和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判断键不存在的方法"><span class="nav-text">判断键不存在的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表的四种操作类型"><span class="nav-text">列表的四种操作类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表的使用场景"><span class="nav-text">列表的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合的使用场景"><span class="nav-text">集合的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表、集合、有序集合的异同点"><span class="nav-text">列表、集合、有序集合的异同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-数据结构与内部编码"><span class="nav-text">Redis 数据结构与内部编码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-3-章-小功能大用处"><span class="nav-text">第 3 章 小功能大用处</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#慢查询"><span class="nav-text">慢查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#慢查询配置"><span class="nav-text">慢查询配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#慢查询命令"><span class="nav-text">慢查询命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#慢查询日志结构"><span class="nav-text">慢查询日志结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-Shell"><span class="nav-text">Redis Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-cli"><span class="nav-text">redis-cli</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-server"><span class="nav-text">redis-server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-benchmark"><span class="nav-text">redis-benchmark</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipeline"><span class="nav-text">Pipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务与-Lua"><span class="nav-text">事务与 Lua</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在-Redis-中执行-Lua-的方法"><span class="nav-text">在 Redis 中执行 Lua 的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bitmaps"><span class="nav-text">Bitmaps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HyperLogLog"><span class="nav-text">HyperLogLog</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布订阅"><span class="nav-text">发布订阅</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GEO"><span class="nav-text">GEO</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-4-章-客户端"><span class="nav-text">第 4 章 客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端常见异常"><span class="nav-text">客户端常见异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端案例分析"><span class="nav-text">客户端案例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis内存陡增"><span class="nav-text">Redis内存陡增</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#现象"><span class="nav-text">现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析原因"><span class="nav-text">分析原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端周期性的超时"><span class="nav-text">客户端周期性的超时</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#现象-1"><span class="nav-text">现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析"><span class="nav-text">分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-5-章-持久化"><span class="nav-text">第 5 章 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB"><span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-的优缺点"><span class="nav-text">RDB 的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF"><span class="nav-text">AOF</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重启加载"><span class="nav-text">重启加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题定位与优化"><span class="nav-text">问题定位与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork-操作"><span class="nav-text">fork 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子进程开销监控和优化"><span class="nav-text">子进程开销监控和优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU"><span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬盘开销"><span class="nav-text">硬盘开销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-追加阻塞"><span class="nav-text">AOF 追加阻塞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本章总结"><span class="nav-text">本章总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-6-章-复制"><span class="nav-text">第 6 章 复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#建立复制"><span class="nav-text">建立复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#断开复制"><span class="nav-text">断开复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓扑"><span class="nav-text">拓扑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一主一从"><span class="nav-text">一主一从</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一主多从"><span class="nav-text">一主多从</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树状主从结构"><span class="nav-text">树状主从结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原理"><span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据同步"><span class="nav-text">数据同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#复制偏移量"><span class="nav-text">复制偏移量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制积压缓冲区"><span class="nav-text">复制积压缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主节点运行ID"><span class="nav-text">主节点运行ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#psync-命令"><span class="nav-text">psync 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全量同步"><span class="nav-text">全量同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#增量同步"><span class="nav-text">增量同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#心跳"><span class="nav-text">心跳</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发与运维中的问题"><span class="nav-text">开发与运维中的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据延时"><span class="nav-text">数据延时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读到过期数据"><span class="nav-text">读到过期数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从节点故障"><span class="nav-text">从节点故障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规避全量复制"><span class="nav-text">规避全量复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规避复制风暴"><span class="nav-text">规避复制风暴</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单主节点复制风暴"><span class="nav-text">单主节点复制风暴</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单机器复制风暴"><span class="nav-text">单机器复制风暴</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-7-章-阻塞"><span class="nav-text">第 7 章 阻塞</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内因"><span class="nav-text">内因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何发现慢查询"><span class="nav-text">如何发现慢查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何发现大对象"><span class="nav-text">如何发现大对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU饱和"><span class="nav-text">CPU饱和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化阻塞"><span class="nav-text">持久化阻塞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外因"><span class="nav-text">外因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-竞争"><span class="nav-text">CPU 竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存交换"><span class="nav-text">内存交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络问题"><span class="nav-text">网络问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-8-章-理解内存"><span class="nav-text">第 8 章 理解内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存消耗"><span class="nav-text">内存消耗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存消耗统计"><span class="nav-text">内存消耗统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存消耗划分"><span class="nav-text">内存消耗划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子进程内存消耗"><span class="nav-text">子进程内存消耗</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设置内存上限"><span class="nav-text">设置内存上限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态调整内存上限"><span class="nav-text">动态调整内存上限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存回收策略"><span class="nav-text">内存回收策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存优化"><span class="nav-text">内存优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redisObject对象"><span class="nav-text">redisObject对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缩减键值对象"><span class="nav-text">缩减键值对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串优化"><span class="nav-text">字符串优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码优化"><span class="nav-text">编码优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制键的数量"><span class="nav-text">控制键的数量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化总结"><span class="nav-text">优化总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-9-章-哨兵"><span class="nav-text">第 9 章 哨兵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础概念"><span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#部署"><span class="nav-text">部署</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哨兵节点的-API"><span class="nav-text">哨兵节点的 API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-Sentinel-的实现原理"><span class="nav-text">Redis Sentinel 的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三个定时监控任务"><span class="nav-text">三个定时监控任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主观下线与客观下线"><span class="nav-text">主观下线与客观下线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#领导者-Sentinel-节点选举"><span class="nav-text">领导者 Sentinel 节点选举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移"><span class="nav-text">故障转移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发与运维问题"><span class="nav-text">开发与运维问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-10-章-集群"><span class="nav-text">第 10 章 集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据分布"><span class="nav-text">数据分布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的哈希分区规则"><span class="nav-text">常见的哈希分区规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群功能限制"><span class="nav-text">集群功能限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群搭建"><span class="nav-text">集群搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节点通信"><span class="nav-text">节点通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群伸缩"><span class="nav-text">集群伸缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扩容集群"><span class="nav-text">扩容集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收缩集群"><span class="nav-text">收缩集群</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求路由"><span class="nav-text">请求路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请求重定向"><span class="nav-text">请求重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hash-tag"><span class="nav-text">hash_tag</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASK-重定向"><span class="nav-text">ASK 重定向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#故障转移-1"><span class="nav-text">故障转移</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群运维"><span class="nav-text">集群运维</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-11-章-缓存设计"><span class="nav-text">第 11 章 缓存设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存更新策略"><span class="nav-text">缓存更新策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU-LFU-FIFO-算法剔除"><span class="nav-text">LRU/LFU/FIFO 算法剔除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超时剔除"><span class="nav-text">超时剔除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主动更新"><span class="nav-text">主动更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最佳实践"><span class="nav-text">最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存穿透"><span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存穿透的解决方案"><span class="nav-text">缓存穿透的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-缓存空对象"><span class="nav-text">1. 缓存空对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-布隆过滤器拦截"><span class="nav-text">2. 布隆过滤器拦截</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无底洞优化"><span class="nav-text">无底洞优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#雪崩优化"><span class="nav-text">雪崩优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#热点key重建优化"><span class="nav-text">热点key重建优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决方案"><span class="nav-text">解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥锁-mutex-key"><span class="nav-text">互斥锁(mutex key)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#永不过期"><span class="nav-text">永不过期</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-12-章-Devops-的陷阱"><span class="nav-text">第 12 章 Devops 的陷阱</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-攻击"><span class="nav-text">Redis 攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令重写"><span class="nav-text">命令重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#防火墙"><span class="nav-text">防火墙</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bigkey"><span class="nav-text">bigkey</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找热点-Key"><span class="nav-text">查找热点 Key</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Shi Xinyu" src="https://tva1.sinaimg.cn/large/006tNbRwly1g9hf0u8313j305o05p3ye.jpg">
  <p class="site-author-name" itemprop="name">Shi Xinyu</p>
  <div class="site-description" itemprop="description">Learn by doing !</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  © 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xinyu © Copyright  |  <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener"> BY-NC-SA</a></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        
<div class="busuanzi-count">
  <script pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  
  



  




  
  




  












    <div id="pjax">

  

  
      



    

  




    </div>


<script type="text/javascript" src="/bundle.js"></script><script type="text/javascript">
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
;

    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  ;

    MathJax.Ajax.config.path['mhchem'] = '//cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.0';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
;

  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
;

NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: true,
    notify: false,
    appId: 'CEo3hR7qTLSO1hx0GRgh4VkR-gzGzoHsz',
    appKey: 'mOoWJCRObxe1hAfLmzmXWKSS',
    placeholder: "拙笔若博君一思，幸甚之至",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script></body></html>