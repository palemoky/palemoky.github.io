<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: true,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="article">
<meta property="og:title" content="《Redis开发与运维》">
<meta property="og:url" content="https:&#x2F;&#x2F;blog.palemoky.top&#x2F;post&#x2F;redis-devops&#x2F;index.html">
<meta property="og:site_name" content="寰宇星辰">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;middle&#x2F;006y8mN6ly1g8ronsawmbj30ku0aft9d.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g8rmou0bzdj30hx0kb0xe.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g8tfeooj3zj30k60hptbk.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;middle&#x2F;006y8mN6ly1g8u1rzsipij30n811un3c.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;middle&#x2F;006y8mN6ly1g8u27kw8tmj30u00ws7ff.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g91c1tnqngj30ky0m3djy.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g91co0mb8fj30g40hz770.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g91e0yu7flj30if0o442t.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g91vyy7e25j30h909875n.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g91xk5bba1j30jh0hejtq.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g91xn7bm5rj30j30lqgp7.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g91xwacukej30hu0d8gnx.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g91z58ncm8j30iv0frgpv.jpg">
<meta property="og:updated_time" content="2019-11-18T04:57:44.776Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;middle&#x2F;006y8mN6ly1g8ronsawmbj30ku0aft9d.jpg">

<link rel="canonical" href="https://blog.palemoky.top/post/redis-devops/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>《Redis开发与运维》 | 寰宇星辰</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script type="text/javascript">
    var host = "blog.palemoky.top";
    if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location.protocol = "https";
</script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">寰宇星辰</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">以有限字符创造无限可能<br>Make it possible</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-todo">

    <a href="/todo/" rel="section"><i class="fa fa-fw fa-list"></i>Todo</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/palemoky" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.palemoky.top/post/redis-devops/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/orca.jpg">
      <meta itemprop="name" content="Palemoky">
      <meta itemprop="description" content="Learn by doing !">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="寰宇星辰">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Redis开发与运维》
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 10:31:49" itemprop="dateCreated datePublished" datetime="2019-11-09T10:31:49+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-18 12:57:44" itemprop="dateModified" datetime="2019-11-18T12:57:44+08:00">2019-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/post/redis-devops/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/redis-devops/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8ronsawmbj30ku0aft9d.jpg" alt=""></p>
<a id="more"></a>

<h1 id="第-1-章-初识-Redis"><a href="#第-1-章-初识-Redis" class="headerlink" title="第 1 章 初识 Redis"></a>第 1 章 初识 Redis</h1><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><ul>
<li>string(Bitmaps &amp; HyperLogLog)</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>zset</li>
</ul>
<h2 id="Redis-提供的功能"><a href="#Redis-提供的功能" class="headerlink" title="Redis 提供的功能"></a>Redis 提供的功能</h2><ul>
<li>键过期</li>
<li>发布订阅（消息系统）</li>
<li>事务</li>
<li>流水线（一批命令一次发送到 Redis，避免网络开销）</li>
<li>Lua 脚本</li>
</ul>
<h2 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h2><ul>
<li>缓存</li>
<li>排行榜</li>
<li>计数器（视频播放数，商品浏览量）</li>
<li>社交（共同好友、粉丝、点赞）</li>
<li>消息队列</li>
<li>共享 Session</li>
<li>限速（如，60s 获取一次手机验证码：<code>redis.set(phoneNum, 1, &quot;EX 60&quot;, &quot;NX&quot;)</code>）</li>
<li>使用哈希类型模拟关系型数据库（优点：用户信息内聚性较强，占用的键较少；缺点：哈希类型是稀疏的，难以做复杂的关系查询。注意：要控制哈希在 ziplist 和 hashtable 两种内部编码的转换，hashtable 会消耗更多的内存）</li>
</ul>
<h2 id="为什么-Redis-很快？"><a href="#为什么-Redis-很快？" class="headerlink" title="为什么 Redis 很快？"></a>为什么 Redis 很快？</h2><ul>
<li>内存访问</li>
<li>C 语言实现</li>
<li>单线程架构，避免线程切换与竞态产生的消耗</li>
<li>I/O 多路复用模型（epoll）</li>
</ul>
<p>安装软件时，为软件建立软连接是一种好习惯，避免将软件固定在指定版本上，有利于未来软件的版本升级。</p>
<p>Redis 借鉴了 Linux 对于版本号的命名规则：版本号第二位如果是奇数，则为非稳定版本（如 2.7、2.9、3.1），否则为稳定版本（如 2.6、2.8、3.0）</p>
<h2 id="Redis-可执行文件说明"><a href="#Redis-可执行文件说明" class="headerlink" title="Redis 可执行文件说明"></a>Redis 可执行文件说明</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>redis-server</code></td>
<td>启动 Redis</td>
</tr>
<tr>
<td><code>redis-cli</code></td>
<td>Redis 命令行客户端</td>
</tr>
<tr>
<td><code>redis-cli shutdown</code></td>
<td>关闭 Redis</td>
</tr>
<tr>
<td><code>redis-benchmark</code></td>
<td>Redis 基准测试工具</td>
</tr>
<tr>
<td><code>redis-check-of</code></td>
<td>Redis AOF 持久化文件检测与修复工具</td>
</tr>
<tr>
<td><code>redis-check-dump</code></td>
<td>Redis RDB 持久化文件检测与修复工具</td>
</tr>
<tr>
<td><code>redis-sentinel</code></td>
<td>启动 Redis Sentinel</td>
</tr>
</tbody></table>
<h2 id="启动-Redis-的3种方式："><a href="#启动-Redis-的3种方式：" class="headerlink" title="启动 Redis 的3种方式："></a>启动 Redis 的3种方式：</h2><ol>
<li>默认配置(<code>redis-server</code>)</li>
<li>运行配置(<code>redis-server --port 6380</code>)</li>
<li>配置文件(<code>redis-server /opt/redis/redis.conf</code>)</li>
</ol>
<h1 id="第-2-章-API-的理解和使用"><a href="#第-2-章-API-的理解和使用" class="headerlink" title="第 2 章 API 的理解和使用"></a>第 2 章 API 的理解和使用</h1><table>
<thead>
<tr>
<th>命令</th>
<th>选项</th>
<th>返回值</th>
<th>含义</th>
<th>复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>keys pattern</code></td>
<td>pattern 使用的是 glob 风格的通配符</td>
<td></td>
<td>查看所有键</td>
<td>$O(n)$</td>
<td>大量键时禁止使用</td>
</tr>
<tr>
<td><code>dbsize</code></td>
<td></td>
<td>int（&gt;=0）</td>
<td>键总数</td>
<td>$O(1)$</td>
<td>不遍历键，直接读取内置键总数</td>
</tr>
<tr>
<td><code>exists key</code></td>
<td></td>
<td>intbool（存在为 1，否则为 0）</td>
<td>检查键是否存在</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>del key [key ...]</code></td>
<td></td>
<td>int（成功删除的个数，若删除不存在的键，返回 0）</td>
<td>删除键</td>
<td>$O(k)$，𝑘为键的个数</td>
<td></td>
</tr>
<tr>
<td><code>expire key seconds</code><br><br><code>expireat key timestamp</code><br><br><code>pexpire key milliseconds</code><br><br><code>pexpireat key milliseconds-timestamp</code></td>
<td></td>
<td>boolint（成功为 1，key 不存在或无法设置为 0）</td>
<td>键过期</td>
<td></td>
<td>1. 无论使用哪种形式，在 Redis 内部最终使用的都是<code>pexpireat</code>；<br>2. 如果<code>expire key</code>的键不存在，返回 0;<br>3. 如果过期时间为负值，键会被立即删除，犹如使用了<code>del</code>;<br>4. <code>persist key</code>可以将键的过期时间清除；<br>5. <strong>对于字符串类型键，执行<code>set</code>命令会去掉过期时间</strong>;<br>6. Redis 不支持二级数据结构（哈希、列表）内部元素的过期功能，如不能对列表类型的一个元素做过期时间设置；<br>7. <code>setex</code>作为<code>set</code>+<code>expire</code>的组合，不但是原子执行，同时减少了一次网络通讯的时间</td>
</tr>
<tr>
<td><code>ttl key</code><br><code>pttl key</code></td>
<td></td>
<td>int（&gt;=0：键剩余过期时间；-1：键未设置过期时间；-2：键不存在）</td>
<td>查看键剩余存活时间（秒/毫秒）</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>type key</code></td>
<td></td>
<td>键存在返回数据类型，不存在返回 none</td>
<td>查看键的数据类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>rename key newkey</code><br><code>renamenx key newkey</code></td>
<td></td>
<td>成功返回<code>OK</code>,失败为 0</td>
<td>键重命名</td>
<td></td>
<td>1. 如果在重命名之前，键值已经存在，则值会被覆盖；<br>2. 由于重命名键期间会执行<code>del</code>删除旧键，如果键对应的值较大，可能会被阻塞</td>
</tr>
<tr>
<td><code>randomkey</code></td>
<td></td>
<td></td>
<td>随机返回一个键</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>move key db</code><br><br><code>dump key</code> + <code>restore key ttl value</code><br><br><code>migrate host port key|&quot;&quot; destination-db timeout [copy] [replace] [keys key [key ...]]</code></td>
<td><code>ttl</code>为 0 时表示无过期时间<br><code>host</code>:目标主机<br><code>port</code>:目标端口<br><code>key|&quot;&quot;</code>:迁移单个键指定键名，多个键则为空字符串<br><code>destination-db</code>:目标 db 索引<br><code>timeout</code>:迁移的超时时间（毫秒）<br><code>copy</code>:不删除源键<br><code>replace</code>:对目标 Redis 覆写操作。若未指定，源 Redis 和目标 Redis 存在同名键会报错<br><code>keys key [key ...]</code>:迁移的键名</td>
<td></td>
<td>迁移键</td>
<td></td>
<td>方式二中，<code>dump</code>会将键值序列化，格式采用 RDB 格式，在目标 Redis 上，<code>restore</code>再将序列化的值复原<br><br><code>migrate</code>实质上是<code>dump</code>、<code>restore</code>、<code>del</code>三个命令的组合。<code>migrate</code>具有原子性，只需在源 Redis 上执行即可，目标 Redis 完成<code>restore</code>后返回 OK，源 Redis 再根据<code>migrate</code>的对应选项决定是否在源 Redis 上删除对应的键</td>
</tr>
<tr>
<td><code>scan cursor [match pattern] [count number]</code></td>
<td><code>cursor</code>：游标，第一次遍历从0开始，每次<code>scan</code>遍历完都会返回当前游标的值，直到游标值为0，表示遍历结束<br><code>·match pattern</code>：模式匹配<br><code>count number</code>：明每次要遍历的键个数，默认值是10，此参数可以适当增大</td>
<td></td>
<td>渐进式遍历</td>
<td></td>
<td>如果在遍历过程中键发生了变化，则结果可能是不准确的；<br><code>hscan</code> 解决 <code>hgetall</code> 的阻塞<br><code>sscan</code>解决<code>smembers</code> 的阻塞<br><code>zscan</code>解决<code>zrange</code> 的阻塞</td>
</tr>
<tr>
<td><code>select dbIndex</code></td>
<td></td>
<td></td>
<td>切换数据库</td>
<td></td>
<td>默认 16 个数据库(0~15)，未指定数据库时，默认为 0 数据库;<br>建议只使用 0 号数据库，避免多数据库的切换错误，以及故障排查困难。如果需要使用多数据库，可以在单机部署多个 Redis 实例，通过端口区分不同数据库</td>
</tr>
<tr>
<td><code>flushdb</code><br><code>flushall</code></td>
<td></td>
<td></td>
<td>清空当前/所有数据库</td>
<td></td>
<td>若数据库键值较多，可能引发阻塞</td>
</tr>
<tr>
<td><strong>字符串 String</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>set key value [ex seconds] [px milliseconds] [nx|xx]</code></td>
<td>ex：设置秒级过期时间<br>px：设置毫秒级过期时间<br>nx：键不存在才能设置成功，用于添加<br>xx：键存在才能设置成功，用于更新</td>
<td>成功返回 OK，失败返回 0</td>
<td>设置值</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>setex key seconds value</code></td>
<td></td>
<td>成功返回 OK，失败返回 0</td>
<td>设定的值存在才会成功</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>setnx key value</code></td>
<td></td>
<td>成功返回 OK，失败返回 0</td>
<td>设定的值不存在才会成功</td>
<td></td>
<td>常用于分布式锁</td>
</tr>
<tr>
<td><code>get key</code></td>
<td></td>
<td>键存在时返回值，不存在返回 nil</td>
<td>获取值</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>mset key value [key value ...]</code></td>
<td></td>
<td>成功返回 OK，失败返回 0</td>
<td>批量设置值</td>
<td>$O(k)$，𝑘为键的个数</td>
<td></td>
</tr>
<tr>
<td><code>mget key [key ...]</code></td>
<td></td>
<td>键存在时返回值，不存在返回 nil。结果按照传入键的顺序返回</td>
<td>批量获取值</td>
<td>$O(k)$，𝑘为键的个数</td>
<td></td>
</tr>
<tr>
<td><code>incr key</code></td>
<td></td>
<td>值不是整数，返回错误<br>值是整数，返回自增后结果<br>键不存在，按照值为 0 自增，返回结果为 1</td>
<td>值自增</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>decr key</code></td>
<td></td>
<td>int</td>
<td>值自减</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>incrby key increment</code></td>
<td></td>
<td>int</td>
<td>自增指定数字</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>decrby key decrement</code></td>
<td></td>
<td>int</td>
<td>自减指定数字</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>incrbyfloat key increment</code></td>
<td></td>
<td>float</td>
<td>自增浮点数</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>append key value</code></td>
<td></td>
<td>int（返回追加后的字符长度）</td>
<td>向字符串尾部追加值</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>strlen key</code></td>
<td></td>
<td>int（根据不同编码返回字符长度，如 UTF8 的“中国”返回值为 6）</td>
<td>字符串长度</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>getset key value</code></td>
<td></td>
<td></td>
<td>设置并返回值</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>setrange key offeset value</code></td>
<td></td>
<td>int（返回字符长度）</td>
<td>设置指定位置的字符</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>getrange key start end</code></td>
<td></td>
<td>返回截取的字符内容</td>
<td>获取部分字符串</td>
<td>$O(n)$，𝑛 为字符串长度，由于获取字符串非常快，若字符串不是很长，可以视为$O(1)$</td>
<td></td>
</tr>
<tr>
<td><strong>哈希 Hash</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>hset key field value</code><br><code>hget key field</code></td>
<td></td>
<td></td>
<td>设置值<br>获取值</td>
<td>$O(1)$<br>$O(1)$</td>
<td>在 Redis 中，哈希类型是指键值本身又是一个键值对结构（形如 JSON）。哈希类型中的映射关系叫作field-value，注意这里的value是指field对应的值，不是键对应的值，请注意value在不同上下文的作用。</td>
</tr>
<tr>
<td><code>hdel key field [field ...]</code></td>
<td></td>
<td>int （成功为删除的个数）</td>
<td>删除 field</td>
<td>$O(k)$ ，𝑘是field个数</td>
<td></td>
</tr>
<tr>
<td><code>hlen key</code></td>
<td></td>
<td>int</td>
<td>计算 field 个数</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>hmset key field value [field value ...]</code><br><code>hmget key field [field ...]</code></td>
<td></td>
<td></td>
<td>批量设置或获取field-value</td>
<td>$O(k)$ ，𝑘是field个数<br>$O(k)$ ，𝑘是field个数</td>
<td></td>
</tr>
<tr>
<td><code>hexists key field</code></td>
<td></td>
<td>存在为 1，否则为 0</td>
<td>判断field是否存在</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>hsetnx key field value</code></td>
<td></td>
<td></td>
<td></td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>hkeys key</code></td>
<td></td>
<td></td>
<td>获取所有field</td>
<td>$O(n)$ ，𝑛 是field个数</td>
<td><code>hkeys</code> 叫 <code>hfields</code>更恰当</td>
</tr>
<tr>
<td><code>hvals key</code></td>
<td></td>
<td></td>
<td>获取所有value</td>
<td>$O(n)$ ，𝑛 是field个数</td>
<td></td>
</tr>
<tr>
<td><code>hgetall key</code></td>
<td></td>
<td></td>
<td>获取所有的field-value</td>
<td>$O(n)$ ，𝑛 是field个数</td>
<td>在使用<code>hgetall</code>时，如果哈希元素个数比较多，可能会阻塞Redis。如果开发人员只需要获取部分field，可以使用<code>hmget</code>，如果一定要获取全部field-value，可以使用<code>hscan</code>命令，该命令会渐进式遍历哈希类型。</td>
</tr>
<tr>
<td><code>hincrby key field</code><br><code>hincrbyfloat key field</code></td>
<td></td>
<td></td>
<td>按指定值递增</td>
<td>$O(1)$<br>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>hstrlen key field</code></td>
<td></td>
<td></td>
<td>计算value的字符串长度</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td>列表 List</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lpush key value [value ...]</code><br><code>rpush key value [value ...]</code></td>
<td></td>
<td>int（成功插入元素个数）</td>
<td>从左/右侧插入元素</td>
<td>$O(k)$，𝑘 为元素个数</td>
<td>列表类型的两个特点：第一，列表中的元素是有序的（即，可以通过索引下标获取元素）；第二，列表中的元素可以是重复的</td>
</tr>
<tr>
<td><code>lpop key</code><br><code>rpop key</code></td>
<td></td>
<td></td>
<td>从列表左/右侧弹出元素</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>linsert key before|after pivot value</code></td>
<td></td>
<td>int（返回当前列表长度）</td>
<td>向某个元素前或者后插入元素</td>
<td>$O(n)$，𝑛 是 pivot 距离列表头或尾的距离</td>
<td></td>
</tr>
<tr>
<td><code>lrange key start end</code></td>
<td></td>
<td></td>
<td>获取指定范围内的元素列表</td>
<td>$O(s+n)$，𝑠 是 start 偏移量，𝑛 是start 到 end 的范围</td>
<td>1. <code>lrange 0 -1</code> 可获取列表所有元素<br>2. end 包含了自身</td>
</tr>
<tr>
<td><code>lindex key index</code></td>
<td></td>
<td></td>
<td>获取列表指定索引下标的元素</td>
<td>$O(n)$，𝑛 是索引的偏移量</td>
<td></td>
</tr>
<tr>
<td><code>llen key</code></td>
<td></td>
<td>int</td>
<td>获取列表长度</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>lrem key count value</code></td>
<td></td>
<td>count &gt; 0，从左到右，删除最多 count 个元素<br>count &lt; 0，从右到左，删除最多 count 绝对值个元素<br>count = 0，删除所有</td>
<td>删除指定元素</td>
<td>$O(n)$，𝑛 是列表长度</td>
<td></td>
</tr>
<tr>
<td><code>ltrim key start end</code></td>
<td></td>
<td></td>
<td>按照索引范围修剪列表</td>
<td>$O(n)$，𝑛 是要裁剪的元素总数</td>
<td></td>
</tr>
<tr>
<td><code>lset key index newValue</code></td>
<td></td>
<td></td>
<td>修改指定索引下标的元素</td>
<td>$O(n)$，𝑛 是索引的偏移量</td>
<td></td>
</tr>
<tr>
<td><code>blpop key [key ...] timeout</code><br><code>brpop key [key ...] timeout</code></td>
<td><code>timeout</code> 为阻塞时间</td>
<td></td>
<td>阻塞式弹出</td>
<td>$O(1)$</td>
<td>如果有多个键，那么<code>brpop</code>会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回</td>
</tr>
<tr>
<td><strong>集合(Set)</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>sadd key element [element ...]</code></td>
<td></td>
<td>int（返回添加成功元素的个数）</td>
<td>添加元素</td>
<td>$O(k)$，𝑘是元素个数</td>
<td></td>
</tr>
<tr>
<td><code>srem key element [element ...]</code></td>
<td></td>
<td>int（返回删除成功元素的个数）</td>
<td>删除元素</td>
<td>$O(k)$，𝑘是元素个数</td>
<td></td>
</tr>
<tr>
<td><code>scard key</code></td>
<td></td>
<td></td>
<td>计算元素个数</td>
<td>$O(1)$</td>
<td>同<code>dbsize</code>类似，直接读取内置变量</td>
</tr>
<tr>
<td><code>sismember key element</code></td>
<td></td>
<td>int（存在返回 1，否则为 0）</td>
<td>判断元素是否在集合中</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>srandmember key [count]</code></td>
<td></td>
<td></td>
<td>随机从集合返回指定个数元素</td>
<td>$O(count)$</td>
<td></td>
</tr>
<tr>
<td><code>spop key</code></td>
<td></td>
<td></td>
<td>从集合随机弹出元素</td>
<td>$O(1)$</td>
<td><code>srandmember</code>和<code>spop</code>都是随机从集合选出元素，两者不同的是<code>spop</code>命令执行后，元素会从集合中删除，而<code>srandmember</code>不会。</td>
</tr>
<tr>
<td><code>smembers key</code></td>
<td></td>
<td></td>
<td>获取所有元素，结果是无序的</td>
<td>$O(n)$，𝑛是元素总数</td>
<td><code>smembers</code>和<code>lrange</code>、<code>hgetall</code>都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，这时候可以使用<code>sscan</code>来完成</td>
</tr>
<tr>
<td><code>sinter key [key ...]</code></td>
<td></td>
<td></td>
<td>取交集</td>
<td>$O(m*k)$，𝑘是多个集合元素最少的个数，𝑚是键个数</td>
<td></td>
</tr>
<tr>
<td><code>suinon key [key ...]</code></td>
<td></td>
<td></td>
<td>取并集</td>
<td>$O(k)$，𝑘是多个集合元素个数和</td>
<td></td>
</tr>
<tr>
<td><code>sdiff key [key ...]</code></td>
<td></td>
<td></td>
<td>取差集</td>
<td>$O(k)$，𝑘是多个集合元素个数和</td>
<td></td>
</tr>
<tr>
<td><code>sinterstore destination key [key ...]</code><br><code>suionstore destination key [key ...]</code><br><code>sdiffstore destination key [key ...]</code></td>
<td></td>
<td></td>
<td>）将交集、并集、差集的结果保存</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>有序集合（Zset）</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>zadd key score member [score member ...]</code></td>
<td></td>
<td></td>
<td>添加成员</td>
<td>$O(k*log(n))$，𝑘是添加成员的个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zcard key</code></td>
<td></td>
<td>int</td>
<td>计算成员个数</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>zscore key member</code></td>
<td></td>
<td>int（成员不存在返回 nil）</td>
<td>计算某个成员的分数</td>
<td>$O(1)$</td>
<td></td>
</tr>
<tr>
<td><code>zrank key member</code><br><code>zrevrank key member</code></td>
<td></td>
<td>返回分数从低到高/从高到低的排名</td>
<td>计算成员的排名</td>
<td>$O(log(n))$，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zrem key member [member ...]</code></td>
<td></td>
<td>返回删除成员的个数</td>
<td>删除成员</td>
<td>$O(k*log(n))$，𝑘是删除成员的个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zincrby key increment member</code></td>
<td></td>
<td></td>
<td>增加成员的分数</td>
<td>$O(log(n))$，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zrange key start end [withscores]</code><br><code>zrevrange key start end [withscores]</code></td>
<td><code>withscores</code>会同时返回成员分数</td>
<td>返回分数从低到高/从高到低的排名</td>
<td>返回指定排名范围的成员</td>
<td>$O(log(n)+k)$，𝑘是要获取的成员个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zrangebyscore key min max [withscores] [limit offset count]</code><br><code>zrevrangebyscore key max min [withscores] [limit offset count]</code></td>
<td><code>min</code>和<code>max</code>还支持开区间（小括号）和闭区间（中括号），<code>-inf</code>和<code>+inf</code>分别代表无限小和无限大</td>
<td></td>
<td>返回指定分数范围的成员</td>
<td>$O(log(n)+k)$，𝑘是要获取的成员个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zcount key min max</code></td>
<td></td>
<td></td>
<td>返回指定分数范围成员个数</td>
<td>$O(log(n))$，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zremrangebyrank key start end</code></td>
<td></td>
<td></td>
<td>删除指定排名内的升序元素</td>
<td>$O(log(n)+k)$，𝑘是要删除的成员个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zremrangebyscore key min max</code></td>
<td></td>
<td></td>
<td>删除指定分数范围的成员</td>
<td>$O(log(n)+k)$，𝑘是要删除的成员个数，𝑛是当前有序集合成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></td>
<td><code>destination</code>：交集计算结果保存到这个键；<br><code>numkeys</code>：需要做交集计算键的个数；<br><code>key [key...]</code>：需要做交集计算的键；<br><code>weights weight[weight...]</code>：每个键的权重，在做交集计算时，每个键中的每个 member 会将自己分数乘以这个权重，每个键的权重默认是1；<br><code>aggregate sum|min|max</code>：计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是sum</td>
<td></td>
<td>取交集</td>
<td>$O(n * k)+O(m*log(m))$，𝑛是成员数最小的有序集合成员个数，𝑘是有序集合的个数，𝑚是结果集中成员个数</td>
<td></td>
</tr>
<tr>
<td><code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></td>
<td></td>
<td></td>
<td>取并集</td>
<td>$O(n)+O(m*log(m))$，𝑛是所有有序集合成员个数和，𝑚是结果集中成员个数</td>
<td></td>
</tr>
</tbody></table>
<h2 id="判断键不存在的方法："><a href="#判断键不存在的方法：" class="headerlink" title="判断键不存在的方法："></a>判断键不存在的方法：</h2><ol>
<li><code>exists</code> 返回 0</li>
<li><code>del</code> 返回 0</li>
<li><code>ttl</code> 返回 -2</li>
<li><code>type</code> 返回 <code>none</code></li>
<li><code>get</code> 返回 <code>nil</code></li>
</ol>
<p>设计合理的键名，有助于防止键冲突和项目的可维护性，比较推荐的方式是使用“业务名：对象名：id：[属性]”作为键名。如果键名较长，可以在能描述键含义的前提下适当减少键的长度，从而减少由于键名过长而导致的内存浪费。</p>
<h2 id="列表的四种操作类型"><a href="#列表的四种操作类型" class="headerlink" title="列表的四种操作类型"></a>列表的四种操作类型</h2><table>
<thead>
<tr>
<th>操作类型</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td><code>rpush</code> <code>lpush</code> <code>linsert</code></td>
</tr>
<tr>
<td>查</td>
<td><code>lrange</code> <code>lindex</code> <code>llen</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>lpop</code> <code>rpop</code> <code>lrem</code> <code>ltrim</code></td>
</tr>
<tr>
<td>修改</td>
<td><code>lset</code></td>
</tr>
<tr>
<td>阻塞操作</td>
<td><code>blpop</code> <code>brpop</code></td>
</tr>
</tbody></table>
<h2 id="列表的使用场景："><a href="#列表的使用场景：" class="headerlink" title="列表的使用场景："></a>列表的使用场景：</h2><ul>
<li><code>lpush</code> + <code>lpop</code> = Stack（栈）</li>
<li><code>lpush</code> + <code>rpop</code> = Queue（队列）</li>
<li><code>lpush</code> + <code>ltrim</code> = Capped Collection（有限集合）</li>
<li><code>lpush</code> + <code>brpop</code> = Message Queue（消息队列）</li>
</ul>
<h2 id="集合的使用场景"><a href="#集合的使用场景" class="headerlink" title="集合的使用场景"></a>集合的使用场景</h2><ul>
<li><code>sadd</code> = Tagging（标签）</li>
<li><code>spop/srandmember</code> = Random item（生成随机数，比如抽奖）</li>
<li><code>sadd</code> + <code>sinter</code>= Social Graph（社交需求）</li>
</ul>
<h2 id="列表、集合、有序集合的异同点"><a href="#列表、集合、有序集合的异同点" class="headerlink" title="列表、集合、有序集合的异同点"></a>列表、集合、有序集合的异同点</h2><table>
<thead>
<tr>
<th>数据结构</th>
<th align="center">是否允许重复元素</th>
<th align="center">是否有序</th>
<th>有序实现方式</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>列表</td>
<td align="center">是</td>
<td align="center">是</td>
<td>索引下标</td>
<td>时间轴、消息队列等</td>
</tr>
<tr>
<td>集合</td>
<td align="center">否</td>
<td align="center">否</td>
<td>无</td>
<td>标签、社交等</td>
</tr>
<tr>
<td>有序集合</td>
<td align="center">否</td>
<td align="center">是</td>
<td>分值</td>
<td>排行榜、社交等</td>
</tr>
</tbody></table>
<h2 id="Redis-数据结构与内部编码"><a href="#Redis-数据结构与内部编码" class="headerlink" title="Redis 数据结构与内部编码"></a>Redis 数据结构与内部编码</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8rmou0bzdj30hx0kb0xe.jpg" alt="Redis数据结构与内部编码"></p>
<ul>
<li>字符串<ul>
<li>int: 8个字节的长整型</li>
<li>embstr: &lt;=39 Byte 的字符串</li>
<li>raw: &gt;39 Byte 的字符串</li>
</ul>
</li>
<li>哈希<ul>
<li>ziplist: 当哈希类型元素个数小于 <code>hash-max-ziplist-entries</code> 配置（默认512个）、同时所有值都小于 <code>hash-max-ziplist-value</code> 配置（默认64字节）时，Redis 会使用 ziplist 作为哈希的内部实现，ziplist 使用更加紧凑的结构实现多个元素的连续存储，所以在<strong>节省内存方面比 hashtable 更加优秀</strong>。</li>
<li>hashtable: 当哈希类型无法满足 ziplist 的条件时，Redis 会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度为$O(1)$</li>
</ul>
</li>
<li>列表<ul>
<li>ziplist: 当列表元素个数小于 <code>list-max-ziplist-entries</code> 配置（默认512个）、同时每个元素值都小于 <code>list-max-ziplist-value</code> 配置（默认64字节）时，Redis 会使用 ziplist 来作为列表的内部实现来减少内存</li>
<li>linkedlist: 当无法满足ziplist条件时</li>
</ul>
</li>
<li>集合<ul>
<li>intset: 当集合中的元素都是整数且元素个数小于<code>set-maxintset-entries</code>配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</li>
<li>hashtable: 无法满足intset时</li>
</ul>
</li>
<li>有序集合<ul>
<li>ziplist: 当有序集合的元素个数小于<code>zset-max-ziplistentries</code>配置（默认128个），同时每个元素的值都小于<code>zset-max-ziplist-value</code>配置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现来减少内存</li>
<li>skiplist: 当无法满足ziplist条件时</li>
</ul>
</li>
</ul>
<p>Redis 设计内部编码与外部结构有两个好处</p>
<ol>
<li>改进内部编码而对外部数据结构和命令没有影响</li>
<li>多种内部编码实现可以在不同场景下发挥各自的优势，如 ziplist 比较节省内存，但在列表元素较多的情况下，性能会有所下降，此时 Redis 会根据配置选项将列表类型的内部实现转换为 linkedlist。</li>
</ol>
<p>可以通过<code>object encoding key</code>命令查询内部编码。</p>
<h1 id="第-3-章-小功能大用处"><a href="#第-3-章-小功能大用处" class="headerlink" title="第 3 章 小功能大用处"></a>第 3 章 小功能大用处</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><h3 id="慢查询配置"><a href="#慢查询配置" class="headerlink" title="慢查询配置"></a>慢查询配置</h3><ul>
<li><code>slowlog-log-slower-than</code> 执行时间阈值<ul>
<li>单位为微秒，默认 10,000，为 0 表示记录所有命令，&lt;0 不记录任何命令</li>
<li>在高并发场景下，需要将该值向下调整</li>
</ul>
</li>
<li><code>slowlog-max-len</code><ul>
<li>Redis 使用列表结构存储慢查询日志，该参数为列表最大长度</li>
<li>当列表达最大长度时，最早插入的命令会被从列表中移出</li>
<li>可定时将慢查询日志持久化处理，便于排查故障</li>
</ul>
</li>
</ul>
<h3 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>slowlog get [n]</code></td>
<td><code>n</code>: 指定条数</td>
<td></td>
</tr>
<tr>
<td><code>slowlog len</code></td>
<td></td>
<td>获取当前慢查询列表长度</td>
</tr>
<tr>
<td><code>slowlog reset</code></td>
<td></td>
<td>重置日志，即清理慢查询列表</td>
</tr>
</tbody></table>
<h3 id="慢查询日志结构"><a href="#慢查询日志结构" class="headerlink" title="慢查询日志结构"></a>慢查询日志结构</h3><p>由 4 个属性组成</p>
<ol>
<li>日志标识 ID</li>
<li>时间戳</li>
<li>命令耗时</li>
<li>执行命令和参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; slowlog get</span><br><span class="line">1) 1) (integer) 666</span><br><span class="line">   2) (integer) 1456786500</span><br><span class="line">   3) (integer) 11615</span><br><span class="line">   4) 1) &quot;BGREWRITEAOF&quot;</span><br><span class="line">2) 1) (integer) 665</span><br><span class="line">   2) (integer) 1456718400</span><br><span class="line">   3) (integer) 12006</span><br><span class="line">   4) 1) &quot;SETEX&quot;</span><br><span class="line">      2) &quot;video_info_200&quot;</span><br><span class="line">      3) &quot;300&quot;</span><br><span class="line">      4) &quot;2&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Redis-Shell"><a href="#Redis-Shell" class="headerlink" title="Redis Shell"></a>Redis Shell</h2><h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a><code>redis-cli</code></h3><table>
<thead>
<tr>
<th>示例</th>
<th>选项</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>redis-cli -r 3 ping</code></td>
<td><code>-r</code>(repeat)：指定命令执行次数</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli -r 5 -i 1 ping</code></td>
<td><code>-i</code>(interval)：执行命令间隔时间，单位秒</td>
<td><code>-i</code>必须与<code>-r</code>一同使用<br>该选项不支持毫秒为单位，若想以 10ms 为间隔，可以使用<code>-i 0.01</code></td>
</tr>
<tr>
<td><code>echo &quot;world&quot; | redis-cli -x set hello</code></td>
<td><code>-x</code>: 从 stdin 读取数据作为 <code>redis-cli</code>的最后一个参数</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>-c</code>(cluster): 连接 Redis cluster 时使用，可以防止 <code>moved</code> 和 <code>ask</code> 异常</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>-a</code>(auth): 密码认证</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli --scan --pattern &quot;app*&quot;</code></td>
<td><code>--scan</code> &amp; <code>--pattern</code>: 于扫描指定模式的键</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli --slave</code></td>
<td><code>--slave</code>选项是把当前客户端模拟成当前 Redis 节点的从节点，可以用来获取当前 Redis 节点的更新操作</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>--rdb</code>: 将 Redis 实例持久化</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>--pipe</code>: 将命令封装成Redis通信协议定义的数据格式，批量发送给Redis执行</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli --bigkeys</code></td>
<td><code>--bigkeys</code>: 使用scan命令对Redis的键进行采样，从中找到内存占用比较大的键值，这些键可能是系统的瓶颈</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>--eval</code>: 指定 Lua 脚本</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli -h {machineB} --latency</code><br><code>redis-cli -h {machineB} --latency-history</code><br><code>redis-cli -h {machineB} --latency-dist</code></td>
<td><code>--latency</code>: 测试目标 Redis 网络延时。仅返回一条结果<br><code>--latency-history</code>: 每间隔一定时间（可通过<code>-i</code>设定）返回结果<br><code>--latency-dist</code>: 以统计图表的方式输出统计信息</td>
<td></td>
</tr>
<tr>
<td><code>redis-cli --stat</code></td>
<td><code>--stat</code>: 实时获取 Redis 统计信息</td>
<td><code>redis-cli info</code>也能查看系统信息</td>
</tr>
<tr>
<td><code>redis-cli --no-raw get apple</code></td>
<td><code>--raw</code> &amp; <code>--no-raw</code>: 是否格式化输出</td>
<td></td>
</tr>
</tbody></table>
<h3 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a><code>redis-server</code></h3><p><code>redis-server --test-memory 1024</code> 可用于检测当前 OS 是否能稳定分配指定容量内存给 Redis，该命令通常用于压测。</p>
<h3 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a><code>redis-benchmark</code></h3><p>该命令会对各类数据结构的命令进行测试，并给出性能指标。</p>
<ul>
<li><code>-c</code>(client) 可指定客户端并发数（默认 50）</li>
<li><code>-n</code> 指定客户端请求总量（默认 100,000）</li>
<li><code>-q</code> 仅显示每秒接收请求数</li>
<li><code>-r</code>(random) 随机插入键，以进行基准测试</li>
<li><code>-P</code> 每个请求 pipeline 的数据量（默认为 1）</li>
<li><code>-k</code> 客户端是否使用<code>keepalive</code>，1 为使用，0 为不使用，默认为 1</li>
<li><code>-t</code> 对指定命令进行基准测试，如<code>redis-benchmark -t get,set -q</code></li>
<li><code>--csv</code> 将结果按照 csv 格式输出</li>
</ul>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>由于 Redis 是单线程机制，当需要执行多条命令时，网络 I/O 成为了瓶颈，因此 pipeline 可将待执行命令“打包”，通过一次往返即可完成。</p>
<p>需要注意的是，如果 pipeline 数据量过大，将会导致网络阻塞。</p>
<h2 id="事务与-Lua"><a href="#事务与-Lua" class="headerlink" title="事务与 Lua"></a>事务与 Lua</h2><p>Redis 中，将一组需要一起执行的事务命令放到<code>multi</code>(开始)和<code>exec</code>(结束)之间即可，如果要停止事务，可以使用<code>discard</code>。需要注意的是，Redis 不支持事务的回滚操作，但可以通过 Lua 来实现回滚。</p>
<p>有些应用场景需要在事务之前，确保事务中的<code>key</code>没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁）。Redis提供了<code>watch</code>命令来解决这类问题。</p>
<p>Lua 的数据类型：</p>
<ol>
<li>booleans(布尔)</li>
<li>numbers(数值)</li>
<li>strings(字符串)</li>
<li>tables(表格)</li>
</ol>
<h3 id="在-Redis-中执行-Lua-的方法"><a href="#在-Redis-中执行-Lua-的方法" class="headerlink" title="在 Redis 中执行 Lua 的方法"></a>在 Redis 中执行 Lua 的方法</h3><p>方式一<br><code>eval 脚本内容 key个数 key列表 参数列表</code></p>
<p>方式二<br>先将 Lua 脚本加载入 Redis，得到该脚本的 SHA1，<code>evalsha</code>使用<code>SHA1</code>执行对应的脚本。这样可以重复批处理。</p>
<ul>
<li>加载脚本：<code>redis-cli script load &quot;$(cat lua_get.lua)&quot;</code></li>
<li>执行脚本：<code>evalsha 脚本SHA1值 key个数 key列表 参数列表</code></li>
<li>判断脚本是否已经被加载：<code>scripts exists sha1 [sha1 …]</code>，返回存在的脚本个数</li>
<li>清除所有脚本：<code>script flush</code></li>
<li>强制终止脚本：<code>script kill</code>。如果当前脚本正在写入，则该命令不会生效，此时要么等待脚本执行结束，要么使用<code>shutdown save</code>停止 Redis 服务</li>
</ul>
<blockquote>
<p>Lua 脚本在 Redis 中是原子执行的，执行过程中不会插入其它命令。</p>
</blockquote>
<h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p>Bitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>setbit key offset value</code></td>
<td>设置值</td>
<td>很多应用的用户id以一个指定数字（例如10000）开头，直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费，通常的做法是每次做 <code>setbit</code> 操作时将用户id减去这个指定数字。在第一次初始化 Bitmaps 时，假如偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成Redis的阻塞</td>
</tr>
<tr>
<td><code>gitbit key offset</code></td>
<td>获取值</td>
<td></td>
</tr>
<tr>
<td><code>bitcount key [start][end]</code></td>
<td>获取Bitmaps指定范围值为1的个数</td>
<td></td>
</tr>
<tr>
<td><code>bitop operator destkey key[key....]</code></td>
<td>Bitmaps间的运算</td>
<td><code>bitop</code>是一个复合操作，它可以做多个Bitmaps的<code>and</code>、<code>or</code>、<code>not</code>、<code>xor</code>操作并将结果保存在<code>destkey</code>中</td>
</tr>
<tr>
<td><code>bitpos key targetBit [start] [end]</code></td>
<td>计算Bitmaps中第一个值为targetBit的偏移量</td>
<td></td>
</tr>
</tbody></table>
<p>当用户量很大时，使用 bitmaps 存储用户的活跃情况是非常好的一种方案，但活跃用户量较少时则不合理，大多数位都是 0。</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>HyperLogLog并不是一种新的数据结构（实际类型为字符串类型），通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>pfadd key element [element …]</code></td>
<td>添加，成功返回 1</td>
<td></td>
</tr>
<tr>
<td><code>pfcount key [key …]</code></td>
<td>计算独立用户</td>
<td></td>
</tr>
<tr>
<td><code>pfmerge destkey sourcekey [sourcekey ...]</code></td>
<td>合并</td>
<td></td>
</tr>
</tbody></table>
<p>相比于集合类型，HyperLogLog 内存占用量非常小，但是存在错误率，因此，在数据结构选型时，需要平衡误差与空间占用率。</p>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>publish channel message</code></td>
<td>发布消息，返回订阅者个数</td>
<td></td>
</tr>
<tr>
<td><code>subscribe channel [channel ...]</code></td>
<td>订阅消息</td>
<td>客户端在执行订阅命令之后进入了订阅状态，只能接收<code>subscribe</code>、<code>psubscribe</code>、<code>unsubscribe</code>、<code>punsubscribe</code>的四个命令<br>新开启的订阅客户端，无法收到该频道之前的消息，因为Redis不会对发布的消息进行持久化</td>
</tr>
<tr>
<td><code>unsubscribe [channel [channel ...]]</code></td>
<td>取消订阅</td>
<td></td>
</tr>
<tr>
<td><code>psubscribe pattern [pattern...]</code><br><code>punsubscribe [pattern [pattern ...]]</code></td>
<td>按照模式订阅和取消订阅</td>
<td></td>
</tr>
<tr>
<td><code>pubsub channels [pattern]</code></td>
<td>查看活跃的频道</td>
<td></td>
</tr>
<tr>
<td><code>pubsub numsub [channel ...]</code></td>
<td>查看频道订阅数</td>
<td></td>
</tr>
<tr>
<td><code>pubsub numpat</code></td>
<td>查看模式订阅数</td>
<td></td>
</tr>
</tbody></table>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p>GEO底层由 zset 实现。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>geoadd key longitude latitude member [longitude latitude member ...]</code></td>
<td>增加地理位置信息。返回成功添加的个数</td>
<td>更新地理位置信息仍然可以使用该命令，但返回为 0。该命令同时支持多个地理位置添加</td>
</tr>
<tr>
<td><code>geopos key member [member ...]</code></td>
<td>获取地理位置信息</td>
<td></td>
</tr>
<tr>
<td><code>geodist key member1 member2 [unit]</code></td>
<td>获取两个地理位置的距离</td>
<td><code>unit</code>为单位，分别为<code>m</code>(米)，<code>km</code>(公里)，<code>mi</code>(英里)，<code>ft</code>(尺)</td>
</tr>
<tr>
<td><code>georadius key longitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</code><br><br><code>georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</code></td>
<td>获取指定位置范围内的地理信息位置集合</td>
<td><code>georadius</code>和<code>georadiusbymember</code>两个命令的作用是一样的，都是以一个地理位置为中心算出指定半径内的其他地理信息位置，不同的是<code>georadius</code>命令的中心位置给出了具体的经纬度，<code>georadiusbymember</code>只需给出成员即可。其中<code>radiusm|km|ft|mi</code>是必需参数，指定了半径<br><code>withcoord</code>:返回经纬度；<br><code>withdist</code>:返回离中心节点位置的距离；<br><code>withhash</code>:返回<code>geohash</code>；<br><code>COUNT count</code>:返回指定结果数量；<br><code>asc|desc</code>:按距中心节点距离升序或降序；<br><code>store key</code>:将结果保存到指定键；<br><code>storedist key</code>:将距中心节点距离保存到指定键</td>
</tr>
<tr>
<td><code>geohash key member [member ...]</code></td>
<td>获取geohash</td>
<td>Redis将所有地理位置信息的<code>geohash</code>存放在<code>zset</code>中，字符串越长，表示的位置更精确</td>
</tr>
<tr>
<td><code>zrem key member</code></td>
<td>删除地理位置信息</td>
<td></td>
</tr>
</tbody></table>
<h1 id="第-4-章-客户端"><a href="#第-4-章-客户端" class="headerlink" title="第 4 章 客户端"></a>第 4 章 客户端</h1><h2 id="客户端常见异常"><a href="#客户端常见异常" class="headerlink" title="客户端常见异常"></a>客户端常见异常</h2><ol>
<li>无法从连接池获取到连接<ol>
<li>连接池设置过小，默认为 8</li>
<li>客户端未正确使用连接池，如没有进行释放</li>
<li>存在慢查询操作</li>
<li>Redis 服务造成命令执行过程阻塞</li>
</ol>
</li>
<li>客户端读写超时<ol>
<li>读写时间设置过短</li>
<li>命令执行时间较长</li>
<li>网路异常</li>
<li>Redis 自身发生阻塞</li>
</ol>
</li>
<li>客户端连接超时<ol>
<li>超时时间过短</li>
<li>Redis 发生阻塞，<code>tcp-backlog</code>已满，造成新的连接失败</li>
<li>网络异常</li>
</ol>
</li>
<li>客户端缓冲区异常<ol>
<li>输出缓冲区满</li>
<li>长时间闲置连接被服务端主动断开</li>
<li>不正常并发读写</li>
</ol>
</li>
<li>Lua 脚本正在执行<ol>
<li>脚本正在执行，且执行时间超过了<code>lua-time-limit</code>，需等待脚本执行完成，或者使用<code>shutdown save</code>关闭 Redis 服务</li>
</ol>
</li>
<li>Redis 正在加载持久化文件</li>
<li>Redis 使用的内存超过<code>maxmemory</code>配置</li>
<li>客户端连接数过大<ol>
<li>客户端：如果<code>maxclients</code>参数不是很小的话，应用方的客户端连接数基本不会超过<code>maxclients</code>，通常来看是由于应用方对于Redis客户端使用不当造成的。此时如果应用方是分布式结构的话，可以通过下线部分应用节点（例如占用连接较多的节点），使得Redis的连接数先降下来。从而让绝大部分节点可以正常运行，此时再通过查找程序bug或者调整<code>maxclients</code>进行问题的修复。</li>
<li>服务端：如果此时客户端无法处理，而当前Redis为高可用模式（例如Redis Sentinel和Redis Cluster），可以考虑将当前Redis做故障转移。</li>
</ol>
</li>
</ol>
<h2 id="客户端案例分析"><a href="#客户端案例分析" class="headerlink" title="客户端案例分析"></a>客户端案例分析</h2><h3 id="Redis内存陡增"><a href="#Redis内存陡增" class="headerlink" title="Redis内存陡增"></a>Redis内存陡增</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>服务端现象：Redis主节点内存陡增，几乎用满<code>maxmemory</code>，而从节点内存并没有变化<br>客户端现象：客户端产生了OOM异常，无法写入新的数据</p>
<h4 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h4><p>从现象看，可能的原因有两个</p>
<ol>
<li>确实有大量写入，但是主从复制出现问题：用<code>dbsize</code>查询Redis复制的相关信息，复制是正常的，主从数据基本一致。</li>
<li>其他原因造成主节点内存使用过大：排查是否由客户端缓冲区造成主节点内存陡增，使用<code>info clients</code>命令查询，发现输出缓冲区不太正常，进一步通过<code>client list</code>命令找到<code>omem</code>不正常的连接，一般来说大部分客户端的<code>omem</code>为0（因为处理速度会足够快），于是通过<code>redis-cli client list | grep -v &quot;omem=0&quot;</code>找到<code>omem</code>非零的客户端连接。</li>
</ol>
<h3 id="客户端周期性的超时"><a href="#客户端周期性的超时" class="headerlink" title="客户端周期性的超时"></a>客户端周期性的超时</h3><h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h4><p>客户端现象：客户端出现大量周期性超时<br>服务端现象：服务端并没有明显的异常，只是有一些慢查询操作</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>网络：查看网络连接正常</li>
<li>Redis：查看 Redis 日志统计，未发现异常</li>
<li>客户端：慢查询与超时发生时间点吻合，推断由慢查询引起</li>
</ul>
<h1 id="第-5-章-持久化"><a href="#第-5-章-持久化" class="headerlink" title="第 5 章 持久化"></a>第 5 章 持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ul>
<li><code>save</code>命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</li>
<li><code>bgsave</code>命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8tfeooj3zj30k60hptbk.jpg" alt="bgsave workflow"></p>
<p>自动触发场景：</p>
<ol>
<li>使用save相关配置，如<code>save m n</code>。表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave</li>
<li>如果从节点执行全量复制操作，主节点自动执行 bgsave 生成RDB文件并发送给从节点</li>
<li>执行<code>debug reload</code>命令重新加载Redis时，也会自动触发 save 操作</li>
<li>默认情况下执行<code>shutdown</code>命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave</li>
</ol>
<p>如果Redis加载损坏的RDB文件时拒绝启动，此时可以使用Redis提供的<code>redis-check-dump</code>工具检测 RDB 文件并获取对应的错误报告。</p>
<h3 id="RDB-的优缺点"><a href="#RDB-的优缺点" class="headerlink" title="RDB 的优缺点"></a>RDB 的优缺点</h3><p>RDB的优点：</p>
<ul>
<li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。<strong>非常适用于备份，全量复制等场景</strong>。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</li>
<li>Redis加载RDB恢复数据远远快于AOF的方式。</li>
</ul>
<p>RDB的缺点：</p>
<ul>
<li>RDB方式数据<strong>无法做到实时持久化/秒级持久化</strong>。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li>
<li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令(类似于 MySQL 的 Binlog)，重启时再重新执行AOF文件中的命令达到恢复数据的目的。目前已经是Redis持久化的主流方式。</p>
<p>开启AOF功能需要设置配置：<code>appendonly yes</code>，默认不开启。AOF文件名通过<code>appendfilename</code>配置设置，默认文件名是<code>appendonly.aof</code>。保存路径同 RDB 持久化方式一致，通过<code>dir</code>配置指定。<br><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8u1rzsipij30n811un3c.jpg" alt="AOF workflow"></p>
<p>AOF缓冲区同步文件策略(参数<code>appendfsync</code>)</p>
<table>
<thead>
<tr>
<th>可配置值</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>always</code></td>
<td>命令写入<code>aof_buf</code>后调用系统<code>fsync</code>操作同步到 AOF 文件，<code>fsync</code> 完成后线程返回</td>
<td>不建议</td>
</tr>
<tr>
<td><code>everysec</code></td>
<td>命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，<code>write</code>完成后线程返回。<code>fsync</code>同步文件操作由专门线程每秒调用一次。</td>
<td>建议，为默认选项</td>
</tr>
<tr>
<td><code>no</code></td>
<td>命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，不对 AOF 文件做<code>fsync</code>同步，同步硬盘操作由 OS 负责，通常同步周期最长 30s</td>
<td>数据安全无法得到保证</td>
</tr>
</tbody></table>
<p>aof 重写过程可通过手动与自动方式触发。手动通过直接调用<code>bgrewriteaof</code>命令，自动方式则根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>的参数确定触发时机。<br><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8u27kw8tmj30u00ws7ff.jpg" alt="AOF rewrite workflow"></p>
<h2 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h2><p>Redis 启动时会优先加载 AOF 文件，如果 AOF 不可加载，然后再加载 RDB 文件。其文件加载流程如下：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91c1tnqngj30ky0m3djy.jpg" alt=""></p>
<p>如果在加载 AOF 文件时发生错误，可以先进行备份，然后采用<code>redis-check-aof --fix</code>命令进行修复，修复后使用<code>diff -u</code>对比数据的差异，找出丢失的数据，有些可以人工修改补全。</p>
<p>AOF文件可能存在结尾不完整的情况，比如机器突然掉电导致AOF尾部文件命令写入不全。Redis为我们提供了<code>aof-load-truncated</code>配置来兼容这种情况，默认开启。加载AOF时，当遇到此问题时会忽略并继续启动，同时打印如下警告日志：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># !!! Warning: short read while loading the AOF file !!!</span><br><span class="line"># !!! Truncating the AOF at offset <span class="number">397856725</span> !!!</span><br><span class="line"># AOF loaded anyway because aof-load-truncated is enabled</span><br></pre></td></tr></table></figure>

<h2 id="问题定位与优化"><a href="#问题定位与优化" class="headerlink" title="问题定位与优化"></a>问题定位与优化</h2><h3 id="fork-操作"><a href="#fork-操作" class="headerlink" title="fork 操作"></a>fork 操作</h3><p>当 Redis 做 RDB 或 AOF 重写时，对于大多数操作系统来说 fork 是个重量级错误。fork操作耗时跟进程总内存量息息相关，如果使用虚拟化技术，特别是 Xen 虚拟机，fork 操作会更耗时。</p>
<p>对于高并发 Redis 实例，如果fork操作耗时在秒级别将拖慢 Redis 几万条命令执行，对线上应用延迟影响非常明显。正常情况下 fork 耗时应该是每 GB 消耗20毫秒左右。可以在<code>info stats</code>统计中查<code>latest_fork_usec</code>指标获取最近一次 fork 操作耗时，单位微秒。</p>
<p>改善fork操作的耗时：</p>
<ol>
<li>优先使用物理机或者高效支持fork操作的虚拟化技术，避免使用Xen。</li>
<li>控制 Redis 实例最大可用内存，fork 耗时跟内存量成正比，线上建议每个 Redis 实例内存控制在 10GB 以内。</li>
<li>合理配置 Linux 内存分配策略，避免物理内存不足导致 fork 失败。</li>
<li>降低 fork 操作的频率，如适度放宽 AOF 自动触发时机，避免不必要的全量复制等。</li>
</ol>
<h3 id="子进程开销监控和优化"><a href="#子进程开销监控和优化" class="headerlink" title="子进程开销监控和优化"></a>子进程开销监控和优化</h3><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul>
<li>CPU开销分析。子进程负责把进程内的数据分批写入文件，这个过程属于CPU密集操作，通常子进程对单核CPU利用率接近90%.</li>
<li>CPU消耗优化。Redis是CPU密集型服务，不要做绑定单核CPU操作。由于子进程非常消耗CPU，会和父进程产生单核资源竞争。</li>
<li>不要和其他CPU密集型服务部署在一起，造成CPU过度竞争。</li>
<li>如果部署多个Redis实例，尽量保证同一时刻只有一个子进程执行重写工作。</li>
</ul>
<h4 id="硬盘开销"><a href="#硬盘开销" class="headerlink" title="硬盘开销"></a>硬盘开销</h4><ul>
<li>不要和其他高硬盘负载的服务部署在一起。如：存储服务、消息队列服务等。</li>
<li>AOF重写时会消耗大量硬盘IO，可以开启配置<code>no-appendfsync-on-rewrite</code>，默认关闭。表示在AOF重写期间不做<code>fsync</code>操作。</li>
<li>当开启 AOF 功能的 Redis 用于高流量写入场景时，如果使用普通机械磁盘，写入吞吐一般在100MB/s左右，这时 Redis 实例的瓶颈主要在 AOF 同步硬盘上。</li>
<li>对于单机配置多个 Redis 实例的情况，可以配置不同实例分盘存储 AOF 文件，分摊硬盘写入压力。</li>
</ul>
<blockquote>
<p>⚠️ 配置<code>no-appendfsync-on-rewrite=yes</code>时，在极端情况下可能丢失整个AOF重写期间的数据，需要根据数据安全性决定是否配置。</p>
</blockquote>
<h3 id="AOF-追加阻塞"><a href="#AOF-追加阻塞" class="headerlink" title="AOF 追加阻塞"></a>AOF 追加阻塞</h3><p>当 Redis 执行 <code>fsync</code> 同步时，如果系统硬盘繁忙，会造成 Redis 主线程的阻塞。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91co0mb8fj30g40hz770.jpg" alt=""></p>
<p>每当发生 AOF 追加阻塞事件发生时，在<code>info Persistence</code>统计中，<code>aof_delayed_fsync</code>指标会累加，查看这个指标方便定位 AOF 阻塞问题。AOF同步最多允许2秒的延迟，当延迟发生时说明硬盘存在高负载问题，可以通过监控工具如<code>iotop</code>，定位消耗硬盘IO资源的进程。</p>
<h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><ul>
<li>RDB使用一次性生成内存快照的方式，产生的文件紧凑压缩比更高，因此读取RDB恢复速度更快。由于每次生成RDB开销较大，<strong>无法做到实时持久化，一般用于数据冷备和复制传输</strong>。</li>
<li>AOF通过追加写命令到文件实现持久化，通过<code>appendfsync</code>参数可以控制实时/秒级持久化。因为需要不断追加写命令，所以AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积。</li>
<li>AOF重写可以通过<code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewritepercentage</code>参数控制自动触发，也可以使用<code>bgrewriteaof</code>命令手动触发。</li>
<li>子进程执行期间使用<code>copy-on-write</code>机制与父进程共享内存，避免内存消耗翻倍。AOF重写期间还需要维护重写缓冲区，保存新的写入命令避免数据丢失。</li>
</ul>
<h1 id="第-6-章-复制"><a href="#第-6-章-复制" class="headerlink" title="第 6 章 复制"></a>第 6 章 复制</h1><h2 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h2><p>配置复制的三种方式</p>
<ol>
<li>在配置文件中加入<code>slaveof {masterHost} {masterPort}</code> 随Redis启动生效。</li>
<li>在<code>redis-server</code>启动命令后加入<code>--slaveof {masterHost} {masterPort}</code> 生效。</li>
<li>直接使用命令<code>slaveof {masterHost} {masterPort}</code>生效。</li>
</ol>
<p>主从节点复制成功建立后，可以使用<code>info replication</code>命令查看复制相关状态。</p>
<h2 id="断开复制"><a href="#断开复制" class="headerlink" title="断开复制"></a>断开复制</h2><p><code>slaveof</code>命令不但可以建立复制，还可以在从节点执行<code>slaveof no one</code>来断开与主节点复制关系。同时，<code>slaveof {newMasterIp} {newMasterPort}</code>还可以实现切主操作，更换主节点。</p>
<blockquote>
<p>⚠️ 切主后从节点会清空之前所有的数据，线上人工操作时小心<code>slaveof</code>在错误的节点上执行或者指向错误的主节点。</p>
</blockquote>
<p>对于数据比较重要的节点，主节点会通过设置<code>requirepass</code>参数进行密码验证，这时所有的客户端访问必须使用<code>auth</code>命令实行校验。</p>
<p>默认情况下，从节点使用<code>slave-read-only=yes</code>配置为只读模式。由于复制只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，修改从节点会造成主从数据不一致。因此建议线上不要修改从节点的只读模式。</p>
<p>Redis为我们提供了<code>repl-disable-tcp-nodelay</code>参数用于控制是否关闭<code>TCP_NODELAY</code>，默认关闭，说明如下：</p>
<ul>
<li>当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延迟会变小，但增加了网络带宽的消耗。适用于主从之间的网络环境良好的场景，如同机架或同机房部署。</li>
<li>当开启时，主节点会合并较小的TCP数据包从而节省带宽。默认发送时间间隔取决于Linux的内核，一般默认为40毫秒。这种配置节省了带宽但增大主从之间的延迟。适用于主从网络环境复杂或带宽紧张的场景，如跨机房部署。</li>
</ul>
<h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><p>根据拓扑的复杂性，可分为三种：一主一从、一主多从、树状主从结构。</p>
<h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><p>当应用写命令并发量较高且需要持久化时，可以只在从节点上开启AOF，这样既保证数据安全性同时也避免了持久化对主节点的性能干扰。但需要注意的是，当主节点关闭持久化功能时，如果主节点脱机要避免自动重启操作。因为主节点之前没有开启持久化功能自动重启后数据集为空，这时从节点如果继续复制主节点会导致从节点数据也被清空的情况，丧失了持久化的意义。安全的做法是在从节点上执行<code>slaveof no one</code>断开与主节点的复制关系，再重启主节点从而避免这一问题。</p>
<h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><p>对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性。</p>
<h3 id="树状主从结构"><a href="#树状主从结构" class="headerlink" title="树状主从结构"></a>树状主从结构</h3><p>当主节点需要挂载多个从节点时为了避免对主节点的性能干扰，可以采用树状主从结构降低主节点压力。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91e0yu7flj30if0o442t.jpg" alt=""></p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>Redis 在初次复制时，会进行全量复制，之后便会根据主从节点的复制偏移量进行<code>psync</code>增量复制。</p>
<p><code>psync</code>命令运行需要以下组件支持：</p>
<ul>
<li>主从节点各自复制偏移量。</li>
<li>主节点复制积压缓冲区。</li>
<li>主节点运行id。</li>
</ul>
<h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>参与复制的主从节点都会维护自身复制偏移量。主节点在理完写入命令后，会把命令的字节长度做累加记录，统计信息在<code>info relication</code>中的<code>master_repl_offset</code>指标中，从节点会每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。统计信息在<code>info relication</code>中的<code>slave_repl_offset</code>指标中。</p>
<p>可以通过主节点的统计信息，计算出<code>master_repl_offset_slave_offset</code>字节量，判断主从节点复制相差的数据量，根据这个差值判定当前复制的健康度。如果主从之间复制偏移量相差较大，则可能是网络延迟或命令阻塞等原因引起。</p>
<h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91vyy7e25j30h909875n.jpg" alt=""></p>
<p>主节点响应从节点的同步时，不但会把命令发送给从节点，还会写入复制积压缓冲区。由于缓冲区本质上是先进先出的定长队列，所以能实现保存最近已复制数据的功能，用于部分复制和复制命令丢失的数据补救。复制缓冲区相关统计信息保存在主节点的<code>info replication</code>中。</p>
<h4 id="主节点运行ID"><a href="#主节点运行ID" class="headerlink" title="主节点运行ID"></a>主节点运行ID</h4><p>每个Redis节点启动后都会动态分配一个40位的十六进制字符串作为运行ID。运行ID的主要作用是用来唯一识别Redis节点，比如从节点保存主节点的运行ID识别自己正在复制的是哪个主节点。如果只使用ip+port的方式识别主节点，那么主节点重启变更了整体数据集（如替换RDB/AOF文件），从节点再基于偏移量复制数据将是不安全的，因此当运行ID变化后从节点将做全量复制。可以运行<code>info server</code>命令查看当前节点的运行ID。</p>
<p>当需要调优一些内存相关配置，例如：<code>hash-max-ziplist-value</code>等，这些配置需要Redis重新加载才能优化已存在的数据，这时可以使用<code>debug reload</code>命令重新加载 RDB 并保持运行 ID 不变，从而有效避免不必要的全量复制。</p>
<blockquote>
<p><code>debug reload</code>命令会阻塞当前Redis节点主线程，阻塞期间会生成本地RDB快照并清空数据之后再加载RDB文件。因此对于大数据量的主节点和无法容忍阻塞的应用场景，谨慎使用。</p>
</blockquote>
<h4 id="psync-命令"><a href="#psync-命令" class="headerlink" title="psync 命令"></a>psync 命令</h4><p>从节点使用<code>psync</code>命令完成部分复制和全量复制功能，命令格式：<code>psync {runId} {offset}</code></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xk5bba1j30jh0hejtq.jpg" alt=""></p>
<p>主节点回复<code>+FULLRESYNC {runId} {offset}</code>会触发全量复制，<code>+CONTINUE</code>则触发增量复制。</p>
<h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xn7bm5rj30j30lqgp7.jpg" alt=""></p>
<p>对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。如果 RDB 文件过大，超过预设的 timeout，则会终止全量同步，并清除已下载临时文件。如果在高并发写的场景，主节点的缓冲区被写满，同样会导致同步的失败。</p>
<p>全量复制的主要时间开销在：</p>
<ul>
<li>主节点 <code>bgsave</code> 时间</li>
<li>RDB 文件网络传输时间</li>
<li>从节点清空数据时间</li>
<li>从节点加载 RDB 时间</li>
<li>可能的 AOF 重写时间</li>
</ul>
<h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xwacukej30hu0d8gnx.jpg" alt=""></p>
<h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><p>主从心跳判断机制：</p>
<ul>
<li>通过<code>client list</code>命令查看复制相关客户端信息，主节点的连接状态为<code>flags=M</code>，从节点连接状态为<code>flags=S</code>。</li>
<li>主节点默认每隔10秒对从节点发送<code>ping</code>命令，判断从节点的存活性和连接状态。可通过参数<code>repl-ping-slave-period</code>控制发送频率。</li>
<li>从节点在主线程中每隔1秒发送<code>replconf ack{offset}</code>命令，给主节点上报自身当前的复制偏移量。<code>replconf</code>命令主要作用如下：<ul>
<li>实时监测主从节点网络状态</li>
<li>上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据</li>
<li>实现保证从节点的数量和延迟性功能，通过min-slaves-to-write、minslaves-max-lag参数配置定义</li>
</ul>
</li>
</ul>
<blockquote>
<p>我们经常会遇到数据同步的问题，但如何在消耗最少的资源下保证数据的一致性是我们一直会遇到的问题，好在，很多成熟的 软件已经为我们提供了借鉴的方案，如 Git 的 hash chain，Redis 的 <code>psync</code> 偏移量增量复制与缓冲区，以及 MySQL 的<code>binlog</code>。没有最好的方案，只有最合适的方案，或许我们能从中得到启发，找到最适合自己的增量同步方式。</p>
</blockquote>
<h2 id="开发与运维中的问题"><a href="#开发与运维中的问题" class="headerlink" title="开发与运维中的问题"></a>开发与运维中的问题</h2><h3 id="数据延时"><a href="#数据延时" class="headerlink" title="数据延时"></a>数据延时</h3><p>Redis复制数据的延迟由于异步复制特性是无法避免的，延迟取决于网络带宽和命令阻塞情况。需要业务场景允许短时间内的数据延迟。对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点。</p>
<h3 id="读到过期数据"><a href="#读到过期数据" class="headerlink" title="读到过期数据"></a>读到过期数据</h3><p>惰性删除：主节点将过期的键同步给从节点<br>定时删除：主节点轮询采样一定数量的键，当采样的键过期后，同步给从节点。<br>Redis 3.2+ 在从节点读取键时会校验是否过期以判断是否返回数据。</p>
<h3 id="从节点故障"><a href="#从节点故障" class="headerlink" title="从节点故障"></a>从节点故障</h3><p>下线故障节点。</p>
<blockquote>
<p>当主节点优化空间不大时再考虑扩展。笔者建议大家在做读写分离之前，可以考虑使用Redis Cluster等分布式解决方案，这样不止扩展了读性能还可以扩展写性能和可支撑数据规模，并且一致性和故障转移也可以得到保证，对于客户端的维护逻辑也相对容易。</p>
</blockquote>
<h3 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h3><ul>
<li>第一次建立复制：由于是第一次建立复制，从节点不包含任何主节点数据，因此必须进行全量复制才能完成数据同步。对于这种情况全量复制无法避免。当对数据量较大且流量较高的主节点添加从节点时，建议在低峰时进行操作，或者尽量规避使用大数据量的Redis节点。</li>
<li>节点运行ID不匹配：当主从复制关系建立后，从节点会保存主节点的运行ID，如果此时主节点因故障重启，那么它的运行ID会改变，从节点发现主节点运行ID不匹配时，会认为自己复制的是一个新的主节点从而进行全量复制。对于这种情况应该从架构上规避，比如提供故障转移功能。当主节点发生故障后，手动提升从节点为主节点或者采用支持自动故障转移的哨兵或集群方案。</li>
<li>复制积压缓冲区不足：当主从节点网络中断后，从节点再次连上主节点时会发送<code>psync {offset} {runId}</code>命令请求部分复制，<strong>如果请求的偏移量不在主节点的积压缓冲区内，则无法提供给从节点数据，因此部分复制会退化为全量复制</strong>。此时需要保证<code>repl_backlog_size &gt; net_break_time*write_size_per_minute</code>以避免缓冲区不足引发的全量复制。</li>
</ul>
<h3 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h3><h4 id="单主节点复制风暴"><a href="#单主节点复制风暴" class="headerlink" title="单主节点复制风暴"></a>单主节点复制风暴</h4><p>一般发生在主节点挂载多个从节点的场景。当主节点重启恢复后，从节点会发起全量复制流程，这时主节点就会为从节点创建RDB快照，如果在快照创建完毕之前，有多个从节点都尝试与主节点进行全量同步，那么其他从节点将共享这份RDB快照，同时向多个从节点发送RDB快照，可能使主节点的网络带宽消耗严重，造成主节点的延迟变大，极端情况会发生主从节点连接断开，导致复制失败。<br>解决方案可以减少主节点挂载的从节点数量，或者采用树形复制结构(这种树状结构也带来了运维的复杂性，增加了手动和自动处理故障转移的难度)。</p>
<h4 id="单机器复制风暴"><a href="#单机器复制风暴" class="headerlink" title="单机器复制风暴"></a>单机器复制风暴</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91z58ncm8j30iv0frgpv.jpg" alt=""></p>
<ul>
<li>应该把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点。</li>
<li>当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制。</li>
</ul>
<h1 id="第-7-章-阻塞"><a href="#第-7-章-阻塞" class="headerlink" title="第 7 章 阻塞"></a>第 7 章 阻塞</h1><p>发生阻塞会有内在与外在原因<br>内在原因：不合理地使用API或数据结构、CPU饱和、持久化阻塞等<br>外在原因：CPU竞争、内存交换、网络问题等</p>
<h1 id="第-8-章-理解内存"><a href="#第-8-章-理解内存" class="headerlink" title="第 8 章 理解内存"></a>第 8 章 理解内存</h1><h1 id="第-9-章-哨兵"><a href="#第-9-章-哨兵" class="headerlink" title="第 9 章 哨兵"></a>第 9 章 哨兵</h1><h1 id="第-10-章-集群"><a href="#第-10-章-集群" class="headerlink" title="第 10 章 集群"></a>第 10 章 集群</h1><h1 id="第-11-章-缓存设计"><a href="#第-11-章-缓存设计" class="headerlink" title="第 11 章 缓存设计"></a>第 11 章 缓存设计</h1><h1 id="第-12-章-Devops-的陷阱"><a href="#第-12-章-Devops-的陷阱" class="headerlink" title="第 12 章 Devops 的陷阱"></a>第 12 章 Devops 的陷阱</h1><h1 id="第-13-章-Redis-监控运维云平台-CachedCloud"><a href="#第-13-章-Redis-监控运维云平台-CachedCloud" class="headerlink" title="第 13 章 Redis 监控运维云平台 CachedCloud"></a>第 13 章 Redis 监控运维云平台 CachedCloud</h1><h1 id="第-14-章-Redis-配置统计字典"><a href="#第-14-章-Redis-配置统计字典" class="headerlink" title="第 14 章 Redis 配置统计字典"></a>第 14 章 Redis 配置统计字典</h1><hr>
<blockquote>
<p>读后感：Redis 是一款强有力的生产力工具，像一把瑞士军刀，只有你熟悉自己使用的工具，才能构建出一座坚固漂亮的大厦。使用什么工具决定了你的下限，但怎么使用工具决定了你的上限，你可以用 Redis 来做缓存，也可以用于流量削峰，年会抽奖，社交推荐。所有工具的背后都取决于人，创新产生价值。</p>
</blockquote>

    </div>

    
    
    
      
        <div class="reward-container">
  <div>因为热爱，所以执着。</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat.png" alt="Palemoky WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Palemoky Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Palemoky
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://blog.palemoky.top/post/redis-devops/" title="《Redis开发与运维》">https://blog.palemoky.top/post/redis-devops/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/post/get-bank-info-by-unionpay/" rel="next" title="银联查询银行卡信息">
                  <i class="fa fa-chevron-left"></i> 银联查询银行卡信息
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/post/Wall-of-Shame/" rel="prev" title="挂南墙">
                  挂南墙 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第-1-章-初识-Redis"><span class="nav-text">第 1 章 初识 Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-数据类型"><span class="nav-text">Redis 数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-提供的功能"><span class="nav-text">Redis 提供的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-使用场景"><span class="nav-text">Redis 使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么-Redis-很快？"><span class="nav-text">为什么 Redis 很快？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-可执行文件说明"><span class="nav-text">Redis 可执行文件说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动-Redis-的3种方式："><span class="nav-text">启动 Redis 的3种方式：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-2-章-API-的理解和使用"><span class="nav-text">第 2 章 API 的理解和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判断键不存在的方法："><span class="nav-text">判断键不存在的方法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表的四种操作类型"><span class="nav-text">列表的四种操作类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表的使用场景："><span class="nav-text">列表的使用场景：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合的使用场景"><span class="nav-text">集合的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表、集合、有序集合的异同点"><span class="nav-text">列表、集合、有序集合的异同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-数据结构与内部编码"><span class="nav-text">Redis 数据结构与内部编码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-3-章-小功能大用处"><span class="nav-text">第 3 章 小功能大用处</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#慢查询"><span class="nav-text">慢查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#慢查询配置"><span class="nav-text">慢查询配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#慢查询命令"><span class="nav-text">慢查询命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#慢查询日志结构"><span class="nav-text">慢查询日志结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-Shell"><span class="nav-text">Redis Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-cli"><span class="nav-text">redis-cli</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-server"><span class="nav-text">redis-server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-benchmark"><span class="nav-text">redis-benchmark</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipeline"><span class="nav-text">Pipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务与-Lua"><span class="nav-text">事务与 Lua</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在-Redis-中执行-Lua-的方法"><span class="nav-text">在 Redis 中执行 Lua 的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bitmaps"><span class="nav-text">Bitmaps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HyperLogLog"><span class="nav-text">HyperLogLog</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布订阅"><span class="nav-text">发布订阅</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GEO"><span class="nav-text">GEO</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-4-章-客户端"><span class="nav-text">第 4 章 客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端常见异常"><span class="nav-text">客户端常见异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端案例分析"><span class="nav-text">客户端案例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis内存陡增"><span class="nav-text">Redis内存陡增</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#现象"><span class="nav-text">现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析原因"><span class="nav-text">分析原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端周期性的超时"><span class="nav-text">客户端周期性的超时</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#现象-1"><span class="nav-text">现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析"><span class="nav-text">分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-5-章-持久化"><span class="nav-text">第 5 章 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB"><span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-的优缺点"><span class="nav-text">RDB 的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF"><span class="nav-text">AOF</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重启加载"><span class="nav-text">重启加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题定位与优化"><span class="nav-text">问题定位与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork-操作"><span class="nav-text">fork 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子进程开销监控和优化"><span class="nav-text">子进程开销监控和优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU"><span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬盘开销"><span class="nav-text">硬盘开销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-追加阻塞"><span class="nav-text">AOF 追加阻塞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本章总结"><span class="nav-text">本章总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-6-章-复制"><span class="nav-text">第 6 章 复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#建立复制"><span class="nav-text">建立复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#断开复制"><span class="nav-text">断开复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓扑"><span class="nav-text">拓扑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一主一从"><span class="nav-text">一主一从</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一主多从"><span class="nav-text">一主多从</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树状主从结构"><span class="nav-text">树状主从结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原理"><span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据同步"><span class="nav-text">数据同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#复制偏移量"><span class="nav-text">复制偏移量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制积压缓冲区"><span class="nav-text">复制积压缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主节点运行ID"><span class="nav-text">主节点运行ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#psync-命令"><span class="nav-text">psync 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全量同步"><span class="nav-text">全量同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#增量同步"><span class="nav-text">增量同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#心跳"><span class="nav-text">心跳</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发与运维中的问题"><span class="nav-text">开发与运维中的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据延时"><span class="nav-text">数据延时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读到过期数据"><span class="nav-text">读到过期数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从节点故障"><span class="nav-text">从节点故障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规避全量复制"><span class="nav-text">规避全量复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规避复制风暴"><span class="nav-text">规避复制风暴</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单主节点复制风暴"><span class="nav-text">单主节点复制风暴</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单机器复制风暴"><span class="nav-text">单机器复制风暴</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-7-章-阻塞"><span class="nav-text">第 7 章 阻塞</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-8-章-理解内存"><span class="nav-text">第 8 章 理解内存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-9-章-哨兵"><span class="nav-text">第 9 章 哨兵</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-10-章-集群"><span class="nav-text">第 10 章 集群</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-11-章-缓存设计"><span class="nav-text">第 11 章 缓存设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-12-章-Devops-的陷阱"><span class="nav-text">第 12 章 Devops 的陷阱</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-13-章-Redis-监控运维云平台-CachedCloud"><span class="nav-text">第 13 章 Redis 监控运维云平台 CachedCloud</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-14-章-Redis-配置统计字典"><span class="nav-text">第 14 章 Redis 配置统计字典</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Palemoky"
    src="/images/orca.jpg">
  <p class="site-author-name" itemprop="name">Palemoky</p>
  <div class="site-description" itemprop="description">Learn by doing !</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/palemoky" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;palemoky" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:palemoky@gmail.com" title="E-Mail &amp;rarr; mailto:palemoky@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Palemoky © Copyright</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://palemoky.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  function loadComments() {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://blog.palemoky.top/post/redis-devops/",
            identifier: "post/redis-devops/",
            title: "《Redis开发与运维》"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://palemoky.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  }
    (function() {
      var offsetTop = document.getElementById('comments').offsetTop - window.innerHeight;
      if (offsetTop <= 0) {
        // load directly when there's no a scrollbar
        window.addEventListener('load', loadComments, false);
      } else {
        var disqus_scroll = () => {
          // offsetTop may changes because of manually resizing browser window or lazy loading images.
          var offsetTop = document.getElementById('comments').offsetTop - window.innerHeight;
          var scrollTop = window.scrollY;

          // pre-load comments a bit? (margin or anything else)
          if (offsetTop - scrollTop < 60) {
            window.removeEventListener('scroll', disqus_scroll);
            loadComments();
          }
        };
        window.addEventListener('scroll', disqus_scroll);
      }
    })();
  
</script>

    </div>
</body>
</html>
