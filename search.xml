<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>订单号应该如何设计</title>
      <link href="/post/how-to-design-order-number/"/>
      <url>/post/how-to-design-order-number/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1gaye6e6z98j30o10d9gmw.jpg" alt=""></p><a id="more"></a><h1 id="订单号的基本原则"><a href="#订单号的基本原则" class="headerlink" title="订单号的基本原则"></a>订单号的基本原则</h1><p>订单号作为交易的重要标识，一个好的订单号应该满足以下要求：</p><ol><li>唯一性。确保订单号的生成不会出现重复。</li><li>安全性。订单号不会泄露用户信息、业务运营状况等敏感信息。</li><li>可读性。好的订单号应该被易于阅读，客户反馈时降低传达错误概率。</li><li>按需包含日常运维信息。</li></ol><p>基于以上原则设计的唯一标识在生活中有一个很好的例子——身份证号，其具体的设计可查看我的另一篇文章<a href="https://blog.shixinyu.space/post/id-number-infos/">你的身份证号码都包含了哪些信息？</a>。在身份证号中，18 位数字包含了地区、生日、派出所编码、性别、校验等信息，如果我们在订单号中加入一些非敏感的日常运维信息，将会极大提升工作效率。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaya6etdstj30hs0a90tx.jpg" alt=""></p><h1 id="电商巨头订单号"><a href="#电商巨头订单号" class="headerlink" title="电商巨头订单号"></a>电商巨头订单号</h1><p>目前，淘宝订单号为 18 位，末6位为部分用户 ID， 2009 年 7 月的淘宝订单号为 10 位；京东订单号为 12 位，2015 年 1 月时订单为 10 位。可见订单号也是随着业务不断变化的，重要的是如何更好的服务于业务。</p><p>美团技术团队直接开源<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf 订单号生成器</a>，这是为数不多的大数据量生成订单解决方案的开源，我们从中能得到很多的借鉴。</p><h1 id="常见设计"><a href="#常见设计" class="headerlink" title="常见设计"></a>常见设计</h1><ol><li>年月日时分秒 + 用户 ID</li><li>年月日时分秒 + 随机数 + 校验码</li><li>随机订单号</li><li>根据业务信息加密处理生成</li><li>根据业务运营情况生成</li></ol><p>在设计订单号时，有些具备唯一性的 ID 是很好的防冲突手段，如用户 ID、时间戳等，但直接加入又会暴露敏感信息，因此可以混入取模、移位、异或、校验位等加密敏感信息，同时防止订单号被构造。</p><p>最后，没有银弹，根据业务的实际情况按需设计，合适的才是最好的。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/792c2bbe107e" target="_blank" rel="noopener">Laravel – 实战篇 UUID (唯一识别码)</a></li><li><a href="https://www.zhihu.com/question/19805896" target="_blank" rel="noopener">电子商务网站中订单号设计有什么规则和依据吗？</a></li><li><a href="https://yemablog.com/posts/how-to-generate-id" target="_blank" rel="noopener">互联网业务中用户、商家、订单号等 id 如何生成</a></li><li><a href="https://yemablog.com/posts/jd-id" target="_blank" rel="noopener">京东的订单号为什么那么短？</a></li><li><a href="https://www.jianshu.com/p/544ab3d60e77" target="_blank" rel="noopener">电商订单号设计思考</a></li><li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf—— 美团点评分布式 ID 生成系统</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Laradock 与 MySQL 8.0 历险记</title>
      <link href="/post/Laradock-and-MySQL-8/"/>
      <url>/post/Laradock-and-MySQL-8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1gax36xnansj30k40bnmy1.jpg" alt=""></p><a id="more"></a><h1 id="Laradock-是什么？"><a href="#Laradock-是什么？" class="headerlink" title="Laradock 是什么？"></a>Laradock 是什么？</h1><p><a href="http://laradock.io/" target="_blank" rel="noopener">Laradock</a> 是一个 PHP 的 docker 集成环境，支持多种 PHP、DB及常用工具版本，能够快速搭建开发生产环境。</p><h2 id="Laradock-配置说明"><a href="#Laradock-配置说明" class="headerlink" title="Laradock 配置说明"></a>Laradock 配置说明</h2><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>在 laradock 根目录设置好<code>.env</code>文件后，执行命令<code>docker-compose up -d nginx mysql redis workspace</code>启动所需容器</p><blockquote><p>docker-compose 命令会依赖<code>docker-compose.yml</code>文件。</p></blockquote><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><p>在 laradock 根目录执行<code>docker-compose stop</code><br>在任意目录执行<code>docker stop $(docker ps -q)</code>会停止所有正在运行中的容器</p><h4 id="停止并删除容器"><a href="#停止并删除容器" class="headerlink" title="停止并删除容器"></a>停止并删除容器</h4><p>在 laradock 根目录执行<code>docker-compose down</code></p><blockquote><p>请<em>谨慎</em>使用该命令 ！！！</p></blockquote><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p>在 <strong>laradock 目录下</strong> 执行<code>docker-compose exec [container] bash</code>命令，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">exec</span> workspace bash      // 进入工作区</span><br><span class="line">$ docker-compose <span class="built_in">exec</span> mysql bash          // 进入 MySQL</span><br><span class="line">$ docker-compose <span class="built_in">exec</span> redis bash          // 进入 Redis</span><br></pre></td></tr></table></figure><h4 id="构建容器"><a href="#构建容器" class="headerlink" title="构建容器"></a>构建容器</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="keyword">build </span>workspace</span><br><span class="line">$ docker-compose <span class="keyword">build </span>mysql</span><br></pre></td></tr></table></figure><h3 id="Nginx-站点配置"><a href="#Nginx-站点配置" class="headerlink" title="Nginx 站点配置"></a>Nginx 站点配置</h3><p>位于 laradock 根目录下的<code>../nginx/sites/*.conf</code></p><h1 id="为什么选择-MySQL-8？"><a href="#为什么选择-MySQL-8？" class="headerlink" title="为什么选择 MySQL 8？"></a>为什么选择 MySQL 8？</h1><p>MySQL 8.0 于 2016 年 9 月发布，在 2018 年 4 月发布第一个通用可用版本。目前为止，MySQL8 的使用还处于小范围的尝鲜阶段，经过近两年的正式版，我任务很多人已经趟过不少坑了，加之升级是未来的趋势，不如早日适应。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gax44awxg8j30d90cr77b.jpg" alt=""></p><p>在 MySQL 8 中，主要有以下的一些优化：</p><ul><li>字符集默认支持 uft8mb4，很好的支持了 emoji，再也不是 latin1 了</li><li>新能较 5.7 提升了两倍</li><li>JSON 的优化支持</li><li>连接方式由 <code>mysql_native_password</code> 修改为 <code>caching_sha2_password</code></li><li>…</li></ul><h1 id="Laravel-配置说明"><a href="#Laravel-配置说明" class="headerlink" title="Laravel 配置说明"></a>Laravel 配置说明</h1><h2 id="Laravel-连接-Laradock-数据库"><a href="#Laravel-连接-Laradock-数据库" class="headerlink" title="Laravel 连接 Laradock 数据库"></a>Laravel 连接 Laradock 数据库</h2><p><code>.env</code>文件需配置为<code>DB_HOST=mysql</code>，不能是<code>127.0.0.1</code>或<code>localhost</code>。如果需使用数据库软件连接，需修改为host 可为<code>127.0.0.1</code>或<code>localhost</code>。</p><p>这是因为<code>127.0.0.1</code>或<code>localhost</code>表示本机回环地址，php 代码是运行在 php 容器中的，与 MySQL 容器相隔离，因此需要设为<code>mysql</code>。MySQL 容器与数据库软件运行于同一宿主机环境，因此可用<code>127.0.0.1</code>或<code>localhost</code>。</p><h3 id="MySQL-8-的认证变化"><a href="#MySQL-8-的认证变化" class="headerlink" title="MySQL 8 的认证变化"></a>MySQL 8 的认证变化</h3><p>MySQL 8.0 将密码验证方式由以前的 <code>mysql_native_password</code> 改为了 <code>caching_sha2_password</code>，以获得更快的连接速度，但目前<code>caching_sha2_password</code>的支持尚不完善，因此连接时可能会出现认证错误。</p><p>PHP 7.4 版本已经支持了 <code>caching_sha2_password</code>，因此可以直接连接，该版本以下则需要使用命令<code>ALTER USER &#39;YOURUSERNAME&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;YOURPASSWORD&#39;;</code>修改账户的连接方式。修改前可使用命令<code>SELECT user,host,plugin from mysql.user where user=&#39;root&#39;;</code>查询当前连接方式。</p><p>另外，当前大多数据库GUI客户端尚不支持 <code>caching_sha2_password</code> 方式，因此需要将 DB 软件的连接账号设置为传统的 <code>mysql_native_password</code>。或者使用终端连接数据库查询，终端查询推荐 mycli 工具，以下是使用示例</p><p><img src="https://d33wubrfki0l68.cloudfront.net/0f0733732e766219aa0a83e631d5cd8b784edabc/5dc57/images/main.gif" alt=""></p><p>由于代码运行于 Laradock 的 workspace 容器，因此当我们在宿主机执行涉及数据库的终端命令时，会出现矛盾的情况：</p><ol><li>代码以<code>DB_HOST=mysql</code>连接数据库，宿主机则以<code>127.0.0.1</code>连接，因此 dsn 错误而无法连接，需要临时修改<code>DB_HOST</code>，但这样容易忘记改回去，不建议操作</li><li>执行中一些依赖目录的代码在宿主机可能会无法正常运行<br>综上，容器中执行终端脚本时需要在容器中执行，请勿在宿主机中执行。</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://laravel-news.com/laravel-and-mysql-8-fixing-mysql-server-has-gone-away-error" target="_blank" rel="noopener">PHP 7.4 修复 MySQL 8 连接问题</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html" target="_blank" rel="noopener">MySQL 8 连接变更的官方说明</a></li></ol><h2 id="连接-Redis"><a href="#连接-Redis" class="headerlink" title="连接 Redis"></a>连接 Redis</h2><p>Laravel Redis 依赖 predis 或者 phpredis，前者纯 php 编写，composer 快捷安装，但作者已经弃坑，未来Laravel 会移除对其支持，采用 socket 连接到 Redis（每次请求均需连接 Redis），后者则是使用 C 语言编写的扩展，可以保持对 Redis 的长连接（pconnect），具备更好的性能，因此若业务对 Redis 依赖性较强，推荐使用 phpredis。</p><h3 id="Laravel-中的-Redis-注意事项"><a href="#Laravel-中的-Redis-注意事项" class="headerlink" title="Laravel 中的 Redis 注意事项"></a>Laravel 中的 Redis 注意事项</h3><p>Laravel 的<code>config/database.php</code>中默认使用<code>phpredis</code>，若使用<code>predis</code>，则注意需要修改<code>REDIS_CLIENT</code>。</p><p>Laravel 中统一使用<code>Illuminate\Support\Facades\Redis</code>中的命令，屏蔽了 predis 与 phpredis 命令的差异，建议使用。</p><h3 id="predis-直接连接"><a href="#predis-直接连接" class="headerlink" title="predis 直接连接"></a>predis 直接连接</h3><p>predis 的<code>new Predis\Client();</code>是使用<code>tcp://127.0.0.1:6379</code>默认连接，而非读取 Laravel 的Redis配置，默认配置信息位于<code>src/Connection/Parameters.php</code>中的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> $defaults = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'scheme'</span> =&gt; <span class="string">'tcp'</span>,</span><br><span class="line">        <span class="string">'host'</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'port'</span> =&gt; <span class="number">6379</span>,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>如果连接非本机 Redis，可使用<code>new Predis\Client(&#39;tcp://10.0.0.1:6379&#39;);</code>连接。</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="宿主机执行与数据库相关命令时遇到以下错误："><a href="#宿主机执行与数据库相关命令时遇到以下错误：" class="headerlink" title="宿主机执行与数据库相关命令时遇到以下错误："></a>宿主机执行与数据库相关命令时遇到以下错误：</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Illuminate\<span class="keyword">Database</span>\QueryException  : <span class="built_in">SQLSTATE</span>[HY000] [<span class="number">2002</span>] php_network_getaddresses: getaddrinfo failed: nodename nor servname provided, <span class="keyword">or</span> <span class="keyword">not</span> known</span><br></pre></td></tr></table></figure><p>这是由于宿主机无法正确连接容器中的数据库，请前往容器中执行</p><h3 id="数据库连接报错"><a href="#数据库连接报错" class="headerlink" title="数据库连接报错"></a>数据库连接报错</h3><p>使用以下代码直接连接数据库验证是否 DB 配置错误，然后根据错误提示借助搜索引擎逐步排查错误</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$db_test = mysqli_connect(<span class="string">'host'</span>, <span class="string">'username'</span>, <span class="string">'password'</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终端计算器</title>
      <link href="/post/terminal-calculator/"/>
      <url>/post/terminal-calculator/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1garaul1518j30sg0g0wff.jpg" alt=""></p><a id="more"></a><p>编程中经常会有一些数值的计算或者进制的转换，虽然各操作系统都自带了计算器应用，但部分功能还是不算完善，比如取余数、进制转换、引用上次的计算结果等，相较而言，Windows 中的计算器应用还是功能很强大的。其实，作为计算机，计算功能当然是其最基础也是最擅长的功能，仅终端就涵盖了各种各样的计算方式，如<code>bc</code>、<code>echo</code>、<code>expr</code>等</p><h1 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h1><h2 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 15/4 | bc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"3+4; 5*2; 5^2; 18/4"</span> | bc</span><br></pre></td></tr></table></figure><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>十六进制转十进制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"ibase=16;A7"</span> | bc</span><br><span class="line">167</span><br></pre></td></tr></table></figure><p>二进制转十进制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"ibase=2;11111111"</span> | bc</span><br><span class="line">255</span><br></pre></td></tr></table></figure><p>十六进制转二进制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"ibase=16; obase=2; B5-A4"</span> | bc</span><br><span class="line">10001</span><br></pre></td></tr></table></figure><h2 id="last-引用上次计算结果"><a href="#last-引用上次计算结果" class="headerlink" title="last 引用上次计算结果"></a>last 引用上次计算结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"50*4; last+100"</span> | bc </span><br><span class="line">200</span><br><span class="line">300</span><br></pre></td></tr></table></figure><p><code>last</code> 也可以用<code>.</code>代替</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"50*4;.+100"</span> | bc</span></span><br></pre></td></tr></table></figure><h2 id="交互式计算"><a href="#交互式计算" class="headerlink" title="交互式计算"></a>交互式计算</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gar9jdt3bsj30fr050weu.jpg" alt=""></p><p>一行多个计算表达式，以<code>;</code>分隔</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>+<span class="number">4</span>; <span class="number">5</span>*<span class="number">2</span>; <span class="number">5</span>^<span class="number">2</span>; <span class="number">18</span>/<span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((3+5))</span><br><span class="line">$ <span class="built_in">echo</span> $(((3+5)*2))</span><br><span class="line">$ <span class="built_in">echo</span> `date +%Y%m%d`</span><br></pre></td></tr></table></figure><h1 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h1><p>注意表达式两侧的空格与转义字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ expr 6 + 3    <span class="comment"># 注意运算符两侧的空格</span></span><br><span class="line">$ expr 2 \* 3   <span class="comment"># 注意转义字符</span></span><br><span class="line">$ expr 14 % 9</span><br></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.cnblogs.com/kevingrace/p/6364307.html" target="_blank" rel="noopener">Linux 下计算命令：求和、求平均值、求最值 - 运维笔记</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络的二三事</title>
      <link href="/post/compter-of-networks/"/>
      <url>/post/compter-of-networks/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1garanctzpgj30dw09m0ti.jpg" alt=""></p><a id="more"></a><h1 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p>为了便于阅读，IPv4 采用了点分十进制，形如<code>192.168.1.2</code>，其二进制为<code>11000000 10101000 00000001 00000010</code>。<br>在 PHP 中的<code>ip2long()</code>与<code>long2ip()</code>函数可将点分十进制形式转换为整数形式，工作原理就是将二进制的值与权重相乘，如 <code>1 * 2^31 + 1 * 2^30 + 1 * 2^23 + 1 * 2^21 + 1 * 2^19 + 1 * 2^8 + 1 * 2^1 = 3232235778</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ip2int</span> <span class="params">(string $ip)</span> </span>&#123;</span><br><span class="line">    $bin = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (explode(<span class="string">'.'</span>, $ip) <span class="keyword">as</span> $dec) &#123;</span><br><span class="line">        $bin .= str_pad(decbin($dec), <span class="number">8</span>, <span class="number">0</span>, STR_PAD_LEFT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bindec($bin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> ip2int(<span class="string">'192.168.1.2'</span>);</span><br></pre></td></tr></table></figure><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>内网 IP 与公网 IP 转换</p><h1 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h1><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>IP to MAC</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h1 id="DDNS"><a href="#DDNS" class="headerlink" title="DDNS"></a>DDNS</h1><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p>发现家里路由器即使设置了 DHCP，但设备的 IP 仍几乎是固定的，比如树莓派的内网 IP 是<code>192.168.1.134</code>，一个月关机，重新打开时仍是<code>192.168.1.134</code>，经常观察，发现 IP 似乎并没有被重新分配，不知道这是否因为 DHCP 也有类似静态分配的机制。</p><h1 id="DDoS"><a href="#DDoS" class="headerlink" title="DDoS"></a>DDoS</h1><p>通常的DDoS攻击是攻击者控制大量僵尸电脑向目标主机发起洪流般的请求，直至目标无法响应；但新型的 DDoS 则是向目标主机注入恶意代码，当访问者访问网站时，也感染了这个病毒，然后所有受感染的访问者向目标主机发送大量请求，这被称为<a href="https://cybersecurity.att.com/blogs/labs-research/the-great-cannon-has-been-deployed-again" target="_blank" rel="noopener">大炮 DDoS 攻击</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机常用编码的二三事</title>
      <link href="/post/computer-encoding/"/>
      <url>/post/computer-encoding/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaklaex35kj30go08c0u7.jpg" alt=""></p><a id="more"></a><h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p>用1个字节表示所有字符，共可以表示2^8=256 个字符。用十六进制表示时只需2位即可表示所有ASCII字符。ASCII 表参见<a href="https://blog.shixinyu.space/ASCII/">此处</a></p><h1 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h1><p>在早期，以英语为主的国家使用 ASCII 是完全够用的，但随着计算机的普及，ASCII 对非英语国家就显得捉襟见肘了，比如中国的汉字就有数万个，而 ASCII 最多只能表示 256 个，因此其他国家对ASCII编码进行扩展，用于显示本国的语言，用2个字节来表示，共可以表示2^16=65536个字符。</p><ul><li>ANSI在简体中文代表GB2312，繁体中文代表BIG5，日文代表JIS</li><li>GB2312中共收录6763个汉字。中文通常有拼音和笔画两种排序方式，GB2312 中，3755 个一级中文汉字是按照拼音序进行编码的，而 3008 个二级汉字则是按部首笔画排列，因此并不能根据字符编码进行拼音排序，很多资料都说 GB2312(GBK) 是按照拼音排序的，实际上是不准确的，比如“赵钱孙李佘”排序的结果是“李钱孙赵佘”，显然不是我们想要的<sup>1</sup>。</li><li>GBK编码：对GB2312进行扩充，收录了一些偏僻字、古汉字等。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$name_list = [<span class="string">'赵'</span>,<span class="string">'钱'</span>,<span class="string">'孙'</span>,<span class="string">'李'</span>,<span class="string">'佘'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符转换为 GBK 编码</span></span><br><span class="line"><span class="keyword">foreach</span> ($name_list <span class="keyword">as</span> $key =&gt; $name)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'GBK'</span> !== <span class="string">'mb_detect_encoding($name)'</span>)&#123;</span><br><span class="line">        $outCharset[$key] = iconv($charset, <span class="string">'GBK'</span>, $name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按拼音排序</span></span><br><span class="line">sort($outCharset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还原 UTF-8 编码</span></span><br><span class="line"><span class="keyword">foreach</span> ($outCharset <span class="keyword">as</span> $key =&gt; $name)&#123;</span><br><span class="line">    $displayCharset[$key] = iconv(<span class="string">'GBK'</span>, <span class="string">'UTF-8'</span>, $name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_r($displayCharset);</span><br></pre></td></tr></table></figure><p>在 PHP 中，也可以通过 <code>(new \Collator(&#39;zh-CN&#39;))-&gt;asort($name_list);</code> 实现按拼音排序<sup>2</sup>，前提是你可以正常安装 intl，我通过<code>sudo pecl install intl</code>折腾了半天，总是报错<code>ERROR: /private/tmp/pear/temp/intl/configure --with-php-config=/usr/local/opt/php/bin/php-config --with-icu-dir=DEFAULT&#39; failed</code>，我用 pecl 好像就从来没有安装成功过东西:(</p><h1 id="Unicode-字符集"><a href="#Unicode-字符集" class="headerlink" title="Unicode 字符集"></a>Unicode 字符集</h1><p>由于各国都制定了自己的编码，导致了群雄割据的局面，很不利于传播与使用，就在此时，Unicode 站了出来，计划将世界上所有字符统一编码，用4个字节表示一个字符，如汉字的“好”Unicode 编码为<code>\u597d</code>，英文的字母“H”编码为<code>\u0048</code>。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaox3jjum2j307y0c7dh9.jpg" alt=""></p><p>这样，所有字符都可以以统一的标准进行管理和表示了，因此迅速得到了Adobe、Apple、HP、IBM、Microsoft 等巨头的支持，并风靡全球。目前最新的版本为 2019 年 5 月公布的 12.1.0，已经收录超过 13 万个字符。</p><p>我们可以在<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">字体编辑用中日韩汉字 Unicode 编码表</a>查看到 Unicode 的 16 进制表示。</p><h2 id="UTF-8-编码"><a href="#UTF-8-编码" class="headerlink" title="UTF-8 编码"></a>UTF-8 编码</h2><p>你以为了有了Unicode就世界和平了？Too young, too simple!</p><p>Unicode 虽然结束了各国编码混战的局面，但一个英文字符也要为了符合标准而强行用两个字节来表示，这就导致浪费了一个字节的空间，将 16 进制的 Unicode 码转换成二进制得：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">01011001 </span><span class="number">01111101</span> // 好</span><br><span class="line"><span class="symbol">00000000 </span><span class="number">01001000</span> // H</span><br></pre></td></tr></table></figure><p>英文字符在 Unicode 中的每个字符都要浪费 1 个字节的空间，这造成了硬盘存储于带宽流量的巨大浪费，因此，UTF-8 横空出世！</p><p>那么，UTF-8是如何平衡统一与空间呢？</p><ol><li>单字节的字符，字节的首位设为 0，对于英语文本，UTF-8 码只占用一个字节，与 ASCII 码完全相同（ASCII 最大值是<code>0111 1111</code>，因此首位必然是 0，也就与 ASCII 完全相同）</li><li>n 个字节的字符 (n&gt;1)，第一个字节的前 n 位设为 1（示例中的蓝色），第 n+1 位设为 0（示例中的黑色），后面字节的前两位都设为 10，这 n 个字节的其余空位填充该字符 Unicode 码，高位用 0 补足（示例中的红色）。</li></ol><table><thead><tr><th>字符所占字节数</th><th>字节码的有效位数</th><th>起始字节码</th><th>末位字节码</th><th>Byte 1</th><th>Byte 2</th><th>Byte 3</th><th>Byte 4</th></tr></thead><tbody><tr><td>1</td><td>7</td><td>U+0000</td><td>U+007F</td><td>0bbbbbbb</td><td></td><td></td><td></td></tr><tr><td>2</td><td>11</td><td>U+0080</td><td>U+07FF</td><td>110bbbbb</td><td>10bbbbbb</td><td></td><td></td></tr><tr><td>3</td><td>16</td><td>U+0800</td><td>U+FFFF</td><td>1110bbbb</td><td>10bbbbbb</td><td>10bbbbbb</td><td></td></tr><tr><td>4</td><td>21</td><td>U+10000</td><td>U+10FFFF</td><td>11110bbb</td><td>10bbbbbb</td><td>10bbbbbb</td><td>10bbbbbb</td></tr></tbody></table><p>明白了 UTF-8 的规则，我们再看下汉字“好”的 UTF8 表示：<font color="blue">111</font><font color="black">0</font><font color="red">0101</font> <font color="blue">10</font><font color="red">100101</font> <font color="blue">10</font><font color="red">111101</font></p><p>根据 Wikipedia 的<a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF8定义</a>，UTF-8(8-bit Unicode Transformation Format)是一种可容纳1,112,064个Unicode码位的变长字符编码，每个字符会占用 1~4 个字节。通过其定义，我们明白 UTF-8 就是 Unicode 的一种转换格式，通过标记位和 Unicode 码位将 Unicode 进行转换。</p><p>明白了 Unicode 与 UTF-8，就能理解为什么绝大多数的代码都是以 UTF-8 编码，因为 UTF-8 能兼容绝大多数的语言，通用性非常好，而代码绝大部分又是英文字符，因此达到了通用性与空间的绝妙平衡。如果要储存一本《红楼梦》，使用 Unicode 是更明智的选择，它不仅包含了绝大多数的汉字，也使得每个汉字以 2 字节存储，达到兼容与空间的平衡。</p><h3 id="UFT-8-with-BOM-和-UFT-8-without-BOM"><a href="#UFT-8-with-BOM-和-UFT-8-without-BOM" class="headerlink" title="UFT-8 with BOM 和 UFT-8 without BOM"></a>UFT-8 with BOM 和 UFT-8 without BOM</h3><p>UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM。所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯（顺便提一下：把带有 BOM 的小端序 UTF-16 称作「Unicode」而又不详细说明，这也是微软的习惯）。BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。「UTF-8」和「带 BOM 的 UTF-8」的区别就是有没有 BOM。即文件开头有没有 U+FEFF。</p><blockquote><p>来自<a href="https://www.zhihu.com/question/20167122/answer/14194448" target="_blank" rel="noopener">「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？ - 梁海的回答</a></p></blockquote><p>但是，文字有 GBK、UTF-8、UFT-16 等多种编码方式，当我们将编写好的文件存储并发送给其他人，计算机识别的都是二进制啊，它怎么知道哪些是标志位，哪些是字符位呢？因此，我们在编写文件时，需要将该文件的编码类型一同写入文件，这样在解读文件内容时，按照对应的规则解读就可以还原了，具体可阅读之前的文章<a href="https://blog.shixinyu.space/post/how-computers-store-and-interpret-files/">计算机是如何存储与解读各种文件的</a>。</p><h2 id="UTF8MB4"><a href="#UTF8MB4" class="headerlink" title="UTF8MB4"></a>UTF8MB4</h2><p>如今，Emoji 表情已经成为社交中最常用的符号😂，如果我们采用 UTF-8 存储 Emoji，则会导致溢出问题，因此 MySQL &lt;= 5.7 存储 Emoji 需手动将编码设置为 Emoji，MySQL 8.0+ 则默认为 UTF8MB4 编码。</p><p>我们可以在<a href="https://getemoji.com/" target="_blank" rel="noopener">这里</a>查询到常用的 Emoji 🤗</p><h1 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h1><p>URL 编码同样是为了将 URL 中的非 ASCII 字符转换为 ASCII 字符传输。其保留字符的百分号编码如下：</p><table><thead><tr><th><code></code></th><th><code>!</code></th><th><code>#</code></th><th><code>$</code></th><th><code>%</code></th><th><code>&amp;</code></th><th><code>&#39;</code></th><th><code>(</code></th><th><code>)</code></th><th><code>*</code></th><th><code>+</code></th><th><code>,</code></th><th><code>/</code></th><th><code>:</code></th><th><code>;</code></th><th><code>=</code></th><th><code>?</code></th><th><code>@</code></th><th><code>[</code></th><th><code>]</code></th></tr></thead><tbody><tr><td>%20</td><td>%21</td><td>%23</td><td>%24</td><td>%25</td><td>%26</td><td>%27</td><td>%28</td><td>%29</td><td>%2A</td><td>%2B</td><td>%2C</td><td>%2F</td><td>%3A</td><td>%3B</td><td>%3D</td><td>%3F</td><td>%40</td><td>%5B</td><td>%5D</td></tr></tbody></table><p>根据最新的RFC 3986标准，非 ASCII 字符建议先转换为 UTF-8 字节序列，然后对其字节值使用百分号编码。因此，汉字“好”的 UTF-8 编码为<code>E5A5BD</code>，URL 编码为<code>%E5%A5%BD</code>。</p><p>另外早期的 URL 编码规则会将空格编码为<code>+</code>，而现在会处理为<code>%20</code>，PHP 中则分别对应处理函数<code>urlencode()</code>与<code>rawurlencode()</code>。</p><p>关于 URL 编码的历史课查看阮一峰老师于十年前所写的文章<a href="https://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">关于 URL 编码</a></p><h1 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h1><p>顾名思义，Base64 是一种基于 64 个可打印字符（<code>A~Z</code>、<code>a~z</code>、<code>0~9</code>、<code>+</code>、<code>/</code>）来表示二进制数据的表示方法。由于2^6=64，所以每 6 个位为一组，对应某个可打印字符。完整的 Base64 定义可见 <a href="https://tools.ietf.org/html/rfc1424" target="_blank" rel="noopener">RFC 1421</a> 和 <a href="https://tools.ietf.org/html/rfc2045" target="_blank" rel="noopener">RFC 2045</a>。由于现在需要 6bit 表示原本用 8bit 表示的 1 个字节，因此编码后的数据比原始数据大 30%。</p><p>最初的电子邮件只能使用 ASCII 字符，因此 Base64 的发明就被用于将图片或非 ASCII 字符转换为 ASCII 字符。其字符列表如下：</p><table><thead><tr><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>16</td><td>Q</td><td>32</td><td>g</td><td>48</td><td>w</td></tr><tr><td>1</td><td>B</td><td>17</td><td>R</td><td>33</td><td>h</td><td>49</td><td>x</td></tr><tr><td>2</td><td>C</td><td>18</td><td>S</td><td>34</td><td>i</td><td>50</td><td>y</td></tr><tr><td>3</td><td>D</td><td>19</td><td>T</td><td>35</td><td>j</td><td>51</td><td>z</td></tr><tr><td>4</td><td>E</td><td>20</td><td>U</td><td>36</td><td>k</td><td>52</td><td>0</td></tr><tr><td>5</td><td>F</td><td>21</td><td>V</td><td>37</td><td>l</td><td>53</td><td>1</td></tr><tr><td>6</td><td>G</td><td>22</td><td>W</td><td>38</td><td>m</td><td>54</td><td>2</td></tr><tr><td>7</td><td>H</td><td>23</td><td>X</td><td>39</td><td>n</td><td>55</td><td>3</td></tr><tr><td>8</td><td>I</td><td>24</td><td>Y</td><td>40</td><td>o</td><td>56</td><td>4</td></tr><tr><td>9</td><td>J</td><td>25</td><td>Z</td><td>41</td><td>p</td><td>57</td><td>5</td></tr><tr><td>10</td><td>K</td><td>26</td><td>a</td><td>42</td><td>q</td><td>58</td><td>6</td></tr><tr><td>11</td><td>L</td><td>27</td><td>b</td><td>43</td><td>r</td><td>59</td><td>7</td></tr><tr><td>12</td><td>M</td><td>28</td><td>c</td><td>44</td><td>s</td><td>60</td><td>8</td></tr><tr><td>13</td><td>N</td><td>29</td><td>d</td><td>45</td><td>t</td><td>61</td><td>9</td></tr><tr><td>14</td><td>O</td><td>30</td><td>e</td><td>46</td><td>u</td><td>62</td><td>+</td></tr><tr><td>15</td><td>P</td><td>31</td><td>f</td><td>47</td><td>v</td><td>63</td><td>/</td></tr></tbody></table><h2 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h2><p>我们已经了解了 Base64 的编码规则，现在就来徒手编码字符<code>Man</code>。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gapdwcowuzj30z40a0q3i.jpg" alt=""></p><p>汉字本身可以有多种编码，比如 GB2312、UTF-8、GBK 等等，每一种编码的 Base64 对应值都不一样。我们以UTF-8编码的汉字“好”（其十六进制为<code>597D</code>）为例：<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gapec9ox9ej31kk09wgmi.jpg" alt=""></p><p>你可能会注意到，我们经常会在 Base64 编码中发现有<code>=</code>字符，比如<code>moky</code>的 Base64 编码为<code>bW9reQ==</code>，而<code>=</code>却没有出现在字符列表中，这是为什么呢？这是因为Base64末位的<code>=</code>仅仅是为了代表补足的字节数，每个<code>=</code>代表了 2bit。如果我们仅解码<code>bW9reQ</code>，同样能得到<code>moky</code>。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaqms5k2xoj30vc04r74m.jpg" alt=""></p><p>这手动编码还是太费劲了，我们还是用代码自动编码吧。由于非 ASCII 字符在不同的编码规则下结果不同，因此我们只编写 ASCII 字符的 Base64 编码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 字符转换为二进制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2bin</span><span class="params">($str)</span> </span>&#123;</span><br><span class="line">    $binary = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (str_split($str) <span class="keyword">as</span> $char) &#123;</span><br><span class="line">        <span class="comment">// 将字符转换为ASCII 码</span></span><br><span class="line">        $ascii_char = ord($char);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取字符的二进制表示</span></span><br><span class="line">        $bin = base_convert($ascii_char, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使二进制填充为 8 位表示</span></span><br><span class="line">        $binary .= str_pad($bin, <span class="number">8</span>, <span class="number">0</span>, STR_PAD_LEFT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $binary; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64 编码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64</span><span class="params">($str)</span> </span>&#123;</span><br><span class="line">    $base_chars = array_merge(</span><br><span class="line">        range(<span class="string">'A'</span>, <span class="string">'Z'</span>), </span><br><span class="line">        range(<span class="string">'a'</span>, <span class="string">'z'</span>), </span><br><span class="line">        range(<span class="number">0</span>, <span class="number">9</span>), </span><br><span class="line">        [<span class="string">'+'</span>, <span class="string">'/'</span>]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理字符两侧的空白字符</span></span><br><span class="line">    $str = trim($str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串的二进制值</span></span><br><span class="line">    $bin = str2bin($str);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将二进制按每 6 位分隔</span></span><br><span class="line">    $b64_bin = rtrim(chunk_split($bin, <span class="number">6</span>, <span class="string">','</span>), <span class="string">','</span>);</span><br><span class="line"></span><br><span class="line">    $output = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (explode(<span class="string">','</span>, $b64_bin) <span class="keyword">as</span> $b) &#123;</span><br><span class="line">        <span class="comment">// 判断末尾是否需要 = 补齐</span></span><br><span class="line">        <span class="keyword">if</span> (strlen($b) &lt; <span class="number">6</span>) &#123;</span><br><span class="line">            $suffix_repeat_times = (<span class="number">6</span> - strlen($b)) / <span class="number">2</span>;</span><br><span class="line">            $b = str_pad($b, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $suffix_repeat_times = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取索引</span></span><br><span class="line">        $index = base_convert($b, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 base64 字符</span></span><br><span class="line">        $output .= $base_chars[$index] . str_repeat(<span class="string">'='</span>, $suffix_repeat_times);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> b64(<span class="string">'moky'</span>); <span class="comment">// bW9reQ==</span></span><br></pre></td></tr></table></figure><p>Base64 解码自然就是编码的逆运算，在此不做赘述。</p><h2 id="Base64-有什么用？"><a href="#Base64-有什么用？" class="headerlink" title="Base64 有什么用？"></a>Base64 有什么用？</h2><p>经过Base64编码后的空间会增大 30%，我们为什么会这样做？我们用空间换取了什么？</p><ul><li>Base64 将 ASCII 不可见字符转换为可见字符，因此解决了早期电子邮件中的图片传输问题。</li><li>其次，Base64 能做简单的对称加密。</li><li>最后，通过 Base64 将所有非 ASCII 字符转换为 ASCII，便于计算机的统一传输处理。</li></ul><h2 id="base64-图片"><a href="#base64-图片" class="headerlink" title="base64 图片"></a>base64 图片</h2><p>以下是一张 5*5 像素的黑色图片的 Base64 编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAyMDJwMfAxcCbmFxc4BgQ4ANUwgCjUcG3a0DVQHBZF2TWJRnvFbbWr5028n1bzP/4mz2mehTAlZJanAyk/wBxWnJBUQkDA2MKkK1cXlIAYncA2SJFQEcB2XNA7HQIewOInQRhHwGrCQlyBrJvANkCyRmJQDMYXwDZOklI4ulIbKi9IMDj4urjoxBgZGJo7kHAuaSDktSKEhDtnF9QWZSZnlGi4AgMpVQFz7xkPR0FIwMjAwYGUJhDVH++AQ5LRjEOhFjKUwYG41ygoAZCLEuAgWH3NwYGwa0IMfWHQG/NZWA4EFCQWJQIdwDjN5biNGMjCJt7OwMD67T//z+HMzCwazIw/L3+///v7f///13GwMB8C6j3GwAfrGAmadjDTwAAAGxlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABIAAAAAQAAAEgAAAABAAKgAgAEAAAAAQAAAAWgAwAEAAAAAQAAAAUAAAAADJnIDgAAAAlwSFlzAAALEwAACxMBAJqcGAAAABVJREFUCB1jlJGRYUACTEhsEJNUPgAbeABexhoAlQAAAABJRU5ErkJggg==</span><br></pre></td></tr></table></figure><p>以下这张图片的十六进制内存地址表示。想必图片编码为 Base64 形式同字符相同，将二进制每 6 位为一组，用可见字符表示。但我现在读不懂内存地址😂，所以不知道从何处开始进行分组，如果起始位错误，那结果将引发雪崩效应。如果有大佬能指点一二，不胜感激。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaqc87r7m2j30u00w17ku.jpg" alt=""></p><h2 id="自定义编码"><a href="#自定义编码" class="headerlink" title="自定义编码"></a>自定义编码</h2><p>了解了 Base64 的原理后，我们完全可以自行定义一套编码规则，比如比特币的钱包地址就是中本聪采用 Base58 编码，其中字符去除了 <code>0</code> - <code>O</code>，<code>I</code> - <code>l</code> 等易混淆的字符，以及非字母数字字符<code>+</code>、<code>/</code>。</p><table><thead><tr><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>15</td><td>G</td><td>30</td><td>X</td><td>45</td><td>n</td></tr><tr><td>1</td><td>2</td><td>16</td><td>H</td><td>31</td><td>Y</td><td>46</td><td>o</td></tr><tr><td>2</td><td>3</td><td>17</td><td>J</td><td>32</td><td>Z</td><td>47</td><td>p</td></tr><tr><td>3</td><td>4</td><td>18</td><td>K</td><td>33</td><td>a</td><td>48</td><td>q</td></tr><tr><td>4</td><td>5</td><td>19</td><td>L</td><td>34</td><td>b</td><td>49</td><td>r</td></tr><tr><td>5</td><td>6</td><td>20</td><td>M</td><td>35</td><td>c</td><td>50</td><td>s</td></tr><tr><td>6</td><td>7</td><td>21</td><td>N</td><td>36</td><td>d</td><td>51</td><td>t</td></tr><tr><td>7</td><td>8</td><td>22</td><td>P</td><td>37</td><td>e</td><td>52</td><td>u</td></tr><tr><td>8</td><td>9</td><td>23</td><td>Q</td><td>38</td><td>f</td><td>53</td><td>v</td></tr><tr><td>9</td><td>A</td><td>24</td><td>R</td><td>39</td><td>g</td><td>54</td><td>w</td></tr><tr><td>10</td><td>B</td><td>25</td><td>S</td><td>40</td><td>h</td><td>55</td><td>x</td></tr><tr><td>11</td><td>C</td><td>26</td><td>T</td><td>41</td><td>i</td><td>56</td><td>y</td></tr><tr><td>12</td><td>D</td><td>27</td><td>U</td><td>42</td><td>j</td><td>57</td><td>z</td></tr><tr><td>13</td><td>E</td><td>28</td><td>V</td><td>43</td><td>k</td><td></td><td></td></tr><tr><td>14</td><td>F</td><td>29</td><td>W</td><td>44</td><td>m</td><td></td><td></td></tr></tbody></table><p>关于 Base64 编码可查看阮一峰于 2008 年所作文章<a href="https://www.ruanyifeng.com/blog/2008/06/base64.html" target="_blank" rel="noopener">Base64 笔记</a></p><h1 id="JSON编码"><a href="#JSON编码" class="headerlink" title="JSON编码"></a>JSON编码</h1><p>json 在计算机中应用广泛，相信很多读者对它都不陌生。<a href="https://www.json.org/" target="_blank" rel="noopener">JSON</a> 是 JavaScript Object Notation 的缩写，尽管 JSON 是 JavaScript 的一个子集，但 JSON 是独立于语言的 文本格式，并且采用了类似于 C 语言家族的一些习惯。JSON 被广泛应用于数据传输格式、配置文件等场景，其 MIME类型是<code>application/json</code>，文件扩展名是 <code>.json</code>。以下是一个简短的 JSON 示例，具体的 JSON 格式描述可以参考 <a href="https://www.ietf.org/rfc/rfc4627.txt" target="_blank" rel="noopener">RFC 4627</a>。需要注意一点的是，JSON 中的字符串引号<em>必须为双引号</em>，单引号是非法的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Hank"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">"shcool"</span>: [</span><br><span class="line">        <span class="string">"University of Oxford"</span>,</span><br><span class="line">        <span class="string">"Yale University"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PHP-中的-JSON"><a href="#PHP-中的-JSON" class="headerlink" title="PHP 中的 JSON"></a>PHP 中的 JSON</h2><h3 id="中文被编码问题"><a href="#中文被编码问题" class="headerlink" title="中文被编码问题"></a>中文被编码问题</h3><p>在 PHP &lt; 5.4的版本中，当进行<code>json_encode()</code>的数据有中文时，中文会被Unicode编码，所以需要在json编码前先urlencode，编码后再urldecode，以免中文被Unicode编码。在 PHP &gt;= 5.4的版本中，只需加入<code>JSON_UNESCAPED_UNICODE</code>这个参数，就无需urlencode了，如<code>json_encode($str, JSON_UNESCAPED_UNICODE)</code>。</p><h3 id="json-encode-浮点数精度丢失问题"><a href="#json-encode-浮点数精度丢失问题" class="headerlink" title="json_encode 浮点数精度丢失问题"></a>json_encode 浮点数精度丢失问题</h3><p>在 PHP &gt;= 7.1 的版本中，<code>json_encode(277.2)</code>的结果是<code>277.19999999999999</code>，即使最新发布的 PHP7.4 中仍存在同样的问题。</p><p>解决该问题的方式是修改 php.ini 中的<code>serialize_precision</code>参数，将默认值 <code>17</code> 修改为 <code>-1</code> 即可。</p><h2 id="轶事"><a href="#轶事" class="headerlink" title="轶事"></a>轶事</h2><p>由于创作者认为 JSON 已足够简洁，无需再进行优化，因此JSON没有版本号。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在很多命名中，数字都有其明确的含义，如 UTF-8 中的 8 表示该编码方式中，最短的文本只需 8 个比特位，Base64 中的 64 表示基于 64 个字符进行编码，而 SHA-256 中的 256 则表示 256 bit 参与散列运算，我们看到命名中的数字，应该有一定的敏锐性，也许这会让你有更好的理解，让你了解其本质时打开一扇新的大门，获取新的启发。</p><p>诸如 Base64 和 URL 编码，都是将非 ASCII 字符编码为 ASCII 字符处理，毕竟计算机能完美兼容 ASCII。世界上的字符形式有千千万，在计算机的世界只认 0 和 1，将非 ASCII 转换为 ASCII 统一处理，化繁为简，是一个不错的解决思路。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/d04e5d097d6e" target="_blank" rel="noopener">Python 中文排序</a></li><li><a href="https://segmentfault.com/q/1010000002727733" target="_blank" rel="noopener">php 数组如何按拼音顺序排序</a></li><li><a href="https://www.zhihu.com/question/23374078/answer/24385963" target="_blank" rel="noopener">Unicode 和 UTF-8 有什么区别？ - 邱昊宇的回答</a></li><li><a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode - 维基百科</a></li><li><a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">Base64 - 维基百科</a></li><li><a href="https://www.zhihu.com/question/36306744/answer/673975520" target="_blank" rel="noopener">为什么要使用base64编码，有哪些情景需求？ - Wang Kai的回答</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>英雄帖</title>
      <link href="/post/who-is-the-hero/"/>
      <url>/post/who-is-the-hero/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1gakcvr2ql3j30lk0e5dic.jpg" alt=""></p><center>召集一群技术热爱者，不断探索，不断前行。</center><a id="more"></a><h1 id="可能你在工作中面临着以下的问题："><a href="#可能你在工作中面临着以下的问题：" class="headerlink" title="可能你在工作中面临着以下的问题："></a>可能你在工作中面临着以下的问题：</h1><ol><li>工作内容只是盲人摸象，不清楚完整项目及背后意义，没有成就感</li><li>公司技术栈陈旧，没有机会更新技术能力</li><li>只清楚自己的一亩三分地，不清楚自动测试、发布、运维流程</li><li>只是将产品要求转换为代码，无产品思维</li><li>想学习新的技术，但苦于身边无人可以讨论，自己摸索又太慢</li></ol><h1 id="我们的目标是"><a href="#我们的目标是" class="headerlink" title="我们的目标是"></a>我们的目标是</h1><ol><li>采用尽可能新、尽可能广的技术，寻求最佳解决方案</li><li>深度参与整个项目，如立项、界面交互规划、产品功能定位、代码编写、自动化测试、发布运维、产品推广等全套流程</li><li>深入理解底层运行原理，剖析源码分享碰撞</li><li>没有 deadline，一切以产品为重。无论是呈现给用户的，还是呈现给开发者的，都表里如一。</li></ol><h1 id="产品方向"><a href="#产品方向" class="headerlink" title="产品方向"></a>产品方向</h1><p>无法转换为产品的技术是没有价值的。参考 <a href="https://xueyuanjun.com/books/laravel-project" target="_blank" rel="noopener">https://xueyuanjun.com/books/laravel-project</a></p><ol><li>视频信息聚合平台，如豆瓣，其中包含宣传片的播放功能</li><li>电子商城，如淘宝，其中包含库存管理，下单配送流程等</li></ol><h1 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h1><p>在这里，没有边界，只有想不到，没有做不到。同一个功能，会有多种后端语言的实现，如前端共用 Vue，后端分别通过 PHP、Python、Golang 实现，前端通过 Electron 实现跨平台等；</p><p>在这里，希望每个人不再管中窥豹，而是一览众山小，让曾经惧怕的东西了然于心，一切的编程方式都只是工具，而且知道如何善用这个工具。操千曲而后晓声，观千剑而后识器；</p><p>在这里，我们能了解到代码运行的本质，能够在思维碰撞中实现守、破、离；</p><p>在这里，我们将通过互助，让每个成员快速奔跑，产生核聚变的威力；</p><p>在这里，我们能提升英语能力，终身受益；</p><h1 id="口号"><a href="#口号" class="headerlink" title="口号"></a>口号</h1><p>Learn by doing!</p><h1 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h1><p>鉴于该计划的愿景，团队成员仅能容纳 5 人，成员需真正热爱编程，以编程为事业而非谋生。团队成员将以邀请制加入。</p><h1 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h1><p>项目运行期间产生的成本 AA 制分摊。目前，我有一台可映射公网的 NAS 和树莓派，NAS 可运行 Docker 和 Gitlab，初期可以在 NAS 上运行，后期如果需要 VPS，可以大家集资分摊成本。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gakcvcd65zj30bz0godhl.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RegExp 正则表达式</title>
      <link href="/post/RegExp%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/post/RegExp%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1gai7yun0ffj31d10u0n1m.jpg" alt=""></p><center>未来的编程能力会像今天的汽车驾驶能力和计算机使用能力一样普及。</center><a id="more"></a><h3 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h3><table><thead><tr><th>符号</th><th>说明</th><th>对应英语单词助记</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配<font color='red'>除</font>换行符意外的任意字符</td><td></td></tr><tr><td><code>\w</code></td><td>匹配字母、数字、下划线、汉字</td><td>word</td></tr><tr><td><code>\s</code></td><td>匹配任意的空白符，如<code>\n</code>、<code>\r</code>、<code>\t</code>等</td><td>space</td></tr><tr><td><code>\d</code></td><td>匹配数字</td><td>digital</td></tr><tr><td><code>\b</code></td><td>匹配单词的开始或者结束</td><td></td></tr><tr><td><code>^</code></td><td>匹配字符串的开始</td><td></td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td><td></td></tr></tbody></table><h3 id="常用限定符"><a href="#常用限定符" class="headerlink" title="常用限定符"></a>常用限定符</h3><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>*</code></td><td>&gt;=0 次</td></tr><tr><td><code>+</code></td><td>&gt;=1 次</td></tr><tr><td><code>?</code></td><td>0 or 1 次</td></tr><tr><td><code>{n}</code></td><td>n 次</td></tr><tr><td><code>{n,}</code></td><td>&gt;=n 次</td></tr><tr><td><code>{n, m}</code></td><td>n 到 m 次</td></tr></tbody></table><h3 id="懒惰限定符"><a href="#懒惰限定符" class="headerlink" title="懒惰限定符"></a>懒惰限定符</h3><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>*?</code></td><td>重复任意次，但尽可能少重复</td></tr><tr><td><code>+?</code></td><td>重复 &gt;=1 次，但尽可能少重复</td></tr><tr><td><code>??</code></td><td>重复 0 或 1 次，但尽可能少重复</td></tr><tr><td><code>{n,m}?</code></td><td>重复 n 到 m 次，但尽可能少重复</td></tr><tr><td><code>{n,}?</code></td><td>重复 n 次以上，但尽可能少重复</td></tr></tbody></table><p>以字符串<code>aabab</code>为例，在贪婪模式下，<code>a.*b</code>的匹配结果是<code>aabab</code>，而懒惰模式下<code>a.*?b</code>的结果则是<code>aab</code>和<code>ab</code></p><h3 id="常用反义词"><a href="#常用反义词" class="headerlink" title="常用反义词"></a>常用反义词</h3><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>\W</code></td><td>匹配任意非字母、数字、下划线、汉字的字符</td></tr><tr><td><code>\S</code></td><td>匹配任意非空白字符的字符</td></tr><tr><td><code>\D</code></td><td>匹配任意非数字的字符</td></tr><tr><td><code>\B</code></td><td>匹配非单词开头或结尾的位置</td></tr><tr><td><code>[^aeiou]</code></td><td>匹配除了 aeiou 这几个字母以外的任意字符</td></tr></tbody></table><h3 id="常用的模式修正符"><a href="#常用的模式修正符" class="headerlink" title="常用的模式修正符"></a>常用的模式修正符</h3><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>忽略大小写的匹配</td></tr><tr><td><code>g</code></td><td>全局匹配</td></tr><tr><td><code>m</code></td><td>将字符串视作多行，包含换行符仍能匹配</td></tr><tr><td><code>s</code></td><td>将字符串视为单行，换行符也作为普通字符处理</td></tr><tr><td><code>x</code></td><td>忽略模式中的空白</td></tr><tr><td><code>A</code></td><td>强制从目标字符串开头匹配</td></tr><tr><td><code>D</code></td><td>如果使用<code>$</code>限制结尾字符，则不允许结尾有换行</td></tr><tr><td><code>U</code></td><td>值匹配最近的一个字符串，不重复匹配</td></tr><tr><td><code>e</code></td><td>匹配函数<code>preg_replace()</code>使用，可以把匹配到的字符串当做正则表达式执行</td></tr></tbody></table><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>|</code></td><td>分支条件</td></tr><tr><td><code>[]</code></td><td>罗列所有需要匹配的字符。需要注意的是，在字母、数字间的中划线表示范围，如<code>[0-9]</code>、<code>[a-z]</code>、<code>[0-9A-Z]</code>，而且需要顺序的表示，如<code>[z-a]</code>无法匹配字符串<code>abced</code> 中的任何字符；如果中划线右侧无对应的字母或数字，则仅仅表示匹配中划线；在<code>[]</code>中的<code>^</code>表示不包含其中的所有字符，而非字符串的起始</td></tr><tr><td><code>()</code></td><td>对条件进行分组</td></tr></tbody></table><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p><code>(?=exp)</code> 也叫零宽度正预测先行断言，它<strong>断言自身出现的位置的<em>后面</em>能匹配表达式 exp</strong>。比如 \b\w+(?=ing\b)，匹配 以 ing 结尾的单词的前面部分 (除了 ing 以外的部分)，如查找 I’m singing while you’re dancing. 时，它会匹配 sing 和 danc。</p><p><code>(?&lt;=exp)</code> 也叫 零宽度正回顾后发断言，它<strong>断言自身出现的位置的<em>前面</em>能匹配表达式 exp</strong>。比如 (?&lt;=\bre)\w+\b 会匹配 以 re 开头的单词的后半部分 (除了 re 以外的部分)，例如在查找 reading a book 时，它匹配 ading。</p><h3 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h3><p>零宽度负预测先行断言 <code>(?!exp)</code>， 断言此位置的后面不能匹配表达式 exp。例如：<code>\d{3}(?!\d)</code> 匹配 三位数字，而且这三位数字的后面不能是数字； <code>\b((?!abc)\w)+\b</code> 匹配 不包含连续字符串 abc 的单词。</p><p>零宽度负回顾后发断言<code>(?&lt;!exp)</code>，用于断言此位置的前面不能匹配表达式 <code>exp：(?&lt;![a-z])\d{7}</code> 匹配 前面不是小写字母的七位数字。</p><p>一个更复杂的例子：<code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code> 匹配 不包含属性的简单 HTML 标签内里的内容。 <code>(?&lt;=&lt;(\w+)&gt;)</code> 指定了这样的 前缀：被尖括号括起来的单词 (比如可能是 <code>&lt;b&gt;</code>)，然后是<code>.*</code>(任意的字符串), 最后是一个 后缀 <code>(?=&lt;\/\1&gt;)</code>。注意后缀里的 <code>\/</code>，它用到了前面提过的字符转义；\1 则是一个反向引用，引用的正是 捕获的第一组，前面的 <code>(\w+)</code> 匹配的内容，这样如果前缀实际上是 <code>&lt;b&gt;</code> 的话，后缀就是 <code>&lt;/b&gt;</code> 了。整个表达式匹配的是 <code>&lt;b&gt;</code> 和 <code>&lt;/b&gt;</code> 之间的内容 (再次提醒，不包括前缀和后缀本身)。</p><h3 id="如何阅读正则表达式"><a href="#如何阅读正则表达式" class="headerlink" title="如何阅读正则表达式"></a>如何阅读正则表达式</h3><p>一个复杂的正则表达式是由简单的形式一点点组合而成，因此解读时也需要肢解后逐步理解。首先查找<code>|</code>判断拆分为多种情况，然后查找<code>()</code>再次细分，最后再根据最近原则判断限定修饰符的修饰范围，依次拆解后就会拨云见日了。同时，也可以借助<a href="https://regexper.com/" target="_blank" rel="noopener">可视化工具</a>来理解，如<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gai6f64qwyj31er0u0q8c.jpg" alt=""></p><h3 id="小感"><a href="#小感" class="headerlink" title="小感"></a>小感</h3><p>正则虽然灵活强大，但对人类不够友好，书写与阅读都比较麻烦，现在很多语言的库或者函数都覆盖了常见类型的验证，如 PHP 中的<a href="https://www.php.net/manual/zh/filter.filters.php" target="_blank" rel="noopener"><code>filter_var()</code></a>支持域名、邮箱、IP、MAC 地址、URL 等验证，我们应当优先考虑这种优雅可读性好的验证方式，仅在不得已或正则更加简洁清晰的场景下使用正则，切勿滥用！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://deerchao.cn/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式 30 分钟入门教程</a></li><li><a href="https://tool.oschina.net/regex" target="_blank" rel="noopener">在线正则表达式测试</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>想象力</title>
      <link href="/post/imagination/"/>
      <url>/post/imagination/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1gaf2od5nyij30to0euju7.jpg" alt=""></p><center>逻辑可以将我从 A 带到 B，但想象可以带我到任何地方。——爱因斯坦</center><a id="more"></a><p>为什么我们觉得小动物或者三岁左右的小孩很可爱？我认为是因为他们在这个年龄段有者天马行空的想象力，还没有被教育所束缚。当我们和一个三岁的小朋友对话时，他总会给你一些出乎意料的答案，这种出乎意料大多会让你感到惊喜。比如，我曾经问 5 岁的表弟，哪辆车是我们家的？他回答到“辣椒的颜色那辆”。</p><p>当我和小朋友聊天时，我突然意识到自己已经失去了他们这样的想象力，那我又是何时失去的呢？是<a href="https://www.bilibili.com/video/av71561435" target="_blank" rel="noopener">学习新的知识</a>忘记了想象吗？知识和想象力是一个零和游戏吗？</p><p>我想，逻辑丰富了人类的物质世界，而想象则丰富了人类的精神世界，二者并不矛盾，只是我们赶路太过匆忙，也要适时停下脚步，抬头看看深邃的星空。</p><p>《风》<br>风去哪里了？<br>风找小树跳舞去了！</p><p>《收玩具》<br>妈妈说一定要收玩具<br>可是我不能<br>我的小兔子<br>正在弹钢琴</p><p>《吃月亮》<br>我和妈妈在回家的路上，<br>看见了一个圆圆的月亮。<br>我问妈妈，<br>月亮为什么这么圆呢？<br>妈妈说，<br>因为十五快到啦！</p><p>圆圆的月亮，真好玩！<br>如果我把月亮咬一小口，<br>月亮会怎么样？<br>嗯，咬小小一口，<br>它应该就和一个苹果<br>被小老鼠啃了一口后一样吧！</p><p>那如果我咬一大口，<br>会变成什么呢？<br>我想会变成小月亮牙，<br>就像一只弯弯的小船！</p><p>如果我把那个小月亮牙也吃了，<br>会怎么样呢？<br>月亮没了！<br>你猜！<br>它会在我的肚子里？<br>还是梦里？</p><p>《大大的天》<br>天，好大好大<br>连到了火车站<br>又连到了火车去的每一个地方。<br>天，好大好大<br>如果在上面散步<br>要散<br>好久好久呢！</p><blockquote><p>以上内容来自<a href="https://www.zhihu.com/question/308829198/answer/670941422" target="_blank" rel="noopener">小笼包马迷</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你的身份证号码都包含了哪些信息？</title>
      <link href="/post/id-number-infos/"/>
      <url>/post/id-number-infos/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1gaa6v59h4pj319s0tknj1.jpg" alt=""></p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1gaa6szfzr9j30qo0h0438.jpg" alt=""></p><p>每位合法中国公民都会获得由政府机关颁发的如图身份证（多年前 P 的太渣了，凑合看吧），这 18 位的数字每位都有自己的含义，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaa9hvxjhzj30dw07ft9b.jpg" alt=""></p><p>其中，第 17 位是按照户口登记顺序，男性 13579，女性 24680，以保证同一地区的同年同月同日出生的人拥有唯一身份证号码（哦吼？看了一眼我身份证的第 17 位，好像发现了点什么🤭)。如果仅靠第 17 位来保证性别的同时又保证唯一，那单一性别的极端情况的容量只有 5，像最近的<a href="https://weibo.com/2286908003/Ia5OnnnQe" target="_blank" rel="noopener">国庆四胞胎</a>，假设四胞胎在极端情况下都是相同性别，那同地区同一天出生的其他人只有一个名额了，所以可能同一派出所会有多个代码。</p><p>第 18 位则是前 17 位的校验和，通过这一位，就能初步校验出身份证号码是否合法，在大多数情况下能发现填写错误，我们以<code>11010519491231002X</code>为例，讲解其具体的校验规则：</p><p>1、 前 17 位每位都对应一个权重值，将每位的身份证号码与权重值相乘，再求前 17 位的和 <code>7*1 + 9*1 ... 4*0 + 2*0</code>，结果为 167</p><table><thead><tr><th align="center">权重</th><th align="center">7</th><th align="center">9</th><th align="center">10</th><th align="center">5</th><th align="center">8</th><th align="center">4</th><th align="center">2</th><th align="center">1</th><th align="center">6</th><th align="center">3</th><th align="center">7</th><th align="center">9</th><th align="center">10</th><th align="center">5</th><th align="center">8</th><th align="center">4</th><th align="center">2</th></tr></thead><tbody><tr><td align="center">号码</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">9</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>2、 将上一步的计算结果 167 取 11 的模，得 2</p><blockquote><p>为什么要取 11 的模呢？这是因为 11 是素数，而素数是只能被 1 和其本身整除的数，因此能在很大程度上保证取到余数，也保证了在大多数输入错误的情况下能检测到。</p></blockquote><p>3、 余数对应校验位的值如下表，对照可得 X，正好是末位值，因此判定为符合规则</p><table><thead><tr><th align="center">余数</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">校验和</td><td align="center">1</td><td align="center">0</td><td align="center">X</td><td align="center">9</td><td align="center">8</td><td align="center">7</td><td align="center">6</td><td align="center">5</td><td align="center">4</td><td align="center">3</td></tr></tbody></table><p>了解了规则，我们就可以写出身份证合法验证的代码了</p><blockquote><p>以下代码是一个简单的身份证号码合法校验，结果不一定准确，主要由于前 6 位是由民政部划分的<a href="http://www.mca.gov.cn/article/sj/xzqh/" target="_blank" rel="noopener">行政区划码</a>，部分行政区域会发生变化，经民政部的批准后会在其网页进行公示，因此同一地理位置的区域划分码是可能发生变化的，比如最近的温州龙港镇撤镇设市变更为龙港市，其区划码也随之由<code>330327</code>变化为<code>330383</code>，因此<br>龙港镇居民区划码是<code>330327</code>，龙港市的新生儿区划码就是<code>330383</code>，都是合法区划码。区划码的验证要考虑该地区的历史区划码。</p></blockquote><p>PHP 版：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验身份证号码是否非法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params</span> string $id_number</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_id_number</span><span class="params">($id_number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前 17 位的权重值</span></span><br><span class="line">    define(<span class="string">'WEIGHT'</span>, [<span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 余数对应的校验和</span></span><br><span class="line">    define(<span class="string">'MOD_MAP'</span>, [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'X'</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 输入参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">18</span> !== strlen($id_number)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidArgumentException(<span class="string">'check_id_number function only accepts 18 characters. Input was:'</span> . $id_number);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (</span><br><span class="line">            ! is_numeric(substr($id_number, <span class="number">0</span>, <span class="number">17</span>)) ||                                      <span class="comment">// 验证前 17 位是纯数字</span></span><br><span class="line">            (! is_numeric($id_number[<span class="number">17</span>]) &amp;&amp; ! in_array($id_number[<span class="number">17</span>], [<span class="string">'x'</span>, <span class="string">'X'</span>])) ||     <span class="comment">// 验证末位是数字或者大小写 x</span></span><br><span class="line">            ! check_birthday(substr($id_number, <span class="number">6</span>, <span class="number">8</span>))                                      <span class="comment">// 验证生日合法</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidArgumentException($id_number . <span class="string">' is an invalid ID number!'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若包含 X，则统一转换为大写</span></span><br><span class="line">        <span class="keyword">if</span> (!is_numeric($id_number)) &#123;</span><br><span class="line">            $id_number = strtoupper($id_number);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截取前 17 位并转为数组</span></span><br><span class="line">        $check_code_array = str_split(substr($id_number, <span class="number">0</span>, <span class="number">17</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算前 17 位的校验权重</span></span><br><span class="line">        $sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">17</span>; $i++) &#123;</span><br><span class="line">            $sum += $check_code_array[$i] * WEIGHT[$i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对校验权重取 11 的模并获取末位校验值比对</span></span><br><span class="line">        <span class="keyword">return</span> MOD_MAP[$sum % <span class="number">11</span>] == $id_number[<span class="number">17</span>];</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidArgumentException $e) &#123;</span><br><span class="line">        <span class="keyword">return</span> $e-&gt;getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证身份证生日</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_birthday</span><span class="params">($birthday)</span> </span>&#123;</span><br><span class="line">    $year  = substr($birthday, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    $month = substr($birthday, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    $day   = substr($birthday, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($birthday &gt; date(<span class="string">'Ymd'</span>) || $birthday &lt; <span class="string">'19000101'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// checkdate() 已包含闰年验证</span></span><br><span class="line">    <span class="keyword">return</span> checkdate($month, $day, $year);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(check_id_number(<span class="string">'11010519491231002X'</span>));</span><br></pre></td></tr></table></figure><p>Python 版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">校验身份证号码是否非法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_id_number</span><span class="params">(id_number)</span>:</span></span><br><span class="line">    weight = (<span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">    mod_map = (<span class="number">1</span>, <span class="number">0</span>, <span class="string">'X'</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 参数校验</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">18</span> != len(id_number):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'check_id_number function only accepts 18 characters. Input was:'</span> + id_number)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> id_number[:<span class="number">17</span>].isdigit() <span class="keyword">or</span> \</span><br><span class="line">                (<span class="keyword">not</span> id_number[<span class="number">17</span>].isdigit() <span class="keyword">and</span> id_number[<span class="number">17</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'x'</span>, <span class="string">'X'</span>]) <span class="keyword">or</span> \</span><br><span class="line">                <span class="keyword">not</span> check_birthday(id_number[<span class="number">6</span>:<span class="number">14</span>]):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(id_number + <span class="string">' is an invalid ID number!'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 包含 X 时转换为大写</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> id_number.isdigit():</span><br><span class="line">            id_number = id_number.upper()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算校验和</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> wgt, num <span class="keyword">in</span> zip(weight, id_number[:<span class="number">17</span>]):</span><br><span class="line">            sum += wgt * int(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str(mod_map[sum % <span class="number">11</span>]) == id_number[<span class="number">17</span>]</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_birthday</span><span class="params">(birthday)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 验证生日是否合法，包含闰年验证</span></span><br><span class="line">        datetime.strptime(birthday, <span class="string">'%Y%m%d'</span>).date()</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 验证生日是否在指定范围</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'19000101'</span> &lt; birthday &lt; date.today().strftime(<span class="string">'%Y%m%d'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(check_id_number(<span class="string">'11010519491231002X'</span>))</span><br></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://www.mca.gov.cn/article/sj/xzqh" target="_blank" rel="noopener">行政区划代码 - 民政部</a></li><li><a href="http://www.mca.gov.cn/article/sj/xzqh//1980/?" target="_blank" rel="noopener">历史行政区划码 - 民政部</a></li><li><a href="http://www.mca.gov.cn/article/sj/xzqh/1980/201507/20150715854848.shtml" target="_blank" rel="noopener">民政统计代码编制规则 - 民政部</a></li><li><a href="https://zh.wikipedia.org/zh-cn/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%88%92%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">中华人民共和国行政区划代码 - 维基百科</a></li><li><a href="https://zh.wikipedia.org/zh-cn/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%85%AC%E6%B0%91%E8%BA%AB%E4%BB%BD%E5%8F%B7%E7%A0%81" target="_blank" rel="noopener">中华人民共和国公民身份号码 - 维基百科</a></li><li><a href="https://www.bilibili.com/video/av79769795" target="_blank" rel="noopener">如何成为一个有身份的人 - 回形针Paperclip</a></li><li><a href="https://www.ithome.com/html/it/277688.htm" target="_blank" rel="noopener">揭秘：你的身份证上究竟包含多少信息？ - IT之家</a></li><li><a href="https://www.zhihu.com/question/68016278/answer/705098217" target="_blank" rel="noopener">怎样确定身份证第1516位的派出所代码？有没有各地列表? - JVKBRS的回答</a></li><li><a href="https://www.zhihu.com/question/20205184/answer/223049155" target="_blank" rel="noopener">身份证号的末位校验码算法最后一步模11是基于什么考虑？ - 刘巍然-学酥的回答</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>六岁小朋友也能懂的计算机术语</title>
      <link href="/post/computer-terms/"/>
      <url>/post/computer-terms/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga92quaubij30i208jdgg.jpg" alt=""></p><center>如果你不能向一个六岁小孩解释某件事，那么你自己就没有真正理解它。—— 爱因斯坦</center><a id="more"></a><blockquote><p>中午休息时，突然想到上午的一个 https 连接问题，类比了拨打电话的过程，于是便有了本文。</p></blockquote><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>你的手机通讯录就相当于 DNS 服务器，你不可能记得住每个人的电话号码，所以手机通讯录存储了小红 138xxx，老李 176xxx，小张 155xxx等，当你要拨打一个电话时，实际拨打的都是电话号码。</p><p>http 也一样，你打开百度(<a href="http://www.baidu.com)的时候，http" target="_blank" rel="noopener">www.baidu.com)的时候，http</a> 也会去 DNS 服务器查询 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 对应的 IP 地址，当你最后请求时，发送的是 IP 地址。</p><p>如果你知道一个人的电话号码，这样就不用去翻通讯录，直接拨打会快很多，同样，直接用 IP 访问会比域名快一些，只不过网络很快的情况下感觉不是那么明显。</p><h1 id="DNS-污染"><a href="#DNS-污染" class="headerlink" title="DNS 污染"></a>DNS 污染</h1><p>有人恶意修改了你的通讯录，把小红的电话号码改成了老李的，老李的电话号码改成了小张的，这样你想给小红打电话时，实际是在给老李打电话。</p><p>在现实生活中，你在公司打开淘宝时，最终打开的页面可能是公司【不要上班摸鱼】的警告页。</p><h1 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h1><p>在正常情况下，胡歌的电话能正常接听她妈的电话，但有一天电话号码被泄露在了网上，就开始有人不停的给他打电话，而他妈在这个过程中则无法拨入，后来知道的人越来越多了，手机充电都来不及，手机直接死机了。在这种情况下，胡歌的电话被骚扰电话一直占线，真正想给他打电话的人却一直打不进去，一直到最后的手机死机。</p><p>服务器在受到 DDoS 攻击时，就是恶意请求将资源耗尽，导致正常请求无法接入，直至最终的服务器宕机。每年的双十一和春节的 12306 抢票都在经历着大规模的 “DDoS 攻击”，心疼累垮的服务器一秒钟。</p><h1 id="HTTP-通信过程"><a href="#HTTP-通信过程" class="headerlink" title="HTTP 通信过程"></a>HTTP 通信过程</h1><p>HTTP 通信过程非常类似于拨打电话，快递小哥给你打电话让你下楼取快递，电话号码即为 HTTP 的 IP 地址，拨打电话即为请求建立 HTTP 连接。首先，他要解锁手机才能拨打电话（401，请求未被认证），如果解锁时密码输入错误（403，请求认证失败），或者电话号码时只输入了十位（400，错误的请求无法被理解）小哥都无法拨通电话，他修正了这些错误后，终于拨下了你的电话。接下来，快递小哥的电话可能会被接听(200，成功)，也可能会得到空号或者不在服务区(404，资源不存在)，正在通话中(100，请求已接收，待处理)，变更了号码并告知新号码(301，永久重定向)，未变更（304）则等待接听，对方拒接或无人接听(500，服务内部错误)，已停机或已关机(503，服务不可用)等，如果对方长时间无人接听，快递小哥等的不耐烦了，挂断了电话(499)。</p><blockquote><p>需要注意的是，499 状态码是 Nginx 定义的扩展状态码，<a href="https://httpstatuses.com/499" target="_blank" rel="noopener">非标准状态码</a></p></blockquote><p>电话拨通后，通话的内容即为 HTTP 报文内容，虽然电话允许通话双方同时说话，但这样的结果是谁也没有明白对方的意思，所以我们通常都是一方在讲，另一方在听，HTTP 也是如此。电话接通后，快递小哥说“下楼来取下快递”，这相当于 HTTP 请求方发送了请求内容，然后你说“好的，我马上下来”，这就相当于 HTTP 的请求消息得到了响应，当你们两个通话结束后，就可以由任一方挂断电话，这就是关闭 HTTP 连接了（在 TCP 连接中，先关闭连接一方会进入TIME_WAIT，被动关闭连接的另一方会进入 CLOSE_WAIT，当确认对方关闭连接后，才会彻底关闭，这也就是为什么 TCP 是可靠连接）。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>如果司令部给前方战士下达指令，肯定不能直接在电话里说“明天中午 12 点发起总攻”，这样有人恶意监听电话后，不仅作战计划被泄露，也可能会被篡改为“暂时按兵不动”，因此，这是非常不安全的。如果他们提前协商好了火星语，电话里叽里咕噜说了一通，监听的人不知道说的什么，等他们破译结果出来时，已经被团灭了。在 HTTPS 中，通过 HTTP + TLS 将原本明文传输的内容进行加密，以保证通信双方内容的安全性。</p><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>在美苏冷战时期，东德与西德无法直接通信，此时你需要先把电话打到中立国瑞士的一个朋友那里，你把你想说的话经瑞士的朋友转述告诉对方，瑞士的朋友在这里就充当了代理的角色。在这种情况下的代理，你不仅可以突破无法访问的限制，也可以隐藏自己的身份，让西德的接听方以为是瑞士的人在和她交谈。</p><p>另一个代理的例子是，假如你想从北京邮寄一份文件给深圳的朋友，你可以选择携带文件乘坐火车或者飞机直接送到深圳，同样可以托管给快递，让快递小哥把文件带给你朋友，这里的快递小哥就是扮演了代理的角色。在这种情况下，代理可以监管包裹，禁止邮递违禁危险物品，但同样引入代理可能导致包裹的遗失损毁，快递小哥生病导致延迟到达的问题。</p><h1 id="正向代理-VS-反向代理"><a href="#正向代理-VS-反向代理" class="headerlink" title="正向代理 VS 反向代理"></a>正向代理 VS 反向代理</h1><p>仍以冷战期间的通话为例，西德的接听方不知道电话的内容是东德的朋友打来的，以为是瑞士的朋友打的，这就是正向代理；如果东德的朋友不知道通话的内容是西德的朋友说的，这就是反向代理。简而言之，正向代理隐藏拨打方(客户端)，反向代理隐藏接听方(服务端)。</p><blockquote><p>来自<a href="https://www.zhihu.com/question/24723688/answer/128105528" target="_blank" rel="noopener">反向代理为何叫反向代理？ - 刘志军的回答</a></p></blockquote><h1 id="静态编译型语言-VS-动态解释型语言"><a href="#静态编译型语言-VS-动态解释型语言" class="headerlink" title="静态编译型语言 VS 动态解释型语言"></a>静态编译型语言 VS 动态解释型语言</h1><p>静态编译型语言就像是做好了一桌子菜再开吃，动态解释型语言就像是吃火锅，边做边吃。</p><blockquote><p>来自 <a href="https://www.zhihu.com/question/21486706/answer/32975999" target="_blank" rel="noopener">程序的编译与解释有什么区别？ - 知乎</a></p></blockquote><h1 id="I-O-多路复用模型"><a href="#I-O-多路复用模型" class="headerlink" title="I/O 多路复用模型"></a>I/O 多路复用模型</h1><p>假设你是一个老师，让 30 个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ol><li>第一种选择：按顺序逐个检查，先检查 A，然后是 B，之后是 C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理 socket，根本不具有并发能力。</li><li>第二种选择：你创建 30 个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</li><li>第三种选择，你站在讲台上等，谁解答完谁举手。这时 C、D 举手，表示他们解答问题完毕，你下去依次检查 C、D 的答案，然后继续回到讲台上等。此时 E、A 又举手，然后去处理 E 和 A。。。 这种就是 IO 复用模型，Linux 下的 select、poll 和 epoll 就是干这个的。将用户 socket 对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些 socket 上有消息到达，这样就避免了大量的无用操作。此时的 socket 应该采用非阻塞模式。</li></ol><blockquote><p>来自<a href="https://www.zhihu.com/question/28594409/answer/52835876" target="_blank" rel="noopener">I/O多路复用技术（multiplexing）是什么？ - 柴小喵的回答</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机是如何存储与解读各种文件的</title>
      <link href="/post/how-computers-store-and-interpret-files/"/>
      <url>/post/how-computers-store-and-interpret-files/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1ga8wegt7vsj30qo0gotbt.jpg" alt=""></p><a id="more"></a><blockquote><p>本文灵感来自于<a href="https://www.zhihu.com/question/19971994/answer/570107874" target="_blank" rel="noopener">文本文件和二进制文件的区别？请举例说明 - 机事本的回答</a></p></blockquote><p>在计算机的世界里，无论是文本、音频、视频、图片，还是压缩文件，一切都是 <code>0</code> 和 <code>1</code>，不同的文件类型通过内容前缀标识，而不是通过文件名后缀来标识，后缀只是为了让人类读懂这个文件应该用什么程序来正确的解码。如果用记事本打开一个照片，就会得到乱码，如果记事本的编码设置与文件不同，同样会得到乱码，如同鸡同鸭讲。文本编码可以理解为是不同的字典，我们通过不同的字典来编/解码人类语言与计算机语言。我们应该怎么查看计算机内部的存储内容呢？在 VS Code 安装<a href="https://marketplace.visualstudio.com/items?itemName=slevesque.vscode-hexdump" target="_blank" rel="noopener">hexdump</a>就可以查看各种文件类型的二进制内容了。</p><h1 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8wyvt4n6j31e007mabj.jpg" alt=""></p><p>我们通过ASCII对照表可以发现，UTF8 下的中文，每个汉字占用了 3 个字节：<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8x0ormj9j30qg0g876k.jpg" alt=""></p><p>每个 UTF8 下的 emoji 字符占用了 4 个字节<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8x1gpflfj30no0ii0v0.jpg" alt=""></p><h1 id="CSS文件"><a href="#CSS文件" class="headerlink" title="CSS文件"></a>CSS文件</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8w3uv84xj31760e4af5.jpg" alt=""></p><h1 id="GIF文件"><a href="#GIF文件" class="headerlink" title="GIF文件"></a>GIF文件</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8w44b4npj317a0g8tdw.jpg" alt=""></p><h1 id="JPG文件"><a href="#JPG文件" class="headerlink" title="JPG文件"></a>JPG文件</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8w4c030bj316u0bwjv2.jpg" alt=""></p><h1 id="PS-处理过的-JPG-文件"><a href="#PS-处理过的-JPG-文件" class="headerlink" title="PS 处理过的 JPG 文件"></a>PS 处理过的 JPG 文件</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8w6red6zj318u0nsn42.jpg" alt=""></p><h1 id="PNG-文件"><a href="#PNG-文件" class="headerlink" title="PNG 文件"></a>PNG 文件</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8w6ia9mpj31600fyq8f.jpg" alt=""></p><h1 id="MP3-文件"><a href="#MP3-文件" class="headerlink" title="MP3 文件"></a>MP3 文件</h1><p>普通的 mp3 太大了，就拿李荣浩的《贝贝》做分析了<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8w4jw2l4j316k0jq0xf.jpg" alt=""></p><blockquote><p>关于 MP3 的文件结构可以查看这篇文章 <a href="https://blog.csdn.net/u010650845/article/details/53520426" target="_blank" rel="noopener">MP3 文件结构解析 (超详细)</a></p></blockquote><h1 id="MP4-文件"><a href="#MP4-文件" class="headerlink" title="MP4 文件"></a>MP4 文件</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8w5gl238j31820de0wa.jpg" alt=""></p><blockquote><p>关于 MP4 的文件接口可以查看<a href="https://www.file-recovery.com/mp4-signature-format.htm" target="_blank" rel="noopener">MP4 Signature Format: Documentation &amp; Recovery Example</a></p></blockquote><h1 id="PDF文件"><a href="#PDF文件" class="headerlink" title="PDF文件"></a>PDF文件</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8w67z72oj317u0cugq7.jpg" alt=""></p><h1 id="ZIP文件"><a href="#ZIP文件" class="headerlink" title="ZIP文件"></a>ZIP文件</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8wcy6xluj316i0gm0yl.jpg" alt=""></p><p>通过验证可知，文件类型是在文件开头字符中标明的（Linux 中的<code>file</code>命令即为此方式判断），因此，在开发过程中，我们不能仅以后缀来判断文件的类型，这会存在很大的安全隐患。</p><h1 id="意外发现"><a href="#意外发现" class="headerlink" title="意外发现"></a>意外发现</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga8vtlx3q6j30ln09ltb1.jpg" alt=""><br>原贴地址：<a href="https://www.v2ex.com/t/388152" target="_blank" rel="noopener">https://www.v2ex.com/t/388152</a></p><p>经过验证，果然是这样的，大家不用扒我的博客图片了，这是图床开发者自己的一个公共账号，也是符合上述规则的，最终会指向一个僵尸账号，分析关注与被关注以及位置信息，再与开发者的部分信息进行印证，可以得到很大概率该账号由图床开发者所有。</p><p>写到这里，突然发现以后可以写个 Python 脚本，抓取 V2EX，知乎，贴吧等平台高点击率的帖子，通常这样的帖子会有很大的价值，节省自己的阅读时间。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>战争对科技的影响</title>
      <link href="/post/war-effect-for-tech/"/>
      <url>/post/war-effect-for-tech/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1ga35rsass8j30sg0ixq5f.jpg" alt=""></p><a id="more"></a><p>战争催生了大量的科技，一方面战争在摧毁人们的生活，另一方面战争又对未来产生了深远的影响。</p><p>在战争中，平民得以获得快速上升的阶层通道，大量的人才得以施展抱负，参战国全力推进技术的发展。二战中涌现了大量的人才，各项技术迅猛发展。诸如原子能、计算机、密码学、航天航空等。</p><p>美苏冷战期间，两国疯狂点科技树，抢夺太空资源，研发重型武器。既对各国安全造成恐慌，也加速了相关领域的探索进程。</p><p>战争后新的世界格局，也导致了部分地区的冲突不断（恐怖主义盛行），有的国家经济快速复苏崛起（中日），有的国家霸位易主（英国）。</p><p>几乎我们现在的每一项重要技术都是“受益”于战争——计算机是为了在战争中快速破译密码，手机雏形最初用于协调军事行动，互联网用于美苏冷战的对抗，GPS 更重要的是精准制导。但这些仅仅是战争的副产物，战争所给人们造成的创伤是难以弥补的，南京大屠杀 30 万的冤魂，奥斯维辛集中营数百万的亡魂仍在警醒着世人。和平诞生科学，战争推动技术。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/qan1PVOgSc2qdZqlKALxDw" target="_blank" rel="noopener">小火箭 | 全球核武器年度报告2019年最终版</a></li><li><a href="https://mp.weixin.qq.com/s/vV4Wk3xNw-7j27a4DAAXfw" target="_blank" rel="noopener">小火箭 | 盘点2019年人类航天的20个大事件</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vim 笔记</title>
      <link href="/post/vim-notes/"/>
      <url>/post/vim-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1ga1uo5tskuj30m80ciaay.jpg" alt=""></p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1ubf7k4pj30sg0k30zg.jpg" alt=""></p><blockquote><ul><li>配置文件 <code>$vim ~/.vimrc</code></li><li>在编辑配置文件前，将原有文件进行备份总是一个好的习惯。比如<code>cp .vimrc .vimrc.bak</code></li><li>另外，在编辑配置文件时，将改动添加注释也是一个很好的习惯，帮未来的自己一个忙吧。</li></ul></blockquote><hr><h1 id="一、编辑"><a href="#一、编辑" class="headerlink" title="一、编辑"></a>一、编辑</h1><table><thead><tr><th align="center">快捷键</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>0</code></td><td align="center">行首</td></tr><tr><td align="center"><code>$</code></td><td align="center">行尾</td></tr><tr><td align="center"><code>^</code></td><td align="center">非空行首</td></tr><tr><td align="center"><code>g_</code></td><td align="center">非空行末</td></tr><tr><td align="center"><code>w</code></td><td align="center">下个词头</td></tr><tr><td align="center"><code>b</code></td><td align="center">上个词头</td></tr><tr><td align="center"><code>e</code></td><td align="center">下个词尾</td></tr><tr><td align="center"><code>x</code></td><td align="center">向右删除</td></tr><tr><td align="center"><code>X</code></td><td align="center">向左删除</td></tr><tr><td align="center"><code>%</code></td><td align="center">括号匹配</td></tr><tr><td align="center"><code>J</code></td><td align="center">合并两行</td></tr><tr><td align="center"><code>H</code></td><td align="center">屏幕顶行</td></tr><tr><td align="center"><code>M</code></td><td align="center">屏幕中间行</td></tr><tr><td align="center"><code>L</code></td><td align="center">屏幕底行</td></tr><tr><td align="center"><code>zz</code></td><td align="center">当前行置于屏幕中央</td></tr><tr><td align="center"><code>zt</code></td><td align="center">顶部</td></tr><tr><td align="center"><code>zb</code></td><td align="center">底部</td></tr><tr><td align="center"><code>gg</code></td><td align="center">跳转到页首</td></tr><tr><td align="center"><code>G</code></td><td align="center">跳转到页尾</td></tr><tr><td align="center"><code>nG</code></td><td align="center">跳转到指定行</td></tr><tr><td align="center"><code>yy</code></td><td align="center">拷贝一行</td></tr><tr><td align="center"><code>ye</code></td><td align="center">从当前位置拷贝到词尾</td></tr><tr><td align="center"><code>ge</code></td><td align="center">移至前一个单词的最后一个字符</td></tr><tr><td align="center"><code>u</code></td><td align="center">撤销上一步操作</td></tr><tr><td align="center"><code>ctrl-r</code></td><td align="center">恢复上一步操作（u的反命令）</td></tr><tr><td align="center"><code>~</code></td><td align="center">转换大小写</td></tr><tr><td align="center"><code>dNw</code></td><td align="center">删除N个词到下个词头</td></tr><tr><td align="center"><code>dNe</code></td><td align="center">删除N个词到下个词尾</td></tr><tr><td align="center"><code>r</code></td><td align="center">替换光标处字符，Nr表示将多个字符替换为即将输入到字符</td></tr><tr><td align="center"><code>R</code></td><td align="center">从当前光标所在处开始替换</td></tr><tr><td align="center"><code>xp</code></td><td align="center">交换左右两个字符</td></tr><tr><td align="center"><code>ddp</code></td><td align="center">交换上下两行</td></tr><tr><td align="center"><code>yNw</code></td><td align="center">复制N个词</td></tr><tr><td align="center"><code>Nyy</code></td><td align="center">复制N行</td></tr><tr><td align="center"><code>y\$</code></td><td align="center">复制到行尾</td></tr><tr><td align="center"><code>s</code></td><td align="center">删除光标处字符并插入</td></tr><tr><td align="center"><code>S</code></td><td align="center">删除光标所在行并插入（同C，cc，c$）</td></tr><tr><td align="center"><code>db</code></td><td align="center">删除前边的字符</td></tr><tr><td align="center"><code>dw</code></td><td align="center">删除后边的字符</td></tr><tr><td align="center"><code>diw</code></td><td align="center">删除光标处字符，不含空白字符</td></tr><tr><td align="center"><code>daw</code></td><td align="center">删除光标处字符，包含空白字符</td></tr><tr><td align="center"><code>ciw</code></td><td align="center">删除光标处字符，并开始插入</td></tr><tr><td align="center"><code>caw</code></td><td align="center">删除光标处字符和其后边空格，并开始插入</td></tr><tr><td align="center"><code>dG</code></td><td align="center">删除到页尾</td></tr><tr><td align="center"><code>dgg</code></td><td align="center">删除到页首</td></tr><tr><td align="center"><code>:m,nd</code></td><td align="center">删除m~n行</td></tr><tr><td align="center"><code>:m,ny</code></td><td align="center">复制m~n行</td></tr><tr><td align="center"><code>:m,nmt</code></td><td align="center">剪切m~n行内容到t行</td></tr><tr><td align="center"><code>:m,ncot</code></td><td align="center">复制m~n行内容到t行</td></tr><tr><td align="center"><code>N&gt;&gt;</code></td><td align="center">N行右缩进</td></tr><tr><td align="center"><code>N&lt;&lt;</code></td><td align="center">N行左缩进</td></tr><tr><td align="center"><code>==</code></td><td align="center">对齐当前行</td></tr><tr><td align="center"><code>gg=G</code></td><td align="center">对齐全文</td></tr><tr><td align="center"><code>ggvG</code></td><td align="center">全选</td></tr><tr><td align="center"><code>ctrl-f/b</code></td><td align="center">上翻页/下翻页</td></tr><tr><td align="center"><code>ctrl-u/d</code></td><td align="center">上翻半页/下翻半页</td></tr><tr><td align="center"><code>ctrl-g</code></td><td align="center">页面底部显示行数等文件相关情况</td></tr><tr><td align="center">``</td><td align="center">在最近停留的两点间跳转</td></tr><tr><td align="center">`.</td><td align="center">跳转到上次修改位置</td></tr><tr><td align="center"><code>ctrl-i/o</code></td><td align="center">跳转到将来/过去停留的位置</td></tr><tr><td align="center"><code>:args</code></td><td align="center">显示当前正在编辑的文件</td></tr><tr><td align="center"><code>.</code></td><td align="center">重复上次操作</td></tr><tr><td align="center">打开最近一次打开的文件</td><td align="center"><code>!vim</code></td></tr><tr><td align="center">查看最近打开过的文件</td><td align="center">在一个打开的文件中输入<code>:ol</code>（ol是oldfiles的缩写），若该命令无效，可以尝试<code>:bro ol</code>（:browse oldfiles的缩写）</td></tr><tr><td align="center">直接打开最近的任何文件</td><td align="center">在用<code>:ol</code>查看历史时，使用<code>:e #&lt;数字</code>来直接打开对应文件</td></tr><tr><td align="center"><code>:sp</code></td><td align="center">水平分隔当前窗格</td></tr><tr><td align="center"><code>:vs</code></td><td align="center">垂直分隔当前窗格</td></tr><tr><td align="center"><code>Ctrl+w,Ctrl+w</code></td><td align="center">切换到下一个窗格（顺时针）</td></tr><tr><td align="center"><code>Ctrl+w,Ctrl+j</code></td><td align="center">切换到下面的窗格</td></tr><tr><td align="center"><code>Ctrl+w,Ctrl+k</code></td><td align="center">切换到上面的窗格</td></tr><tr><td align="center"><code>Ctrl+w,Ctrl+h</code></td><td align="center">切换到左边的窗格</td></tr><tr><td align="center"><code>Ctrl+w,Ctrl+l</code></td><td align="center">切换到右边的窗格</td></tr></tbody></table><h1 id="二、搜索"><a href="#二、搜索" class="headerlink" title="二、搜索"></a>二、搜索</h1><table><thead><tr><th align="center">快捷键</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>*</code></td><td align="center">在文本中查找当前光标所在处字符（向下查找）</td></tr><tr><td align="center"><code>#</code></td><td align="center">（向上查找）</td></tr><tr><td align="center"><code>?</code></td><td align="center">向上搜索</td></tr><tr><td align="center"><code>/</code></td><td align="center">向下搜索 <code>/was$</code>(只匹配位于行末的was);<code>/^was</code>(只匹配位于行首的was)</td></tr><tr><td align="center"><code>v</code></td><td align="center">字符选择</td></tr><tr><td align="center"><code>V</code></td><td align="center">行选择</td></tr><tr><td align="center"><code>ctrl-v</code></td><td align="center">块选择（选择后o可在选择区域两端跳转）</td></tr><tr><td align="center"><code>:set ignorecase</code></td><td align="center">忽略大小写搜索</td></tr><tr><td align="center"><code>:set noignorecase</code></td><td align="center">区分大小写搜索</td></tr><tr><td align="center"><code>:set hlsearch</code></td><td align="center">高亮搜索结果</td></tr><tr><td align="center"><code>:set nohlsearch</code></td><td align="center">关闭高亮</td></tr><tr><td align="center"><code>.</code></td><td align="center">匹配任意单字符</td></tr><tr><td align="center"><code>\</code></td><td align="center"></td></tr></tbody></table><h1 id="三、替换"><a href="#三、替换" class="headerlink" title="三、替换"></a>三、替换</h1><table><thead><tr><th align="center">快捷键</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>:%s/old/new/g</code></td><td align="center">全文替换</td></tr><tr><td align="center"><code>:m,ns/old/new/g</code></td><td align="center">m~n行替换</td></tr><tr><td align="center"><code>:s/正则/替换文本/g</code></td><td align="center">本行内替换</td></tr><tr><td align="center"><code>&amp;</code></td><td align="center">重复上次替换命令</td></tr></tbody></table><h1 id="四、标记"><a href="#四、标记" class="headerlink" title="四、标记"></a>四、标记</h1><table><thead><tr><th align="center">快捷键</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>ma</code></td><td align="center">在当前光标处标记“a”，可用“a~z”,“A～Z”作为标记字母，小写仅用于当前缓冲区，大写可跨越不同的缓冲</td></tr><tr><td align="center"><code>&#39;a</code></td><td align="center">单引号+标记，可移动到指定标记行的首个非空字符</td></tr><tr><td align="center">`a</td><td align="center">反引号+标记，可移动到标记时的光标位置</td></tr><tr><td align="center"><code>:marks</code></td><td align="center">显示所有的标记</td></tr><tr><td align="center"><code>:delmarks a b c</code></td><td align="center">删除a,b,c标记</td></tr><tr><td align="center"><code>:delmarks!</code></td><td align="center">删除所有标记</td></tr><tr><td align="center">使用标记快速删除文本行：<code>d&#39;a</code></td><td align="center">复制行：<code>y&#39;a</code></td></tr></tbody></table><p>系统内置的特殊标记如下：</p><ul><li><code>.</code> 最近编辑位置</li><li><code>0～9</code> 最近使用的文件 </li><li><code>^</code>最近插入的位置</li><li><code>&#39;</code> 上次跳转前的位置</li><li><code>&quot;</code> 上次退出文件前的位置</li><li><code>[</code> 上次修改开始处</li><li><code>]</code> 上次修改结束处</li></ul><h1 id="五、折叠与展开"><a href="#五、折叠与展开" class="headerlink" title="五、折叠与展开"></a>五、折叠与展开</h1><table><thead><tr><th align="center">快捷键</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>zc</code></td><td align="center">折叠代码(close)</td></tr><tr><td align="center"><code>zo</code></td><td align="center">展开代码(open)</td></tr><tr><td align="center"><code>zm</code></td><td align="center">折叠全部</td></tr><tr><td align="center"><code>zr</code></td><td align="center">展开全部</td></tr><tr><td align="center"><code>zj</code></td><td align="center">下一个折叠</td></tr><tr><td align="center"><code>zk</code></td><td align="center">上一个折叠</td></tr><tr><td align="center"><code>zn</code></td><td align="center">禁用折叠</td></tr><tr><td align="center"><code>zN</code></td><td align="center">启用折叠</td></tr></tbody></table><h1 id="六、保存退出"><a href="#六、保存退出" class="headerlink" title="六、保存退出"></a>六、保存退出</h1><table><thead><tr><th align="center">快捷键</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>:w</code></td><td align="center">保存</td></tr><tr><td align="center"><code>:wq</code></td><td align="center">保存退出</td></tr><tr><td align="center"><code>ZZ</code></td><td align="center">保存退出</td></tr><tr><td align="center"><code>:q!</code></td><td align="center">不保存退出</td></tr><tr><td align="center"><code>:wq!</code></td><td align="center">保存退出（忽略只读属性，所有者及root可用）</td></tr></tbody></table><h1 id="七、示例"><a href="#七、示例" class="headerlink" title="七、示例"></a>七、示例</h1><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>向下移动 7 行</td><td><code>7j</code></td></tr><tr><td>删除一个词</td><td><code>dw</code></td></tr><tr><td>删除一行</td><td><code>dd</code></td></tr><tr><td>从光标处删除到行尾</td><td><code>d$</code></td></tr><tr><td>从光标处删除到行首</td><td><code>d0</code></td></tr><tr><td>删除<code>{}</code>中的内容</td><td><code>di{</code></td></tr><tr><td>光标移动至 80 行</td><td><code>80G</code></td></tr><tr><td>在当前文件中搜索光标所在位置</td><td><code>*(#)</code></td></tr><tr><td>在 50 行至 100 行间查找并替换</td><td><code>:50,100/old/new/g</code></td></tr><tr><td>在同一文件中对比两个不同的块</td><td><code>:sp(to &#39;split&#39; the view)</code></td></tr><tr><td>输入<code>23+45+119</code>的结果</td><td><code>Ctrl+r=23+45+119</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP数组函数总结</title>
      <link href="/post/php-array/"/>
      <url>/post/php-array/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1g9yly50tbaj31400qo11r.jpg" alt=""></p><a id="more"></a><p>作为一门 Web 开发语言，PHP 无疑是成功的：</p><ol><li><p>只需简单的学习便可快速上手</p></li><li><p>内置大量系统函数</p></li><li><p>动态解释型更快更灵活的应对业务快速迭代</p></li><li><p>……</p><p>PHP 的数组函数非常丰富，用好这些系统内置函数，让你的开发效率事半功倍。</p></li></ol><h2 id="1-array-column"><a href="#1-array-column" class="headerlink" title="1. array_column"></a>1. array_column</h2><h3 id="1-1-提取指定列"><a href="#1-1-提取指定列" class="headerlink" title="1.1 提取指定列"></a>1.1 提取指定列</h3><p>相信很多 PHPer 对这个函数并不陌生，这个函数就是取数组中的某一列，如</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$records = <span class="keyword">array</span>(</span><br><span class="line">    <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'id'</span> =&gt; <span class="number">2135</span>,</span><br><span class="line">        <span class="string">'first_name'</span> =&gt; <span class="string">'John'</span>,</span><br><span class="line">        <span class="string">'last_name'</span> =&gt; <span class="string">'Doe'</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'id'</span> =&gt; <span class="number">3245</span>,</span><br><span class="line">        <span class="string">'first_name'</span> =&gt; <span class="string">'Sally'</span>,</span><br><span class="line">        <span class="string">'last_name'</span> =&gt; <span class="string">'Smith'</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'id'</span> =&gt; <span class="number">5342</span>,</span><br><span class="line">        <span class="string">'first_name'</span> =&gt; <span class="string">'Jane'</span>,</span><br><span class="line">        <span class="string">'last_name'</span> =&gt; <span class="string">'Jones'</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'id'</span> =&gt; <span class="number">5623</span>,</span><br><span class="line">        <span class="string">'first_name'</span> =&gt; <span class="string">'Peter'</span>,</span><br><span class="line">        <span class="string">'last_name'</span> =&gt; <span class="string">'Doe'</span>,</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$first_names = array_column($records, <span class="string">'first_name'</span>);</span><br><span class="line">print_r($first_names);</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; John</span><br><span class="line">    [<span class="number">1</span>] =&gt; Sally</span><br><span class="line">    [<span class="number">2</span>] =&gt; Jane</span><br><span class="line">    [<span class="number">3</span>] =&gt; Peter</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-2-指定列作键值对"><a href="#1-2-指定列作键值对" class="headerlink" title="1.2 指定列作键值对"></a>1.2 指定列作键值对</h3><p>如果我们需要提取<code>last_name</code>，并用相应的<code>id</code>作为键值，应该怎么实现呢？你可能想到了<code>foreach</code>循环，但用<code>array_column()</code>可以一行代码搞定：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$last_names = array_column($records, <span class="string">'last_name'</span>, <span class="string">'id'</span>);</span><br><span class="line">print_r($last_names);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">2135</span>] =&gt; Doe</span><br><span class="line">    [<span class="number">3245</span>] =&gt; Smith</span><br><span class="line">    [<span class="number">5342</span>] =&gt; Jones</span><br><span class="line">    [<span class="number">5623</span>] =&gt; Doe</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-3-重新生成索引关系"><a href="#1-3-重新生成索引关系" class="headerlink" title="1.3 重新生成索引关系"></a>1.3 重新生成索引关系</h3><p>我们还可以将每个用户的 ID 作为<code>$records</code>的<code>key</code>重新生成索引数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$idRecords = array_column($records, <span class="keyword">null</span>, <span class="string">'id'</span>);</span><br><span class="line">print_r($idRecords);</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">2135</span>] =&gt; <span class="keyword">Array</span></span><br><span class="line">        (</span><br><span class="line">            [id] =&gt; <span class="number">2135</span></span><br><span class="line">            [first_name] =&gt; John</span><br><span class="line">            [last_name] =&gt; Doe</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    [<span class="number">3245</span>] =&gt; <span class="keyword">Array</span></span><br><span class="line">        (</span><br><span class="line">            [id] =&gt; <span class="number">3245</span></span><br><span class="line">            [first_name] =&gt; Sally</span><br><span class="line">            [last_name] =&gt; Smith</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    [<span class="number">5342</span>] =&gt; <span class="keyword">Array</span></span><br><span class="line">        (</span><br><span class="line">            [id] =&gt; <span class="number">5342</span></span><br><span class="line">            [first_name] =&gt; Jane</span><br><span class="line">            [last_name] =&gt; Jones</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    [<span class="number">5623</span>] =&gt; <span class="keyword">Array</span></span><br><span class="line">        (</span><br><span class="line">            [id] =&gt; <span class="number">5623</span></span><br><span class="line">            [first_name] =&gt; Peter</span><br><span class="line">            [last_name] =&gt; Doe</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-4-从对象中获取属性"><a href="#1-4-从对象中获取属性" class="headerlink" title="1.4 从对象中获取属性"></a>1.4 从对象中获取属性</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(string $username)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = $username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$users = [</span><br><span class="line">    <span class="keyword">new</span> User(<span class="string">'user 1'</span>),</span><br><span class="line">    <span class="keyword">new</span> User(<span class="string">'user 2'</span>),</span><br><span class="line">    <span class="keyword">new</span> User(<span class="string">'user 3'</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">print_r(array_column($users, <span class="string">'username'</span>));</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; user <span class="number">1</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; user <span class="number">2</span></span><br><span class="line">    [<span class="number">2</span>] =&gt; user <span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="2-array-filter"><a href="#2-array-filter" class="headerlink" title="2. array_filter"></a>2. array_filter</h2><p><code>array_filter()</code>将删除 array 中所有等值为 <code>FALSE</code> 的条目。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(array_filter([<span class="number">0</span>, <span class="number">0.0</span>, <span class="string">'0'</span>, <span class="string">''</span>, <span class="keyword">false</span>, <span class="keyword">null</span>, [], <span class="keyword">true</span>, <span class="number">123</span>, <span class="string">'1'</span>]));</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="number">7</span>] =&gt;</span><br><span class="line">  bool(<span class="keyword">true</span>)</span><br><span class="line">  [<span class="number">8</span>] =&gt;</span><br><span class="line">  int(<span class="number">123</span>)</span><br><span class="line">  [<span class="number">9</span>] =&gt;</span><br><span class="line">  string(<span class="number">1</span>) <span class="string">"1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用回调函数，我们还可以做更多的事：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$employees = [</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'John'</span>,</span><br><span class="line">        <span class="string">'age'</span> =&gt; <span class="number">45</span>,</span><br><span class="line">        <span class="string">'language'</span> =&gt; <span class="string">'Python'</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'Robbin'</span>,</span><br><span class="line">        <span class="string">'age'</span> =&gt; <span class="number">25</span>,</span><br><span class="line">        <span class="string">'language'</span> =&gt; <span class="string">'Golang'</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'Smith'</span>,</span><br><span class="line">        <span class="string">'age'</span> =&gt; <span class="number">35</span>,</span><br><span class="line">        <span class="string">'language'</span> =&gt; <span class="string">'PHP'</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'Steven'</span>,</span><br><span class="line">        <span class="string">'age'</span> =&gt; <span class="number">29</span>,</span><br><span class="line">        <span class="string">'language'</span> =&gt; <span class="string">'C#'</span></span><br><span class="line">    ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$fireList = array_filter(</span><br><span class="line">    $employees,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">($employee, $key)</span> <span class="title">use</span> <span class="params">(&amp;$employees)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $employee[<span class="string">'age'</span>] &gt; <span class="number">35</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    ARRAY_FILTER_USE_BOTH</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">print_r($fireList);</span><br></pre></td></tr></table></figure><blockquote><p>注意：用户不应在回调函数中修改数组本身。例如增加／删除单元或者对 <code>array_filter()</code> 正在作用的数组进行 <code>unset</code>。如果数组改变了，此函数的行为将不可预测。</p></blockquote><h2 id="2-array-map"><a href="#2-array-map" class="headerlink" title="2. array_map"></a>2. array_map</h2><p>通过<code>array_map()</code>，我们可以通过预设的函数对数组元素进行批量处理</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cube</span><span class="params">($n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>($n * $n * $n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">$b = array_map(<span class="string">"cube"</span>, $a);</span><br><span class="line">print_r($b);</span><br></pre></td></tr></table></figure><p><code>$b</code> 将输出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">1</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; <span class="number">8</span></span><br><span class="line">    [<span class="number">2</span>] =&gt; <span class="number">27</span></span><br><span class="line">    [<span class="number">3</span>] =&gt; <span class="number">64</span></span><br><span class="line">    [<span class="number">4</span>] =&gt; <span class="number">125</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>从PHP 5.3起，我们也可以将调用的函数写作闭包的形式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$b = array_map(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">($n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>($n * $n * $n);</span><br><span class="line">    &#125;, </span><br><span class="line">    $a</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>同样的，我们还可以使用系统内置的函数来处理一些数据，如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$values = [<span class="string">'say'</span>, <span class="string">'  bye'</span>, <span class="string">''</span>, <span class="string">' to'</span>, <span class="string">' spaces  '</span>, <span class="string">'    '</span>];</span><br><span class="line">$result = array_map(<span class="string">'trim'</span>, $values);</span><br></pre></td></tr></table></figure><p><code>array_map()</code>也可以在类中使用，以下是在类中的调用方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Static outside of class context</span></span><br><span class="line">array_map( <span class="keyword">array</span>( <span class="string">'ClassName'</span>, <span class="string">'methodName'</span> ), $array );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Static inside class context</span></span><br><span class="line">array_map( <span class="keyword">array</span>( <span class="keyword">__CLASS__</span>, <span class="string">'methodName'</span> ), $array );</span><br><span class="line">array_map( <span class="keyword">array</span>( <span class="string">'self'</span>, <span class="string">'methodName'</span> ), $array );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-static outside of object context</span></span><br><span class="line">array_map( <span class="keyword">array</span>( $object, <span class="string">'methodName'</span> ), $array );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-static inside of object context</span></span><br><span class="line">array_map( <span class="keyword">array</span>( <span class="keyword">$this</span>, <span class="string">'methodName'</span> ), $array );</span><br></pre></td></tr></table></figure><h2 id="3-array-reduce"><a href="#3-array-reduce" class="headerlink" title="3. array_reduce"></a>3. array_reduce</h2><p>求 1 ~ 100 的和：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$hunder = range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">$sum = array_reduce(</span><br><span class="line">    $hunder,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">($carry, $item)</span> </span>&#123;</span><br><span class="line">        $carry += $item;</span><br><span class="line">        <span class="keyword">return</span> $carry;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $sum;</span><br></pre></td></tr></table></figure><h2 id="4-array-walk"><a href="#4-array-walk" class="headerlink" title="4. array_walk"></a>4. array_walk</h2><p><code>array_walk()</code>可以让我们便捷的修改数组内的元素：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$infos = [</span><br><span class="line">    [<span class="string">'uid'</span> =&gt; <span class="number">1</span>, <span class="string">'email'</span> =&gt; <span class="string">'jack@example.com'</span>],</span><br><span class="line">    [<span class="string">'uid'</span> =&gt; <span class="number">2</span>, <span class="string">'email'</span> =&gt; <span class="string">'rose@example.com'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">array_walk(</span><br><span class="line">  $infos,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="params">(&amp;$info)</span> </span>&#123;</span><br><span class="line">      $info[<span class="string">'username'</span>] = strstr($info[<span class="string">'email'</span>], <span class="string">'@'</span>, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">unset</span>($info[<span class="string">'email'</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> json_encode($infos); <span class="comment">// [&#123;"uid":1,"username":"jack"&#125;,&#123;"uid":2,"username":"rose"&#125;]</span></span><br></pre></td></tr></table></figure><h2 id="5-array-walk-recursive"><a href="#5-array-walk-recursive" class="headerlink" title="5. array_walk_recursive"></a>5. array_walk_recursive</h2><p>把任意维度的数组转换成一维数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$user = [</span><br><span class="line">    <span class="string">'a'</span> =&gt; [<span class="number">100</span>, <span class="string">'a1'</span>],</span><br><span class="line">    <span class="string">'b'</span> =&gt; [<span class="number">101</span>, <span class="string">'a2'</span>],</span><br><span class="line">    <span class="string">'c'</span> =&gt; [</span><br><span class="line">        <span class="string">'d'</span> =&gt; [<span class="number">102</span>, <span class="string">'a3'</span>],</span><br><span class="line">        <span class="string">'e'</span> =&gt; [<span class="number">103</span>, <span class="string">'a4'</span>]</span><br><span class="line">    ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array_flat</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $result = [];</span><br><span class="line">    array_walk_recursive($arr, <span class="function"><span class="keyword">function</span> <span class="params">($value)</span> <span class="title">use</span> <span class="params">(&amp;$result)</span> </span>&#123;</span><br><span class="line">        array_push($result, $value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_r(array_flat($user));</span><br></pre></td></tr></table></figure><h2 id="6-filter-var"><a href="#6-filter-var" class="headerlink" title="6. filter_var"></a>6. filter_var</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证邮箱</span></span><br><span class="line">var_dump(filter_var(<span class="string">'username@example.com'</span>, FILTER_VALIDATE_EMAIL)); <span class="comment">// 有效输出email地址，无效输出false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 IPv4</span></span><br><span class="line">var_dump(filter_var(<span class="string">'8.8.8.8'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)); <span class="comment">// 有效输出IP，无效输出false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 IPv6</span></span><br><span class="line">var_dump(filter_var(<span class="string">'2001:4860:4860::8888'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)); <span class="comment">// 有效输出IP，无效输出false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证非私网 IP</span></span><br><span class="line">var_dump(filter_var(<span class="string">'10.0.0.1'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE)); <span class="comment">// 非私网输出IP，否则输出false</span></span><br><span class="line">var_dump(filter_var(<span class="string">'192.0.0.1'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证非保留 IP</span></span><br><span class="line">var_dump(filter_var(<span class="string">'8.8.8.8'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_RES_RANGE)); <span class="comment">// // 非保留IP输出IP，否则输出false</span></span><br><span class="line">var_dump(filter_var(<span class="string">'127.0.0.1'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_RES_RANGE));</span><br><span class="line">var_dump(filter_var(<span class="string">'0.0.0.0'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_RES_RANGE));</span><br><span class="line">var_dump(filter_var(<span class="string">'169.254.0.0'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_RES_RANGE));</span><br><span class="line">var_dump(filter_var(<span class="string">'255.255.255.255'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_RES_RANGE));</span><br><span class="line">var_dump(filter_var(<span class="string">'::1'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_RES_RANGE));</span><br><span class="line">var_dump(filter_var(<span class="string">'2002'</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_RES_RANGE));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 Mac 地址</span></span><br><span class="line">var_dump(filter_var(<span class="string">'F1:5C:89:A4:40:49'</span>, FILTER_VALIDATE_MAC)); <span class="comment">// 有效输出地址，无效输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证布尔值</span></span><br><span class="line">var_dump(filter_var(<span class="string">'1'</span>, FILTER_VALIDATE_BOOLEAN)); <span class="comment">// 1, true, on ,yes 返回 true，否则返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证浮点数</span></span><br><span class="line">var_dump(filter_var(<span class="string">'1234.233'</span>, FILTER_VALIDATE_FLOAT)); <span class="comment">// 有效输出浮点数，无效输出 false</span></span><br><span class="line">var_dump(filter_var(<span class="string">'1,234.233'</span>, FILTER_VALIDATE_FLOAT, FILTER_FLAG_ALLOW_THOUSAND));</span><br></pre></td></tr></table></figure><h2 id="7-array-multisort"><a href="#7-array-multisort" class="headerlink" title="7. array_multisort"></a>7. array_multisort</h2><p>通过<code>array_multisort()</code>，可以让我们像操作 Excel 一样对数据进行排序操作，我们先来看一个简单的例子</p><h3 id="7-1-多个数组排序"><a href="#7-1-多个数组排序" class="headerlink" title="7.1 多个数组排序"></a>7.1 多个数组排序</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ar1 = <span class="keyword">array</span>(<span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">$ar2 = <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">array_multisort($ar1, $ar2);</span><br><span class="line"></span><br><span class="line">var_dump($ar1);</span><br><span class="line">var_dump($ar2);</span><br></pre></td></tr></table></figure><p>这个例子里，排序后，第一个数组会包含 0、 10、 100、 100。 第二个数组会包含 4、1、 2、 3。 第二个数组里的项目对应第一个数组后也进行了排序（100 和 100）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt; int(<span class="number">0</span>)</span><br><span class="line">  [<span class="number">1</span>]=&gt; int(<span class="number">10</span>)</span><br><span class="line">  [<span class="number">2</span>]=&gt; int(<span class="number">100</span>)</span><br><span class="line">  [<span class="number">3</span>]=&gt; int(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt; int(<span class="number">4</span>)</span><br><span class="line">  [<span class="number">1</span>]=&gt; int(<span class="number">1</span>)</span><br><span class="line">  [<span class="number">2</span>]=&gt; int(<span class="number">2</span>)</span><br><span class="line">  [<span class="number">3</span>]=&gt; int(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-对数据库结果进行排序"><a href="#7-2-对数据库结果进行排序" class="headerlink" title="7.2 对数据库结果进行排序"></a>7.2 对数据库结果进行排序</h3><p>现在数据表中存储着如下的数据:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">volume | edition</span><br><span class="line">-------+--------</span><br><span class="line">    <span class="number">67</span> |       <span class="number">2</span></span><br><span class="line">    <span class="number">86</span> |       <span class="number">1</span></span><br><span class="line">    <span class="number">85</span> |       <span class="number">6</span></span><br><span class="line">    <span class="number">98</span> |       <span class="number">2</span></span><br><span class="line">    <span class="number">86</span> |       <span class="number">6</span></span><br><span class="line">    <span class="number">67</span> |       <span class="number">7</span></span><br></pre></td></tr></table></figure><p>我们将 volume 降序排列，把 edition 升序排列</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$data = [</span><br><span class="line">    [<span class="string">'volume'</span> =&gt; <span class="number">67</span>, <span class="string">'edition'</span> =&gt; <span class="number">2</span>],</span><br><span class="line">    [<span class="string">'volume'</span> =&gt; <span class="number">86</span>, <span class="string">'edition'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">    [<span class="string">'volume'</span> =&gt; <span class="number">85</span>, <span class="string">'edition'</span> =&gt; <span class="number">6</span>],</span><br><span class="line">    [<span class="string">'volume'</span> =&gt; <span class="number">98</span>, <span class="string">'edition'</span> =&gt; <span class="number">2</span>],</span><br><span class="line">    [<span class="string">'volume'</span> =&gt; <span class="number">86</span>, <span class="string">'edition'</span> =&gt; <span class="number">6</span>],</span><br><span class="line">    [<span class="string">'volume'</span> =&gt; <span class="number">67</span>, <span class="string">'edition'</span> =&gt; <span class="number">7</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得列的列表</span></span><br><span class="line">$volume = array_column($data, <span class="string">'volume'</span>);</span><br><span class="line">$edition = array_column($data, <span class="string">'edition'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据根据 volume 降序排列，根据 edition 升序排列</span></span><br><span class="line"><span class="comment">// 把 $data 作为最后一个参数，以通用键排序</span></span><br><span class="line">array_multisort($volume, SORT_DESC, $edition, SORT_ASC, $data);</span><br></pre></td></tr></table></figure><p>数据集合现在排好序了，结果如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">volume | edition</span><br><span class="line">-------+--------</span><br><span class="line">    <span class="number">98</span> |       <span class="number">2</span></span><br><span class="line">    <span class="number">86</span> |       <span class="number">1</span></span><br><span class="line">    <span class="number">86</span> |       <span class="number">6</span></span><br><span class="line">    <span class="number">85</span> |       <span class="number">6</span></span><br><span class="line">    <span class="number">67</span> |       <span class="number">2</span></span><br><span class="line">    <span class="number">67</span> |       <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="8-array-merge"><a href="#8-array-merge" class="headerlink" title="8. array_merge"></a>8. array_merge</h2><p>这个应该都很熟悉，就是将两个数组合并：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$array1 = <span class="keyword">array</span>(<span class="string">"color"</span> =&gt; <span class="string">"red"</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">$array2 = <span class="keyword">array</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"color"</span> =&gt; <span class="string">"green"</span>, <span class="string">"shape"</span> =&gt; <span class="string">"trapezoid"</span>, <span class="number">4</span>);</span><br><span class="line">print_r(array_merge($array1, $array2));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [color] =&gt; green</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">2</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; <span class="number">4</span></span><br><span class="line">    [<span class="number">2</span>] =&gt; a</span><br><span class="line">    [<span class="number">3</span>] =&gt; b</span><br><span class="line">    [shape] =&gt; trapezoid</span><br><span class="line">    [<span class="number">4</span>] =&gt; <span class="number">4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>⚠️：如果合并的数组中包含了关联数组，则相同键名元素会覆盖，且合并后的数组保留原键名。若是索引数组，则会重新生成索引。</p></blockquote><p>同名关联数组被覆盖：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$array1 = <span class="keyword">array</span>(<span class="string">"color"</span> =&gt; <span class="string">"red"</span>);</span><br><span class="line">$array2 = <span class="keyword">array</span>(<span class="string">"color"</span> =&gt; <span class="string">"green"</span>, <span class="string">"shape"</span> =&gt; <span class="string">"trapezoid"</span>);</span><br><span class="line">print_r(array_merge($array1, $array2));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="built_in">color</span>] =&gt; <span class="built_in">green</span></span><br><span class="line">    [<span class="built_in">shape</span>] =&gt; trapezoid</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同名索引数组重新索引：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$array1 = <span class="keyword">array</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">$array2 = <span class="keyword">array</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="number">4</span>);</span><br><span class="line">print_r(array_merge($array1, $array2));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">2</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; <span class="number">4</span></span><br><span class="line">    [<span class="number">2</span>] =&gt; a</span><br><span class="line">    [<span class="number">3</span>] =&gt; b</span><br><span class="line">    [<span class="number">4</span>] =&gt; <span class="number">4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>还有另一种合并数组的方式：<code>+</code>运算符，这种方式可以完全保留原有数组并将新的数组附加到后面。<strong>在两个数组中存在相同的键名时，第一个数组中的同键名的元素将会被保留，第二个数组中的元素将会被忽略</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$array1 = <span class="keyword">array</span>(<span class="number">0</span> =&gt; <span class="string">'zero_a'</span>, <span class="number">2</span> =&gt; <span class="string">'two_a'</span>, <span class="number">3</span> =&gt; <span class="string">'three_a'</span>);</span><br><span class="line">$array2 = <span class="keyword">array</span>(<span class="number">1</span> =&gt; <span class="string">'one_b'</span>, <span class="number">3</span> =&gt; <span class="string">'three_b'</span>, <span class="number">4</span> =&gt; <span class="string">'four_b'</span>);</span><br><span class="line">$result = $array1 + $array2;</span><br><span class="line">print_r($result);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; zero_a</span><br><span class="line">    [<span class="number">2</span>] =&gt; two_a</span><br><span class="line">    [<span class="number">3</span>] =&gt; three_a</span><br><span class="line">    [<span class="number">1</span>] =&gt; one_b</span><br><span class="line">    [<span class="number">4</span>] =&gt; four_b</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="9-array-merge-recursive"><a href="#9-array-merge-recursive" class="headerlink" title="9. array_merge_recursive"></a>9. array_merge_recursive</h2><p>将相同 <code>key</code>的不同数组中信息进行合并：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$baseInfo = [</span><br><span class="line">    <span class="string">'jack'</span> =&gt; [</span><br><span class="line">        <span class="string">'age'</span> =&gt; <span class="number">22</span>,</span><br><span class="line">        <span class="string">'tel'</span> =&gt; <span class="string">'56710937'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'rose'</span> =&gt; [</span><br><span class="line">        <span class="string">'age'</span> =&gt; <span class="number">21</span>,</span><br><span class="line">        <span class="string">'tel'</span> =&gt; <span class="string">'578391038'</span></span><br><span class="line">    ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$extInfo = [</span><br><span class="line">    <span class="string">'jack'</span> =&gt; [</span><br><span class="line">        <span class="string">'addrs'</span> =&gt; <span class="string">'NYC'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'rose'</span> =&gt; [</span><br><span class="line">        <span class="string">'addrs'</span> =&gt; <span class="string">'London'</span></span><br><span class="line">    ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> json_encode(array_merge_recursive($baseInfo, $extInfo));</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"jack"</span>:&#123;</span><br><span class="line">        <span class="attr">"age"</span>:<span class="number">22</span>,</span><br><span class="line">        <span class="attr">"tel"</span>:<span class="string">"56710937"</span>,</span><br><span class="line">        <span class="attr">"addrs"</span>:<span class="string">"NYC"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"rose"</span>:&#123;</span><br><span class="line">        <span class="attr">"age"</span>:<span class="number">21</span>,</span><br><span class="line">        <span class="attr">"tel"</span>:<span class="string">"578391038"</span>,</span><br><span class="line">        <span class="attr">"addrs"</span>:<span class="string">"London"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-range"><a href="#10-range" class="headerlink" title="10. range"></a>10. range</h2><p>生成指定区间的数组</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(<span class="number">0</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>指定步长为 10</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(<span class="number">1</span>, <span class="number">100</span>, <span class="number">10</span>); <span class="comment">// [0,10,20,30,40,50,60,70,80,90,100]</span></span><br></pre></td></tr></table></figure><p>如果起始值大于结束值，则会按照递减的顺序生成</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(<span class="number">100</span>, <span class="number">0</span>, <span class="number">10</span>); <span class="comment">// [100,90,80,70,60,50,40,30,20,10,0]</span></span><br></pre></td></tr></table></figure><p>三个参数也可以是浮点数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(<span class="number">12.8</span>, <span class="number">2.2</span>, <span class="number">2.5</span>); <span class="comment">// [12.8, 10.3, 7.8, 5.3, 2.8]</span></span><br></pre></td></tr></table></figure><p><code>$start</code> 和 <code>$end</code> 如果全部是字符串，那么会<strong>取两个字符串的第一个字母</strong>，并按照 ASCII 字母顺序表，取步长对应的值</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">range</span>(<span class="string">'a'</span>, <span class="string">'i'</span>); // [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>]</span><br></pre></td></tr></table></figure><p>那么，我们如何使用<code>range()</code>来输出 <a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII</a> 的所有可见字符呢？，这在PHP中非常简单：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">range</span>(<span class="string">' '</span>, <span class="string">'~'</span>);</span><br></pre></td></tr></table></figure><h2 id="11-array-chunk"><a href="#11-array-chunk" class="headerlink" title="11. array_chunk"></a>11. array_chunk</h2><p>如果我们需要将一个数组拆分为多个数组，就可以通过<code>array_chunk()</code>快速实现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$input_array = <span class="keyword">array</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>);</span><br><span class="line"><span class="keyword">echo</span> json_encode(array_chunk($input_array, <span class="number">2</span>)),PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> json_encode(array_chunk($input_array, <span class="number">2</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [["a","b"],["c","d"],["e"]]</span></span><br><span class="line"><span class="comment">// [["a","b"],&#123;"2":"c","3":"d"&#125;,&#123;"4":"e"&#125;]</span></span><br></pre></td></tr></table></figure><h2 id="12-array-combine"><a href="#12-array-combine" class="headerlink" title="12. array_combine"></a>12. array_combine</h2><p>现在有两个数组，我们希望一个数组的元素做<code>key</code>，另一个数组的元素做<code>value</code>，合并为一个数组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="keyword">array</span>(<span class="string">'green'</span>, <span class="string">'red'</span>, <span class="string">'yellow'</span>);</span><br><span class="line">$b = <span class="keyword">array</span>(<span class="string">'avocado'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>);</span><br><span class="line">$c = array_combine($a, $b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> json_encode($c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;"green":"avocado","red":"apple","yellow":"banana"&#125;</span></span><br></pre></td></tr></table></figure><h2 id="13-extract"><a href="#13-extract" class="headerlink" title="13. extract"></a>13. extract</h2><h2 id="14-compact"><a href="#14-compact" class="headerlink" title="14. compact"></a>14. compact</h2><h2 id="15-array-diff-amp-array-intersect"><a href="#15-array-diff-amp-array-intersect" class="headerlink" title="15. array_diff &amp; array_intersect"></a>15. array_diff &amp; array_intersect</h2><p>如果需要求数组元素的差集/交集，可以使用<code>array_diff($array1, $array2[,$arrayn])</code>，这将返回存在于<code>$array1</code>中而不存在其他 array 中值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$array1 = <span class="keyword">array</span>(<span class="string">"a"</span> =&gt; <span class="string">"green"</span>, <span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"red"</span>);</span><br><span class="line">$array2 = <span class="keyword">array</span>(<span class="string">"b"</span> =&gt; <span class="string">"green"</span>, <span class="string">"yellow"</span>, <span class="string">"red"</span>);</span><br><span class="line">$diff = array_diff($array1, $array2);</span><br><span class="line">$intersect = array_intersect($array1, $array2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> json_encode($diff); <span class="comment">// &#123;"1":"blue"&#125;</span></span><br><span class="line"><span class="keyword">echo</span> json_encode($diff); <span class="comment">// &#123;"a":"green","0":"red","2":"red"&#125;</span></span><br></pre></td></tr></table></figure><h2 id="16-array-diff-key-amp-array-intersect-key"><a href="#16-array-diff-key-amp-array-intersect-key" class="headerlink" title="16. array_diff_key &amp; array_intersect_key"></a>16. array_diff_key &amp; array_intersect_key</h2><p>顾名思义，使用键名计算数组的差集/交集，同样是返回存在于<code>$array1</code>中而不存在与其他<code>$array</code>中的值。</p><h2 id="17-array-diff-assoc-amp-array-intersect-assoc"><a href="#17-array-diff-assoc-amp-array-intersect-assoc" class="headerlink" title="17. array_diff_assoc &amp; array_intersect_assoc"></a>17. array_diff_assoc &amp; array_intersect_assoc</h2><p>该函数会将键名与元素都作为比较条件。</p><h2 id="18-version-compare"><a href="#18-version-compare" class="headerlink" title="18. version_compare"></a>18. version_compare</h2><p>默认情况下，在第一个版本低于第二个时，version_compare() 返回 -1；如果两者相等，返回 0；第二个版本更低时则返回 1。(类似于太空操作符)))</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo version_compare('<span class="number">5.3</span><span class="number">.0</span>', '<span class="number">7.1</span><span class="number">.4</span>'); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h2 id="19-number-format"><a href="#19-number-format" class="headerlink" title="19. number_format"></a>19. number_format</h2><p>该函数用于格式化数字，能实现</p><ul><li>是否保留小数</li><li>数字的精度</li><li>自定义千分位分隔符与小数点分隔符</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$num</span> = 123456.789;</span><br><span class="line"><span class="built_in">echo</span> number_format(<span class="variable">$num</span>),PHP_EOL;</span><br><span class="line"><span class="built_in">echo</span> number_format(<span class="variable">$num</span>, 2),PHP_EOL;</span><br><span class="line"><span class="built_in">echo</span> number_format(<span class="variable">$num</span>, 1, <span class="string">','</span>, <span class="string">'/'</span>),PHP_EOL;</span><br></pre></td></tr></table></figure><h2 id="20-trim"><a href="#20-trim" class="headerlink" title="20. trim"></a>20. trim</h2><p><code>tirm()</code>可以去除字符串首尾处的空白字符（或者其他字符），如果没有指定待删除的字符列表，则会删除以下字符：</p><ul><li>“ “ (ASCII 32 (0x20))，普通空格符。</li><li>“\t” (ASCII 9 (0x09))，制表符。</li><li>“\n” (ASCII 10 (0x0A))，换行符。</li><li>“\r” (ASCII 13 (0x0D))，回车符。</li><li>“\0” (ASCII 0 (0x00))，空字节符。</li><li>“\x0B” (ASCII 11 (0x0B))，垂直制表符。</li></ul><p>通常情况下，我们都会指定删除的字符列表</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">trim</span>(<span class="string">'@apple……'</span>, <span class="string">'@#￥%……'</span>); <span class="comment">// apple</span></span><br></pre></td></tr></table></figure><p>tips: 该函数与<code>array_map()</code>同时服用，效果更佳。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>玩转 HTTPS</title>
      <link href="/post/https-illustrated/"/>
      <url>/post/https-illustrated/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87bjl942qj30pg0dwgn0.jpg" alt=""></p><blockquote><p>理解一个问题与讲明白一个问题哪个更困难？</p></blockquote><a id="more"></a><h2 id="什么是-CA-？"><a href="#什么是-CA-？" class="headerlink" title="什么是 CA ？"></a>什么是 CA ？</h2><p>CA(Certificate Authority) 是证书的签发机构，它是 PKI(Public key infrastructure，公钥基础设施) 的核心。CA 是负责签发证书、认证证书、管理已颁发证书的机关。它要制定政策和具体步骤来验证、识别用户身份，并对用户证书进行签名，以确保证书持有者的身份和公钥的拥有权。</p><p>常见的 CA 机构有 Let’s Encrypt、CAcert.org、Comodo、DigiCert、GlobalSign、Verisign</p><h2 id="证书中都包含哪些信息？"><a href="#证书中都包含哪些信息？" class="headerlink" title="证书中都包含哪些信息？"></a>证书中都包含哪些信息？</h2><p>证书需要保证用户之间在网上传递信息的安全性、真实性、可靠性、完整性和不可抵赖性。<br>证书的内容包括：电子签证机关的信息、公钥用户信息、公钥、权威机构的签字和有效期等等。目前，证书的格式和验证方法普遍遵循 X.509 国际标准，其内容格式如下</p><ul><li>版本：现行通用版本是 V3</li><li>序号：用以辨识每一张凭证，特别在撤消凭证的时候有用</li><li>主体：拥有此凭证的法人或自然人身份或机器，包括：<ul><li>国家（C，Country）</li><li>州 / 省（S，State）</li><li>地域 / 城市（L，Location）</li><li>组织 / 单位（O，Organization）</li><li>通用名称 （CN，Common Name）：在 TLS 应用上，此栏位一般是 网域</li></ul></li><li>发行者：以数位签章形式签署此凭证的数字证书认证机构</li><li>有效期开始时间：此凭证的有效开始时间，在此前该凭证并未生效</li><li>有效期结束时间：此凭证的有效结束时间，在此后该凭证作废</li><li>公钥用途：指定凭证上公钥的用途，例如数字签名、服务器验证、用户端验证等</li><li>公钥</li><li>公钥指纹</li><li>数位签章</li><li>数位签章演算法</li><li>主体别名：例如一个网站可能会有多个网域（<a href="http://www.wikipedia.org" target="_blank" rel="noopener">www.wikipedia.org</a>, zh.wikipedia.org, zh.m.wikipedia.org 都是维基百科）、一个组织可能会有多个网站（*.wikipedia.org, *.wikibooks.org, *.wikidata.org 都是维基媒体基金会旗下的网域），不同的网域可以一并使用同一张凭证，方便实作应用及管理<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gam15g7wd7j30qw0py47a.jpg" alt=""></li></ul><h2 id="证书的作用是什么？"><a href="#证书的作用是什么？" class="headerlink" title="证书的作用是什么？"></a>证书的作用是什么？</h2><p>使用数字证书实现身份识别和电子信息加密。数字证书中含有密钥对（公钥和私钥）所有者的识别信息，通过验证识别信息的真伪实现对证书持有者身份的认证。</p><h2 id="CA-给认证者颁发了什么？公钥和私钥？还是签名？"><a href="#CA-给认证者颁发了什么？公钥和私钥？还是签名？" class="headerlink" title="CA 给认证者颁发了什么？公钥和私钥？还是签名？"></a>CA 给认证者颁发了什么？公钥和私钥？还是签名？</h2><p>用户若欲取得证书，应先向 CA 提出申请，CA 判明申请者的身份后，为之分配一个公钥，并将该公钥与其身份信息绑定，为该整体签字，签字后的整体即为证书，发还给申请者。</p><p>简而言之，CA 用自己的私钥对需要认证的人（或组织机构）的公钥施加数字签名并生成证书，即证书的本质就是对公钥施加数字签名。</p><h2 id="向-CA-申领证书的流程是怎样的？"><a href="#向-CA-申领证书的流程是怎样的？" class="headerlink" title="向 CA 申领证书的流程是怎样的？"></a>向 CA 申领证书的流程是怎样的？</h2><p>用户若欲取得证书，应先向 CA 提出申请，CA 判明申请者的身份后，为之分配一个公钥，并将该公钥与其身份信息绑定，为该整体签字，签字后的整体即为证书，发还给申请者。具体流程如下：</p><ol><li>鲍伯在自己的机器上使用密码学安全伪随机数生成器产生一对足够强的密钥，鲍伯的私钥不会向任何人传送。</li><li>鲍伯把他的公钥，连同主体讯息、使用目的等组成凭证签署请求，传送给认证机构伊凡。</li><li>伊凡（用另外一些渠道）核实鲍伯的身份（如验证公司主体、营业执照等方式）。</li><li>如果伊凡信任这个请求，他便使用鲍伯的公钥和主体讯息，加上凭证有效期、用途等限制条件，组成凭证的基本资料。</li><li>伊凡用自己的私钥对鲍勃的公钥加上数字签名并生成证书。</li><li>伊凡把生成的凭证传送给鲍伯（伊凡也可以透过证书透明度公布他签发了新的证书）。</li></ol><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gam1vcczfzj316f0u0gsw.jpg" alt=""></p><h2 id="获取到-CA-颁发的证书的使用流程是怎样的？"><a href="#获取到-CA-颁发的证书的使用流程是怎样的？" class="headerlink" title="获取到 CA 颁发的证书的使用流程是怎样的？"></a>获取到 CA 颁发的证书的使用流程是怎样的？</h2><p>如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。</p><ol><li>鲍伯可以随便把凭证向外发布。</li><li>鲍伯与爱丽丝事先可能互不认识，但鲍伯与爱丽丝都信任伊凡，爱丽丝使用认证机构伊凡的公钥验证数字签名，如果验证成功，便可以信任鲍勃的公钥是真正属于鲍伯的。</li><li>爱丽丝可以使用凭证上的鲍勃的公钥加密明文，得到密文并传送给鲍伯。</li><li>鲍伯可以可以用自己的私钥把密文解密，得到明文。</li></ol><p>证书的存储格式是怎样的？<br>电子证书可以二进制或 Base64 形式储存，常见的二进制 文件扩展名有 <code>.cer</code>、<code>.crt</code>、<code>.der</code>，Base64 的文件扩展名则通常是 <code>.pem</code>。如果把证书和私钥一起储存，则可以使用 PKCS#12（<code>.p12</code>）格式</p><h2 id="客户浏览器内置-CA-证书是在浏览器还是在操作系统？是只内置根证书吗？"><a href="#客户浏览器内置-CA-证书是在浏览器还是在操作系统？是只内置根证书吗？" class="headerlink" title="客户浏览器内置 CA 证书是在浏览器还是在操作系统？是只内置根证书吗？"></a>客户浏览器内置 CA 证书是在浏览器还是在操作系统？是只内置根证书吗？</h2><p>根证书没有上层机构再为其本身作数位签章，所以都是自签证书。许多应用软件（例如操作系统、网页浏览器）会预先安装可被信任的根证书。</p><h2 id="从服务端获取的公钥如何完成信任链的验证？"><a href="#从服务端获取的公钥如何完成信任链的验证？" class="headerlink" title="从服务端获取的公钥如何完成信任链的验证？"></a>从服务端获取的公钥如何完成信任链的验证？</h2><p>CA 也拥有一个证书（内含公钥）和私钥。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。</p><h2 id="如果客户端验证服务端公钥是安全的，就用公钥加密对称加密的算法和盐值发给服务端？"><a href="#如果客户端验证服务端公钥是安全的，就用公钥加密对称加密的算法和盐值发给服务端？" class="headerlink" title="如果客户端验证服务端公钥是安全的，就用公钥加密对称加密的算法和盐值发给服务端？"></a>如果客户端验证服务端公钥是安全的，就用公钥加密对称加密的算法和盐值发给服务端？</h2><h2 id="根证书也是存在有效期的，如何更新根证书？"><a href="#根证书也是存在有效期的，如何更新根证书？" class="headerlink" title="根证书也是存在有效期的，如何更新根证书？"></a>根证书也是存在有效期的，如何更新根证书？</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84" target="_blank" rel="noopener">证书颁发机构</a></p><h2 id="RSA如何实现数字签名"><a href="#RSA如何实现数字签名" class="headerlink" title="RSA如何实现数字签名"></a>RSA如何实现数字签名</h2><p>信息发送者用其私钥对从所传报文中提取出的特征数据（或称数字指纹）进行 RSA 算法操作，以保证发信人无法抵赖曾发过该信息（即不可抵赖性），同时也确保信息报文在传递过程中未被篡改（即完整性）。当信息接收者收到报文后，就可以用发送者的公钥对数字签名进行验证。（将某个人与某人所说的话绑定在一起进行 hash，如果其中任何一项被篡改，则 hash 值就会不一致（防篡改）；通过对方的特征，如公钥，确定对方无法抵赖）</p><h2 id="什么是根证书？"><a href="#什么是根证书？" class="headerlink" title="什么是根证书？"></a>什么是根证书？</h2><p>根证书（root certificate）是属于根证书颁发机构（CA）的公钥证书，是在公开金钥基础建设中，信任链的起点。任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。</p><p>形成一个以其根证书为顶层的树状结构，在此传递关系中所有下层证书都会因为根证书可被信赖而继承信任基础。</p><p>如何完成证书的认证过程呢？就比如你去银行存钱，你看到工行有经中国人民银行认证的资质（如通过文件盖章、签名等方式），而你信任中国人民银行，因此你认定工行也是值得信任的，最后你放心的把钱存在了工行。这就是信任链关系。</p><p>使用网页浏览器造访一个网站，会执行认证路径验证演算法，使用该主机提供的电子证书，验证是否能够对应到预先安装的根证书，从而验证从根证书到终端节点的路径是否为一条有效的信任链，确保 TLS 安全连接中的身份。但是，这意味着用户信任浏览器的发布商、它所预先安装的证书颁发机构，以及这些证书颁发机构可能颁发的所有中间证书颁发机构，相信他们忠诚地确保各证书持有人的身份和意图。(从最末级的证书开始逐步认证，判断最终的证书是否符合系统内嵌的根证书)</p><h2 id="根证书是如何产生的？"><a href="#根证书是如何产生的？" class="headerlink" title="根证书是如何产生的？"></a>根证书是如何产生的？</h2><p>钥匙典礼：凭证机构自签一张新的根凭证时，需要产生一对公开金钥及私有密钥，这个过程在公证人、律师及录影系统监察下经过一系列严谨的程序，在高度防护的设施内进行。</p><p>根证书是如何被保护的？<br>根证书作为自签证书，但是获得广泛认可，通常已预先安装在各种软件（包括操作系统、浏览器、电邮软件等），作为信任链的起点，来自于公认可靠的政府机关（如香港邮政）、软件公司（如 Google、Let’s Encrypt）等，与各大软件商透过严谨的核认程序才在不同的软件广泛部署。由于部署程序复杂费时，需要行政人员的授权及机构法人身份的核认，一张根证书有效期可能长达十年以上。</p><p>我们可以在 Mac 中的 Keychain Access 中查到这些内置根证书。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gam0v5hlm3j314k0puk12.jpg" alt=""></p><p>由于根凭证在信任链中的重要角色，一旦凭证机构的私钥外泄，将可能导致整个信任链被摧毁，影响广及众多客户，所以认证机构会使用各种方法保护根凭证，例如硬体安全模组。有些储存私钥的电脑甚至平时不会连线，只在固定的排程下，经过一系列严谨的行政程式重重把关，才会取出私钥为客户签章凭证。在信任链设计中，绝大部份的根凭证都不会直接为客户签章，而是先签章一个（或多个）中继凭证，再由中继凭证为客户签章，这可以加强控管能力及控制一旦签章私钥被泄时的损失</p><p>HTTPS 会有中间人攻击（MIMT）问题吗？<br>答案是会，前提是中间人将其证书植入通讯方的主机上。我们以用户 C 与服务端 S 为例。</p><ol><li>假设C的电脑已在较早前被M安装了特定的根凭证，M拥有对应的私钥</li><li>当C尝试与S建立安全连线时，M以代理服务器的身份先行收到连线请求</li><li>M暂时搁下C的请求，转而建立另一条连线向S请求他的电子证书</li><li>S的电子证书已得到一个受广泛认可的认证机构数位签章，如果M如实转交给爱丽斯，一切都不会有问题</li><li>但M使用自己的私钥签发一个电子证书，证书上主体名称声称是属于S，并交给爱丽斯，而S不曾知道</li><li>爱丽斯验证收到的电子证书，根据其信任链，她找到签发的根证书</li><li>她发现自己的电脑中已安装并信任这样一个根证书，便信以为真，开始使用证书上的公钥与S的秘密通讯</li><li>其实该根证书就是M早前安装上去用以欺骗爱丽斯，这时M能够利用自己的私钥解密爱丽斯传出的密文，并即时再用先前收到、S真正的电子证书上的公钥再加密，并传给S</li><li>S收到密文时不虞有诈，他能够用自己的私钥解密M传送过来的密文</li></ol><p>这也就是我们使用 Charles 等抓包工具抓取 HTTPS 包时为什么要安装软件提供证书的原因了。</p><p>那么，如何避免 HTTPS 的 MIMT 呢？要避免中间人攻击置换假冒的电子证书，HTTPS 网站可以使用 <a href="https://zh.wikipedia.org/wiki/HTTP公钥固定" target="_blank" rel="noopener">HPKP</a> 指明其固定的公钥，或者通过<a href="https://zh.wikipedia.org/wiki/证书透明度" target="_blank" rel="noopener">证书透明度</a>验证证书，让中间人的欺诈证书无法使用。验证证书是否被吊销可以采用黑名单方式或者 OCSP 方式。黑名单就是定期从 CA 下载一个名单列表，里面有吊销的证书序列号，自己在本地比对一下就行，优点是效率高，缺点是不实时；OCSP 是实时连接 CA 去验证，优点是实时，缺点是效率不高。</p><p>为什么有些网站会有证书不受信任的警告？<br>最为著名的案例就是12306刚上线时的页面警告<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1galxifjtkej30ka0ex75q.jpg" alt=""></p><p>造成这个原因就是 12306 的证书是自签的，而非 CA 机构签发的，这就导致信任链条无法完成，从而发出警告。而当时 12306 对该问题的解决方案是让用户自行安装根证书<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1galxjexgofj311y0ksgqj.jpg" alt=""></p><p>在 2017 年，12306 就将证书更换了 CA 机构签发的，从而彻底解决了该问题。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1galxfssk3uj30dg07n40l.jpg" alt=""></p><p>数字签名的优势是什么？<br>数位凭证的其中一个最主要好处是在认证拥有者身分期间，拥有者的敏感个人资料（如出生日期、身分证号码等）并不会传输至索取资料者的电脑系统上。透过这种资料交换模式，拥有者既可证实自己的身分，亦不用过度披露个人资料，对保障电脑服务存取双方皆有好处。</p><p>总结<br>从 HTTPS 的流程中我们可以看到，整个认证流程是中心化的，CA 即为整个流程的中心，就像中央银行一样，一旦 CA 私钥泄露，将造成灾难性后果。如果采用去中心化该如何认证呢？我想去中心化的核心思想在于所有的参与者都清楚发生的每一件事，这样就让少数别有用心的人拒之门外，即少数服从多数。<br>正如去中心化技术的代表 Git 和区块链一样，每个参与者都有创世以来的所有操作记录，如果有人想作弊，那就要篡改掉至少 51% 的系统成员才会成功，这个成本无疑是巨大的。</p><p>在这种去中心化的模式下，缺点也是显而易见的，即每个人都要记录所有被证实的消息，而中心化则可以让参与者轻装上阵。世间安得两全法，轻量又能去中心？</p><h2 id="PGP-与-GPG-的区别"><a href="#PGP-与-GPG-的区别" class="headerlink" title="PGP 与 GPG 的区别"></a>PGP 与 GPG 的区别</h2><p>PGP 是商业软件，而 GPG 是开源软件，二者具有相同功能。</p><p>GnuPG 是一个混合加密软件程序，它使用常规对称密钥提高加密速度，使用公钥便于交换。通常使用一次性的收件人公钥用以加密会话。</p><p>TODO<br>使用 GPG， 生成密钥对<br>用公钥加密的内容能否用公钥解密<br>完成一次 HTTPS 握手过程（包括信任链的完成）<br>模拟一次CA颁发流程</p><p><a href="https://www.bilibili.com/video/av74880228" target="_blank" rel="noopener">非对称加密</a><br><a href="https://www.bilibili.com/video/av75355180" target="_blank" rel="noopener">数字签名</a></p><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E8%AF%81%E4%B9%A6" target="_blank" rel="noopener">根证书 - 维基百科</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">公钥认证 - 维基百科</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84" target="_blank" rel="noopener">证书颁发机构 - 维基百科</a></li><li><a href="https://www.yinchengli.com/2019/07/27/https-base/" target="_blank" rel="noopener">再谈 HTTPS - 会编程的猪</a></li><li><a href="https://www.zhihu.com/question/22076666/answer/69638270" target="_blank" rel="noopener">比特币是什么？ - 江卓尔的回答</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《HTTP权威指南》</title>
      <link href="/post/http-definitive-guide/"/>
      <url>/post/http-definitive-guide/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1g9w8q5c92zj30xc0hi434.jpg" alt=""></p><a id="more"></a><h1 id="第1章-HTTP-概述"><a href="#第1章-HTTP-概述" class="headerlink" title="第1章 HTTP 概述"></a>第1章 HTTP 概述</h1><p>http 通过为 web 传输的对象打上 MIME 来区分数据类型。MIME 设计之初被用于解决在不同电子邮件间移动报文时存在的问题。MIME 类型通过主要的对象类型与特定的子类型来表示，如：text/plain。完整的 MIME 类型参见<a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="noopener">Media Types - IANA</a></p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><table><thead><tr><th>状态码</th><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>1XX</td><td>Informational</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection</td><td>重定向</td></tr><tr><td>4XX</td><td>Client Error</td><td>客户端错误</td></tr><tr><td>5XX</td><td>Server Error</td><td>服务器端错误</td></tr></tbody></table><blockquote><p>业务状态码应该与 HTTP 状态码混用吗？<br>根据个人的经验，不建议这样使用。很多程序员都喜欢将200作为业务成功处理返回，代码逻辑 catch 作为 500 处理。这样导致 HTTP 状态与业务状态混乱，难以维护，比如，一个请求得到了 500 的响应，我不知道是服务器资源导致的内部错误还是我本次请求的代码逻辑错误，这增加了调试的难度。<br>个人建议以<code>0</code>作为业务码的成功响应码，大于 0 的值作为错误码，并且如 HTTP 将错误码分段处理，比如 1xxx 代表传入参数异常，2xxx 代表相关请求限制等，内部维护这样的错误关系。<br>当一个请求传入了非法参数时，http 状态码为 200，业务状态码为 1001，这样很清晰的得到网络及服务通讯正常，业务处理异常，并通过简单的提示信息进行纠错处理。<br>在错误状态返回时，还需要有相应简洁的错误描述，以及纠错处理，而且在给普通用户显示代码逻辑错误时，应当重点展示错误码，因为文字很容易在表述过程中偏离其含义，错误码则有效解决了该问题。关于错误码，微信公众号的开发文档就有很好的示例，可<a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Global_Return_Code.html" target="_blank" rel="noopener">点击此处</a>查看。</p></blockquote><p>我应该使用 RESTful 开发吗？<br>我认为每个标准接口都应该是 RESTful 的。很多开发者可能只用到<code>GET</code>或者<code>POST</code>，或者一个<code>POST</code>走天下。这种开发习惯会导致接口语义不清，代码耦合，HTTP 中的多种请求方式可以更加清晰的解决该问题，如<code>PUT</code>用于表示创建资源，<code>GET</code>表示获取资源，且该请求允许是幂等的，<code>DELETE</code>表示删除资源，<code>POST</code>表示修改资源，将所有的请求糅合在一个<code>POST</code>中，显然不是一种良好的设计实现。</p><p>HTTP 与 HPPTS 网络协议栈<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9wbf070kyj30ej06igm3.jpg" alt=""></p><h2 id="Web的结构组件"><a href="#Web的结构组件" class="headerlink" title="Web的结构组件"></a>Web的结构组件</h2><ul><li>代理<ul><li>代理的作用有：①隐藏真实访问者，如匿名代理；②实现流量的控制与分析，如通过代理控制某些网站的访问</li></ul></li><li>缓存</li><li>网关<ul><li>在局域网通过路由接入网络的环境中，网关指用于连接局域网和 Internet。网关也常指把一种协议封装为另一种协议的设备，如语音网关。</li></ul></li><li>隧道</li><li>Agent 代理<ul><li>如搜索引擎的爬虫</li></ul></li></ul><h1 id="第2章-URL-与资源"><a href="#第2章-URL-与资源" class="headerlink" title="第2章 URL 与资源"></a>第2章 URL 与资源</h1><h2 id="URL-的各种形式"><a href="#URL-的各种形式" class="headerlink" title="URL 的各种形式"></a>URL 的各种形式</h2><p>大多数的URL语法都建立在<code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code>的通用格式上，但最重要的三个部分是由<code>scheme://host/path</code>组成。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http</span>:<span class="comment">//www.example.com:80</span></span><br><span class="line"><span class="attribute">ftp</span>:<span class="comment">//ftp.example.com</span></span><br><span class="line"><span class="attribute">ssh</span>:<span class="comment">//example.github.com</span></span><br><span class="line"><span class="attribute">mailto</span>:username<span class="variable">@example</span>.com</span><br></pre></td></tr></table></figure><p>对于一个 GET 请求<code>http://www.example.com/index.php?item=1245&amp;color=blue</code>，我们应该如何理解呢？<br>该 URL 中的<code>?</code>表示向服务器询问/查询，查询什么呢？编号为 12456 和颜色为蓝色的商品，这样我们就能从 URL 中获得清晰的语义了。</p><h1 id="第3章-HTTP-报文"><a href="#第3章-HTTP-报文" class="headerlink" title="第3章 HTTP 报文"></a>第3章 HTTP 报文</h1><h2 id="常用的-HTTP-方法"><a href="#常用的-HTTP-方法" class="headerlink" title="常用的 HTTP 方法"></a>常用的 HTTP 方法</h2><table><thead><tr><th>方法</th><th>描述</th><th>是否包含主体</th></tr></thead><tbody><tr><td><code>GET</code></td><td>从服务器获取内容</td><td>否</td></tr><tr><td><code>POST</code></td><td>向服务器发送需要处理的数据</td><td>是</td></tr><tr><td><code>PUT</code></td><td>将请求主体内容存储在服务器中</td><td>是</td></tr><tr><td><code>DELETE</code></td><td>从服务器删除文件</td><td>否</td></tr><tr><td><code>HEAD</code></td><td>只从服务器获取文档的首部</td><td>否</td></tr><tr><td><code>TRACE</code></td><td>对可能经过代理服务器传送到服务器上的报文进行追踪</td><td>否</td></tr><tr><td><code>OPTIONS</code></td><td>决定可以在服务器上执行哪些方法</td><td>否</td></tr></tbody></table><p> POST 与 PUT 的不同之处在于，PUT 表示对资源进行整体覆盖，而 POST 则表示对资源的部分修改。</p><p>HEAD 允许客户端在未获取实际资源的情况下，对资源的首部进行检查。我们可以利用 HEAD 来实现：</p><ul><li>在不获取资源的情况下了解资源的情况，如判断资源类型</li><li>通过查看响应中的状态码，判断某个对象是否存在</li><li>通过查看首部，测试资源是否被修改</li></ul><p>客户端发起一个请求时，这个请求额能要穿过防火墙、代理、网关或者其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求，TRACE 允许客户端在最终请求发送给服务器时，查看请求的变化。</p><h2 id="常用-HTTP-状态码"><a href="#常用-HTTP-状态码" class="headerlink" title="常用 HTTP 状态码"></a>常用 HTTP 状态码</h2><ul><li>301：代表资源被永久移除，响应的 Location 首部中应该包含资源现在所处的 URL。</li><li>302：代表资源被临时移除（临时重定向）</li><li>304：代表自从上次请求后，服务端资源未发生变化，可以直接从本地缓存加载，避免带宽的浪费。</li><li>401：当前请求未被认证，可作为业务状态码，</li><li>403：请求不被允许。如用户无权限访问某个资源</li><li>404：请求的资源未找到</li><li>405：不支持的请求方法，如使用 TRACE 方法请求。使用此状态码时，应该在响应中包含 Allow 首部，以告知客户端对所请求的资源允许的方法</li><li>408：请求超时</li><li>500：服务器内部错误。建议仅在意外时使用，此时需要人工介入修复。</li><li>502：网关错误</li><li>503：服务不可用</li><li>504：网关超时</li></ul><h2 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h2><p>HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型</p><ul><li>端对端首部(End-to-end)：分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在有缓存生成的响应中，另外规定它必须被转发</li><li>逐跳首部(Hop-by-hop)：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。</li></ul><p>在 HTTP 1.1 中，除了<code>Connection</code>、<code>Keep-Alive</code>、<code>Proxy-Authenticate</code>、<code>Proxy-Authorization</code>、<code>Trailer</code>、<code>TE</code>、<code>Transfer-Encoding</code>、<code>Upgrade</code>等 8 个逐跳首部外，其余都是端对端首部。</p><h3 id="Connection-首部"><a href="#Connection-首部" class="headerlink" title="Connection 首部"></a>Connection 首部</h3><ul><li>控制不再转发给代理的首部字段。在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。</li><li>管理持久连接。HTTP/1.1 版本的默认连接都是持久连接。当服务器想明确断开连接时，则指定 Connection 首部字段的值为 Close。HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接，则需要指定 Connection 首部字段的值为 Keep-Alive。</li></ul><h3 id="Accept-首部"><a href="#Accept-首部" class="headerlink" title="Accept 首部"></a>Accept 首部</h3><table><thead><tr><th>首部</th><th>描述</th></tr></thead><tbody><tr><td><code>Accept</code></td><td>可处理的媒体类型</td></tr><tr><td><code>Accept-Charset</code></td><td>可处理的字符集</td></tr><tr><td><code>Accept-Encoding</code></td><td>可处理的编码方式</td></tr><tr><td><code>Accept-Language</code></td><td>可处理的语言</td></tr></tbody></table><h3 id="Upgrade-首部"><a href="#Upgrade-首部" class="headerlink" title="Upgrade 首部"></a>Upgrade 首部</h3><p>用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><h3 id="Via-首部"><a href="#Via-首部" class="headerlink" title="Via 首部"></a>Via 首部</h3><p>Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。<br>Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使用。</p><h3 id="条件请求首部"><a href="#条件请求首部" class="headerlink" title="条件请求首部"></a>条件请求首部</h3><table><thead><tr><th>首部</th><th>描述</th></tr></thead><tbody><tr><td><code>Expect</code></td><td></td></tr><tr><td><code>If-Match</code></td><td>若匹配则获取该资源</td></tr><tr><td><code>If-Modified-Since</code></td><td>若从某个时间后修改则获取</td></tr><tr><td><code>If-None-Match</code></td><td>若不匹配则获取</td></tr><tr><td><code>If-Range</code></td><td>指定范围获取</td></tr><tr><td><code>If-Unmodified-Since</code></td><td>若从某个时间后未修改则获取</td></tr></tbody></table><h3 id="内容首部"><a href="#内容首部" class="headerlink" title="内容首部"></a>内容首部</h3><table><thead><tr><th>首部</th><th>描述</th></tr></thead><tbody><tr><td><code>Content-Encoding</code></td><td>主体的编码方式，如 gzip</td></tr><tr><td><code>Content-Language</code></td><td>主体的最佳语言</td></tr><tr><td><code>Content-Length</code></td><td>主体的长度或尺寸</td></tr><tr><td><code>Content-Location</code></td><td>资源实际位置</td></tr><tr><td><code>Content-Type</code></td><td>该主体的对象类型</td></tr><tr><td><code>Content-Range</code></td><td>在整个资源中此实体表示的字节范围</td></tr></tbody></table><h1 id="第4章-连接管理"><a href="#第4章-连接管理" class="headerlink" title="第4章 连接管理"></a>第4章 连接管理</h1><p>TCP 连接通过&lt;source ip, source port, destn ip, destn port&gt; 唯一定义一个连接。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gacjkgnhr4j30wo0u04ho.jpg" alt=""></p><p>单个 HTTP 时延如下图：<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gacjzsn0wnj31780fidkv.jpg" alt=""></p><p>从图中我们可以看到，与TCP 的建立、传输请求与响应报文相比，事务处理的时间很短。造成 HTTP 时延的主要原因有：</p><ul><li>DNS 解析</li><li>TCP 连接的建立</li><li>服务端对请求的处理</li></ul><p>常见的影响 TCP 时延的因素包括：</p><ul><li>TCP 连接建立握手</li><li>TCP 慢启动拥塞控制<ul><li>TCP 连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据传输成功，会随着时间的推移提高传输的速度。该调谐即为 TCP 慢启动，用于防止因特网的突然过载和拥塞。</li></ul></li><li>数据聚集的 Nagle 算法<ul><li>该算法让数据在缓冲到一定尺寸后发送，若大量小块数据则会造成严重的延时。当确保向 TCP 写入大块数据时，可以禁用 Nagle 算法</li></ul></li><li>用于捎带确认的 TCP 延迟确认算法<ul><li>若在指定时间窗口内未收到确认分组，则重新发送分组数据。由于分组数据较少，因此在某个时间窗口内存放于缓冲区，待区满后发送；时间窗口内未满则单独发送。</li></ul></li><li>TIME_WAIT 时延和端口耗尽</li></ul><p>根据以上情况，我们可得到优化的方向：</p><ul><li>将多个请求进行合并，避免频繁建立连接</li><li>优化 TCP，加速连接的建立</li></ul><h2 id="TIME-WAIT-与-CLOSE-WAIT"><a href="#TIME-WAIT-与-CLOSE-WAIT" class="headerlink" title="TIME_WAIT 与 CLOSE_WAIT"></a>TIME_WAIT 与 CLOSE_WAIT</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gade8xlrirj30kc0fnq44.jpg" alt=""><br>从上图我们可以看到，TIME_WAIT 出现在主动关闭方，CLOSE_WAIT 则出现在被动关闭方（两个通话结束的人，先挂断电话的一方进入TIME_WAIT，另一方则进入CLOSE_WAIT）。</p><h3 id="TIME-WAIT-产生的场景"><a href="#TIME-WAIT-产生的场景" class="headerlink" title="TIME_WAIT 产生的场景"></a>TIME_WAIT 产生的场景</h3><p>基于 TCP 的 HTTP 协议，一般由服务端主动关闭 TCP（keepalive 时间内客户端主动关闭则是客户端进入 TIME_WAIT），这样服务端就会进入 TIME_WAIT 状态。当服务端出现大量请求时，就会产生大量的 TIME_WAIT 状态。如果堆积的大量TIME_WAIT不及时处理，可能会造成服务端无法接收新的请求。</p><h3 id="CLOSE-WAIT-产生的场景"><a href="#CLOSE-WAIT-产生的场景" class="headerlink" title="CLOSE_WAIT 产生的场景"></a>CLOSE_WAIT 产生的场景</h3><p>爬虫运行在 A 主机，向 B 主机采集数据，但是 A 很快就发现出现了大量的 CLOSE_WAIT 状态的连接，经检查发现这些处于 CLOSE_WAIT 状态的请求结果都是 404。这是由于，在 404 的状态下，B 主动关闭了连接，A 进入了CLOSE_WAIT，如果 A 的程序中未能释放 HTTP 连接，则造成了CLOSE_WAIT。</p><blockquote><p>小疑惑：TIME_WAIT 与 CLOSE_WAIT 是成对出现的，即通信是由双方完成的，因此，其中一方出现了TIME_WAIT 或 CLOSE_WAIT，则另一方必然出现与之对立的状态。</p></blockquote><h3 id="为什么需要TIME-WAIT-与-CLOSE-WAIT-呢？"><a href="#为什么需要TIME-WAIT-与-CLOSE-WAIT-呢？" class="headerlink" title="为什么需要TIME_WAIT 与 CLOSE_WAIT 呢？"></a>为什么需要TIME_WAIT 与 CLOSE_WAIT 呢？</h3><p>当一个 socket 关闭的时候，是通过两端四次握手完成的，当一端调用 close() 时，就说明本端没有数据要发送了。这好似看来在握手完成以后，socket 就都可以处于初始的 CLOSED 状态了，其实不然。原因是这样安排状态有两个问题，首先，我们没有任何机制保证最后的一个 ACK 能够正常传输，第二，网络上仍然有可能有残余的数据包（残留的数据包经2MSL时间丢弃），我们也必须能够正常处理。</p><h3 id="如果已经进入TIME-WAIT-与-CLOSE-WAIT连接，这个连接接下来会被怎样处理呢？"><a href="#如果已经进入TIME-WAIT-与-CLOSE-WAIT连接，这个连接接下来会被怎样处理呢？" class="headerlink" title="如果已经进入TIME_WAIT 与 CLOSE_WAIT连接，这个连接接下来会被怎样处理呢？"></a>如果已经进入TIME_WAIT 与 CLOSE_WAIT连接，这个连接接下来会被怎样处理呢？</h3><p>目前优化 HTTP 资源加载速度的方式有</p><ul><li>并行连接<ul><li>并行连接适用于总数较小（通常是 4 个）的情况，如果一个页面有 100 个图片，使用并行的方式处理的话，每个客户端要打开 100 个连接，100 个用户的请求，服务器则需要处理 10000 个连接，这造成了服务器性能的严重下降。请勿滥用并行连接。</li><li>并行连接的缺点<ul><li>每个事务都会打开/关闭一条新的连接，会耗费时间和宽带</li><li>由于 TCP 慢启动特性的存在，每条新的连接性能都会有所降低</li><li>可打开的并行连接数量实际上是有限的</li></ul></li></ul></li><li>持久连接<ul><li>由于初始化了对某服务器 HTTP 请求的应用程序很可能会在不久的将来对那台服务器发起更多的请求（站点局部性 site locality），因此持久连接适用于对同一个站点多次获取资源（如 12306 购票？淘宝购物？）。</li><li>重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段。而且，已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。</li><li>管理持久连接时要特别小心，避免出现大量空闲连接，耗费本地及远程客户端和服务器的资源</li><li><strong>在 HTTP 1.1 中，持久连接时默认激活的， 主动关闭连接时向报文中显示添加<code>Connection: close</code></strong>。客户端与服务器仍可以随时关闭空闲连接，并非不发送 close 就永久保持连接。</li><li>一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以免服务器过载。</li></ul></li><li>管道化连接<ul><li>如果HTTP客户端无法确认连接是持久的，就不应该使用管道。</li><li>必须按照与请求相同的顺序回送HTTP响应。</li><li>HTTP客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接，并立即发出了10条请求，服务器可能在处理5条请求之后关闭连接。剩下的5条请求会失败，客户端必须能够应对这些过早关闭连接的情况，重新发出这些请求。</li><li>HTTP客户端不应该用管道化的方式发送会产生副作用的请求(比如POST).总之，出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试POST这样的非幕等请求，所以出错时，就存在某些方法永远不会被执行的风险。</li></ul></li></ul><p>如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部，若响应中没有 <code>Connection: Keep-Alive</code> 首部，客户端就认为服务器不支持 keep-alive，会在发回响应报文之后关闭连接。<code>Keep-Alive:  max=5, timeout=120</code>首部中的值都仅仅是预估值，并不是承诺值，即，虽然声明服务器可能保持活跃状态在120s 内，但可能 20s 就关闭了。</p><p>现代代理不应该转发的一些HTTP首部包括：Connection,  Proxy-Authenticate, Proxy-Connection, Transfer-Encoding 和 Upgrade。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gadn0sgnwmj30u00usncj.jpg" alt=""></p><h2 id="关于连接关闭"><a href="#关于连接关闭" class="headerlink" title="关于连接关闭"></a>关于连接关闭</h2><p>所有 HTTP 客户端、服务器或代理都可以在任意时刻关闭一条 TCP 传输连接。在持久连接空闲一段时间之后，服务器可能会决定将其关闭。但是，服务器永远都无法确定在它关闭“空闲”连接的那一刻，在线路那一头的客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现了连接错误。</p><p>每条HTTP响应都应该有精确的<code>Content-Length</code>首部，用以描述响应主体的尺寸。客户端或代理收到一条随连接关闭而结束的HTTP响应，且实际传输的实体长度与<code>Content-Length</code>并不匹配(或没有<code>Content -Length</code>)时，接收端就应该质疑长度的正确性。如果接收端是个缓存代理，接收端就不应该缓存这条响应(以降低今后将潜在的错误报文混合起来的可能)。代理应该将有问题的报文原封不动地转发出去，而不应该试图去“校正”<code>Content-Length</code>，以维护语义的透明性。</p><p>即使在非错误情况下，连接也可以在任意时刻关闭。HTTP应用程序要做好正确处理非预期关闭的准备。如果在客户端执行事务的过程中，传输连接关闭了，那么，除非事务处理会带来一些副作用，否则客户端就应该重新打开连接，并重试一次。对管道化连接来说，这种情况更加严重-些。客户端可以将大量请求放入队列中排队，但源端服务器可以关闭连接，这样就会留下大量未处理的请求，需要重新调度。副作用是很重要的问题。如果在发送出一些请求数据之后，收到返回结果之前，连接关闭了，客户端就无法百分之百地确定服务器端实际激活了多少事务。有些事务，比如GET一个静态的HTML页面，可以反复执行多次，也不会有什么变化。而其他一些事务，比如向一个在线书店POST一张订单，就不能重复执行，不然会有下多张订单的危险。</p><p>TCP 是双向的，TCP 连接的每一端都有一个输入队列和一个输出队列，用于数据的读或者写。如果另一端向你已关闭的输入信道发送数据，操作系统就会向另一端的机器回送一条 TCP“连接被对端重置”的报文。实现正常关闭的应用程序首先应该关闭它们的输出信道，然后等待连接另一端的对等实体关闭它的输出信道。当两端都告诉对方它们不会再发送任何数据(比如关闭输出信道)之后，连接就会被完全关闭，而不会有重置的危险。</p><h1 id="第5章-Web-服务器"><a href="#第5章-Web-服务器" class="headerlink" title="第5章 Web 服务器"></a>第5章 Web 服务器</h1><p>服务器的工作流程：</p><ol><li>建立连接 - 接受一个客户端连接，不希望建立连接则关闭</li><li>接收请求 - 从网络中读取一条 HTTP 请求报文</li><li>处理请求 - 对请求报文进行解释，并采取行动</li><li>访问资源 - 访问报文中指定的资源</li><li>构建响应 - 创建带有正确首部的 HTTP 响应报文</li><li>发送响应 - 将响应回送给客户端</li><li>记录事务处理过程 - 将与已完成事务有关的内容记录在一个日志文件中</li></ol><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gadpha81d0j30ks0cqdjj.jpg" alt=""></p><h1 id="第6章-代理"><a href="#第6章-代理" class="headerlink" title="第6章 代理"></a>第6章 代理</h1><h2 id="为什么使用代理"><a href="#为什么使用代理" class="headerlink" title="为什么使用代理"></a>为什么使用代理</h2><ul><li>儿童过滤器</li><li>文档访问控制</li><li>安全防火墙</li><li>Web 缓存</li><li>反向代理</li><li>内容路由器</li><li>转码器</li><li>匿名性<ul><li>匿名代理会主动从 HTTP 报文中删除身份特性，如客户端 IP，From 首部，Referer 首部，cookie，URI 回话 ID 等，从而提供高度私密性和匿名性。</li></ul></li></ul><p>Via 首部字段列出了与报文途经的每个中间节点（代理或网关）有关的信息。</p><h1 id="第7章-缓存"><a href="#第7章-缓存" class="headerlink" title="第7章 缓存"></a>第7章 缓存</h1><p>缓存的优点：</p><ul><li>减少了冗余的数据传输</li><li>缓解了网络瓶颈的问题</li><li>降低了对原始服务器的要求</li><li>降低了距离时延</li></ul><p>缓存的缺点：</p><ul><li>未及时更新的缓存造成信息滞后，如抢购时的库存缓存可能导致超售</li><li>缓存会占用空间资源</li></ul><p>过期日期以<code>Expires</code>或<code>Cache-Control: max-age=86400</code>来控制，二者的区别在于，前者是一个绝对时间，如 <code>Expires: Fri, 05 Jul 2002, 05:00:00 GMT</code>，后者则是一个相对时间（单位为秒）。我们更推荐使用相对时间，因为绝对时间依赖于计算机时钟的正确设置。</p><h1 id="第8章-集成点：网关、隧道及中继"><a href="#第8章-集成点：网关、隧道及中继" class="headerlink" title="第8章 集成点：网关、隧道及中继"></a>第8章 集成点：网关、隧道及中继</h1><p>Web 隧道允许用户通过 HTTP 连接发送非 HTTP 流量，这样就可以在 HTTP 上捎带其它协议数据了。使用 Web 隧道最常见的原因就是要在 HTTP 连接中嵌入非 HTTP 流量，这样，这类流量就可以穿过只允许 Web 流量通过的防火墙了。</p><p>Web 隧道是通过 HTTP 的 CONNECT 方法建立起来的。</p><p>盲中继可能导致 keep-alive 的挂起<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaeqdw9524j318s0gsqcf.jpg" alt=""></p><h1 id="第9章-Web-机器人"><a href="#第9章-Web-机器人" class="headerlink" title="第9章 Web 机器人"></a>第9章 Web 机器人</h1><h2 id="爬虫的工作流"><a href="#爬虫的工作流" class="headerlink" title="爬虫的工作流"></a>爬虫的工作流</h2><p>爬虫从根集开始，爬取所需的大多数页面，在以下的示例中，根集只需要 A、G、S 即可抓取到所有页面。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaervii1rjj30zu0eq42u.jpg" alt=""></p><p>爬虫在 Web 上移动时，会不停地对 HTML 页面进行解析，它要对所解析的每个页面上的 URL 链接进行分析，并将这些链接添加到需要爬行的页面列表中去。随着爬虫的前进，当期发现需要探查的新链接时，这个列表常常会迅速地扩张。爬虫要通过简单的 HTML 解析，将这些链接提取出来，并将相对 URL 转换为绝对形式。</p><h2 id="循环陷阱"><a href="#循环陷阱" class="headerlink" title="循环陷阱"></a>循环陷阱</h2><p>爬虫在抓取页面时，要特别小心不要陷入循环。爬虫必须知道它们所到之处，以避免环路的出现。一些复杂的爬虫可能会用搜索树或散列表来记录已访问的 URL。</p><p>大型爬虫会采用“集群”的方式，每个爬虫分配一个特定的 URL“片”，然后配合抓取整个 Web。</p><p>别名与机器人环路<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaesvn44oaj31a20i6k3z.jpg" alt=""></p><p>解决循环陷阱的方法</p><ul><li>规范化 URL<ul><li>如果没有指定端口的话，就像主机名中添加”:80”</li><li>将所有转义符 %xx 都转换成等价字符</li><li>删除 # 标签</li></ul></li><li>广度优先的爬行<ul><li>如果采用了深度优先，很有可能会陷入循环，无法访问其它站点</li></ul></li><li>节流<ul><li>限制一段时间内机器人可以从一个 web 站点获取的页面数量</li></ul></li><li>限制 URL 的大小<ul><li>现在很多站点都会用 URL 来管理用户的状态（如，在一个页面引用的 URL 中存储用户 ID），这可能会让你错过一些东西</li></ul></li><li>URL/站点黑名单</li><li>模式检测</li><li>内容指纹<ul><li>将采集的内容计算校验和，避免重复采集</li></ul></li><li>人工监视<ul><li>当爬虫遇到困难时可以及时发出警告</li></ul></li></ul><p>高级爬虫只在内容发生了变化时才重新获取内容，它们实现了条件 HTTP 请求，即它们会对时间戳或实体标签进行比较，查看最近的内容是否发生变化。</p><p>Web 管理者应该记住，不止用户会访问站点，也会有很多爬虫来访问站点。</p><h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p>如果网站不希望爬虫采集某些页面，可以在根目录下放置<code>robots.txt</code>文件（因为一些系统中的 URL 是大小写敏感的，所以 robots.txt 的文件名应统一为小写），声明哪些是允许抓取的，哪些是不允许抓取的，如<a href="https://www.baidu.com/robots.txt" target="_blank" rel="noopener">百度的robots.txt</a>，<a href="https://cn.bing.com/robots.txt" target="_blank" rel="noopener">必应的 robots.txt</a>，<a href="https://www.zhihu.com/robots.txt" target="_blank" rel="noopener">知乎的robots.txt</a>。该文件并不是规范，只能限制遵循规则的爬虫，并不代表声明禁止抓取的内容一定不会被抓取。</p><p>爬虫应该首先访问 robots.txt 文件，并根据该文件状态和内容来决定最终的访问。即该文件是 401 或 403 时，表明该网站受限；503 时，表明该网站当前不可用，应推迟访问；404 则表示无任何限制；200 则需要依据文件内容访问网站。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>当你在搜索引擎中键入关键字时，可能会有数以亿计的文件中包含该关键字，因此，如何对这些文件排序成为了各搜索引擎的关键。通常来说，用户会点击排名靠前的搜索结果，如何才能让用户最快找到自己想要的呢？很多搜索引擎会将页面的被引用次数作为重要的排名依据，被引用越多，说明该页面价值也高，用户也最可能得到想要的东西。</p><p>部分网站为了获取较高的排名，列出了无数的关键字，甚至有些是毫不相干的，因此需要爬虫能够及时识别并过滤此类页面。</p><h1 id="第10章-HTTP-NG"><a href="#第10章-HTTP-NG" class="headerlink" title="第10章 HTTP-NG"></a>第10章 HTTP-NG</h1><h1 id="第11章-客户端识别与-cookie-机制"><a href="#第11章-客户端识别与-cookie-机制" class="headerlink" title="第11章 客户端识别与 cookie 机制"></a>第11章 客户端识别与 cookie 机制</h1><p>为了使 Web 站点的登陆更加简便，HTTP 中包含了一种内建机制，可以用 WWW-Authenticate 首部和 Authorization 首部向 Web 站点传送用户的相关信息。</p><p>本章 cookie内容较为简单且已过时，需要当前的浏览器与开发框架对 cookie 的处理及管理，以及未来如何更加准确识别用户，并让保证用户的信息不会被泄露。当前缓解用户在每个网站注册账户的方式是引入用户的社交账户登录，未来是否可以让所有用户以统一方式登录所有网站，而且这些网站获取不到用户的真实信息，eID 或许是未来的一个方向。</p><h1 id="第12章-基本认证机制"><a href="#第12章-基本认证机制" class="headerlink" title="第12章 基本认证机制"></a>第12章 基本认证机制</h1><p>服务器对用户进行质询时，会返回一条 401 响应，并在<code>WWW-Authenticate</code>首部说明如何以及在哪里认证，如以下示例。其中，<code>realm</code>是安全域，帮助用户了解应该使用哪个账号密码（不同资源有不同的访问权限，每个安全域都有不同的授权用户集）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">WWW-Authenticate</span>: Basic realm="Corporate Financials"</span><br></pre></td></tr></table></figure><p>当客户端收到 401 时，填写账号密码后，会在<code>Authorization</code>首部附加经 base64 编码的<code>账号:密码</code>形式的认证信息。如以下请求的认证信息即为<code>username:passowrd</code>的编码结果。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gafqe4gnp4j30t40kgn03.jpg" alt=""></p><p>从基本认证的工作流中我们可以看到，用户的账号密码几乎就是明文传输的，这造成了很大的安全隐患，安全使用基本认证的唯一方式就是将其与 SSL 配合使用。</p><h1 id="第13章-摘要认证"><a href="#第13章-摘要认证" class="headerlink" title="第13章 摘要认证"></a>第13章 摘要认证</h1><p>摘要认证的箴言是“绝不通过网络发送密码”。客户端不会发送密码，而是会发送一个“指纹”或密码的“摘要”，这是密码的不可逆扰码。客户端和服务器都知道这个密码，因此服务器可以验证所提供的摘要是否与密码相匹配。（某公司的 X5 协议）</p><p>摘要是“对信息主体的浓缩”。摘要是一种单向函数，主要用于将无限的输入值转换为有限的浓缩输出值。常见的摘要函数有 MD5、SHA-1、SHA-2 等。</p><p>为了防止重放攻击，服务器可以向客户端发送一个称为随机数（nonce）的特殊令牌，这个数会经常发生变化（可能是每毫秒，或者是每次认证都变化）。客户端在计算摘要之前要先将这个随机数令牌附加到密码上去。<strong>摘要认证要求使用随机数来破坏重放攻击</strong>，因为这个小小的重放弱点会使未随机化的摘要认证变得和基本认证一样脆弱，随机数是在<code>WWW-Authenticate</code>质询中从服务器传送给客户端的。</p><p>随机数过期时，即便老的<code>Authorization</code>首部所包含的随机数不再新鲜了，服务器也可以选择接受其中的信息。服务器也可以返回一个带有新随机数的 401 响应，让客户端重试这条请求；指定这个响应为<code>stale=true</code>，表示服务器在告知客户端用新的随机数来重试，而不再重新提示输入新的用户名和密码了。（参照微信公众号的 token 过期处理方式）</p><p>RFC 2617 建议采用这个假想的随机数公式：<code>BASE64(time-stamp H(time-stamp &quot;:&quot; ETag &quot;:&quot; private-key))</code>。其中 time-stamp 是服务器产生的时间或其他不会重复的值，ETag 是与所请求实体有关的 HTTP ETag 首部的值，private-key 是只有服务器知道的数据。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gakjg3ndflj30mn0m3qbk.jpg" alt=""></p><p>在实际应用中，我们需要考虑到服务器可以对某个资源发起多重质询。比如，如果服务器不了解客户端的能力，就可以既提供基本认证质询，又提供摘要认证质询。客户端面对多重质询时，必须以它所支持的最强的质询机制来应答。另外，如果请求的摘要不匹配，就应该记录一次登录失败。某客户端连续多次失败可能说明有攻击者正在猜测密码。</p><p>一种可以完全避免重放攻击的方法就是为每个事务都使用一个唯一的随机数。在这种实现方式中，服务器会为每个事务发布唯一的随机数和一个超时值。发布的随机数只对指定的事务有效，而且只在超时值的持续区间内有效。这种方式会增加服务器的负担，但这种负担可忽略不计。</p><p>nonce 用于认证客户端，cnonce 用于认证服务端。</p><h1 id="第14章-安全-HTTP"><a href="#第14章-安全-HTTP" class="headerlink" title="第14章 安全 HTTP"></a>第14章 安全 HTTP</h1><p>安全 HTTP 需要满足</p><ul><li>服务器认证。服务单不会被伪造</li><li>客户端认证。客户端不会被伪造</li><li>完整性。数据不会被修改</li><li>加密。通信内容加密</li><li>效率。足够快的算法</li><li>普适性。基本上所有的客户端和服务器都支持这些协议</li><li>管理的可扩展性。在任何地方的任何人都可以立即进行安全通信</li><li>适应性。能够支持当前最知名的安全方法</li><li>在社会上的可行性</li></ul><p>早期，人们使用密码机加解密，加密算法和密码机都有可能落入敌人手中，所以大部分机器上都有一些号盘，可以将其设置为大量不同的值以改变密码的工作方式，即使机器被盗，没有正确的号盘设置（密钥），解码器也无法正常工作。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>在对称加密技术中，发送端与接收端要共享相同的密钥才能进行通信。常见的对称加密算法有：AES、3DES、DES(已被证明不安全)等。</p><p>可用密钥值的数量取决于密钥中的位数，以及可能的密钥中有多少是有效的。就对称密钥加密技术来说，通常所有的密钥值都是有效的（RSA 中，有效密钥必须以某种方式与质数相关）。8位的密钥只有256个可能的密钥值，40位的密钥可以有2^40个可能的密钥值(大约是-万亿个密钥)，128 位的密钥可以产生大约 3.4*10^38 个可能的密钥值。</p><p>在对称加密中，如果服务器与 100 万个用户进行安全会话，就需要维护 100 万个密钥，这无疑是一笔不小的开销。公开密钥技术避免了对称加密技术中成对密钥数目的 N^2 扩展问题。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。</p><p>用户若欲取得证书，应先向 CA 提出申请，CA 判明申请者的身份后，为之分配一个公钥，并将该公钥与其身份信息绑定，为该整体签字，签字后的整体即为证书，发还给申请者。(<a href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84</a>)</p><p><a href="https://www.bilibili.com/video/av74880228" target="_blank" rel="noopener">非对称加密</a><br><a href="https://www.bilibili.com/video/av75355180" target="_blank" rel="noopener">数字签名</a></p><h1 id="第15章-实体和编码"><a href="#第15章-实体和编码" class="headerlink" title="第15章 实体和编码"></a>第15章 实体和编码</h1><p>每天都有数以亿计的各种媒体对象经由 HTTP 发送，HTTP 要确保它所承载的“货物”满足以下条件：</p><ul><li>可以被正确地识别（Content-type 说明媒体格式，Content-Language 说明语言），以便浏览器等正确处理内容</li><li>可以被正确地几包（Content-Length 和 Content-Encoding）</li><li>是最新的（通过实体验证码和缓存过期控制）</li><li>符合用户的需要（基于 Accept 系列的内容协商首部）</li><li>在网络上可以快速有效地传输（通过范围请求、差异编码以及其他数据压缩方法）</li><li>完整到达、未被篡改（通过传输编码首部和 Content-MD5 校验和首部）</li></ul><h1 id="第16章-国际化"><a href="#第16章-国际化" class="headerlink" title="第16章 国际化"></a>第16章 国际化</h1><h1 id="第17章-内容协商与转码"><a href="#第17章-内容协商与转码" class="headerlink" title="第17章 内容协商与转码"></a>第17章 内容协商与转码</h1><h1 id="第18章-Web-主机托管"><a href="#第18章-Web-主机托管" class="headerlink" title="第18章 Web 主机托管"></a>第18章 Web 主机托管</h1><h1 id="第19章-发布系统"><a href="#第19章-发布系统" class="headerlink" title="第19章 发布系统"></a>第19章 发布系统</h1><h1 id="第20章-重定向与负载均衡"><a href="#第20章-重定向与负载均衡" class="headerlink" title="第20章 重定向与负载均衡"></a>第20章 重定向与负载均衡</h1><h1 id="第21章-日志记录与使用情况跟踪"><a href="#第21章-日志记录与使用情况跟踪" class="headerlink" title="第21章 日志记录与使用情况跟踪"></a>第21章 日志记录与使用情况跟踪</h1><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">HTTP - MDN</a></li><li><a href="https://httpstatuses.com/" target="_blank" rel="noopener">HTTP Status</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" target="_blank" rel="noopener">HTTP request methods - MDN</a></li><li><a href="https://www.zhihu.com/question/28469005/answer/40934178" target="_blank" rel="noopener">请求参数用string好还是数字好？ - Ivony的回答</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自然传奇</title>
      <link href="/post/nature-legend/"/>
      <url>/post/nature-legend/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1g9o8l03ynoj30u00gvq9c.jpg" alt=""></p><a id="more"></a><p>在优胜劣汰的自然法则面前，一切力量都显得太过渺小羸弱——刚出生的角马就要躲避狮子的追捕，洄游产卵的鱼群要经过九死一生，无法争得领地的雄性只能孤独终老，因生病或受伤而丧失捕食能力的动物只能面临被捕食或者饿死的命运。</p><p>但各种物种的生存技能又令人惊叹不已——飞鱼为躲避追击，跃出水面滑翔数百米；海豚为了捕食，团队合作搅拌淤泥驱赶鱼群；变色龙作为伪装大师让自己“隐身”，非洲野犬通过协作捕杀数倍于自己的猎物。</p><p>在自然世界里，充满了伪装、狡诈、残酷、合作、温情，令人惊心动魄的生死逃亡在时刻上演，令人动容的故事也不会被我们所遗忘，它们所有的努力都只是为了生命的延续。</p><p>小时候我在想，为什么我是一个人，而不是一直蚂蚁，一条蚯蚓？我为什么是我，而不是你，或者他？我终究还是没能找到答案，在思索中沉沉睡去。现在，我庆幸自己是人类，而且是在一个安定的强国中，至少在文明的社会里，生存不用那么血腥残暴，我不会因为骨折而被淘汰，不用时刻担心掠食者的突然出现。</p><p>在浩瀚的宇宙中，适宜生命的星球是少之又少，而在<a href="http://timelineofearth.com/" target="_blank" rel="noopener">地球亿万年</a>间，生物群发生多次的灭绝与复苏，气候环境剧烈变化，说不定哪次的物种灭绝就会导致地球不再适宜生命，能产生适宜人类生存的环境概率真的比中彩票的概率还要低的多。迄今为止，地球已经发生了五次大规模物种<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E9%9B%86%E7%BE%A4%E7%81%AD%E7%BB%9D" target="_blank" rel="noopener">灭绝事件</a>，在<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%A0%E7%BA%AA%EF%BC%8D%E4%B8%89%E5%8F%A0%E7%BA%AA%E7%81%AD%E7%BB%9D%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">二叠纪 - 三叠纪灭绝事件</a>中更是灭绝了当时地球约 90%的物种。恐龙曾经作为地球霸主，横扫大陆，支配陆地生态系统超过一亿四千万年之久，非鸟形恐龙最终在<a href="https://zh.wikipedia.org/wiki/%E7%99%BD%E5%9E%A9%E7%BA%AA%EF%B9%A3%E5%8F%A4%E8%BF%91%E7%BA%AA%E7%81%AD%E7%BB%9D%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">白垩纪﹣古近纪灭绝事件</a>中灭绝，仅存鸟形恐龙，即今天的<a href="https://zh.wikipedia.org/wiki/%E9%B8%9F" target="_blank" rel="noopener">鸟类</a>。</p><p>在物种的灭绝之后，随之而来的就是新物种的诞生与发展。人类在近代进化中脱颖而出——由四足进化为两足直立行走，在智力方面取得空前的进化，历经茹毛饮血、刀耕火种、手提肩扛、机械化、电气化、信息化，进入高度文明阶段。虽然现在的人类与野生动物赤身肉搏几乎没有胜算，但通过智力足以战胜其它物种，甚至驯化它们。人类已经有很强的环境适应能力，上至珠穆朗玛峰，下到马里亚纳海沟，北达格陵兰岛，南抵南极大陆，甚至于月球、火星，无一没有人类活动的踪迹。这个历程真的是令人赞叹不已。</p><p>我们真的太幸运了，在整个演化过程中，稍有偏差，这个世界就可能完全是另外一个样子。我们现在所认为的理所当然，不知承蒙了多大的福荫庇佑，倘若人类毁损了生存家园，可能再也没有适宜人类生存的环境了。</p><p>那么，下次的大灭绝会在什么时候到来？人类最终的命运会是怎样的呢？会存活下来吗？</p><p>如今，人类科技的发展已经取得了长足的进步，人类不太可能会在行星撞击地球中灭绝。目前人类已经开始探索外太空，有能力预测撞击事件，在不久的未来，人类极有可能完成太阳系的<a href="https://zh.wikipedia.org/zh-cn/%E7%81%AB%E6%98%9F%E6%AE%96%E6%B0%91" target="_blank" rel="noopener">星球殖民</a>，太阳系外的生命探索人类可能永远找不到答案。这个故事最终会是怎样的结局，你我都不得而知，我们所能做的，只有不要亲手毁掉家园吧。</p><p>最近的<a href="https://news.un.org/en/story/2019/12/1052661" target="_blank" rel="noopener">联合国报告</a>指出，近十年是有记录以来最热十年。人类的发展依赖于经济的发展，经济的发展又依赖于能源，更多的能源消耗导致了全球变暖。气候变化似乎与人类的发展是矛盾的，现在气候已经发出了警告，我们还远没有到壮士断腕的地步，我们是时候放缓脚步，思考一下如何在发展经济的同时兼顾环境，这需要各国政府出台政策来大力推动能源的升级，中美两国作为最大的碳排放国，也有责任帮助一些欠发达国家发展经济。巴西为了将更多的牛肉出口到中国，砍伐、焚烧亚马逊雨林以扩大牧场，从而导致了<a href="https://zh.wikipedia.org/zh-cn/2019%E5%B9%B4%E4%BA%9A%E9%A9%AC%E5%AD%99%E9%9B%A8%E6%9E%97%E9%87%8E%E7%81%AB" target="_blank" rel="noopener">2019 年雨林大火</a>，引发国际关注。亚马逊雨林号称“地球之肺”，在生态圈有着举足轻重的地位，雨林受损将导致生态与气候的进一步恶化。我们不应该一面享受雨林带给我们的适宜气候与巴西牛肉的同时，一面在雨林受损时指责当地农民，他们也需要生存，也需要经济发展，雨林需要全人类的呵护。</p><p>最后，安利一些 BBC 高分纪录片，我们或许能从这些生存大师中学到一些生存技能，也让我们得以关注日益严峻的生态问题</p><ul><li>《我们的星球》</li><li>《地球脉动》</li><li>《蓝色星球》</li><li>《冰冻星球》</li><li>《南太平洋》</li><li>《生命》</li><li>《猎捕》</li><li>《非洲》</li><li>《王朝》</li><li>《七个世界，一个星球》</li></ul><hr><p>相关阅读</p><ol><li><a href="https://www.unenvironment.org/interactive/emissions-gap-report/2019/" target="_blank" rel="noopener">Emissions Gap Report 2019</a></li><li><a href="https://wedocs.unep.org/bitstream/handle/20.500.11822/30798/EGR19ESCH.pdf" target="_blank" rel="noopener">2019 年《碳排放差距报告》 - 联合国规划署</a></li><li><a href="https://www.carbonbrief.org/mapped-worlds-coal-power-plants" target="_blank" rel="noopener">世界火力发电厂地图</a></li><li><a href="https://www.zhihu.com/question/280876600/answer/429905382" target="_blank" rel="noopener">霸王龙前面两只小手手是干嘛用的？ - Heimerdinger的回答</a></li><li><a href="https://www.zhihu.com/question/52115602/answer/141762022" target="_blank" rel="noopener">地球上有哪些细思恐极之事？ - 叶山Shan Ye的回答</a></li><li><a href="https://neal.fun/deep-sea/" target="_blank" rel="noopener">The Deep Sea</a></li><li><a href="https://neal.fun/size-of-space/" target="_blank" rel="noopener">The Size of Space</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 影像志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈站点国际化</title>
      <link href="/post/website-i18n/"/>
      <url>/post/website-i18n/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1g9lnhdm7prj30rs0dp75q.jpg" alt=""></p><a id="more"></a><blockquote><p><em>本文基于个人有限的国际化经验思考而得，未经完整实际项目验证，仅供参考。</em></p></blockquote><p>很多项目在拓展海外业务时开始对代码进行国际化改造，但经常在这个时候要偿还技术债，被搞的焦头烂额，那么，国际化在什么时候做最合适，又该怎么做呢？</p><h1 id="When"><a href="#When" class="headerlink" title="When"></a>When</h1><p>项目应该从一开始就做好国际化的准备，这并不会让你投入太多，但会让你在未来收益颇丰。</p><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>不要在代码中硬编码任何语言，应该独立语言包处理。展示时可通过用户预设语言、浏览器 header <code>Accept-Language</code>字段决定显示语言。</p><p>你也可以在<a href="https://i18ns.com/" target="_blank" rel="noopener">该网站</a>获取某种语言的多语言翻译，配置为 Alfred 工作流会进一步提升体验。</p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>统一使用 UTC 时区存储时间，然后在显示时，先判断用户预设时区，未知则可根据 IP 显示。亦可在邮件等场景直接表明时间和时区，如苹果的通知邮件时间<code>November 24, 2019, 3:20 PM PST</code>。</p><h2 id="手机号"><a href="#手机号" class="headerlink" title="手机号"></a>手机号</h2><p>由国家码和手机号两字段组成，仅在单一国家存在业务时，可隐藏并设定默认国家码，待拓展海外业务时再行开放，为国际化做好充足的准备。</p><h2 id="国家-地区列表争议"><a href="#国家-地区列表争议" class="headerlink" title="国家/地区列表争议"></a>国家/地区列表争议</h2><p>由于当前部分国家的领土主权存在争议，稍有不慎可能会面临严重的政策风险，为了规避风险，可以采用下述两种方式以避免主权概念：</p><ol><li>以【位置/Location】来替代，如 Windows 的语言/地区设置</li><li>以【国家/地区(Country or region)】来替代，如<a href="https://www.apple.com/choose-your-country/" target="_blank" rel="noopener">苹果的网站</a></li></ol><h2 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h2><p>以位标表示，如 1Byte 含有 8bit，每 bit 又可以表示两种状态，如性别、是否在线、数据是否可见等明确二值状态。这种方式易于扩充、节省空间、限定两种状态，如果未来某个状态需要更多的值表示，还可以提取独立表示。</p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>部分地区会有些特别活动，如中国农历新年，因此，我认为此时应该提取一套基础核心代码，然后各地区根据该核心代码实现业务自定义，如核心代码包括新产品或新功能在全球的发布，而地区代码则处理该地区的本地化业务。</p><h2 id="ISO-标准"><a href="#ISO-标准" class="headerlink" title="ISO 标准"></a>ISO 标准</h2><p>建立一套全球通用的标准对我们的维护会有很大的便利。该部分可查看我的另一篇文章——<a href="https://blog.shixinyu.space/post/standard-list">常用 ISO 标准列表</a>，在此不做赘述。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.xiaohui.com/weekly/software-and-politics.htm" target="_blank" rel="noopener">如何规避软件开发中的大中华区政治红线问题 - 程序员小辉</a></li><li><a href="https://book.douban.com/subject/25982663/" target="_blank" rel="noopener">Modern PHP</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> i18n </tag>
            
            <tag> 国际化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API 汇总</title>
      <link href="/post/api-collect/"/>
      <url>/post/api-collect/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1g9kpdmizt7j30tw0jgwhm.jpg" alt=""></p><a id="more"></a><h1 id="京东商品价格"><a href="#京东商品价格" class="headerlink" title="京东商品价格"></a>京东商品价格</h1><p>商品<code>https://item.jd.com/7892099.html</code>对应的价格接口地址为<code>https://p.3.cn/prices/mgets?skuIds=J_7892099</code></p><p>返回参数：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"cbf"</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"J_7892099"</span>,</span><br><span class="line">    <span class="attr">"m"</span>: <span class="string">"8999.00"</span>,</span><br><span class="line">    <span class="attr">"op"</span>: <span class="string">"7649.00"</span>,</span><br><span class="line">    <span class="attr">"p"</span>: <span class="string">"6999.00"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中，<code>op</code>为划线价，<code>p</code>为当前价，<code>m</code>含义未知</p><h1 id="京东搜索联想词"><a href="#京东搜索联想词" class="headerlink" title="京东搜索联想词"></a>京东搜索联想词</h1><p>URL: <code>https://dd-search.jd.com/?terminal=pc&amp;newjson=1&amp;ver=2&amp;zip=1&amp;key=iphone11 PRO MAX</code><br>⚠️：需设定 header <code>Referer = &#39;https://www.jd.com/&#39;</code></p><h1 id="淘宝商品搜索建议"><a href="#淘宝商品搜索建议" class="headerlink" title="淘宝商品搜索建议"></a>淘宝商品搜索建议</h1><p>URL: <code>https://suggest.taobao.com/sug?code=utf-8&amp;q=iphone11</code></p><h1 id="Bing-壁纸"><a href="#Bing-壁纸" class="headerlink" title="Bing 壁纸"></a>Bing 壁纸</h1><p>URL: <code>https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;nc=1572500909531&amp;pid=hp&amp;FORM=BEHPTB&amp;video=1</code></p><hr><p>一些页面可能确实需要模拟浏览器才能正常调用，我们可以通过 <a href="https://github.com/puppeteer/puppeteer" target="_blank" rel="noopener">Puppeteer</a> 无头浏览器来模拟。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP备忘录</title>
      <link href="/post/php-guide/"/>
      <url>/post/php-guide/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9koq37pe3j30jg0a8gm7.jpg" alt=""></p><a id="more"></a><h1 id="PHP的一些特性"><a href="#PHP的一些特性" class="headerlink" title="PHP的一些特性"></a>PHP的一些特性</h1><p>官方说明：<a href="https://www.php.net/manual/zh/migration70.new-features.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/migration70.new-features.php</a></p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><blockquote><p>php7.0+</p></blockquote><p><code>declare(strict_types=1);</code><br>⚠️该声明指令必须放在文件的顶部。</p><h2 id="批量使用-use"><a href="#批量使用-use" class="headerlink" title="批量使用 use"></a>批量使用 use</h2><blockquote><p>php7.0+</p></blockquote><p><code>use app\models\{Area, Category};</code></p><h2 id="NULL-合并操作符"><a href="#NULL-合并操作符" class="headerlink" title="NULL 合并操作符"></a>NULL 合并操作符</h2><p><code>$a ?? $b ?? $c;</code> 从左往右第一个存在且不为 NULL 的操作数。如果都没有定义且不为 NULL，则返回 NULL</p><h2 id="定义常量数组"><a href="#定义常量数组" class="headerlink" title="定义常量数组"></a>定义常量数组</h2><blockquote><p>php7.0+</p></blockquote><p>方式一：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">define(<span class="string">'ANIMALS'</span>, [</span><br><span class="line">    <span class="string">'dog'</span>,</span><br><span class="line">    <span class="string">'cat'</span>,</span><br><span class="line">    <span class="string">'bird'</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> ANIMALS[<span class="number">1</span>]; <span class="comment">// 输出 "cat"</span></span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">const</span> ANIMALS = [</span></span><br><span class="line"><span class="php">    <span class="string">'dog'</span>,</span></span><br><span class="line"><span class="php">    <span class="string">'cat'</span>,</span></span><br><span class="line"><span class="php">    <span class="string">'bird'</span></span></span><br><span class="line"><span class="php">];</span></span><br></pre></td></tr></table></figure><h2 id="太空船操作符"><a href="#太空船操作符" class="headerlink" title="太空船操作符"></a>太空船操作符</h2><blockquote><p>php7.0+</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &lt;=&gt; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line">echo <span class="number">1</span> &lt;=&gt; <span class="number">2</span>; <span class="comment">// -1</span></span><br><span class="line">echo <span class="number">2</span> &lt;=&gt; <span class="number">1</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="整数除法函数"><a href="#整数除法函数" class="headerlink" title="整数除法函数"></a>整数除法函数</h2><blockquote><p>php7.0+</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(<span class="built_in">int</span>div(<span class="number">10</span>, <span class="number">3</span>)); <span class="comment">// int(3)</span></span><br></pre></td></tr></table></figure><h2 id="支持多个异常处理"><a href="#支持多个异常处理" class="headerlink" title="支持多个异常处理"></a>支持多个异常处理</h2><blockquote><p>php5.5+</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Error | <span class="keyword">Exception</span> | Throwable $e) &#123;</span><br><span class="line">    var_dump(<span class="string">'Error'</span>, $e-&gt;getMessage(), $e-&gt;getCode());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; <span class="comment">// Code within the finally block will always be executed after the try and catch blocks</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"First finally.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><p>PHP Bug 官方主页 <a href="https://bugs.php.net/index.php" target="_blank" rel="noopener">https://bugs.php.net/index.php</a></p><h2 id="PHP-7-1-版本以上-json-encode-编码浮点数精度丢失问题"><a href="#PHP-7-1-版本以上-json-encode-编码浮点数精度丢失问题" class="headerlink" title="PHP 7.1 版本以上 json_encode 编码浮点数精度丢失问题"></a>PHP 7.1 版本以上 json_encode 编码浮点数精度丢失问题</h2><p>Bug 报告：<a href="https://bugs.php.net/bug.php?id=74221" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=74221</a></p><p>Bug 复现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> json_encode(<span class="number">1.2</span>);</span><br><span class="line"><span class="comment">// output 1.1999999999999999555910790149937383830547332763671875</span></span><br></pre></td></tr></table></figure><p>解决方案<br>调整 php.ini 文件中的<code>serialize_precision</code> 为 <code>serialize_precision = -1</code>。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="获取毫秒级时间戳"><a href="#获取毫秒级时间戳" class="headerlink" title="获取毫秒级时间戳"></a>获取毫秒级时间戳</h2><p><code>round(microtime(true) * 1000)</code></p><blockquote><p>浮点数中显示有效数字的位数由 php.ini 中的 <code>precision</code> 参数控制</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>时间拯救者——快捷键</title>
      <link href="/post/keyboard-shortcuts/"/>
      <url>/post/keyboard-shortcuts/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1g9ilkop0tpj30sg0e8ab7.jpg" alt=""></p><p>巧用快捷键，就是快人一步！</p><a id="more"></a><p>看了很多人都不太会使用快捷键，其中不乏工作多年的老程序员，看他们的操作有时候真的让我很着急，我就把我所了解的一些快捷键记录在此，希望能节省大家的时间。</p><blockquote><p>本文主要环境为 macOS，不过很多快捷键在 Windows 中也适用，只不过把 ⌘ 替换成 Ctrl 即可。</p></blockquote><h1 id="macOS-10-15"><a href="#macOS-10-15" class="headerlink" title="macOS 10.15"></a>macOS 10.15</h1><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>⌘ + Tab</code></td><td>切换应用</td></tr><tr><td>双击</td><td>选中分词</td></tr><tr><td>三击</td><td>选中一行</td></tr><tr><td><code>Alt + ←/→</code></td><td>光标按照分词跳动</td></tr><tr><td><code>⌘ + ←/→</code></td><td>光标移动到行首/行尾</td></tr><tr><td><code>Shift + Alt + ←/→</code></td><td>从当前光标处按照分词选中</td></tr><tr><td><code>Shift + ⌘ + ←/→</code></td><td>从当前光标处选中到行首/行尾</td></tr><tr><td><code>⌘ + Alt + Shift + V</code></td><td>无格式粘贴</td></tr><tr><td><code>⌘ 和 +/-</code></td><td>放大/缩小页面内容</td></tr><tr><td><code>⌘ + Ctrl + F</code></td><td>进入/退出全屏</td></tr><tr><td><code>⌘ + Shift + Z</code></td><td>取消撤销操作</td></tr><tr><td><code>⌘ + P</code></td><td>打印</td></tr><tr><td><code>⌘ + Q</code></td><td>退出软件</td></tr><tr><td><code>Fn + delete</code></td><td>删除光标右侧字符</td></tr><tr><td><code>Option + Delete</code></td><td>删除文本字段中的上一个字词</td></tr><tr><td><code>Fn + Option + Delete</code></td><td>删除文本字段中的下一个字词</td></tr></tbody></table><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><table><thead><tr><th>快捷键</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>⌘ + L</code></td><td>聚焦地址栏</td><td></td></tr><tr><td><code>Fn + ←</code></td><td>回到页首</td><td></td></tr><tr><td><code>Fn + →</code></td><td>回到页尾</td><td></td></tr><tr><td><code>⌘ + R</code></td><td>刷新页面</td><td></td></tr><tr><td><code>⌘ + Shift + R</code></td><td>清除缓存刷新页面</td><td>Only Chrome &amp; Firefox</td></tr><tr><td><code>⌘ + W</code></td><td>关闭窗口</td><td></td></tr><tr><td><code>⌘ + N</code></td><td>新建窗口</td><td></td></tr><tr><td><code>⌘ + Shit + N</code></td><td>新建隐身窗口</td><td></td></tr><tr><td><code>⌘ + T</code></td><td>新建标签页</td><td></td></tr><tr><td><code>⌘ + Option + I</code></td><td>打开开发者工具</td><td></td></tr><tr><td><code>⌘ + Option + ←/→</code></td><td>切换相邻的标签页</td><td>Only Chrome</td></tr><tr><td><code>⌘ + Shift + B</code></td><td>打开/隐藏书签栏</td><td></td></tr><tr><td><code>⌘ + Shift + F</code></td><td>隐藏标签栏与地址栏</td><td>Only Chrome</td></tr><tr><td><code>⌘ + 单击链接</code></td><td>在新建后台标签页打开</td><td></td></tr><tr><td><code>Shift + 单击链接</code></td><td>在新建窗口打开</td><td></td></tr><tr><td><code>Alt + 单击链接</code></td><td>下载链接内容</td><td></td></tr><tr><td><code>Shift + Fn + Delete</code></td><td>从地址栏中移除联想查询内容</td><td></td></tr></tbody></table><p>对于知名网站来说，Chrome 地址栏输入网址+Tab即可直接检索，已确定支持的有：Google、GitHub、Stack Overflow、维基百科、百度、淘宝、天猫、京东、知乎、哔哩哔哩、豆瓣读书、豆瓣电影、微博、高德地图、美团、小米商城、Facebook、Twitter、YouTube、Amazon、Bing等。所以，以后就不要在地址栏先输入 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ，再在搜索框键入关键字了，答应我，好吗？</p><p>如果你是一名开发者，推荐使用<a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=zh" target="_blank" rel="noopener">Chrome Vimium 插件</a>快速操作页面。</p><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p>Linux命令行常用快捷键<br>|快捷键|功能说明|<br>|-|-|<br>|<code>tab</code>|自动补全命令或路径|<br>|<code>Ctrl + c</code>|中断正在执行的任务|<br>|<code>Ctrl+z</code>|将正在终端执行的任务停下来放到后台|<br>|<code>Ctrl + a</code>|光标移至行首|<br>|<code>Ctrl + e</code>|光标移至行尾|<br>|<code>Ctrl + u</code>|剪切光标至行首的内容|<br>|<code>Ctrl + k</code>|剪切光标至行尾的内容|<br>|<code>Esc + b</code>|移动到当前单词的开头|<br>|<code>Esc + f</code>|移动到当前单词的结尾|</p><p>man查阅命令手册的内容说明<br>|手册中的标题|功能说明|<br>|-|-|<br>|<code>NAME</code>| 命令的说明和介绍|<br>|<code>SYNOPSIS</code>| 使用该命令的基本语法|<br>|<code>DESCRIPTION</code>| 使用该命令的详细描述，各个参数的作用，有时候这些信息会出现在OPTIONS中 |<br>|<code>OPTIONS</code>| 命令相关参数选项的说明|<br>|<code>EXAMPLES</code>| 使用该命令的参考例子|<br>|<code>EXIT STATUS</code>| 命令结束的退出状态码，通常<code>0</code>表示成功执行|<br>|<code>SEE ALSO</code>| 和命令相关的其他命令或信息|<br>|<code>BUGS</code>| 和命令相关的缺陷的描述|<br>|<code>AUTHOR</code>| 该命令的作者介绍|</p><h1 id="iOS-13"><a href="#iOS-13" class="headerlink" title="iOS 13"></a>iOS 13</h1><ul><li>点击时间快速回到页首</li><li>屏幕左侧向右滑动返回上一页</li><li>照片点击选择按钮后，滑动选择照片快速批量管理</li><li>长按 WiFi 图标快速切换 WiFi</li><li>长按蓝牙图标，快速连接蓝牙设备</li><li>长按微信/支付宝图标可快速打开扫一扫、付款码</li><li>App Store 切换账号：点击应用商店右上角的用户头像 ==&gt; 下拉到最下边 ==&gt; 退出 ==&gt; 点击时间回到页首输入新的账号</li><li>系统设置页下拉显示搜索框</li><li>Earpods 单击暂停/播放⏯，双击下一首⏭，三击上一首⏮，双击第二次长按快进⏩，三击第三次长按快退⏪︎</li><li>摇一摇撤销输入</li><li>计算器横屏切换为科学计算器模式</li><li>设置闹钟太麻烦？试试对 Siri 说：嘿，Siri，明天早上七点叫我起床。</li></ul><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h3 id="多点编辑"><a href="#多点编辑" class="headerlink" title="多点编辑"></a>多点编辑</h3><p>长按<code>Alt</code>键，然后在需要编辑的位置点击定位光标，即可实现快速批量编辑。</p><h3 id="纵向批量编辑"><a href="#纵向批量编辑" class="headerlink" title="纵向批量编辑"></a>纵向批量编辑</h3><p>以 Visual Studio Code 编辑器为例，光标定位在第一行开始处，然后按住<code>Shift + Alt</code>并在欲结束位置点击，我们便获取了纵向批处理光标，再结合<code>Alt + ←/→</code>分词跳转，<code>⌘ + ←/→</code>行首/行尾跳转，让你一切尽在掌控。这对于批量处理邮箱、SQL 条件等尤为有用。</p><h3 id="批量替换"><a href="#批量替换" class="headerlink" title="批量替换"></a>批量替换</h3><p>批量替换应该非常简单，这里不做过多的赘述，值得一提的是，我们除了批量替换外，还可以批量删除指定字符，如批量删除换行。同样以 Visual Studio Code 为例，具体操作为：</p><ol><li>开启批量替换的正则表达式</li><li>在搜索字符中搜索<code>\n</code>，替换的字符留空</li></ol><h2 id="OCR-识别"><a href="#OCR-识别" class="headerlink" title="OCR 识别"></a>OCR 识别</h2><p>Mac 最新版 QQ 截图集成了文字识别的功能，如果别人截图了某段打印文字，或者要从 PDF 中截取某段文字，可以快速提取，识别率还可以，需要对提取结果进行校对。</p><p>其实快捷键也不需要特意去记，当你感觉操作太慢时，就去查一下快捷键，用的多了自然就记住了，你也可以借助 CheatSheet 来查询当前软件的快捷键。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans" target="_blank" rel="noopener">Chrome 键盘快捷键</a></li><li><a href="https://support.mozilla.org/zh-CN/kb/%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE" target="_blank" rel="noopener">Firefox 键盘快捷键</a></li><li><a href="https://support.apple.com/zh-cn/guide/safari/cpsh003/mac" target="_blank" rel="noopener">《Safari 浏览器使用手册》</a></li><li><a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="noopener">Mac 键盘快捷键</a></li><li><a href="https://support.microsoft.com/zh-cn/help/12445/windows-keyboard-shortcuts" target="_blank" rel="noopener">Windows 中的键盘快捷方式</a></li><li><a href="https://help.ubuntu.com/stable/ubuntu-help/shell-keyboard-shortcuts.html.en" target="_blank" rel="noopener">Ubuntu Useful keyboard shortcuts</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
            <tag> 时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cURL 使用指南</title>
      <link href="/post/curl-guide/"/>
      <url>/post/curl-guide/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1g9idtepi63j30xc0crjsf.jpg" alt=""></p><a id="more"></a><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><blockquote><p>我们可以在<a href="https://curl.haxx.se/docs/manpage.html" target="_blank" rel="noopener">这里</a>查看到更多关于 curl 命令的参数解释，本文仅覆盖日常的一些使用场景。</p></blockquote><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>如果要发起简单的 GET 请求，只需直接请求地址即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://cn.bing.com/HPImageArchive.aspx\?format\=js\&amp;idx\=0\&amp;n\=1\&amp;nc\=1572500909531\&amp;pid\=hp\&amp;FORM\=BEHPTB\&amp;video\=1 | jq</span><br></pre></td></tr></table></figure><p>我们使用<code>jq</code>来使 json 数据在终端格式化展示。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9iegxw00oj317i0u0458.jpg" alt=""></p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-o</code></td><td>将结果写入指定文件</td></tr><tr><td><code>-O</code></td><td>直接以远程文件名保存到本地</td></tr><tr><td><code>-#</code></td><td>显示下载进度条</td></tr><tr><td><code>-s</code></td><td>将终端的输出关闭</td></tr><tr><td><code>-v</code></td><td>输出详细的请求</td></tr><tr><td><code>-C</code></td><td>断点续传</td></tr><tr><td><code>–limit-rate</code></td><td>设置传输速度（默认单位为 B/s，手动添加 <code>k</code>，<code>m</code>，<code>g</code> 指定单位）</td></tr><tr><td><code>–retry 5</code></td><td>传输出现问题时，重试 5 次</td></tr><tr><td><code>–retry-delay</code></td><td>传输出现问题时，设置重试时间间隔 (秒)</td></tr><tr><td><code>–retry-max-time</code></td><td>传输出现问题时，设置最大重试时间</td></tr><tr><td><code>-m</code></td><td>设置最大传输时间，单位秒</td></tr></tbody></table><p>保存结果<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ifve2phnj30zy04smxr.jpg" alt="保存结果"></p><p>输出详细请求信息<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ifu88t6mj316m0pcq6l.jpg" alt="输出详细请求过程"></p><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-H</code></td><td>设定 header 信息</td></tr><tr><td><code>-d/--data</code></td><td>对应<code>Content-Type:application/x-www-form-urlencoded</code></td></tr><tr><td><code>-F</code></td><td>对应<code>Content-Type:multipart/form-data</code>，可用于指定上传文件的路径</td></tr><tr><td><code>-G</code></td><td>使用 GET 方式发送数据</td></tr><tr><td><code>-I</code></td><td>只显示请求头信息</td></tr><tr><td><code>-x</code></td><td>使用 http 代理</td></tr><tr><td><code>-A</code></td><td>设置 <code>User-Agent</code> 信息</td></tr><tr><td><code>-e</code></td><td>设置 <code>Referer</code> 信息</td></tr><tr><td><code>--cookie</code></td><td>设置 cookie 信息，多个 cookie 用分号分隔，分号后带一个空格</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">'https://open.unionpay.com/tjwx/api/cardbin/cardinfo'</span> \</span><br><span class="line">-H <span class="string">'Content-Type:application/x-www-form-urlencoded'</span> \</span><br><span class="line">-H <span class="string">'Accept:application/json, text/javascript, */*; q=0.01'</span> \</span><br><span class="line">-e <span class="string">'https://open.unionpay.com/tjwx/openapi/cardbin-pc.html'</span> \</span><br><span class="line">-A <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36'</span> \</span><br><span class="line">-d <span class="string">'cardNo=6227000280070859140'</span> \</span><br><span class="line">--cookie <span class="string">'fruit=apple; colour=red'</span> \</span><br><span class="line">-s \</span><br><span class="line">| jq</span><br></pre></td></tr></table></figure><p>最后，如果本地没有安装 Postman 等图形化请求工具，还可以直接打开浏览器的控制台，获取到某次网络的 curl 形式，这样在调试某些页面请求或者忘记 curl 的请求格式时可以用到。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ieuom1jgj30ek0ca45m.jpg" alt=""></p><p>更多终端使用教程请查看<a href="https://curl.haxx.se/docs/manual.html" target="_blank" rel="noopener">curl tutorial</a></p><p>还有一个终端 HTTP 请求工具<a href="https://httpie.org/" target="_blank" rel="noopener">HTTPie</a>会比 curl 更加友好，支持自动 json 格式化，可以尝试一下。</p><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><h2 id="GET-1"><a href="#GET-1" class="headerlink" title="GET"></a>GET</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$url = <span class="string">'https://cn.bing.com/HPImageArchive.aspx?'</span>;</span><br><span class="line">$query = http_build_query([</span><br><span class="line">    <span class="string">'format'</span> =&gt; <span class="string">'js'</span>,</span><br><span class="line">    <span class="string">'idx'</span>    =&gt; <span class="number">0</span>,</span><br><span class="line">    <span class="string">'n'</span>      =&gt; <span class="number">1</span>,</span><br><span class="line">    <span class="string">'nc'</span>     =&gt; <span class="number">1572500909531</span>,</span><br><span class="line">    <span class="string">'pid'</span>    =&gt; <span class="string">'hp'</span>,</span><br><span class="line">    <span class="string">'FORM'</span>   =&gt; <span class="string">'BEHPTB'</span>,</span><br><span class="line">    <span class="string">'video'</span>  =&gt; <span class="number">1</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$ch = curl_init($url . $query);</span><br><span class="line"></span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">$res = curl_exec($ch);</span><br><span class="line"></span><br><span class="line">curl_close($ch);</span><br></pre></td></tr></table></figure><p>通常，一个简单的 GET 请求，我们可以用<code>file_get_contents()</code>更快速的获取结果。</p><h2 id="POST-1"><a href="#POST-1" class="headerlink" title="POST"></a>POST</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ch = curl_init(<span class="string">'https://open.unionpay.com/tjwx/api/cardbin/cardinfo'</span>);</span><br><span class="line"></span><br><span class="line">curl_setopt_array(</span><br><span class="line">    $ch,</span><br><span class="line">    [</span><br><span class="line">        CURLOPT_POST           =&gt; <span class="keyword">true</span>,</span><br><span class="line">        CURLOPT_POSTFIELDS     =&gt; http_build_query([<span class="string">'cardNo'</span> =&gt; $cardNo]),<span class="comment">//设定 POST 参数内容</span></span><br><span class="line">        CURLOPT_FOLLOWLOCATION =&gt; <span class="keyword">true</span>,<span class="comment">//跟随重定向地址</span></span><br><span class="line">        CURLOPT_AUTOREFERER    =&gt; <span class="keyword">true</span>,</span><br><span class="line">        CURLOPT_RETURNTRANSFER =&gt; <span class="keyword">true</span>,<span class="comment">//将curl_exec()获取的信息以字符串返回，而不是直接输出。</span></span><br><span class="line">        CURLOPT_USERAGENT      =&gt; <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span>,</span><br><span class="line">        CURLOPT_REFERER        =&gt; <span class="string">'https://open.unionpay.com/tjwx/openapi/cardbin-pc.html'</span>,<span class="comment">//必填项</span></span><br><span class="line">        CURLOPT_HTTPHEADER     =&gt; [<span class="string">"Content-Type: application/x-www-form-urlencoded"</span>, <span class="string">"Accept: application/json, text/javascript, */*; q=0.01"</span>]</span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$response = curl_exec($ch);</span><br><span class="line"></span><br><span class="line">curl_close($ch);</span><br></pre></td></tr></table></figure><p>需要注意的几点：</p><ol><li><code>curl_setopt_array</code>中的第二个参数的 key 为预设常量，不要写作字符串</li><li>若未设置<code>CURLOPT_RETURNTRANSFER = true</code>，则 curl 会默认输出结果，这个问题我调了一个下午😅</li><li>在调用 curl 结束后，记得调用<code>curl_close()</code>关闭句柄，为了防止遗忘，建议<code>curl_init()</code>与<code>curl_close()</code>成对创建</li><li>如果有多个互不依赖的请求，可以使用<code>curl_multi</code>来提升加载速度，使用<a href="https://www.php.net/manual/zh/function.curl-multi-init.php#118142" target="_blank" rel="noopener">示例</a>如下</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// build the individual requests, but do not execute them</span></span><br><span class="line">$ch_1 = curl_init(<span class="string">'http://webservice.one.com/'</span>);</span><br><span class="line">$ch_2 = curl_init(<span class="string">'http://webservice.two.com/'</span>);</span><br><span class="line">curl_setopt($ch_1, CURLOPT_RETURNTRANSFER, <span class="keyword">true</span>);</span><br><span class="line">curl_setopt($ch_2, CURLOPT_RETURNTRANSFER, <span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// build the multi-curl handle, adding both $ch</span></span><br><span class="line">$mh = curl_multi_init();</span><br><span class="line">curl_multi_add_handle($mh, $ch_1);</span><br><span class="line">curl_multi_add_handle($mh, $ch_2);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// execute all queries simultaneously, and continue when all are complete</span></span><br><span class="line">  $running = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    curl_multi_exec($mh, $running);</span><br><span class="line">  &#125; <span class="keyword">while</span> ($running);</span><br><span class="line"></span><br><span class="line"><span class="comment">//close the handles</span></span><br><span class="line">curl_multi_remove_handle($mh, $ch1);</span><br><span class="line">curl_multi_remove_handle($mh, $ch2);</span><br><span class="line">curl_multi_close($mh);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// all of our requests are done, we can now access the results</span></span><br><span class="line">$response_1 = curl_multi_getcontent($ch_1);</span><br><span class="line">$response_2 = curl_multi_getcontent($ch_2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$response_1 $response_2"</span>; <span class="comment">// output results</span></span><br></pre></td></tr></table></figure><p>更多请求参数设置请点击<a href="https://www.php.net/manual/zh/function.curl-setopt.php" target="_blank" rel="noopener">curl_setop</a>查看。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://curl.haxx.se/" target="_blank" rel="noopener">cURL - Offical Website</a></li><li><a href="https://www.php.net/manual/zh/book.curl.php" target="_blank" rel="noopener">Client URL 库 - PHP Manual</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实名认证变迁</title>
      <link href="/post/real-name-authentication/"/>
      <url>/post/real-name-authentication/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9afgrs3mbj30go0bgjse.jpg" alt=""></p><a id="more"></a><h1 id="实名认证方式"><a href="#实名认证方式" class="headerlink" title="实名认证方式"></a>实名认证方式</h1><h2 id="1-姓名-身份证号-公安系统接口"><a href="#1-姓名-身份证号-公安系统接口" class="headerlink" title="1. 姓名 + 身份证号 + 公安系统接口"></a>1. 姓名 + 身份证号 + 公安系统接口</h2><p>这是最原始的认证方式，缺点很明显：</p><ul><li>需要具备调用公安系统公民信息接口的资质</li><li>无法保证被认证者的真实性。比如我在黑市两元钱购买了一张身份证，这个身份证的信息是真实有效的，但使用者却不是本人。这种身份证信息可能是身份证丢失，也可能是有人专门用不锈钢脸盆在农村骗取村民的身份证信息，甚至会诱使他们拍下手持身份证的照片，也有可能是早年深圳三和人才市场的落魄者出售身份证而来。</li></ul><h2 id="2-姓名-身份证号-手持身份证照片"><a href="#2-姓名-身份证号-手持身份证照片" class="headerlink" title="2. 姓名 + 身份证号 + 手持身份证照片"></a>2. 姓名 + 身份证号 + 手持身份证照片</h2><p>鉴于第一种方式可能会出现冒用的情况，因此后来出现了手持身份证验证本人的认证方式。但这种方式同样存在很大的漏洞：我直接诱使本人拍下手持身份证的照片，或者使用 Photoshop 修改身份证照片或者手持者照片，使二者一致，同样可以轻易绕过。</p><h2 id="3-绑定银行卡"><a href="#3-绑定银行卡" class="headerlink" title="3. 绑定银行卡"></a>3. 绑定银行卡</h2><p>银行卡开户时，柜员会进行实名认证，包括身份证有效性和真实性认证，身份证是否本人等。银行的实名信息相对可靠，因此，网络实名认证就可以根据用户在开户时的银行预留信息验证来进行实名认证</p><p>这种方式相对安全性最高，同时认证过程也是最复杂的。如果网站没有支付功能，只是匿名用户会经常发表一些政治敏感话题，导致网站有被查封的风险，此时我用这种方式实名认证就有些大题小做了。另一方面，有些用户的银行预留信息可能太久而模糊，会造成这样一些用户的认证困难，进而造成这部分用户的流失。</p><h2 id="4-使用支付宝实名认证"><a href="#4-使用支付宝实名认证" class="headerlink" title="4. 使用支付宝实名认证"></a>4. 使用支付宝实名认证</h2><p>如今，几乎国内绝大多数的上网用户都拥有支付宝账户，而使用支付宝的前提就是要绑定银行卡，从而完成了支付宝的实名认证。</p><p>当支付宝积累了足够多的可信用户后，它就可以扩展一些能力，如为第三方提供实名认证能力，通过用户在旗下网站的行为进行用户画像等。</p><p>现在，支付宝已经推出了<a href="https://docs.open.alipay.com/271" target="_blank" rel="noopener">芝麻认证</a>服务，根据其介绍</p><blockquote><p>对个人进行实人认证，核验方式包括人脸识别、眼纹识别、姓名和身份证号验证等。芝麻认证主要解决线上实人开户、帐号实名认证、帐号实人登录等场景中个人身份的识别问题。与其他实人认证服务相比，芝麻认证在使用流程中甚至不需要用户做动作就能快速得出认证结果，速度快、体验好、通过率高，拥有业内独有的眼纹人脸双因子认证技术，安全水平已达金融级要求。</p></blockquote><p>我们可以看到，这已经满足了大多数的网络实名认证场景，且速度快，体验好，作弊难。活体认证既解决了冒用的问题，也解决了用户活体的认证问题，而且整个认证过程只需两步：扫码 ==&gt; 扫脸 ==&gt; 完成。</p><p>现在的一些实名认证我都有些警惕，有些连https都不支持的网站都要收集个人信息，你的信息在数据库里更可能是明文存储的，造成了很大的安全风险。但现在国内的常用网站现在还有几个不要求实名认证的？</p><h2 id="5-未来：eID"><a href="#5-未来：eID" class="headerlink" title="5. 未来：eID"></a>5. 未来：eID</h2><p><a href="https://eid.cn/" target="_blank" rel="noopener">eID</a> (electronic IDentity) 是以密码技术为基础、以智能安全芯片为载体、由“公安部公民网络身份识别系统”签发的公民网络电子身份标识，能够在不泄露身份信息的前提下在线远程识别身份。eID 不仅在中国支持，还是一个全球解决方案，早在 1999 年，欧盟就已经支持，以下是一些主要国家的支持情况。</p><ul><li>1999 欧盟 </li><li>2004 中国香港 </li><li>2004 澳大利亚 </li><li>2011 俄罗斯 </li><li>2013 加拿大 </li><li>2014 美国 </li></ul><p>目前，eID，在德国普及率较好，国内尚未普及，但中国手机制造商华为(荣耀)、OPPO、Vivo 最新款均已支持，希望工信部能推进一下 eID 的普及，连 Facebook 这样的公司都滥用用户信息，更遑论不知名的公司了。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://en.wikipedia.org/wiki/Electronic_identification" target="_blank" rel="noopener">Electronic identification - WikiPedia</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【转】文艺的代码</title>
      <link href="/post/funny-code/"/>
      <url>/post/funny-code/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9acekmjqvj31900u0jyy.jpg" alt=""></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> world;               <span class="comment">// 二人世界</span></span><br><span class="line">unsigned letter;            <span class="comment">// 未签名的信笺</span></span><br><span class="line"><span class="keyword">short</span> stay;                 <span class="comment">// 短暂的缱绻</span></span><br><span class="line"><span class="keyword">long</span> memories;              <span class="comment">// 长久的回忆</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ago;              <span class="comment">// 很久很久以前</span></span><br><span class="line"><span class="keyword">float</span> cloud;                <span class="comment">// 天空漂浮着一朵云</span></span><br><span class="line">printf(<span class="string">"I miss you.\n"</span>);    <span class="comment">// 上边写着：I miss u.</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (everynight <span class="keyword">in</span> mydreams) &#123;</span><br><span class="line">    i.see(you);</span><br><span class="line">    i.feel(you);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> world <span class="keyword">where</span> someone <span class="keyword">like</span> <span class="string">'%you%'</span>;</span><br></pre></td></tr></table></figure><p>Nothing is absolute.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">* &#123; <span class="attribute">position</span>: relative; &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>物是人非事事休，欲语泪先流。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(item &amp;&amp; !people) everything = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (tears.setFlowing()) <span class="keyword">try</span> &#123;</span><br><span class="line">    Speaker skr = <span class="keyword">new</span> <span class="type">Speaker</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">    IOException e;</span><br><span class="line">&#125; ()</span><br></pre></td></tr></table></figure><p>先天下之忧而忧，后天下之乐而乐。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (others.rejoice() == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.rejoice();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.worry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻寻觅觅，冷冷清清，凄凄惨惨戚戚。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">Seeking</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span></span><br><span class="line"><span class="comment">Loneliness</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span></span><br><span class="line"><span class="comment">(Misery</span><span class="literal">+</span><span class="literal">+</span><span class="comment">)</span> <span class="literal">+</span> <span class="comment">(Sadness</span><span class="literal">+</span><span class="literal">+</span><span class="comment">);</span></span><br></pre></td></tr></table></figure><p>野火烧不尽，春风吹又生。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(true) &#123;</span><br><span class="line">    Grass *gr;</span><br><span class="line">    <span class="keyword">if</span> (springBreeze.isComing()) &#123;</span><br><span class="line">        gr = <span class="keyword">new</span> Grass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wildFire.isComing()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> gr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假作真时真亦假，无为有处有还无。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">FALSE</span> == <span class="literal">true</span>) <span class="literal">TRUE</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == exist) exist = <span class="literal">NULL</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>欲穷千里目，更上一层楼。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sight.getRange() &lt;= <span class="number">1000</span>) building.level++;</span><br></pre></td></tr></table></figure><p>明日复明日，明日何其多。我生待明日，万事成蹉跎。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (tomorrow.hasNext()) &#123;</span><br><span class="line">    howMany(tomorrow);</span><br><span class="line">    tomorrow.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.wait(WHOLE_LIFE);</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">null</span> == everything) ? <span class="literal">null</span> : <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>路漫漫兮修远兮，吾将上下而求索。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roadAheadEnding.isVisual = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!spare<span class="constructor">Effort()</span>) &#123;</span><br><span class="line">    i.search<span class="constructor">With(<span class="params">willUnbending</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但愿人长久，千里共婵娟。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BOOL)wish: </span>(People *) longNine &#123;</span><br><span class="line">    <span class="keyword">BOOL </span>km = YES<span class="comment">;</span></span><br><span class="line">    <span class="keyword">BOOL </span>moon = YES<span class="comment">;</span></span><br><span class="line">    return km &amp;&amp; moon<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>东风不与周郎便，铜雀春深锁二乔。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!eastWind.help(zhouyu)) &#123;</span><br><span class="line">    season = spring<span class="comment">;</span></span><br><span class="line">    bronzeBird.<span class="keyword">lock</span>(bigQiao)<span class="comment">;</span></span><br><span class="line">    bronzeBird.<span class="keyword">lock</span>(smallQiao)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两岸猿声啼不住，轻舟已过万重山。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    listen(Ape1Cry &amp;&amp; Ape2Cry);</span><br><span class="line">    Boat.pass(Mountain);</span><br><span class="line">    <span class="keyword">if</span> (Mountain &gt; <span class="number">10000</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桃花潭水深千尺，不及汪伦送我情。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peachFlowerLake.deep = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span> (peachFlowerLake.deep &lt; wl.friendship) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//运算结果：true</span></span><br></pre></td></tr></table></figure><p>黑夜给了我黑色的眼睛，我却用它来寻找光明。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eye = dark.poll<span class="comment">()</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(eye.color == black)</span> &#123;</span><br><span class="line">    eye.seek_for<span class="comment">(bright)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鱼和熊掌不可兼得。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hold ? fish : <span class="type">palm</span>;</span><br></pre></td></tr></table></figure><p>笑渐不闻声渐悄，多情却被无情恼。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">laugh--<span class="comment">;</span></span><br><span class="line">sound--<span class="comment">;</span></span><br><span class="line">person(feeling &gt; <span class="number">999</span>).<span class="keyword">bothered_by(person(feeling </span>== <span class="number">0</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>举头望明月，低头思故乡。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.Head.SetDirection(TheMoon.GetInstance().Position)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.Head.SetDirection(GROUND_DIRECTION);</span><br><span class="line">    <span class="keyword">this</span>.ThinkAbout(<span class="keyword">this</span>.OriginalPlace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一直在做程序员，直到膝盖中了一箭。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ActAs(Programmer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (KneeTilledException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.Weapon <span class="keyword">is</span> Arror) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽刀断水水更流，举杯消愁愁更愁。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cut<span class="constructor">Water(<span class="params">getKnife</span>()</span>) &#123;</span><br><span class="line">    water++;</span><br><span class="line">&#125;</span><br><span class="line">reduce<span class="constructor">Worry(<span class="params">toast</span>)</span> &#123;</span><br><span class="line">    worry++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>驿寄梅花，鱼传尺素，砌成此恨无重数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (received(<span class="keyword">friend</span>.plumBlossom) &amp;&amp; received(<span class="keyword">friend</span>.letter)) &#123;</span><br><span class="line">    nostalgicThoughts++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总为浮云能蔽日，长安不见使人愁。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(cloudsHideSun == true)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="comment">(!seeChangan)</span> &#123;</span><br><span class="line">        self.worry<span class="comment">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人生得意须尽欢，莫使金樽空对月。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (life.satisfied()) &#123;</span><br><span class="line">    <span class="keyword">while</span> (happy--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!goldenCup.empty() &amp;&amp; moon.visible()) &#123;</span><br><span class="line">            goldenCup.fulfill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苟利国家生死以，岂因祸福避趋之。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dog</span>(pear -&gt; fruit)<span class="selector-class">.home</span><span class="selector-class">.deliver</span>(death, <span class="number">1</span>);</span><br><span class="line"><span class="selector-tag">flag</span> <span class="selector-tag">in</span> <span class="selector-attr">[ disaster, fortune ]</span> <span class="selector-tag">-</span>&gt; () &#123; <span class="selector-tag">pen</span><span class="selector-class">.go</span>(arguments[<span class="number">0</span>]) &#125;;</span><br></pre></td></tr></table></figure><hr><p>原文地址：<a href="https://mi.js.org/2018-04/%E6%96%87%E8%89%BA%E7%9A%84%E4%BB%A3%E7%A0%81/" target="_blank" rel="noopener">文艺的代码 - 米米的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Canvas 绘制黑客帝国数字效果</title>
      <link href="/post/matrix-number/"/>
      <url>/post/matrix-number/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006tNbRwly1g9gjw2k3ahj30x00ik40v.jpg" alt=""></p><a id="more"></a><p>今天在访问 <a href="https://api.pkupi.com/" target="_blank" rel="noopener">https://api.pkupi.com/</a> 时，发现页面效果很是酷炫，查看 whois 显示域名将于 3 天后到期，就先把源码备份下来，万一以后<del>装逼</del>用得着呢</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"user-scalable=no, viewport-fit=cover"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"/favicon.ico"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">sizes</span>=<span class="string">"180x180"</span> <span class="attr">href</span>=<span class="string">"/images/favicon.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Danger!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    html, body &#123;</span><br><span class="line">        font-family: courier, monospace;</span><br><span class="line">    &#125;</span><br><span class="line">    span &#123;</span><br><span class="line">        animation: flash 1s infinite;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        /*</span><br><span class="line">        * _(:з」∠)_</span><br><span class="line"><span class="actionscript">        * Created by Shuqiao Zhang <span class="keyword">in</span> <span class="number">2018.</span></span></span><br><span class="line"><span class="actionscript">        * https:<span class="comment">//zhangshuqiao.org</span></span></span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line"><span class="vbscript">        * This program <span class="keyword">is</span> free software: you can redistribute it <span class="keyword">and</span>/<span class="keyword">or</span> modify</span></span><br><span class="line"><span class="javascript">        *  it under the terms <span class="keyword">of</span> the GNU General Public License <span class="keyword">as</span> published by</span></span><br><span class="line"><span class="javascript">        *  the Free Software Foundation, either version <span class="number">3</span> <span class="keyword">of</span> the License, or</span></span><br><span class="line"><span class="vbscript">        *  (at your <span class="keyword">option</span>) any later version.</span></span><br><span class="line">        *</span><br><span class="line"><span class="actionscript">        * This program <span class="keyword">is</span> distributed <span class="keyword">in</span> the hope that it will be useful,</span></span><br><span class="line"><span class="javascript">        *  but WITHOUT ANY WARRANTY; without even the implied warranty <span class="keyword">of</span></span></span><br><span class="line"><span class="vbscript">        *  MERCHANTABILITY <span class="keyword">or</span> FITNESS <span class="keyword">FOR</span> A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="vbscript">        *  GNU General <span class="keyword">Public</span> License <span class="keyword">for</span> more details.</span></span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>),</span></span><br><span class="line"><span class="actionscript">            context = canvas.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(canvas);</span></span><br><span class="line"><span class="actionscript">        canvas.style.cssText = <span class="string">"position: fixed; top: 0; left: 0; background-color: #111; z-index: -100;"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> W = <span class="built_in">window</span>.innerWidth,</span></span><br><span class="line"><span class="javascript">            H = <span class="built_in">window</span>.innerHeight;</span></span><br><span class="line">        canvas.width = W;</span><br><span class="line">        canvas.height = H;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> colunms = <span class="number">49</span>,</span></span><br><span class="line"><span class="javascript">            fontSize = <span class="built_in">Math</span>.floor(W / colunms),</span></span><br><span class="line"><span class="vbscript">            <span class="built_in">string</span> = <span class="string">"1234567890"</span>,</span></span><br><span class="line">            number = [],</span><br><span class="line">            jmax = 2;</span><br><span class="line">        </span><br><span class="line"><span class="actionscript">        setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            context.fillStyle = <span class="string">"rgba(0,0,0,0.4)"</span>;</span></span><br><span class="line">            context.fillRect(0, 0, W, H);</span><br><span class="line"><span class="actionscript">            context.font = <span class="string">"700 "</span> + fontSize + <span class="string">"px monospace"</span>;</span></span><br><span class="line"><span class="actionscript">            context.fillStyle = <span class="string">"#00cc33"</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; colunms; i++) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">9</span>) <span class="keyword">continue</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; jmax; j++) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * string.length);</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> x = (i + <span class="number">0.5</span>) * fontSize;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> y = j * fontSize;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (!number[[x, y]] || <span class="built_in">Math</span>.random() &lt; <span class="number">0.1</span>) number[[x, y]] = string[index];</span></span><br><span class="line">                    context.fillText(number[[x, y]], x, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (jmax &lt; <span class="built_in">Math</span>.ceil(H / fontSize)) jmax++;</span></span><br><span class="line">        &#125;, 80);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">"1"</span> <span class="attr">height</span>=<span class="string">"821"</span> <span class="attr">style</span>=<span class="string">"position: fixed; top: 0px; left: 0px; background-color: rgb(17, 17, 17); z-index: -100;"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><script async src="//jsfiddle.net/palemoky/newLybz4/1/embed/result/"></script><blockquote><p>由于 jsfiddle 在大陆有时不可访问，可能无法加载结果，请直接保存运行以上代码查看效果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Excel 处理小技巧</title>
      <link href="/post/excel-tricks/"/>
      <url>/post/excel-tricks/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g93qys36u6j30m80d575i.jpg" alt=""></p><a id="more"></a><h1 id="将多个-csv-文件合并为一个"><a href="#将多个-csv-文件合并为一个" class="headerlink" title="将多个 csv 文件合并为一个"></a>将多个 csv 文件合并为一个</h1><p>在 macOS 下，如果我们想要将多个 csv 文件合并，可以使用如下命令</p><p>不关心文件的顺序<br><code>$ cat *.csv &gt; all-in-one.csv</code></p><p>需要文件顺有序<br><code>$ cat file1.csv file2.csv ... file24.csv &gt; all-in-one.csv</code></p><blockquote><p>该方法来自知乎<a href="https://www.zhihu.com/question/26525722/answer/33093791" target="_blank" rel="noopener">Rio 的回答</a></p></blockquote><h1 id="使用-VLOOKUP-函数纵向查找"><a href="#使用-VLOOKUP-函数纵向查找" class="headerlink" title="使用 VLOOKUP 函数纵向查找"></a>使用 VLOOKUP 函数纵向查找</h1><p>假如我们现在有两个工作表，分别为 Sheet1 和 Sheet2，内容分别为<br>Sheet1 的内容<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g93qf6p4v6j308g07kaaa.jpg" alt=""></p><p>Sheet2 的内容<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g93qgct6whj30980783ys.jpg" alt=""></p><p>此时，我们需要将 Sheet2 的地区信息补充在 sheet1 的最后一列，于是我们在<code>C2</code>单元格输入公式<code>=VLOOKUP(A2,Sheet2!A2:B2,2,FALSE)</code>，然后拖动单元格即可自动补充。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g93qmt0qwej30vw08k0u7.jpg" alt=""></p><blockquote><p>⚠️ Sheet1 与 Sheet2 要查找的值顺序需要一致，否则无法匹配。</p></blockquote><p>现在，我们来看下这个公式分别是什么意思：<br><code>lookup_value</code>：要查找的值，类似于 SQL 中的 <code>join on</code> 条件<br><code>table_array</code>：要查找的区域，即我们要在 Sheet2 中要检索哪几列<br><code>col_index_num</code>：返回数据在查找区域的第几列数<br><code>[range_lookup]</code>：模糊匹配(TRUE)/精确匹配(FALSE)</p><p>再回到我们的公式，<code>A2</code>表示我们要在当前 Sheet 中查找<code>A2</code>单元格的值，<code>Sheet2!A2:B2</code>表示我们要在 Sheet2 的<code>A2</code>至<code>B2</code>单元格间查找匹配的值，<code>2</code>则表示我们取 Sheet2 匹配结果的第 2 列，<code>FALSE</code>表示精确匹配查找的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息杂谈</title>
      <link href="/post/informations-essays/"/>
      <url>/post/informations-essays/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g92d5qfevhj30ka0eh3zs.jpg" alt=""></p><a id="more"></a><p>在 19 世纪末，一个小镇上发生的事情就像发生在另一个星球上。电话和无线电改变了 20 世纪，打破了这些障碍。21 世纪，SNS 让地球村得以实现，我们可以在一方小小的屏幕前了解到世界另一端正在发生的事情。</p><p>从烽火狼烟到报纸杂志，再到广播电视，再到互联网、移动互联网，每一次的信息革命都加速了人类文明。虽然信息的形式在不断的变化，但信息的本质并没有太多的变化，人们在不断追求信息更高效的获取：文字比肢体能表达更多的信息，声音又能传递更丰富的信息，视频则承载了更多的信息容量。</p><p>虽然信息载体的形式在不断的进化，但信息的有效性是另一个伴随着的问题，人们如何才能在洪水般的信息流中高效检索到有效信息？如今，我们看到，机器学习和算法推荐提升了有效信息，Apple News+ 则通过帮助人们检索高价值信息提供服务。在任何时代，我们都需要有思辨能力，掌握高效获取信息的技巧，让你的人生延长，回到过去，看到未来。</p><hr><p>参考资料</p><ol><li><a href="https://www.collaborativefund.com/blog/three-big-things-the-most-important-forces-shaping-the-world/" target="_blank" rel="noopener">Three Big Things: The Most Important Forces Shaping the World</a></li><li><a href="https://book.douban.com/subject/1013208/" target="_blank" rel="noopener">《如何阅读一本书》</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>挂南墙</title>
      <link href="/post/Wall-of-Shame/"/>
      <url>/post/Wall-of-Shame/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xlov4al5j30m80agdgk.jpg" alt=""></p><a id="more"></a><h1 id="错误变量命名-amp-深层嵌套循环"><a href="#错误变量命名-amp-深层嵌套循环" class="headerlink" title="错误变量命名 &amp; 深层嵌套循环"></a>错误变量命名 &amp; 深层嵌套循环</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xkmljfu1j31t40oswiz.jpg" alt=""></p><h1 id="switch-嵌套-amp-滥用数字枚举"><a href="#switch-嵌套-amp-滥用数字枚举" class="headerlink" title="switch 嵌套 &amp; 滥用数字枚举"></a>switch 嵌套 &amp; 滥用数字枚举</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xkmtcrgoj30u00u8djh.jpg" alt=""></p><h1 id="不-OK-不要返回-OK，OK？"><a href="#不-OK-不要返回-OK，OK？" class="headerlink" title="不 OK 不要返回 OK，OK？"></a>不 OK 不要返回 OK，OK？</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xkofqkonj30hk05sgls.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xkphec22j30u806y0th.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xkqyaevsj31fg07074w.jpg" alt=""></p><h1 id="无效异常"><a href="#无效异常" class="headerlink" title="无效异常"></a>无效异常</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xks8hsgpj30rg040jry.jpg" alt=""></p><p>你能告诉我这样的报错有什么意义吗？是什么原因？我该怎么做？</p><h1 id="滥用数字枚举"><a href="#滥用数字枚举" class="headerlink" title="滥用数字枚举"></a>滥用数字枚举</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xla935ftj306505o0ss.jpg" alt=""></p><h1 id="滥用静态方法"><a href="#滥用静态方法" class="headerlink" title="滥用静态方法"></a>滥用静态方法</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xl0z6oo0j30me0qnq6n.jpg" alt=""></p><h1 id="方法臃肿"><a href="#方法臃肿" class="headerlink" title="方法臃肿"></a>方法臃肿</h1><p>//todo</p><h1 id="无视-IDE-警告"><a href="#无视-IDE-警告" class="headerlink" title="无视 IDE 警告"></a>无视 IDE 警告</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xl6adn42j301817cmwy.jpg" alt=""></p><h1 id="git-同名文件大小写敏感区分"><a href="#git-同名文件大小写敏感区分" class="headerlink" title="git 同名文件大小写敏感区分"></a>git 同名文件大小写敏感区分</h1><p>大多数的开发者电脑是大小写不敏感的，这会导致 Git 在这样的电脑中将两个文件识别为同一个文件，始终检测到有一个文件被修改而又无法被跟踪。你确定同名大小写文件所带来的错误风险是小于优势收益吗？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《Redis开发与运维》</title>
      <link href="/post/redis-devops/"/>
      <url>/post/redis-devops/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8ronsawmbj30ku0aft9d.jpg" alt=""></p><a id="more"></a><h1 id="第-1-章-初识-Redis"><a href="#第-1-章-初识-Redis" class="headerlink" title="第 1 章 初识 Redis"></a>第 1 章 初识 Redis</h1><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><ul><li>string(Bitmaps &amp; HyperLogLog)</li><li>hash</li><li>list</li><li>set</li><li>zset</li></ul><h2 id="Redis-提供的功能"><a href="#Redis-提供的功能" class="headerlink" title="Redis 提供的功能"></a>Redis 提供的功能</h2><ul><li>键过期</li><li>发布订阅（消息系统）</li><li>事务</li><li>流水线（一批命令一次发送到 Redis，避免网络开销）</li><li>Lua 脚本</li></ul><h2 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h2><ul><li>缓存</li><li>排行榜</li><li>计数器（视频播放数，商品浏览量）</li><li>社交（共同好友、粉丝、点赞）</li><li>消息队列</li><li>共享 Session</li><li>限速（如，60s 获取一次手机验证码：<code>redis.set(phoneNum, 1, &quot;EX 60&quot;, &quot;NX&quot;)</code>）</li><li>使用哈希类型模拟关系型数据库（优点：用户信息内聚性较强，占用的键较少；缺点：哈希类型是稀疏的，难以做复杂的关系查询。注意：要控制哈希在 ziplist 和 hashtable 两种内部编码的转换，hashtable 会消耗更多的内存）</li></ul><h2 id="为什么-Redis-很快？"><a href="#为什么-Redis-很快？" class="headerlink" title="为什么 Redis 很快？"></a>为什么 Redis 很快？</h2><ul><li>内存访问</li><li>C 语言实现</li><li>单线程架构，避免线程切换与竞态产生的消耗</li><li>I/O 多路复用模型（epoll）</li></ul><p>安装软件时，为软件建立软连接是一种好习惯，避免将软件固定在指定版本上，有利于未来软件的版本升级。</p><p>Redis 借鉴了 Linux 对于版本号的命名规则：版本号第二位如果是奇数，则为非稳定版本（如 2.7、2.9、3.1），否则为稳定版本（如 2.6、2.8、3.0）</p><h2 id="Redis-可执行文件说明"><a href="#Redis-可执行文件说明" class="headerlink" title="Redis 可执行文件说明"></a>Redis 可执行文件说明</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>redis-server</code></td><td>启动 Redis</td></tr><tr><td><code>redis-cli</code></td><td>Redis 命令行客户端</td></tr><tr><td><code>redis-cli shutdown</code></td><td>关闭 Redis</td></tr><tr><td><code>redis-benchmark</code></td><td>Redis 基准测试工具</td></tr><tr><td><code>redis-check-of</code></td><td>Redis AOF 持久化文件检测与修复工具</td></tr><tr><td><code>redis-check-dump</code></td><td>Redis RDB 持久化文件检测与修复工具</td></tr><tr><td><code>redis-sentinel</code></td><td>启动 Redis Sentinel</td></tr></tbody></table><h2 id="启动-Redis-的3种方式"><a href="#启动-Redis-的3种方式" class="headerlink" title="启动 Redis 的3种方式"></a>启动 Redis 的3种方式</h2><ol><li>默认配置(<code>redis-server</code>)</li><li>运行配置(<code>redis-server --port 6380</code>)</li><li>配置文件(<code>redis-server /opt/redis/redis.conf</code>)</li></ol><h1 id="第-2-章-API-的理解和使用"><a href="#第-2-章-API-的理解和使用" class="headerlink" title="第 2 章 API 的理解和使用"></a>第 2 章 API 的理解和使用</h1><table><thead><tr><th>命令</th><th>选项</th><th>返回值</th><th>含义</th><th>复杂度</th><th>备注</th></tr></thead><tbody><tr><td><code>keys pattern</code></td><td>pattern 使用的是 glob 风格的通配符</td><td></td><td>查看所有键</td><td>$O(n)$</td><td>大量键时禁止使用</td></tr><tr><td><code>dbsize</code></td><td></td><td>int（&gt;=0）</td><td>键总数</td><td>$O(1)$</td><td>不遍历键，直接读取内置键总数</td></tr><tr><td><code>exists key</code></td><td></td><td>intbool（存在为 1，否则为 0）</td><td>检查键是否存在</td><td></td><td></td></tr><tr><td><code>del key [key ...]</code></td><td></td><td>int（成功删除的个数，若删除不存在的键，返回 0）</td><td>删除键</td><td>$O(k)$，𝑘为键的个数</td><td></td></tr><tr><td><code>expire key seconds</code><br><br><code>expireat key timestamp</code><br><br><code>pexpire key milliseconds</code><br><br><code>pexpireat key milliseconds-timestamp</code></td><td></td><td>boolint（成功为 1，key 不存在或无法设置为 0）</td><td>键过期</td><td></td><td>1. 无论使用哪种形式，在 Redis 内部最终使用的都是<code>pexpireat</code>；<br>2. 如果<code>expire key</code>的键不存在，返回 0;<br>3. 如果过期时间为负值，键会被立即删除，犹如使用了<code>del</code>;<br>4. <code>persist key</code>可以将键的过期时间清除；<br>5. <strong>对于字符串类型键，执行<code>set</code>命令会去掉过期时间</strong>;<br>6. Redis 不支持二级数据结构（哈希、列表）内部元素的过期功能，如不能对列表类型的一个元素做过期时间设置；<br>7. <code>setex</code>作为<code>set</code>+<code>expire</code>的组合，不但是原子执行，同时减少了一次网络通讯的时间</td></tr><tr><td><code>ttl key</code><br><code>pttl key</code></td><td></td><td>int（&gt;=0：键剩余过期时间；-1：键未设置过期时间；-2：键不存在）</td><td>查看键剩余存活时间（秒/毫秒）</td><td></td><td></td></tr><tr><td><code>type key</code></td><td></td><td>键存在返回数据类型，不存在返回 none</td><td>查看键的数据类型</td><td></td><td></td></tr><tr><td><code>rename key newkey</code><br><code>renamenx key newkey</code></td><td></td><td>成功返回<code>OK</code>,失败为 0</td><td>键重命名</td><td></td><td>1. 如果在重命名之前，键值已经存在，则值会被覆盖；<br>2. 由于重命名键期间会执行<code>del</code>删除旧键，如果键对应的值较大，可能会被阻塞</td></tr><tr><td><code>randomkey</code></td><td></td><td></td><td>随机返回一个键</td><td></td><td></td></tr><tr><td><code>move key db</code><br><br><code>dump key</code> + <code>restore key ttl value</code><br><br><code>migrate host port key|&quot;&quot; destination-db timeout [copy] [replace] [keys key [key ...]]</code></td><td><code>ttl</code>为 0 时表示无过期时间<br><code>host</code>:目标主机<br><code>port</code>:目标端口<br><code>key|&quot;&quot;</code>:迁移单个键指定键名，多个键则为空字符串<br><code>destination-db</code>:目标 db 索引<br><code>timeout</code>:迁移的超时时间（毫秒）<br><code>copy</code>:不删除源键<br><code>replace</code>:对目标 Redis 覆写操作。若未指定，源 Redis 和目标 Redis 存在同名键会报错<br><code>keys key [key ...]</code>:迁移的键名</td><td></td><td>迁移键</td><td></td><td>方式二中，<code>dump</code>会将键值序列化，格式采用 RDB 格式，在目标 Redis 上，<code>restore</code>再将序列化的值复原<br><br><code>migrate</code>实质上是<code>dump</code>、<code>restore</code>、<code>del</code>三个命令的组合。<code>migrate</code>具有原子性，只需在源 Redis 上执行即可，目标 Redis 完成<code>restore</code>后返回 OK，源 Redis 再根据<code>migrate</code>的对应选项决定是否在源 Redis 上删除对应的键</td></tr><tr><td><code>scan cursor [match pattern] [count number]</code></td><td><code>cursor</code>：游标，第一次遍历从0开始，每次<code>scan</code>遍历完都会返回当前游标的值，直到游标值为0，表示遍历结束<br><code>·match pattern</code>：模式匹配<br><code>count number</code>：明每次要遍历的键个数，默认值是10，此参数可以适当增大</td><td></td><td>渐进式遍历</td><td></td><td>如果在遍历过程中键发生了变化，则结果可能是不准确的；<br><code>hscan</code> 解决 <code>hgetall</code> 的阻塞<br><code>sscan</code>解决<code>smembers</code> 的阻塞<br><code>zscan</code>解决<code>zrange</code> 的阻塞</td></tr><tr><td><code>select dbIndex</code></td><td></td><td></td><td>切换数据库</td><td></td><td>默认 16 个数据库(0~15)，未指定数据库时，默认为 0 数据库;<br>建议只使用 0 号数据库，避免多数据库的切换错误，以及故障排查困难。如果需要使用多数据库，可以在单机部署多个 Redis 实例，通过端口区分不同数据库</td></tr><tr><td><code>flushdb</code><br><code>flushall</code></td><td></td><td></td><td>清空当前/所有数据库</td><td></td><td>若数据库键值较多，可能引发阻塞</td></tr><tr><td><strong>字符串 String</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>set key value [ex seconds] [px milliseconds] [nx|xx]</code></td><td>ex：设置秒级过期时间<br>px：设置毫秒级过期时间<br>nx：键不存在才能设置成功，用于添加<br>xx：键存在才能设置成功，用于更新</td><td>成功返回 OK，失败返回 0</td><td>设置值</td><td>$O(1)$</td><td></td></tr><tr><td><code>setex key seconds value</code></td><td></td><td>成功返回 OK，失败返回 0</td><td>设定的值存在才会成功</td><td></td><td></td></tr><tr><td><code>setnx key value</code></td><td></td><td>成功返回 OK，失败返回 0</td><td>设定的值不存在才会成功</td><td></td><td>常用于分布式锁</td></tr><tr><td><code>get key</code></td><td></td><td>键存在时返回值，不存在返回 nil</td><td>获取值</td><td>$O(1)$</td><td></td></tr><tr><td><code>mset key value [key value ...]</code></td><td></td><td>成功返回 OK，失败返回 0</td><td>批量设置值</td><td>$O(k)$，𝑘为键的个数</td><td></td></tr><tr><td><code>mget key [key ...]</code></td><td></td><td>键存在时返回值，不存在返回 nil。结果按照传入键的顺序返回</td><td>批量获取值</td><td>$O(k)$，𝑘为键的个数</td><td></td></tr><tr><td><code>incr key</code></td><td></td><td>值不是整数，返回错误<br>值是整数，返回自增后结果<br>键不存在，按照值为 0 自增，返回结果为 1</td><td>值自增</td><td>$O(1)$</td><td></td></tr><tr><td><code>decr key</code></td><td></td><td>int</td><td>值自减</td><td>$O(1)$</td><td></td></tr><tr><td><code>incrby key increment</code></td><td></td><td>int</td><td>自增指定数字</td><td>$O(1)$</td><td></td></tr><tr><td><code>decrby key decrement</code></td><td></td><td>int</td><td>自减指定数字</td><td>$O(1)$</td><td></td></tr><tr><td><code>incrbyfloat key increment</code></td><td></td><td>float</td><td>自增浮点数</td><td>$O(1)$</td><td></td></tr><tr><td><code>append key value</code></td><td></td><td>int（返回追加后的字符长度）</td><td>向字符串尾部追加值</td><td>$O(1)$</td><td></td></tr><tr><td><code>strlen key</code></td><td></td><td>int（根据不同编码返回字符长度，如 UTF8 的“中国”返回值为 6）</td><td>字符串长度</td><td>$O(1)$</td><td></td></tr><tr><td><code>getset key value</code></td><td></td><td></td><td>设置并返回值</td><td></td><td></td></tr><tr><td><code>setrange key offeset value</code></td><td></td><td>int（返回字符长度）</td><td>设置指定位置的字符</td><td>$O(1)$</td><td></td></tr><tr><td><code>getrange key start end</code></td><td></td><td>返回截取的字符内容</td><td>获取部分字符串</td><td>$O(n)$，𝑛 为字符串长度，由于获取字符串非常快，若字符串不是很长，可以视为$O(1)$</td><td></td></tr><tr><td><strong>哈希 Hash</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>hset key field value</code><br><code>hget key field</code></td><td></td><td></td><td>设置值<br>获取值</td><td>$O(1)$<br>$O(1)$</td><td>在 Redis 中，哈希类型是指键值本身又是一个键值对结构（形如 JSON）。哈希类型中的映射关系叫作field-value，注意这里的value是指field对应的值，不是键对应的值，请注意value在不同上下文的作用。</td></tr><tr><td><code>hdel key field [field ...]</code></td><td></td><td>int （成功为删除的个数）</td><td>删除 field</td><td>$O(k)$ ，𝑘是field个数</td><td></td></tr><tr><td><code>hlen key</code></td><td></td><td>int</td><td>计算 field 个数</td><td>$O(1)$</td><td></td></tr><tr><td><code>hmset key field value [field value ...]</code><br><code>hmget key field [field ...]</code></td><td></td><td></td><td>批量设置或获取field-value</td><td>$O(k)$ ，𝑘是field个数<br>$O(k)$ ，𝑘是field个数</td><td></td></tr><tr><td><code>hexists key field</code></td><td></td><td>存在为 1，否则为 0</td><td>判断field是否存在</td><td>$O(1)$</td><td></td></tr><tr><td><code>hsetnx key field value</code></td><td></td><td></td><td></td><td>$O(1)$</td><td></td></tr><tr><td><code>hkeys key</code></td><td></td><td></td><td>获取所有field</td><td>$O(n)$ ，𝑛 是field个数</td><td><code>hkeys</code> 叫 <code>hfields</code>更恰当</td></tr><tr><td><code>hvals key</code></td><td></td><td></td><td>获取所有value</td><td>$O(n)$ ，𝑛 是field个数</td><td></td></tr><tr><td><code>hgetall key</code></td><td></td><td></td><td>获取所有的field-value</td><td>$O(n)$ ，𝑛 是field个数</td><td>在使用<code>hgetall</code>时，如果哈希元素个数比较多，可能会阻塞Redis。如果开发人员只需要获取部分field，可以使用<code>hmget</code>，如果一定要获取全部field-value，可以使用<code>hscan</code>命令，该命令会渐进式遍历哈希类型。</td></tr><tr><td><code>hincrby key field</code><br><code>hincrbyfloat key field</code></td><td></td><td></td><td>按指定值递增</td><td>$O(1)$<br>$O(1)$</td><td></td></tr><tr><td><code>hstrlen key field</code></td><td></td><td></td><td>计算value的字符串长度</td><td>$O(1)$</td><td></td></tr><tr><td>列表 List</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>lpush key value [value ...]</code><br><code>rpush key value [value ...]</code></td><td></td><td>int（成功插入元素个数）</td><td>从左/右侧插入元素</td><td>$O(k)$，𝑘 为元素个数</td><td>列表类型的两个特点：第一，列表中的元素是有序的（即，可以通过索引下标获取元素）；第二，列表中的元素可以是重复的</td></tr><tr><td><code>lpop key</code><br><code>rpop key</code></td><td></td><td></td><td>从列表左/右侧弹出元素</td><td>$O(1)$</td><td></td></tr><tr><td><code>linsert key before|after pivot value</code></td><td></td><td>int（返回当前列表长度）</td><td>向某个元素前或者后插入元素</td><td>$O(n)$，𝑛 是 pivot 距离列表头或尾的距离</td><td></td></tr><tr><td><code>lrange key start end</code></td><td></td><td></td><td>获取指定范围内的元素列表</td><td>$O(s+n)$，𝑠 是 start 偏移量，𝑛 是start 到 end 的范围</td><td>1. <code>lrange 0 -1</code> 可获取列表所有元素<br>2. end 包含了自身</td></tr><tr><td><code>lindex key index</code></td><td></td><td></td><td>获取列表指定索引下标的元素</td><td>$O(n)$，𝑛 是索引的偏移量</td><td></td></tr><tr><td><code>llen key</code></td><td></td><td>int</td><td>获取列表长度</td><td>$O(1)$</td><td></td></tr><tr><td><code>lrem key count value</code></td><td></td><td>count &gt; 0，从左到右，删除最多 count 个元素<br>count &lt; 0，从右到左，删除最多 count 绝对值个元素<br>count = 0，删除所有</td><td>删除指定元素</td><td>$O(n)$，𝑛 是列表长度</td><td></td></tr><tr><td><code>ltrim key start end</code></td><td></td><td></td><td>按照索引范围修剪列表</td><td>$O(n)$，𝑛 是要裁剪的元素总数</td><td></td></tr><tr><td><code>lset key index newValue</code></td><td></td><td></td><td>修改指定索引下标的元素</td><td>$O(n)$，𝑛 是索引的偏移量</td><td></td></tr><tr><td><code>blpop key [key ...] timeout</code><br><code>brpop key [key ...] timeout</code></td><td><code>timeout</code> 为阻塞时间</td><td></td><td>阻塞式弹出</td><td>$O(1)$</td><td>如果有多个键，那么<code>brpop</code>会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回</td></tr><tr><td><strong>集合(Set)</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>sadd key element [element ...]</code></td><td></td><td>int（返回添加成功元素的个数）</td><td>添加元素</td><td>$O(k)$，𝑘是元素个数</td><td></td></tr><tr><td><code>srem key element [element ...]</code></td><td></td><td>int（返回删除成功元素的个数）</td><td>删除元素</td><td>$O(k)$，𝑘是元素个数</td><td></td></tr><tr><td><code>scard key</code></td><td></td><td></td><td>计算元素个数</td><td>$O(1)$</td><td>同<code>dbsize</code>类似，直接读取内置变量</td></tr><tr><td><code>sismember key element</code></td><td></td><td>int（存在返回 1，否则为 0）</td><td>判断元素是否在集合中</td><td>$O(1)$</td><td></td></tr><tr><td><code>srandmember key [count]</code></td><td></td><td></td><td>随机从集合返回指定个数元素</td><td>$O(count)$</td><td></td></tr><tr><td><code>spop key</code></td><td></td><td></td><td>从集合随机弹出元素</td><td>$O(1)$</td><td><code>srandmember</code>和<code>spop</code>都是随机从集合选出元素，两者不同的是<code>spop</code>命令执行后，元素会从集合中删除，而<code>srandmember</code>不会。</td></tr><tr><td><code>smembers key</code></td><td></td><td></td><td>获取所有元素，结果是无序的</td><td>$O(n)$，𝑛是元素总数</td><td><code>smembers</code>和<code>lrange</code>、<code>hgetall</code>都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，这时候可以使用<code>sscan</code>来完成</td></tr><tr><td><code>sinter key [key ...]</code></td><td></td><td></td><td>取交集</td><td>$O(m*k)$，𝑘是多个集合元素最少的个数，𝑚是键个数</td><td></td></tr><tr><td><code>suinon key [key ...]</code></td><td></td><td></td><td>取并集</td><td>$O(k)$，𝑘是多个集合元素个数和</td><td></td></tr><tr><td><code>sdiff key [key ...]</code></td><td></td><td></td><td>取差集</td><td>$O(k)$，𝑘是多个集合元素个数和</td><td></td></tr><tr><td><code>sinterstore destination key [key ...]</code><br><code>suionstore destination key [key ...]</code><br><code>sdiffstore destination key [key ...]</code></td><td></td><td></td><td>）将交集、并集、差集的结果保存</td><td></td><td></td></tr><tr><td><strong>有序集合（Zset）</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>zadd key score member [score member ...]</code></td><td></td><td></td><td>添加成员</td><td>$O(k*log(n))$，𝑘是添加成员的个数，𝑛是当前有序集合成员个数</td><td></td></tr><tr><td><code>zcard key</code></td><td></td><td>int</td><td>计算成员个数</td><td>$O(1)$</td><td></td></tr><tr><td><code>zscore key member</code></td><td></td><td>int（成员不存在返回 nil）</td><td>计算某个成员的分数</td><td>$O(1)$</td><td></td></tr><tr><td><code>zrank key member</code><br><code>zrevrank key member</code></td><td></td><td>返回分数从低到高/从高到低的排名</td><td>计算成员的排名</td><td>$O(log(n))$，𝑛是当前有序集合成员个数</td><td></td></tr><tr><td><code>zrem key member [member ...]</code></td><td></td><td>返回删除成员的个数</td><td>删除成员</td><td>$O(k*log(n))$，𝑘是删除成员的个数，𝑛是当前有序集合成员个数</td><td></td></tr><tr><td><code>zincrby key increment member</code></td><td></td><td></td><td>增加成员的分数</td><td>$O(log(n))$，𝑛是当前有序集合成员个数</td><td></td></tr><tr><td><code>zrange key start end [withscores]</code><br><code>zrevrange key start end [withscores]</code></td><td><code>withscores</code>会同时返回成员分数</td><td>返回分数从低到高/从高到低的排名</td><td>返回指定排名范围的成员</td><td>$O(log(n)+k)$，𝑘是要获取的成员个数，𝑛是当前有序集合成员个数</td><td></td></tr><tr><td><code>zrangebyscore key min max [withscores] [limit offset count]</code><br><code>zrevrangebyscore key max min [withscores] [limit offset count]</code></td><td><code>min</code>和<code>max</code>还支持开区间（小括号）和闭区间（中括号），<code>-inf</code>和<code>+inf</code>分别代表无限小和无限大</td><td></td><td>返回指定分数范围的成员</td><td>$O(log(n)+k)$，𝑘是要获取的成员个数，𝑛是当前有序集合成员个数</td><td></td></tr><tr><td><code>zcount key min max</code></td><td></td><td></td><td>返回指定分数范围成员个数</td><td>$O(log(n))$，𝑛是当前有序集合成员个数</td><td></td></tr><tr><td><code>zremrangebyrank key start end</code></td><td></td><td></td><td>删除指定排名内的升序元素</td><td>$O(log(n)+k)$，𝑘是要删除的成员个数，𝑛是当前有序集合成员个数</td><td></td></tr><tr><td><code>zremrangebyscore key min max</code></td><td></td><td></td><td>删除指定分数范围的成员</td><td>$O(log(n)+k)$，𝑘是要删除的成员个数，𝑛是当前有序集合成员个数</td><td></td></tr><tr><td><code>zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></td><td><code>destination</code>：交集计算结果保存到这个键；<br><code>numkeys</code>：需要做交集计算键的个数；<br><code>key [key...]</code>：需要做交集计算的键；<br><code>weights weight[weight...]</code>：每个键的权重，在做交集计算时，每个键中的每个 member 会将自己分数乘以这个权重，每个键的权重默认是1；<br><code>aggregate sum|min|max</code>：计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是sum</td><td></td><td>取交集</td><td>$O(n * k)+O(m*log(m))$，𝑛是成员数最小的有序集合成员个数，𝑘是有序集合的个数，𝑚是结果集中成员个数</td><td></td></tr><tr><td><code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></td><td></td><td></td><td>取并集</td><td>$O(n)+O(m*log(m))$，𝑛是所有有序集合成员个数和，𝑚是结果集中成员个数</td><td></td></tr></tbody></table><h2 id="判断键不存在的方法"><a href="#判断键不存在的方法" class="headerlink" title="判断键不存在的方法"></a>判断键不存在的方法</h2><ol><li><code>exists</code> 返回 0</li><li><code>del</code> 返回 0</li><li><code>ttl</code> 返回 -2</li><li><code>type</code> 返回 <code>none</code></li><li><code>get</code> 返回 <code>nil</code></li></ol><p>设计合理的键名，有助于防止键冲突和项目的可维护性，比较推荐的方式是使用“业务名:对象名:id:[属性]”作为键名。如果键名较长，可以在能描述键含义的前提下适当减少键的长度，从而减少由于键名过长而导致的内存浪费。</p><h2 id="列表的四种操作类型"><a href="#列表的四种操作类型" class="headerlink" title="列表的四种操作类型"></a>列表的四种操作类型</h2><table><thead><tr><th>操作类型</th><th>操作</th></tr></thead><tbody><tr><td>添加</td><td><code>rpush</code> <code>lpush</code> <code>linsert</code></td></tr><tr><td>查</td><td><code>lrange</code> <code>lindex</code> <code>llen</code></td></tr><tr><td>删除</td><td><code>lpop</code> <code>rpop</code> <code>lrem</code> <code>ltrim</code></td></tr><tr><td>修改</td><td><code>lset</code></td></tr><tr><td>阻塞操作</td><td><code>blpop</code> <code>brpop</code></td></tr></tbody></table><h2 id="列表的使用场景"><a href="#列表的使用场景" class="headerlink" title="列表的使用场景"></a>列表的使用场景</h2><ul><li><code>lpush</code> + <code>lpop</code> = Stack（栈）</li><li><code>lpush</code> + <code>rpop</code> = Queue（队列）</li><li><code>lpush</code> + <code>ltrim</code> = Capped Collection（有限集合）</li><li><code>lpush</code> + <code>brpop</code> = Message Queue（消息队列）</li></ul><h2 id="集合的使用场景"><a href="#集合的使用场景" class="headerlink" title="集合的使用场景"></a>集合的使用场景</h2><ul><li><code>sadd</code> = Tagging（标签）</li><li><code>spop/srandmember</code> = Random item（生成随机数，比如抽奖）</li><li><code>sadd</code> + <code>sinter</code>= Social Graph（社交需求）</li></ul><h2 id="列表、集合、有序集合的异同点"><a href="#列表、集合、有序集合的异同点" class="headerlink" title="列表、集合、有序集合的异同点"></a>列表、集合、有序集合的异同点</h2><table><thead><tr><th>数据结构</th><th align="center">是否允许重复元素</th><th align="center">是否有序</th><th>有序实现方式</th><th>应用场景</th></tr></thead><tbody><tr><td>列表</td><td align="center">是</td><td align="center">是</td><td>索引下标</td><td>时间轴、消息队列等</td></tr><tr><td>集合</td><td align="center">否</td><td align="center">否</td><td>无</td><td>标签、社交等</td></tr><tr><td>有序集合</td><td align="center">否</td><td align="center">是</td><td>分值</td><td>排行榜、社交等</td></tr></tbody></table><h2 id="Redis-数据结构与内部编码"><a href="#Redis-数据结构与内部编码" class="headerlink" title="Redis 数据结构与内部编码"></a>Redis 数据结构与内部编码</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8rmou0bzdj30hx0kb0xe.jpg" alt="Redis数据结构与内部编码"></p><ul><li>字符串<ul><li>int: 8个字节的长整型</li><li>embstr: &lt;=39 Byte 的字符串</li><li>raw: &gt;39 Byte 的字符串</li></ul></li><li>哈希<ul><li>ziplist: 当哈希类型元素个数小于 <code>hash-max-ziplist-entries</code> 配置（默认512个）、同时所有值都小于 <code>hash-max-ziplist-value</code> 配置（默认64字节）时，Redis 会使用 ziplist 作为哈希的内部实现，ziplist 使用更加紧凑的结构实现多个元素的连续存储，所以在<strong>节省内存方面比 hashtable 更加优秀</strong>。</li><li>hashtable: 当哈希类型无法满足 ziplist 的条件时，Redis 会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度为$O(1)$</li></ul></li><li>列表<ul><li>ziplist: 当列表元素个数小于 <code>list-max-ziplist-entries</code> 配置（默认512个）、同时每个元素值都小于 <code>list-max-ziplist-value</code> 配置（默认64字节）时，Redis 会使用 ziplist 来作为列表的内部实现来减少内存</li><li>linkedlist: 当无法满足ziplist条件时</li></ul></li><li>集合<ul><li>intset: 当集合中的元素都是整数且元素个数小于<code>set-maxintset-entries</code>配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</li><li>hashtable: 无法满足intset时</li></ul></li><li>有序集合<ul><li>ziplist: 当有序集合的元素个数小于<code>zset-max-ziplistentries</code>配置（默认128个），同时每个元素的值都小于<code>zset-max-ziplist-value</code>配置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现来减少内存</li><li>skiplist: 当无法满足ziplist条件时</li></ul></li></ul><p>Redis 设计内部编码与外部结构有两个好处</p><ol><li>改进内部编码而对外部数据结构和命令没有影响</li><li>多种内部编码实现可以在不同场景下发挥各自的优势，如 ziplist 比较节省内存，但在列表元素较多的情况下，性能会有所下降，此时 Redis 会根据配置选项将列表类型的内部实现转换为 linkedlist。</li></ol><p>可以通过<code>object encoding key</code>命令查询内部编码。</p><h1 id="第-3-章-小功能大用处"><a href="#第-3-章-小功能大用处" class="headerlink" title="第 3 章 小功能大用处"></a>第 3 章 小功能大用处</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><h3 id="慢查询配置"><a href="#慢查询配置" class="headerlink" title="慢查询配置"></a>慢查询配置</h3><ul><li><code>slowlog-log-slower-than</code> 执行时间阈值<ul><li>单位为微秒，默认 10,000，为 0 表示记录所有命令，&lt;0 不记录任何命令</li><li>在高并发场景下，需要将该值向下调整</li></ul></li><li><code>slowlog-max-len</code><ul><li>Redis 使用列表结构存储慢查询日志，该参数为列表最大长度</li><li>当列表达最大长度时，最早插入的命令会被从列表中移出</li><li>可定时将慢查询日志持久化处理，便于排查故障</li></ul></li></ul><h3 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h3><table><thead><tr><th>命令</th><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>slowlog get [n]</code></td><td><code>n</code>: 指定条数</td><td></td></tr><tr><td><code>slowlog len</code></td><td></td><td>获取当前慢查询列表长度</td></tr><tr><td><code>slowlog reset</code></td><td></td><td>重置日志，即清理慢查询列表</td></tr></tbody></table><h3 id="慢查询日志结构"><a href="#慢查询日志结构" class="headerlink" title="慢查询日志结构"></a>慢查询日志结构</h3><p>由 4 个属性组成</p><ol><li>日志标识 ID</li><li>时间戳</li><li>命令耗时</li><li>执行命令和参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; slowlog get</span><br><span class="line">1) 1) (integer) 666</span><br><span class="line">   2) (integer) 1456786500</span><br><span class="line">   3) (integer) 11615</span><br><span class="line">   4) 1) &quot;BGREWRITEAOF&quot;</span><br><span class="line">2) 1) (integer) 665</span><br><span class="line">   2) (integer) 1456718400</span><br><span class="line">   3) (integer) 12006</span><br><span class="line">   4) 1) &quot;SETEX&quot;</span><br><span class="line">      2) &quot;video_info_200&quot;</span><br><span class="line">      3) &quot;300&quot;</span><br><span class="line">      4) &quot;2&quot;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Redis-Shell"><a href="#Redis-Shell" class="headerlink" title="Redis Shell"></a>Redis Shell</h2><h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a><code>redis-cli</code></h3><table><thead><tr><th>示例</th><th>选项</th><th>备注</th></tr></thead><tbody><tr><td><code>redis-cli -r 3 ping</code></td><td><code>-r</code>(repeat)：指定命令执行次数</td><td></td></tr><tr><td><code>redis-cli -r 5 -i 1 ping</code></td><td><code>-i</code>(interval)：执行命令间隔时间，单位秒</td><td><code>-i</code>必须与<code>-r</code>一同使用<br>该选项不支持毫秒为单位，若想以 10ms 为间隔，可以使用<code>-i 0.01</code></td></tr><tr><td><code>echo &quot;world&quot; | redis-cli -x set hello</code></td><td><code>-x</code>: 从 stdin 读取数据作为 <code>redis-cli</code>的最后一个参数</td><td></td></tr><tr><td></td><td><code>-c</code>(cluster): 连接 Redis cluster 时使用，可以防止 <code>moved</code> 和 <code>ask</code> 异常</td><td></td></tr><tr><td></td><td><code>-a</code>(auth): 密码认证</td><td></td></tr><tr><td><code>redis-cli --scan --pattern &quot;app*&quot;</code></td><td><code>--scan</code> &amp; <code>--pattern</code>: 于扫描指定模式的键</td><td></td></tr><tr><td><code>redis-cli --slave</code></td><td><code>--slave</code>选项是把当前客户端模拟成当前 Redis 节点的从节点，可以用来获取当前 Redis 节点的更新操作</td><td></td></tr><tr><td></td><td><code>--rdb</code>: 将 Redis 实例持久化</td><td></td></tr><tr><td></td><td><code>--pipe</code>: 将命令封装成Redis通信协议定义的数据格式，批量发送给Redis执行</td><td></td></tr><tr><td><code>redis-cli --bigkeys</code></td><td><code>--bigkeys</code>: 使用scan命令对Redis的键进行采样，从中找到内存占用比较大的键值，这些键可能是系统的瓶颈</td><td></td></tr><tr><td></td><td><code>--eval</code>: 指定 Lua 脚本</td><td></td></tr><tr><td><code>redis-cli -h {machineB} --latency</code><br><code>redis-cli -h {machineB} --latency-history</code><br><code>redis-cli -h {machineB} --latency-dist</code></td><td><code>--latency</code>: 测试目标 Redis 网络延时。仅返回一条结果<br><code>--latency-history</code>: 每间隔一定时间（可通过<code>-i</code>设定）返回结果<br><code>--latency-dist</code>: 以统计图表的方式输出统计信息</td><td></td></tr><tr><td><code>redis-cli --stat</code></td><td><code>--stat</code>: 实时获取 Redis 统计信息</td><td><code>redis-cli info</code>也能查看系统信息</td></tr><tr><td><code>redis-cli --no-raw get apple</code></td><td><code>--raw</code> &amp; <code>--no-raw</code>: 是否格式化输出</td><td></td></tr></tbody></table><h3 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a><code>redis-server</code></h3><p><code>redis-server --test-memory 1024</code> 可用于检测当前 OS 是否能稳定分配指定容量内存给 Redis，该命令通常用于压测。</p><h3 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a><code>redis-benchmark</code></h3><p>该命令会对各类数据结构的命令进行测试，并给出性能指标。</p><ul><li><code>-c</code>(client) 可指定客户端并发数（默认 50）</li><li><code>-n</code> 指定客户端请求总量（默认 100,000）</li><li><code>-q</code> 仅显示每秒接收请求数</li><li><code>-r</code>(random) 随机插入键，以进行基准测试</li><li><code>-P</code> 每个请求 pipeline 的数据量（默认为 1）</li><li><code>-k</code> 客户端是否使用<code>keepalive</code>，1 为使用，0 为不使用，默认为 1</li><li><code>-t</code> 对指定命令进行基准测试，如<code>redis-benchmark -t get,set -q</code></li><li><code>--csv</code> 将结果按照 csv 格式输出</li></ul><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>由于 Redis 是单线程机制，当需要执行多条命令时，网络 I/O 成为了瓶颈，因此 pipeline 可将待执行命令“打包”，通过一次往返即可完成。</p><p>需要注意的是，如果 pipeline 数据量过大，将会导致网络阻塞。</p><h2 id="事务与-Lua"><a href="#事务与-Lua" class="headerlink" title="事务与 Lua"></a>事务与 Lua</h2><p>Redis 中，将一组需要一起执行的事务命令放到<code>multi</code>(开始)和<code>exec</code>(结束)之间即可，如果要停止事务，可以使用<code>discard</code>。需要注意的是，Redis 不支持事务的回滚操作，但可以通过 Lua 来实现回滚。</p><p>有些应用场景需要在事务之前，确保事务中的<code>key</code>没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁）。Redis提供了<code>watch</code>命令来解决这类问题。</p><p>Lua 的数据类型：</p><ol><li>booleans(布尔)</li><li>numbers(数值)</li><li>strings(字符串)</li><li>tables(表格)</li></ol><h3 id="在-Redis-中执行-Lua-的方法"><a href="#在-Redis-中执行-Lua-的方法" class="headerlink" title="在 Redis 中执行 Lua 的方法"></a>在 Redis 中执行 Lua 的方法</h3><p>方式一<br><code>eval 脚本内容 key个数 key列表 参数列表</code></p><p>方式二<br>先将 Lua 脚本加载入 Redis，得到该脚本的 SHA1，<code>evalsha</code>使用<code>SHA1</code>执行对应的脚本。这样可以重复批处理。</p><ul><li>加载脚本：<code>redis-cli script load &quot;$(cat lua_get.lua)&quot;</code></li><li>执行脚本：<code>evalsha 脚本SHA1值 key个数 key列表 参数列表</code></li><li>判断脚本是否已经被加载：<code>scripts exists sha1 [sha1 …]</code>，返回存在的脚本个数</li><li>清除所有脚本：<code>script flush</code></li><li>强制终止脚本：<code>script kill</code>。如果当前脚本正在写入，则该命令不会生效，此时要么等待脚本执行结束，要么使用<code>shutdown save</code>停止 Redis 服务</li></ul><blockquote><p>Lua 脚本在 Redis 中是原子执行的，执行过程中不会插入其它命令。</p></blockquote><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p>Bitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</p><table><thead><tr><th>命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>setbit key offset value</code></td><td>设置值</td><td>很多应用的用户id以一个指定数字（例如10000）开头，直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费，通常的做法是每次做 <code>setbit</code> 操作时将用户id减去这个指定数字。在第一次初始化 Bitmaps 时，假如偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成Redis的阻塞</td></tr><tr><td><code>gitbit key offset</code></td><td>获取值</td><td></td></tr><tr><td><code>bitcount key [start][end]</code></td><td>获取Bitmaps指定范围值为1的个数</td><td></td></tr><tr><td><code>bitop operator destkey key[key....]</code></td><td>Bitmaps间的运算</td><td><code>bitop</code>是一个复合操作，它可以做多个Bitmaps的<code>and</code>、<code>or</code>、<code>not</code>、<code>xor</code>操作并将结果保存在<code>destkey</code>中</td></tr><tr><td><code>bitpos key targetBit [start] [end]</code></td><td>计算Bitmaps中第一个值为targetBit的偏移量</td><td></td></tr></tbody></table><p>当用户量很大时，使用 bitmaps 存储用户的活跃情况是非常好的一种方案，但活跃用户量较少时则不合理，大多数位都是 0。</p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>HyperLogLog并不是一种新的数据结构（实际类型为字符串类型），通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。</p><table><thead><tr><th>命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>pfadd key element [element …]</code></td><td>添加，成功返回 1</td><td></td></tr><tr><td><code>pfcount key [key …]</code></td><td>计算独立用户</td><td></td></tr><tr><td><code>pfmerge destkey sourcekey [sourcekey ...]</code></td><td>合并</td><td></td></tr></tbody></table><p>相比于集合类型，HyperLogLog 内存占用量非常小，但是存在错误率，因此，在数据结构选型时，需要平衡误差与空间占用率。</p><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><table><thead><tr><th>命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>publish channel message</code></td><td>发布消息，返回订阅者个数</td><td></td></tr><tr><td><code>subscribe channel [channel ...]</code></td><td>订阅消息</td><td>客户端在执行订阅命令之后进入了订阅状态，只能接收<code>subscribe</code>、<code>psubscribe</code>、<code>unsubscribe</code>、<code>punsubscribe</code>的四个命令<br>新开启的订阅客户端，无法收到该频道之前的消息，因为Redis不会对发布的消息进行持久化</td></tr><tr><td><code>unsubscribe [channel [channel ...]]</code></td><td>取消订阅</td><td></td></tr><tr><td><code>psubscribe pattern [pattern...]</code><br><code>punsubscribe [pattern [pattern ...]]</code></td><td>按照模式订阅和取消订阅</td><td></td></tr><tr><td><code>pubsub channels [pattern]</code></td><td>查看活跃的频道</td><td></td></tr><tr><td><code>pubsub numsub [channel ...]</code></td><td>查看频道订阅数</td><td></td></tr><tr><td><code>pubsub numpat</code></td><td>查看模式订阅数</td><td></td></tr></tbody></table><h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p>GEO底层由 zset 实现。</p><table><thead><tr><th>命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>geoadd key longitude latitude member [longitude latitude member ...]</code></td><td>增加地理位置信息。返回成功添加的个数</td><td>更新地理位置信息仍然可以使用该命令，但返回为 0。该命令同时支持多个地理位置添加</td></tr><tr><td><code>geopos key member [member ...]</code></td><td>获取地理位置信息</td><td></td></tr><tr><td><code>geodist key member1 member2 [unit]</code></td><td>获取两个地理位置的距离</td><td><code>unit</code>为单位，分别为<code>m</code>(米)，<code>km</code>(公里)，<code>mi</code>(英里)，<code>ft</code>(尺)</td></tr><tr><td><code>georadius key longitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</code><br><br><code>georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</code></td><td>获取指定位置范围内的地理信息位置集合</td><td><code>georadius</code>和<code>georadiusbymember</code>两个命令的作用是一样的，都是以一个地理位置为中心算出指定半径内的其他地理信息位置，不同的是<code>georadius</code>命令的中心位置给出了具体的经纬度，<code>georadiusbymember</code>只需给出成员即可。其中<code>radiusm|km|ft|mi</code>是必需参数，指定了半径<br><code>withcoord</code>:返回经纬度；<br><code>withdist</code>:返回离中心节点位置的距离；<br><code>withhash</code>:返回<code>geohash</code>；<br><code>COUNT count</code>:返回指定结果数量；<br><code>asc|desc</code>:按距中心节点距离升序或降序；<br><code>store key</code>:将结果保存到指定键；<br><code>storedist key</code>:将距中心节点距离保存到指定键</td></tr><tr><td><code>geohash key member [member ...]</code></td><td>获取geohash</td><td>Redis将所有地理位置信息的<code>geohash</code>存放在<code>zset</code>中，字符串越长，表示的位置更精确</td></tr><tr><td><code>zrem key member</code></td><td>删除地理位置信息</td><td></td></tr></tbody></table><h1 id="第-4-章-客户端"><a href="#第-4-章-客户端" class="headerlink" title="第 4 章 客户端"></a>第 4 章 客户端</h1><h2 id="客户端常见异常"><a href="#客户端常见异常" class="headerlink" title="客户端常见异常"></a>客户端常见异常</h2><ol><li>无法从连接池获取到连接<ol><li>连接池设置过小，默认为 8</li><li>客户端未正确使用连接池，如没有进行释放</li><li>存在慢查询操作</li><li>Redis 服务造成命令执行过程阻塞</li></ol></li><li>客户端读写超时<ol><li>读写时间设置过短</li><li>命令执行时间较长</li><li>网路异常</li><li>Redis 自身发生阻塞</li></ol></li><li>客户端连接超时<ol><li>超时时间过短</li><li>Redis 发生阻塞，<code>tcp-backlog</code>已满，造成新的连接失败</li><li>网络异常</li></ol></li><li>客户端缓冲区异常<ol><li>输出缓冲区满</li><li>长时间闲置连接被服务端主动断开</li><li>不正常并发读写</li></ol></li><li>Lua 脚本正在执行<ol><li>脚本正在执行，且执行时间超过了<code>lua-time-limit</code>，需等待脚本执行完成，或者使用<code>shutdown save</code>关闭 Redis 服务</li></ol></li><li>Redis 正在加载持久化文件</li><li>Redis 使用的内存超过<code>maxmemory</code>配置</li><li>客户端连接数过大<ol><li>客户端：如果<code>maxclients</code>参数不是很小的话，应用方的客户端连接数基本不会超过<code>maxclients</code>，通常来看是由于应用方对于Redis客户端使用不当造成的。此时如果应用方是分布式结构的话，可以通过下线部分应用节点（例如占用连接较多的节点），使得Redis的连接数先降下来。从而让绝大部分节点可以正常运行，此时再通过查找程序bug或者调整<code>maxclients</code>进行问题的修复。</li><li>服务端：如果此时客户端无法处理，而当前Redis为高可用模式（例如Redis Sentinel和Redis Cluster），可以考虑将当前Redis做故障转移。</li></ol></li></ol><h2 id="客户端案例分析"><a href="#客户端案例分析" class="headerlink" title="客户端案例分析"></a>客户端案例分析</h2><h3 id="Redis内存陡增"><a href="#Redis内存陡增" class="headerlink" title="Redis内存陡增"></a>Redis内存陡增</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>服务端现象：Redis主节点内存陡增，几乎用满<code>maxmemory</code>，而从节点内存并没有变化<br>客户端现象：客户端产生了OOM异常，无法写入新的数据</p><h4 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h4><p>从现象看，可能的原因有两个</p><ol><li>确实有大量写入，但是主从复制出现问题：用<code>dbsize</code>查询Redis复制的相关信息，复制是正常的，主从数据基本一致。</li><li>其他原因造成主节点内存使用过大：排查是否由客户端缓冲区造成主节点内存陡增，使用<code>info clients</code>命令查询，发现输出缓冲区不太正常，进一步通过<code>client list</code>命令找到<code>omem</code>不正常的连接，一般来说大部分客户端的<code>omem</code>为0（因为处理速度会足够快），于是通过<code>redis-cli client list | grep -v &quot;omem=0&quot;</code>找到<code>omem</code>非零的客户端连接。</li></ol><h3 id="客户端周期性的超时"><a href="#客户端周期性的超时" class="headerlink" title="客户端周期性的超时"></a>客户端周期性的超时</h3><h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h4><p>客户端现象：客户端出现大量周期性超时<br>服务端现象：服务端并没有明显的异常，只是有一些慢查询操作</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>网络：查看网络连接正常</li><li>Redis：查看 Redis 日志统计，未发现异常</li><li>客户端：慢查询与超时发生时间点吻合，推断由慢查询引起</li></ul><h1 id="第-5-章-持久化"><a href="#第-5-章-持久化" class="headerlink" title="第 5 章 持久化"></a>第 5 章 持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ul><li><code>save</code>命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</li><li><code>bgsave</code>命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8tfeooj3zj30k60hptbk.jpg" alt="bgsave workflow"></p><p>自动触发场景：</p><ol><li>使用save相关配置，如<code>save m n</code>。表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave</li><li>如果从节点执行全量复制操作，主节点自动执行 bgsave 生成RDB文件并发送给从节点</li><li>执行<code>debug reload</code>命令重新加载Redis时，也会自动触发 save 操作</li><li>默认情况下执行<code>shutdown</code>命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave</li></ol><p>如果Redis加载损坏的RDB文件时拒绝启动，此时可以使用Redis提供的<code>redis-check-dump</code>工具检测 RDB 文件并获取对应的错误报告。</p><h3 id="RDB-的优缺点"><a href="#RDB-的优缺点" class="headerlink" title="RDB 的优缺点"></a>RDB 的优缺点</h3><p>RDB的优点：</p><ul><li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。<strong>非常适用于备份，全量复制等场景</strong>。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</li><li>Redis加载RDB恢复数据远远快于AOF的方式。</li></ul><p>RDB的缺点：</p><ul><li>RDB方式数据<strong>无法做到实时持久化/秒级持久化</strong>。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li><li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令(类似于 MySQL 的 Binlog)，重启时再重新执行AOF文件中的命令达到恢复数据的目的。目前已经是Redis持久化的主流方式。</p><p>开启AOF功能需要设置配置：<code>appendonly yes</code>，默认不开启。AOF文件名通过<code>appendfilename</code>配置设置，默认文件名是<code>appendonly.aof</code>。保存路径同 RDB 持久化方式一致，通过<code>dir</code>配置指定。<br><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8u1rzsipij30n811un3c.jpg" alt="AOF workflow"></p><p>AOF缓冲区同步文件策略(参数<code>appendfsync</code>)</p><table><thead><tr><th>可配置值</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>always</code></td><td>命令写入<code>aof_buf</code>后调用系统<code>fsync</code>操作同步到 AOF 文件，<code>fsync</code> 完成后线程返回</td><td>不建议</td></tr><tr><td><code>everysec</code></td><td>命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，<code>write</code>完成后线程返回。<code>fsync</code>同步文件操作由专门线程每秒调用一次。</td><td>建议，为默认选项</td></tr><tr><td><code>no</code></td><td>命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，不对 AOF 文件做<code>fsync</code>同步，同步硬盘操作由 OS 负责，通常同步周期最长 30s</td><td>数据安全无法得到保证</td></tr></tbody></table><p>aof 重写过程可通过手动与自动方式触发。手动通过直接调用<code>bgrewriteaof</code>命令，自动方式则根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>的参数确定触发时机。<br><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8u27kw8tmj30u00ws7ff.jpg" alt="AOF rewrite workflow"></p><h2 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h2><p>Redis 启动时会优先加载 AOF 文件，如果 AOF 不可加载，然后再加载 RDB 文件。其文件加载流程如下：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91c1tnqngj30ky0m3djy.jpg" alt=""></p><p>如果在加载 AOF 文件时发生错误，可以先进行备份，然后采用<code>redis-check-aof --fix</code>命令进行修复，修复后使用<code>diff -u</code>对比数据的差异，找出丢失的数据，有些可以人工修改补全。</p><p>AOF文件可能存在结尾不完整的情况，比如机器突然掉电导致AOF尾部文件命令写入不全。Redis为我们提供了<code>aof-load-truncated</code>配置来兼容这种情况，默认开启。加载AOF时，当遇到此问题时会忽略并继续启动，同时打印如下警告日志：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># !!! Warning: short read while loading the AOF file !!!</span><br><span class="line"># !!! Truncating the AOF at offset <span class="number">397856725</span> !!!</span><br><span class="line"># AOF loaded anyway because aof-load-truncated is enabled</span><br></pre></td></tr></table></figure><h2 id="问题定位与优化"><a href="#问题定位与优化" class="headerlink" title="问题定位与优化"></a>问题定位与优化</h2><h3 id="fork-操作"><a href="#fork-操作" class="headerlink" title="fork 操作"></a>fork 操作</h3><p>当 Redis 做 RDB 或 AOF 重写时，对于大多数操作系统来说 fork 是个重量级错误。fork操作耗时跟进程总内存量息息相关，如果使用虚拟化技术，特别是 Xen 虚拟机，fork 操作会更耗时。</p><p>对于高并发 Redis 实例，如果fork操作耗时在秒级别将拖慢 Redis 几万条命令执行，对线上应用延迟影响非常明显。正常情况下 fork 耗时应该是每 GB 消耗20毫秒左右。可以在<code>info stats</code>统计中查<code>latest_fork_usec</code>指标获取最近一次 fork 操作耗时，单位微秒。</p><p>改善fork操作的耗时：</p><ol><li>优先使用物理机或者高效支持fork操作的虚拟化技术，避免使用Xen。</li><li>控制 Redis 实例最大可用内存，fork 耗时跟内存量成正比，线上建议每个 Redis 实例内存控制在 10GB 以内。</li><li>合理配置 Linux 内存分配策略，避免物理内存不足导致 fork 失败。</li><li>降低 fork 操作的频率，如适度放宽 AOF 自动触发时机，避免不必要的全量复制等。</li></ol><h3 id="子进程开销监控和优化"><a href="#子进程开销监控和优化" class="headerlink" title="子进程开销监控和优化"></a>子进程开销监控和优化</h3><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul><li>CPU开销分析。子进程负责把进程内的数据分批写入文件，这个过程属于CPU密集操作，通常子进程对单核CPU利用率接近90%.</li><li>CPU消耗优化。Redis是CPU密集型服务，不要做绑定单核CPU操作。由于子进程非常消耗CPU，会和父进程产生单核资源竞争。</li><li>不要和其他CPU密集型服务部署在一起，造成CPU过度竞争。</li><li>如果部署多个Redis实例，尽量保证同一时刻只有一个子进程执行重写工作。</li></ul><h4 id="硬盘开销"><a href="#硬盘开销" class="headerlink" title="硬盘开销"></a>硬盘开销</h4><ul><li>不要和其他高硬盘负载的服务部署在一起。如：存储服务、消息队列服务等。</li><li>AOF重写时会消耗大量硬盘IO，可以开启配置<code>no-appendfsync-on-rewrite</code>，默认关闭。表示在AOF重写期间不做<code>fsync</code>操作。</li><li>当开启 AOF 功能的 Redis 用于高流量写入场景时，如果使用普通机械磁盘，写入吞吐一般在100MB/s左右，这时 Redis 实例的瓶颈主要在 AOF 同步硬盘上。</li><li>对于单机配置多个 Redis 实例的情况，可以配置不同实例分盘存储 AOF 文件，分摊硬盘写入压力。</li></ul><blockquote><p>⚠️ 配置<code>no-appendfsync-on-rewrite=yes</code>时，在极端情况下可能丢失整个AOF重写期间的数据，需要根据数据安全性决定是否配置。</p></blockquote><h3 id="AOF-追加阻塞"><a href="#AOF-追加阻塞" class="headerlink" title="AOF 追加阻塞"></a>AOF 追加阻塞</h3><p>当 Redis 执行 <code>fsync</code> 同步时，如果系统硬盘繁忙，会造成 Redis 主线程的阻塞。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91co0mb8fj30g40hz770.jpg" alt=""></p><p>每当发生 AOF 追加阻塞事件发生时，在<code>info Persistence</code>统计中，<code>aof_delayed_fsync</code>指标会累加，查看这个指标方便定位 AOF 阻塞问题。AOF同步最多允许2秒的延迟，当延迟发生时说明硬盘存在高负载问题，可以通过监控工具如<code>iotop</code>，定位消耗硬盘IO资源的进程。</p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><ul><li>RDB使用一次性生成内存快照的方式，产生的文件紧凑压缩比更高，因此读取RDB恢复速度更快。由于每次生成RDB开销较大，<strong>无法做到实时持久化，一般用于数据冷备和复制传输</strong>。</li><li>AOF通过追加写命令到文件实现持久化，通过<code>appendfsync</code>参数可以控制实时/秒级持久化。因为需要不断追加写命令，所以AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积。</li><li>AOF重写可以通过<code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewritepercentage</code>参数控制自动触发，也可以使用<code>bgrewriteaof</code>命令手动触发。</li><li>子进程执行期间使用<code>copy-on-write</code>机制与父进程共享内存，避免内存消耗翻倍。AOF重写期间还需要维护重写缓冲区，保存新的写入命令避免数据丢失。</li></ul><h1 id="第-6-章-复制"><a href="#第-6-章-复制" class="headerlink" title="第 6 章 复制"></a>第 6 章 复制</h1><h2 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h2><p>配置复制的三种方式</p><ol><li>在配置文件中加入<code>slaveof {masterHost} {masterPort}</code> 随Redis启动生效。</li><li>在<code>redis-server</code>启动命令后加入<code>--slaveof {masterHost} {masterPort}</code> 生效。</li><li>直接使用命令<code>slaveof {masterHost} {masterPort}</code>生效。</li></ol><p>主从节点复制成功建立后，可以使用<code>info replication</code>命令查看复制相关状态。</p><h2 id="断开复制"><a href="#断开复制" class="headerlink" title="断开复制"></a>断开复制</h2><p><code>slaveof</code>命令不但可以建立复制，还可以在从节点执行<code>slaveof no one</code>来断开与主节点复制关系。同时，<code>slaveof {newMasterIp} {newMasterPort}</code>还可以实现切主操作，更换主节点。</p><blockquote><p>⚠️ 切主后从节点会清空之前所有的数据，线上人工操作时小心<code>slaveof</code>在错误的节点上执行或者指向错误的主节点。</p></blockquote><p>对于数据比较重要的节点，主节点会通过设置<code>requirepass</code>参数进行密码验证，这时所有的客户端访问必须使用<code>auth</code>命令实行校验。</p><p>默认情况下，从节点使用<code>slave-read-only=yes</code>配置为只读模式。由于复制只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，修改从节点会造成主从数据不一致。因此建议线上不要修改从节点的只读模式。</p><p>Redis为我们提供了<code>repl-disable-tcp-nodelay</code>参数用于控制是否关闭<code>TCP_NODELAY</code>，默认关闭，说明如下：</p><ul><li>当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延迟会变小，但增加了网络带宽的消耗。适用于主从之间的网络环境良好的场景，如同机架或同机房部署。</li><li>当开启时，主节点会合并较小的TCP数据包从而节省带宽。默认发送时间间隔取决于Linux的内核，一般默认为40毫秒。这种配置节省了带宽但增大主从之间的延迟。适用于主从网络环境复杂或带宽紧张的场景，如跨机房部署。</li></ul><h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><p>根据拓扑的复杂性，可分为三种：一主一从、一主多从、树状主从结构。</p><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><p>当应用写命令并发量较高且需要持久化时，可以只在从节点上开启AOF，这样既保证数据安全性同时也避免了持久化对主节点的性能干扰。但需要注意的是，当主节点关闭持久化功能时，如果主节点脱机要避免自动重启操作。因为主节点之前没有开启持久化功能自动重启后数据集为空，这时从节点如果继续复制主节点会导致从节点数据也被清空的情况，丧失了持久化的意义。安全的做法是在从节点上执行<code>slaveof no one</code>断开与主节点的复制关系，再重启主节点从而避免这一问题。</p><h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><p>对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性。</p><h3 id="树状主从结构"><a href="#树状主从结构" class="headerlink" title="树状主从结构"></a>树状主从结构</h3><p>当主节点需要挂载多个从节点时为了避免对主节点的性能干扰，可以采用树状主从结构降低主节点压力。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91e0yu7flj30if0o442t.jpg" alt=""></p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>Redis 在初次复制时，会进行全量复制，之后便会根据主从节点的复制偏移量进行<code>psync</code>增量复制。</p><p><code>psync</code>命令运行需要以下组件支持：</p><ul><li>主从节点各自复制偏移量。</li><li>主节点复制积压缓冲区。</li><li>主节点运行id。</li></ul><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>参与复制的主从节点都会维护自身复制偏移量。主节点在理完写入命令后，会把命令的字节长度做累加记录，统计信息在<code>info relication</code>中的<code>master_repl_offset</code>指标中，从节点会每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。统计信息在<code>info relication</code>中的<code>slave_repl_offset</code>指标中。</p><p>可以通过主节点的统计信息，计算出<code>master_repl_offset_slave_offset</code>字节量，判断主从节点复制相差的数据量，根据这个差值判定当前复制的健康度。如果主从之间复制偏移量相差较大，则可能是网络延迟或命令阻塞等原因引起。</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91vyy7e25j30h909875n.jpg" alt=""></p><p>主节点响应从节点的同步时，不但会把命令发送给从节点，还会写入复制积压缓冲区。由于缓冲区本质上是先进先出的定长队列，所以能实现保存最近已复制数据的功能，用于部分复制和复制命令丢失的数据补救。复制缓冲区相关统计信息保存在主节点的<code>info replication</code>中。</p><h4 id="主节点运行ID"><a href="#主节点运行ID" class="headerlink" title="主节点运行ID"></a>主节点运行ID</h4><p>每个Redis节点启动后都会动态分配一个40位的十六进制字符串作为运行ID。运行ID的主要作用是用来唯一识别Redis节点，比如从节点保存主节点的运行ID识别自己正在复制的是哪个主节点。如果只使用ip+port的方式识别主节点，那么主节点重启变更了整体数据集（如替换RDB/AOF文件），从节点再基于偏移量复制数据将是不安全的，因此当运行ID变化后从节点将做全量复制。可以运行<code>info server</code>命令查看当前节点的运行ID。</p><p>当需要调优一些内存相关配置，例如：<code>hash-max-ziplist-value</code>等，这些配置需要Redis重新加载才能优化已存在的数据，这时可以使用<code>debug reload</code>命令重新加载 RDB 并保持运行 ID 不变，从而有效避免不必要的全量复制。</p><blockquote><p><code>debug reload</code>命令会阻塞当前Redis节点主线程，阻塞期间会生成本地RDB快照并清空数据之后再加载RDB文件。因此对于大数据量的主节点和无法容忍阻塞的应用场景，谨慎使用。</p></blockquote><h4 id="psync-命令"><a href="#psync-命令" class="headerlink" title="psync 命令"></a>psync 命令</h4><p>从节点使用<code>psync</code>命令完成部分复制和全量复制功能，命令格式：<code>psync {runId} {offset}</code></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xk5bba1j30jh0hejtq.jpg" alt=""></p><p>主节点回复<code>+FULLRESYNC {runId} {offset}</code>会触发全量复制，<code>+CONTINUE</code>则触发增量复制。</p><h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xn7bm5rj30j30lqgp7.jpg" alt=""></p><p>对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。如果 RDB 文件过大，超过预设的 timeout，则会终止全量同步，并清除已下载临时文件。如果在高并发写的场景，主节点的缓冲区被写满，同样会导致同步的失败。</p><p>全量复制的主要时间开销在：</p><ul><li>主节点 <code>bgsave</code> 时间</li><li>RDB 文件网络传输时间</li><li>从节点清空数据时间</li><li>从节点加载 RDB 时间</li><li>可能的 AOF 重写时间</li></ul><h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91xwacukej30hu0d8gnx.jpg" alt=""></p><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><p>主从心跳判断机制：</p><ul><li>通过<code>client list</code>命令查看复制相关客户端信息，主节点的连接状态为<code>flags=M</code>，从节点连接状态为<code>flags=S</code>。</li><li>主节点默认每隔10秒对从节点发送<code>ping</code>命令，判断从节点的存活性和连接状态。可通过参数<code>repl-ping-slave-period</code>控制发送频率。</li><li>从节点在主线程中每隔1秒发送<code>replconf ack{offset}</code>命令，给主节点上报自身当前的复制偏移量。<code>replconf</code>命令主要作用如下：<ul><li>实时监测主从节点网络状态</li><li>上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据</li><li>实现保证从节点的数量和延迟性功能，通过min-slaves-to-write、minslaves-max-lag参数配置定义</li></ul></li></ul><blockquote><p>我们经常会遇到数据同步的问题，但如何在消耗最少的资源下保证数据的一致性是我们一直会遇到的问题，好在，很多成熟的 软件已经为我们提供了借鉴的方案，如 Git 的 hash chain，Redis 的 <code>psync</code> 偏移量增量复制与缓冲区，以及 MySQL 的<code>binlog</code>。没有最好的方案，只有最合适的方案，或许我们能从中得到启发，找到最适合自己的增量同步方式。</p></blockquote><h2 id="开发与运维中的问题"><a href="#开发与运维中的问题" class="headerlink" title="开发与运维中的问题"></a>开发与运维中的问题</h2><h3 id="数据延时"><a href="#数据延时" class="headerlink" title="数据延时"></a>数据延时</h3><p>Redis复制数据的延迟由于异步复制特性是无法避免的，延迟取决于网络带宽和命令阻塞情况。需要业务场景允许短时间内的数据延迟。对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点。</p><h3 id="读到过期数据"><a href="#读到过期数据" class="headerlink" title="读到过期数据"></a>读到过期数据</h3><p>惰性删除：主节点将过期的键同步给从节点<br>定时删除：主节点轮询采样一定数量的键，当采样的键过期后，同步给从节点。<br>Redis 3.2+ 在从节点读取键时会校验是否过期以判断是否返回数据。</p><h3 id="从节点故障"><a href="#从节点故障" class="headerlink" title="从节点故障"></a>从节点故障</h3><p>下线故障节点。</p><blockquote><p>当主节点优化空间不大时再考虑扩展。笔者建议大家在做读写分离之前，可以考虑使用Redis Cluster等分布式解决方案，这样不止扩展了读性能还可以扩展写性能和可支撑数据规模，并且一致性和故障转移也可以得到保证，对于客户端的维护逻辑也相对容易。</p></blockquote><h3 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h3><ul><li>第一次建立复制：由于是第一次建立复制，从节点不包含任何主节点数据，因此必须进行全量复制才能完成数据同步。对于这种情况全量复制无法避免。当对数据量较大且流量较高的主节点添加从节点时，建议在低峰时进行操作，或者尽量规避使用大数据量的Redis节点。</li><li>节点运行ID不匹配：当主从复制关系建立后，从节点会保存主节点的运行ID，如果此时主节点因故障重启，那么它的运行ID会改变，从节点发现主节点运行ID不匹配时，会认为自己复制的是一个新的主节点从而进行全量复制。对于这种情况应该从架构上规避，比如提供故障转移功能。当主节点发生故障后，手动提升从节点为主节点或者采用支持自动故障转移的哨兵或集群方案。</li><li>复制积压缓冲区不足：当主从节点网络中断后，从节点再次连上主节点时会发送<code>psync {offset} {runId}</code>命令请求部分复制，<strong>如果请求的偏移量不在主节点的积压缓冲区内，则无法提供给从节点数据，因此部分复制会退化为全量复制</strong>。此时需要保证<code>repl_backlog_size &gt; net_break_time*write_size_per_minute</code>以避免缓冲区不足引发的全量复制。</li></ul><h3 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h3><h4 id="单主节点复制风暴"><a href="#单主节点复制风暴" class="headerlink" title="单主节点复制风暴"></a>单主节点复制风暴</h4><p>一般发生在主节点挂载多个从节点的场景。当主节点重启恢复后，从节点会发起全量复制流程，这时主节点就会为从节点创建RDB快照，如果在快照创建完毕之前，有多个从节点都尝试与主节点进行全量同步，那么其他从节点将共享这份RDB快照，同时向多个从节点发送RDB快照，可能使主节点的网络带宽消耗严重，造成主节点的延迟变大，极端情况会发生主从节点连接断开，导致复制失败。<br>解决方案可以减少主节点挂载的从节点数量，或者采用树形复制结构(这种树状结构也带来了运维的复杂性，增加了手动和自动处理故障转移的难度)。</p><h4 id="单机器复制风暴"><a href="#单机器复制风暴" class="headerlink" title="单机器复制风暴"></a>单机器复制风暴</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91z58ncm8j30iv0frgpv.jpg" alt=""></p><ul><li>应该把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点。</li><li>当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制。</li></ul><h1 id="第-7-章-阻塞"><a href="#第-7-章-阻塞" class="headerlink" title="第 7 章 阻塞"></a>第 7 章 阻塞</h1><p>发生阻塞会有内在与外在原因<br>内在原因：不合理地使用API或数据结构、CPU饱和、持久化阻塞等<br>外在原因：CPU竞争、内存交换、网络问题等</p><h2 id="内因"><a href="#内因" class="headerlink" title="内因"></a>内因</h2><h3 id="如何发现慢查询"><a href="#如何发现慢查询" class="headerlink" title="如何发现慢查询"></a>如何发现慢查询</h3><p>执行<code>slowlog get {n}</code>获取最近的 n 条慢查询命令，线上实例建议设置为1毫秒便于及时发现毫秒级以上的命令。如果命令执行时间在毫秒级，则实例实际OPS只有1000左右。慢查询队列长度默认128，可适当调大。慢查询本身只记录了命令执行时间，不包括数据网络传输时间和命令排队时间，因此客户端发生阻塞异常后，可能不是当前命令缓慢，而是在等待其他命令执行。需要重点比对异常和慢查询发生的时间点，确认是否有慢查询造成的命令阻塞排队。</p><p>解决慢查询</p><ul><li>修改为低算法度的命令，如<code>hgetall</code>改为<code>hmget</code>等，禁用<code>keys</code>、<code>sort</code>等命令。</li><li>调整大对象：缩减大对象数据或把大对象拆分为多个小对象，防止一次命令操作过多的数据。大对象拆分过程需要具体的业务决定，如用户好友集合存储在Redis中，有些热点用户会关注大量好友，这时可以按时间或其他维度拆分到多个集合中。</li></ul><h3 id="如何发现大对象"><a href="#如何发现大对象" class="headerlink" title="如何发现大对象"></a>如何发现大对象</h3><p>Redis本身提供发现大对象的工具<code>redis-cli -h{ip} -p{port} bigkeys</code>。内部原理采用分段进行<code>scan</code>操作，把历史扫描过的最大对象统计出来便于分析优化，</p><h3 id="CPU饱和"><a href="#CPU饱和" class="headerlink" title="CPU饱和"></a>CPU饱和</h3><p>使用<code>top</code>命令很容易识别出对应Redis进程的CPU使用率。CPU饱和是非常危险的，将导致Redis无法处理更多的命令，严重影响吞吐量和应用方的稳定性。对于这种情况，首先判断当前Redis的并发量是否达到极限，建议使用统计命令<code>redis-cli -h{ip} -p{port} --stat</code>获取当前Redis使用情况，该命令每秒输出一行统计信息。</p><h3 id="持久化阻塞"><a href="#持久化阻塞" class="headerlink" title="持久化阻塞"></a>持久化阻塞</h3><p>持久化引起主线程阻塞的操作主要有：fork阻塞、AOF刷盘阻塞、HugePage写操作阻塞。</p><p>fork 阻塞可以执行<code>info stats</code>命令获取到<code>latest_fork_usec</code>指标，表示Redis最近一次fork操作耗时，如果耗时很大，比如超过1秒，则需要做出优化调整，如避免使用过大的内存实例和规避fork缓慢的操作系统等。</p><p>AOF刷盘阻塞主要是硬盘压力引起，可以查看Redis日志识别出这种情况。硬盘压力可能是Redis进程引起的，也可能是其他进程引起的，可以使用iotop查看具体是哪个进程消耗过多的硬盘资源。</p><p>HugePage写操作阻塞。子进程在执行重写期间利用Linux写时复制技术降低内存开销，因此只有写操作时Redis才复制要修改的内存页。对于开启Transparent HugePages的操作系统，每次写命令引起的复制内存页单位由4K变为2MB，放大了512倍，会拖慢写操作的执行时间，导致大量写操作慢查询。例如简单的incr命令也会出现在慢查询中。关于Transparent HugePages的细节见第12章的12.1节“Linux配置优化”。</p><blockquote><p>Redis 对阻塞问题的说明：<a href="https://redis.io/topics/latency" target="_blank" rel="noopener">https://redis.io/topics/latency</a></p></blockquote><h2 id="外因"><a href="#外因" class="headerlink" title="外因"></a>外因</h2><h3 id="CPU-竞争"><a href="#CPU-竞争" class="headerlink" title="CPU 竞争"></a>CPU 竞争</h3><p>进程竞争：Redis是典型的CPU密集型应用，不建议和其他多核CPU密集型服务部署在一起。当其他进程过度消耗CPU时，将严重影响Redis吞吐量。可以通过<code>top</code>、<code>sar</code>等命令定位到CPU消耗的时间点和具体进程，这个问题比较容易发现，需要调整服务之间部署结构。<br>绑定CPU：部署Redis时为了充分利用多核CPU，通常一台机器部署多个实例。常见的一种优化是把Redis进程绑定到CPU上，用于降低CPU频繁上下文切换的开销。但当Redis父进程创建子进程进行RDB/AOF重写时，如果做了CPU绑定，会与父进程共享使用一个CPU。子进程重写时对单核CPU使用率通常在90%以上，父进程与子进程将产生激烈CPU竞争，极大影响Redis稳定性。因此对于开启了持久化或参与复制的主节点不建议绑定CPU。</p><h3 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h3><p>内存交换（swap）对于Redis来说是非常致命的，Redis保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把Redis使用的部分内存换出到硬盘，由于内存与硬盘读写速度差几个数量级，会导致发生交换后的Redis性能急剧下降。</p><p>判断 Redis 是否内存交换的方法：</p><ol><li>查询 Redis 的进程号：<code># redis-cli -p 6379 info server | grep process_id</code> // process_id:4476</li><li>根据进程号查询内存交换信息：<code># cat /proc/4476/smaps | grep Swap</code><br>如果交换量都是0KB或者个别的是4KB，则是正常现象，说明Redis进程内存没有被交换。</li></ol><p>预防 Redis 的内存交换</p><ul><li>保证机器可用内存充足</li><li>确保所有 Redis 实例设置最大可用内存(maxmemory)</li><li>降低系统使用swap优先级，如<code>echo10&gt;/proc/sys/vm/swappiness</code></li></ul><h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>Redis连接拒绝：Redis通过maxclients参数控制客户端最大连接数，默认10000。当Redis连接数大于<code>maxclients</code>时会拒绝新的连接进入，<code>info stats</code>的<code>rejected_connections</code>统计指标记录所有被拒绝连接的数量。客户端访问Redis时尽量采用NIO长连接或者连接池的方式。Redis 默认不会主动关闭长时间闲置连接或检查关闭无效的TCP连接，因此会导致Redis连接数快速消耗且无法释放的问题，此时可设置<code>tcp-keepalive</code>和<code>timeout</code>参数让Redis主动检查和关闭无效连接。</p><p>连接溢出：OS 一般会对进程使用的资源做限制，其中一项是对进程可打开最大文件数控制，默认 1024，对需要支撑高并发的 Redis 需要调大该限制。</p><p>常见的物理拓扑按网络延迟由快到慢可分为：同物理机&gt;同机架&gt;跨机架&gt;同机房&gt;同城机房&gt;异地机房。但它们容灾性正好相反。</p><h1 id="第-8-章-理解内存"><a href="#第-8-章-理解内存" class="headerlink" title="第 8 章 理解内存"></a>第 8 章 理解内存</h1><p>内存消耗可以分为进程自身消耗和子进程消耗。</p><h2 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h2><h3 id="内存消耗统计"><a href="#内存消耗统计" class="headerlink" title="内存消耗统计"></a>内存消耗统计</h3><p>通过<code>info memory</code>命令获取内存相关指标，指标说明如下表：</p><table><thead><tr><th>属性名</th><th>属性说明</th></tr></thead><tbody><tr><td><code>used_memory</code></td><td>Redis分配器分配的内存总量，也就是内部存储的所有数据内存占用量</td></tr><tr><td><code>used_memory_human</code></td><td>以可读的格式返回<code>used memory</code></td></tr><tr><td><code>used_memory_rss</code></td><td>从操作系统的角度显示Redis进程占用的物理内存总量</td></tr><tr><td><code>used_memory_peak</code></td><td>内存使用的最大值，表示<code>used memory</code>的峰值</td></tr><tr><td><code>used_memory_peak_human</code></td><td>以可读的格式返回<code>used_memory_peak</code></td></tr><tr><td><code>used_memory_lua</code></td><td>Lua 引擎所消耗的内存大小</td></tr><tr><td><code>mem_fragmentation_ratio</code></td><td><code>used_memory_rss/used_memory</code>比值，表示内存碎片率</td></tr><tr><td><code>mem_allocator</code></td><td>Redis 所使用的内存分配器，默认为 jemalloc</td></tr></tbody></table><p>当<code>mem_fragmentation_ratio &gt; 1</code>时，说明<code>used_memory_rss-used_memory</code>多出的部分内存并没有用于数据存储，而是被内存碎片所消耗，如果两者相差很大，说明碎片率严重。<br>当<code>mem_fragmentation_ratio &lt; 1</code>时，这种情况一般出现在操作系统把Redis内存交换（Swap）到硬盘导致，出现这种情况时要格外关注，由于硬盘速度远远慢于内存，Redis性能会变得很差，甚至僵死。</p><h3 id="内存消耗划分"><a href="#内存消耗划分" class="headerlink" title="内存消耗划分"></a>内存消耗划分</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g94c4oj8s0j30y20mmtfb.jpg" alt=""></p><p>内存碎片问题虽然是所有内存服务的通病，但是jemalloc针对碎片化问题专门做了优化，一般不会存在过度碎片化的问题，正常的碎片率（<code>mem_fragmentation_ratio</code>）在1.03左右。但是当存储的数据长短差异较大时，以下场景容易出现高内存碎片问题：</p><ul><li>频繁做更新操作，例如频繁对已存在的键执行<code>append</code>、<code>setrange</code>等更新操作。</li><li>大量过期键删除，键对象过期删除后，释放的空间无法得到充分利用，导致碎片率上升。</li></ul><p>出现高内存碎片问题时常见的解决方式如下：</p><ul><li>数据对齐：在条件允许的情况下尽量做数据对齐，比如数据尽量采用数字类型或者固定长度字符串等，但是这要视具体的业务而定，有些场景无法做到。</li><li>安全重启：重启节点可以做到内存碎片重新整理，因此可以利用高可用架构，如Sentinel或Cluster，将碎片率过高的主节点转换为从节点，进行安全重启。</li></ul><h3 id="子进程内存消耗"><a href="#子进程内存消耗" class="headerlink" title="子进程内存消耗"></a>子进程内存消耗</h3><ul><li>Redis产生的子进程并不需要消耗1倍的父进程内存，实际消耗根据期间写入命令量决定，但是依然要预留出一些内存防止溢出。</li><li>需要设置<code>sysctl vm.overcommit_memory = 1</code>允许内核可以分配所有的物理内存，防止Redis进程执行fork时因系统剩余内存不足而失败。</li><li>排查当前系统是否支持并开启THP，如果开启，建议关闭，防止<code>copy-onwrite</code>期间内存过度消耗。如果在高并发写的场景下开启THP，子进程内存消耗可能是父进程的数倍，极易造成机器物理内存溢出，从而触发SWAP或OOM killer。</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>Redis主要通过控制内存上限和回收策略实现内存管理。</p><h3 id="设置内存上限"><a href="#设置内存上限" class="headerlink" title="设置内存上限"></a>设置内存上限</h3><p>Redis使用<code>maxmemory</code>参数限制最大可用内存。需要注意，<code>maxmemory</code>限制的是Redis实际使用的内存量，也就是<code>used_memory</code>统计项对应的内存。由于内存碎片率的存在，实际消耗的内存可能会比<code>maxmemory</code>设置的更大，实际使用时要小心这部分内存溢出。通过设置内存上限可以非常方便地实现一台服务器部署多个Redis进程的内存控制。比如一台24GB内存的服务器，为系统预留4GB内存，预留4GB空闲内存给其他进程或Redis fork进程，留给Redis16GB内存，这样可以部署4个<code>maxmemory=4GB</code>的Redis进程。得益于Redis单线程架构和内存限制机制，即使没有采用虚拟化，不同的Redis进程之间也可以很好地实现CPU和内存的隔离性，</p><h3 id="动态调整内存上限"><a href="#动态调整内存上限" class="headerlink" title="动态调整内存上限"></a>动态调整内存上限</h3><p>Redis的内存上限可以通过<code>config set maxmemory</code>进行动态修改。该方式过于简单，推荐使用哨兵或者集群来处理。</p><p>Redis默认无限使用服务器内存，为防止极端情况下导致系统内存耗尽，建议所有的Redis进程都要配置<code>maxmemory</code>。</p><h3 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h3><p>Redis的内存回收机制分为删除过期的键对象，与内存使用达到maxmemory上限时触发内存溢出控制策略。</p><p>Redis所有的键都可以设置过期属性，内部保存在过期字典中。由于进程内保存大量的键，维护每个键精准的过期删除机制会导致消耗大量的CPU，对于单线程的Redis来说成本过高，因此Redis采用惰性删除和定时任务删除机制实现过期键的内存回收。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g94i0a1qirj30u00wg49h.jpg" alt=""></p><p>Redis 的内存溢出有 6 种控制策略，可通过<code>config set maxmemory-policy {policy}</code>配置</p><ol><li>noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息（error）OOM command not allowed when used memory，此时Redis只响应读操作。</li><li>volatile-lru：根据LRU算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。</li><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random：随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li></ol><p>频繁执行回收内存成本很高，会导致 Redis 的性能下降，如果当前Redis有从节点，回收内存操作对应的删除命令会同步到从节点，导致写放大的问题。</p><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><h3 id="redisObject对象"><a href="#redisObject对象" class="headerlink" title="redisObject对象"></a>redisObject对象</h3><p>Redis存储的所有值对象在内部定义为redisObject结构体，内部结构如图<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g94ig5abpxj30zi0u0tkp.jpg" alt=""></p><p>type字段：表示当前对象使用的数据类型，可以使用<code>type {key}</code>命令查看对象所属类型<br>encoding 字段：Redis内部编码类型<br>lru 字段：记录对象最后一次被访问的时间，当配置了<code>maxmemory</code>和<code>maxmemory-policy=volatile-lru</code>或者<code>allkeys-lru</code>时，用于辅助LRU算法删除键数据。可以使用<code>object idletime {key}</code>命令在不更新lru字段情况下查看当前键的空闲时间。<br>refcount字段：记录当前对象被引用的次数，用于通过引用次数回收内存，当<code>refcount=0</code>时，可以安全回收当前对象空间。<br><code>*ptr</code>字段：与对象的数据内容相关，如果是整数，直接存储数据；否则表示指向数据的指针。Redis在3.0之后对值对象是字符串且长度&lt;=39字节的数据，内部编码为<code>embstr</code>类型，字符串<code>sds</code>和r<code>edisObject</code>一起分配，从而<strong>只要一次内存操作即可</strong>。</p><h3 id="缩减键值对象"><a href="#缩减键值对象" class="headerlink" title="缩减键值对象"></a>缩减键值对象</h3><p>降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。</p><ul><li>key长度：如在设计键时，在完整描述业务情况下，键值越短越好。如<code>user：{uid}：friends：notify：{fid}</code>可以简化为<code>u：{uid}：fs：nt：{fid}</code></li><li>value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该<strong>在业务上精简业务对象，去掉不必要的属性避免存储无效数据</strong>。其次在序列化工具选择上，应该<strong>选择更高效的序列化工具来降低字节数组大小</strong>。值对象除了存储二进制数据之外，通常还会使用通用格式存储数据比如：json、xml等作为字符串存储在Redis中。这种方式优点是方便调试和跨语言，但是同样的数据相比字节数组所需的空间更大，在内存紧张的情况下，可以使用通用压缩算法压缩json、xml后再存入Redis，从而降低内存占用，例如使用GZIP压缩后的json可降低约60%的空间。（当频繁压缩解压json等文本数据时，开发人员需要考虑压缩速度和计算开销成本，这里推荐使用Google的Snappy压缩工具，在特定的压缩率情况下效率远远高于GZIP等传统压缩工具，且支持所有主流语言环境。）</li></ul><h3 id="字符串优化"><a href="#字符串优化" class="headerlink" title="字符串优化"></a>字符串优化</h3><p>Redis没有采用原生C语言的字符串类型而是自己实现了字符串结构，内部简单动态字符串（simple dynamic string，SDS）。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97yccw87dj30kt0dq0w8.jpg" alt=""></p><p>Redis自身实现的字符串结构有如下特点：</p><ul><li>$O(1)$时间复杂度获取：字符串长度、已用长度、未用长度。</li><li>可用于保存字节数组，支持安全的二进制数据存储。</li><li>内部实现空间预分配机制，降低内存再分配次数。</li><li>惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。</li></ul><p>字符串之所以采用预分配的方式是防止修改操作需要不断重分配内存和字节数据拷贝。但同样也会造成内存的浪费。我们需要尽量减少字符串频繁修改操作如<code>append</code>、<code>setrange</code>可能导致的预分配容量翻倍（内存碎片率上升）的问题。</p><p>字符串重构：指<strong>不一定把每份数据作为字符串整体存储，像json这样的数据可以使用hash结构，使用二级结构存储也能帮我们节省内存</strong>。同时可以使用<code>hmget</code>、<code>hmset</code>命令支持字段的部分读取修改，而不用每次整体存取。如下面的json数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"vid"</span>: <span class="string">"413368768"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"搜狐屌丝男士"</span>,</span><br><span class="line">    <span class="attr">"videoAlbumPic"</span>:<span class="string">"http://photocdn.sohu.com/60160518/vrsa_ver8400079_ae433_pic26.jpg"</span>,</span><br><span class="line">    <span class="attr">"pid"</span>: <span class="string">"6494271"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"1024"</span>,</span><br><span class="line">    <span class="attr">"playlist"</span>: <span class="string">"6494271"</span>,</span><br><span class="line">    <span class="attr">"playTime"</span>: <span class="string">"468"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>测试内存表现</center><table><thead><tr><th align="center">数据量</th><th align="center">key</th><th align="left">存储类型</th><th align="center">value</th><th align="center">配置</th><th align="center">used_mem</th></tr></thead><tbody><tr><td align="center">200w</td><td align="center">20字节</td><td align="left">string</td><td align="center">json 字符串</td><td align="center">默认</td><td align="center">612.2M</td></tr><tr><td align="center">200w</td><td align="center">20字节</td><td align="left">hash</td><td align="center">key-value 对</td><td align="center">默认</td><td align="center">1.88G</td></tr><tr><td align="center">200w</td><td align="center">20字节</td><td align="left">hash</td><td align="center">key-value 对</td><td align="center">hash-max-ziplist-value:66</td><td align="center">535.60M</td></tr></tbody></table><p>根据测试结构，第一次默认配置下使用hash类型，内存消耗不但没有降低反而比字符串存储多出2倍，而调整<code>hash-max-ziplist-value=66</code>之后内存降低为535.60M。因为json的<code>videoAlbumPic</code>属性长度是65，而<code>hash-max-ziplist-value</code>默认值是64，Redis采用<code>hashtable</code>编码方式，反而消耗了大量内存。调整配置后hash类型内部编码方式变为<code>ziplist</code>，相比字符串更省内存且支持属性的部分操作。</p><h3 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h3><table><thead><tr><th>类型</th><th>编码方式</th><th>数据结构</th></tr></thead><tbody><tr><td>string</td><td>raw</td><td>动态字符串编码</td></tr><tr><td></td><td>embstr</td><td>优化内存分配的字符串编码</td></tr><tr><td></td><td>int</td><td>整数编码</td></tr><tr><td>hash</td><td>hashtable</td><td>散列表编码</td></tr><tr><td></td><td>ziplist</td><td>压缩列表编码</td></tr><tr><td>list</td><td>linkedlist</td><td>双向链表编码</td></tr><tr><td></td><td>ziplist</td><td>压缩列表编码</td></tr><tr><td></td><td>quicklist</td><td></td></tr><tr><td>set</td><td>hashtable</td><td>散列表编码</td></tr><tr><td></td><td>intset</td><td>整数集合编码</td></tr><tr><td>zset</td><td>skiplist</td><td>跳跃表编码</td></tr><tr><td></td><td>ziplist</td><td>压缩列表编码</td></tr></tbody></table><p>Redis 对一种数据结构实现多种编码方式主要原因是Redis作者想通过不同编码实现效率和空间的平衡。比如当我们的存储只有10个元素的列表，当使用双向链表数据结构时，必然需要维护大量的内部字段如每个元素需要：前置指针，后置指针，数据指针等，造成空间浪费，如果采用连续内存结构的压缩列表（ziplist），将会节省大量内存，而由于数据长度较小，存取操作时间复杂度即使为$O(n^2)$性能也可满足需求。</p><table><thead><tr><th>类型</th><th>编码</th><th>决定条件</th></tr></thead><tbody><tr><td>hash</td><td>ziplist</td><td>满足所有条件：<br>value 最大空间（字节）&lt;= hash-max-ziplist-value<br>field 个数 &lt;= hash-max-ziplist-entries</td></tr><tr><td></td><td>hashtable</td><td>满足任意条件：<br>value 最大空间（字节）&gt; hash-max-ziplist-value<br>field 个数 &gt; hash-max-ziplist-entries</td></tr><tr><td>list</td><td>ziplist</td><td>满足所有条件：<br>value 最大空间（字节）&lt;= list-max-ziplist-value<br>链表长度 &lt;= list-max-ziplist-entries</td></tr><tr><td></td><td>linkedlist</td><td>满足任意条件：<br>value 最大空间（字节）&gt; list-max-ziplist-value<br>链表长度 &gt; list-max-ziplist-entries</td></tr><tr><td></td><td>quicklist</td><td>list-max-ziplist-size：表示最大压缩空间或长度<br>最大空间使用[-5-1]范围配置，默认-2 表示 8KB<br>正整数表示最大压缩长度<br>list-compress-depth：表示最大压缩深度，默认为 0 表示不压缩</td></tr><tr><td>set</td><td>intset</td><td>满足所有条件：<br>元素必须为整数<br>集合长度 &lt;= set-max-intset-entries</td></tr><tr><td></td><td>hashtable</td><td>满足任意条件：<br>元素非整数类型<br>集合长度 &gt; set-max-ziplist-entries</td></tr><tr><td>zset</td><td>ziplist</td><td>满足所有条件：<br>value 最大空间（字节）&lt;= zset-max-ziplist-value<br>有序集合长度 &lt;= zset-max-ziplist-entries</td></tr><tr><td></td><td>skiplist</td><td>满足任意条件：<br>value 最大空间（字节）&gt; zset-max-ziplist-value<br>有序集合长度 &gt; zset-max-ziplist-entries</td></tr></tbody></table><p>ziplist编码主要目的是为了节约内存，因此所有数据都是采用线性连续的内存结构。ziplist编码是应用范围最广的一种，可以分别作为hash、list、zset类型的底层数据结构实现。其内部结构如图：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g982kp4di3j30lh0fadim.jpg" alt=""></p><p>ziplist特点如下：</p><ul><li>内部表现为数据紧凑排列的一块连续内存数组。</li><li>可以模拟双向链表结构，以$O(1)$时间复杂度入队和出队。</li><li>新增删除操作涉及内存重新分配或释放，加大了操作的复杂性。(<strong>ziplist压缩编码的原则：追求空间和时间的平衡</strong>)</li><li>读写操作涉及复杂的指针移动，最坏时间复杂度为$O(n^2)$。</li><li><strong>适合存储小对象和长度有限的数据</strong>。</li></ul><blockquote><p>我们可以看到，Redis 通过多种手段来保障性能，如单线程、epoll、基于内存操作、内存预分配、自动切换合理的数据结构等，作者在这方便做了很多的努力，所以才会有很多$O(1)$复杂度方法，日后才能大行其道，这其中我们可以借鉴的经验俯拾皆是，足见作者是一个有追求的 coder，相信 Redis 的源码会给与我们更多的启发。</p></blockquote><h3 id="控制键的数量"><a href="#控制键的数量" class="headerlink" title="控制键的数量"></a>控制键的数量</h3><p>对于存储相同的数据内容利用Redis的数据结构(如hash)降低外层键的数量，也可以节省大量内存。</p><p>建议使用Redis存储大量数据时，把内存优化环节加入到前期设计阶段，否则数据大幅增长后，开发人员需要面对重新优化内存所带来开发和数据迁移的双重成本。<strong>当Redis内存不足时，首先考虑的问题不是加机器做水平扩展，应该先尝试做内存优化，当遇到瓶颈时，再去考虑水平扩展</strong>。即使对于集群化方案，垂直层面优化也同样重要，避免不必要的资源浪费和集群化后的管理成本。</p><h2 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h2><p>内存是相对宝贵的资源，通过合理的优化可以有效地降低内存的使用量，内存优化的思路包括</p><ul><li>精简键值对大小，使用高效二进制序列化工具。</li><li>使用对象共享池优化小整数对象。</li><li>数据优先使用整数，比字符串类型更节省空间。</li><li>优化字符串使用，避免预分配造成的内存浪费。</li><li>使用<code>ziplist</code>压缩编码优化<code>hash</code>、<code>list</code>等结构，注重效率和空间的平衡。</li><li>使用<code>intset</code>编码优化整数集合。</li><li>使用<code>ziplist</code>编码的<code>hash</code>结构降低小对象链规模。</li></ul><h1 id="第-9-章-哨兵"><a href="#第-9-章-哨兵" class="headerlink" title="第 9 章 哨兵"></a>第 9 章 哨兵</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>主从模式下存在的问题：</p><ol><li>主节点宕机的故障转移需要人工介入恢复（👉 哨兵）</li><li>主节点的写能力与存储能力受到单机的限制（👉 集群）</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g994eh8oswj30lt0fr41y.jpg" alt=""></p><p>Redis Sentinel 具有以下几个功能：</p><ul><li>监控：Sentinel节点会定期检测Redis数据节点、其余Sentinel节点是否可达。</li><li>通知：Sentinel节点会将故障转移的结果通知给应用方。</li><li>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系。</li><li>配置提供者：在Redis Sentinel结构中，客户端在初始化的时候连接的是Sentinel节点集合，从中获取主节点信息。</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>从节点的部署与主节点的基本一致，只是添加了<code>slaveof</code>配置。<br>可通过<code>info replication</code>命令查看从节点或所属主节点。</p><p>哨兵节点配置信息如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel<span class="number">-26379.</span>conf</span><br><span class="line">port <span class="number">26379</span>                                                      <span class="comment">// 哨兵默认端口</span></span><br><span class="line">daemonize yes</span><br><span class="line">logfile <span class="string">"26379.log"</span>                                             <span class="comment">// 日志文件</span></span><br><span class="line">dir /opt/soft/redis/data</span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span>                      <span class="comment">// 该哨兵监控 mymaster 127.0.0.1 6379 的主节点，同时需要 2 个哨兵判断故障才会进行故障转移。故障判定参数 quorum 建议设置为**哨兵节点数量的一般加 1**，同时该参数还与哨兵节点的领导者选举有关，至少需要有 `max(quorum, num(sentinels)/2 + 1)`个节点参与选举，才能选出哨兵领导者</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span>                 <span class="comment">// 监控节点的超时时间</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span>                              <span class="comment">// 用于限制一次故障转移后，每次向新的主节点发起复制操作的从节点个数。同时向主节点发起复制，必然会对主机诶单所在机器造成网络与磁盘开销</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span>                       <span class="comment">// 故障转移超时时间</span></span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;                   </span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;      <span class="comment">// 在故障**转移期间**的告警事件脚本</span></span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;   <span class="comment">// 在故障**转移结束后**的事件脚本</span></span><br></pre></td></tr></table></figure><p>启动Sentinel节点的命令：<code>redis-sentinel</code>或<code>redis-server redis-sentinel-26379.conf --sentinel</code>。<br>可通过<code>info sentinel</code>命令查看哨兵节点信息<br>哨兵节点会通过主节点发现从节点以及其它哨兵节点，从而实现对所有节点的监控。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bsaxy49ij30kq0eetcb.jpg" alt=""></p><p>部署技巧</p><ul><li>哨兵节点不应该部署在同一台物理机上</li><li>部署至少三个且奇数个哨兵节点</li><li>如果哨兵节点集合监控的是同一个业务的多个主节点集合，那么采用一套哨兵节点监控多个主从节点，否则采用多个哨兵节点监控多个主从节点的方案。</li></ul><h2 id="哨兵节点的-API"><a href="#哨兵节点的-API" class="headerlink" title="哨兵节点的 API"></a>哨兵节点的 API</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>sentinel masters</code></td><td>展示所有被监控的主节点状态以及相关统计信息</td></tr><tr><td><code>sentinel master &lt;master name&gt;</code></td><td>展示指定<code>&lt;master name&gt;</code>的主节点状态以及相关的统计信息</td></tr><tr><td><code>sentinel slaves &lt;master name&gt;</code></td><td>展示指定<code>&lt;master name&gt;</code>的从节点状态以及相关的统计信息</td></tr><tr><td><code>sentinel sentinels &lt;master name&gt;</code></td><td>展示指定<code>&lt;master name&gt;</code>的Sentinel节点集合（不包含当前Sentinel节点）</td></tr><tr><td><code>sentinel get-master-addr-by-name &lt;master name&gt;</code></td><td>返回指定<code>&lt;master name&gt;</code>主节点的IP地址和端口</td></tr><tr><td><code>sentinel reset &lt;pattern&gt;</code></td><td>当前Sentinel节点对符合<code>&lt;pattern&gt;</code>（通配符风格）主节点的配置进行重置，包含清除主节点的相关状态（例如故障转移），重新发现从节点和Sentinel节点。</td></tr><tr><td><code>sentinel failover &lt;master name&gt;</code></td><td>对指定<code>&lt;master name&gt;</code>主节点进行强制故障转移（没有和其他Sentinel节点“协商”），当故障转移完成后，其他Sentinel节点按照故障转移的结果更新自身配置，这个命令在Redis Sentinel的日常运维中非常有用。</td></tr><tr><td><code>sentinel ckquorum &lt;master name&gt;</code></td><td>检测当前可达的Sentinel节点总数是否达到<code>&lt;quorum&gt;</code>的个数</td></tr><tr><td><code>sentinel flushconfig</code></td><td>将Sentinel节点的配置强制刷到磁盘上，这个命令Sentinel节点自身用得比较多，对于开发和运维人员只有当外部原因（例如磁盘损坏）造成配置文件损坏或者丢失时，这个命令是很有用的。</td></tr><tr><td><code>sentinel remove &lt;master name&gt;</code></td><td>取消当前Sentinel节点对于指定<code>&lt;master name&gt;</code>主节点的监控。</td></tr><tr><td><code>sentinel monitor &lt;master name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</code></td><td>与配置文件中的含义是完全一样</td></tr><tr><td><code>sentinel set &lt;master name&gt;</code></td><td>动态修改Sentinel节点配置选项。注意：该命令只会对当前节点有效，且修改成功后会立即生效</td></tr><tr><td><code>sentinel is-master-down-by-addr</code></td><td>Sentinel节点之间用来交换对主节点是否下线的判断，根据参数的不同，还可以作为Sentinel领导者选举的通信方式</td></tr></tbody></table><p>Redis Sentinel 客户端基本实现原理</p><ol><li>遍历Sentinel节点集合获取一个可用的Sentinel节点(Sentinel节点之间可以共享数据)，所以可以从任意一个Sentinel节点获取主节点信息</li><li>通过<code>sentinel get-master-addr-by-name master-name</code>这个API来获取对应主节点的相关信息</li><li>验证当前获取的“主节点”是真正的主节点(通过 <code>role</code> 或者 <code>info replication</code> 判定)，这样做的目的是为了防止故障转移期间主节点的变化</li><li>保持和Sentinel节点集合的“联系”，时刻获取关于主节点的相关“信息”</li></ol><h2 id="Redis-Sentinel-的实现原理"><a href="#Redis-Sentinel-的实现原理" class="headerlink" title="Redis Sentinel 的实现原理"></a>Redis Sentinel 的实现原理</h2><h3 id="三个定时监控任务"><a href="#三个定时监控任务" class="headerlink" title="三个定时监控任务"></a>三个定时监控任务</h3><ol><li>每隔10秒，每个Sentinel节点会向主节点和从节点发送<code>info</code>命令获取最新的拓扑结构。该任务的作用表现在：<ol><li>通过向主节点执行<code>info</code>命令，获取从节点的信息</li><li>当有新的从节点加入时都可以立刻感知出来</li><li>节点不可达或者故障转移后，可以通过<code>info</code>命令实时更新节点拓扑信息。</li></ol></li><li>每隔2秒，每个Sentinel节点会向Redis数据节点的<code>__sentinel__：hello</code>频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断，所以这个定时任务可以完成以下两个工作：<ol><li>发现新的Sentinel节点：通过订阅主节点的<code>__sentinel__：hello</code>了解其他的Sentinel节点信息，如果是新加入的Sentinel节点，将该Sentinel节点信息保存起来，并与该Sentinel节点创建连接。</li><li>Sentinel节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。Sentinel节点publish的消息格式：<code>&lt;Sentinel节点IP&gt; &lt;Sentinel节点端口&gt; &lt;Sentinel节点runId&gt; &lt;Sentinel节点配置版本&gt; &lt;主节点名字&gt; &lt;主节点Ip&gt; &lt;主节点端口&gt; &lt;主节点配置版本&gt;</code></li></ol></li><li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。这个定时任务是节点失败判定的重要依据。</li></ol><p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9chovnyqwj30lm0ls77d.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9chuf4cjdj30ld0hogp4.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g9chunrge9j30mh0hbtbn.jpg" alt=""></p><h3 id="主观下线与客观下线"><a href="#主观下线与客观下线" class="headerlink" title="主观下线与客观下线"></a>主观下线与客观下线</h3><p>主观下线：单个哨兵节点判断主节点超过<code>down-after-milliseconds</code>时，该哨兵节点即认为该主节点已下线<br>客观下线：为了防止主观下线的误判，因此还需要发送<code>过sentinel ismaster-down-by-addr</code>命令向其他Sentinel节点询问对主节点的判断，当超过<code>&lt;quorum&gt;</code>个数，即判定该主节点确实已下线</p><h3 id="领导者-Sentinel-节点选举"><a href="#领导者-Sentinel-节点选举" class="headerlink" title="领导者 Sentinel 节点选举"></a>领导者 Sentinel 节点选举</h3><p><strong>Redis 使用了 <a href="https://raft.github.io/" target="_blank" rel="noopener">Raft 算法</a> 实现领导者选举</strong>。该算法的思路为：每个节点均有选举与被选举资格，且每个节点有且只有 1 票。当哨兵节点完成主观下线后，向其它哨兵节点询问客观下线时，会提议自身作为哨兵领导者，若被询问者尚未投票，则取得该被询问者的票数，如果询问者的票数大于等于<code>max(quorum, num(sentinels)/2 + 1)</code>，则该询问者成为领导，选举结束，同时终止其它节点的询问。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>故障转移的具体步骤如下：</p><ol><li>在从节点列表中选出一个节点作为新的主节点，选择方法如下<ol><li>过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过<code>down-after-milliseconds * 10</code>秒。</li><li>选择<code>slave-priority</code>（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。</li><li>选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续。</li><li>选择runid最小的从节点。</li></ol></li><li>Sentinel领导者节点会对第一步选出来的从节点执行<code>slaveof no one命</code>令让其成为主节点</li><li>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和<code>parallel-syncs</code>参数有关</li><li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cieyqdx2j30je0riwj1.jpg" alt=""></p><h2 id="开发与运维问题"><a href="#开发与运维问题" class="headerlink" title="开发与运维问题"></a>开发与运维问题</h2><p>模拟故障的方式：</p><ul><li>方法一，强制杀掉对应节点的进程号，这样可以模拟出宕机的效果。</li><li>方法二，使用Redis的<code>debug sleep</code>命令，让节点进入睡眠状态，这样可以模拟阻塞的效果。</li><li>方法三，使用Redis的<code>shutdown</code>命令，模拟正常的停掉Redis。</li></ul><p>Sentinel节点只支持如下命令：<code>ping</code>、<code>sentinel</code>、<code>subscribe</code>、<code>unsubscribe</code>、<code>psubscribe</code>、<code>punsubscribe</code>、<code>publish</code>、<code>info</code>、<code>role</code>、<code>client</code>、<code>shutdown</code>。</p><h1 id="第-10-章-集群"><a href="#第-10-章-集群" class="headerlink" title="第 10 章 集群"></a>第 10 章 集群</h1><h2 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h2><p>常见的分区规则有哈希分区与顺序分区两种。Redis 集群采用了哈希分区。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9e35sce95j30m505ywfm.jpg" alt=""></p><h3 id="常见的哈希分区规则"><a href="#常见的哈希分区规则" class="headerlink" title="常见的哈希分区规则"></a>常见的哈希分区规则</h3><ul><li>节点取余<ul><li>使用特定的数据，如Redis的键或用户ID，再根据节点数量N使用公式：<code>hash(key)%N</code>计算出哈希值，用来决定数据映射到哪一个节点上。这种方案存在一个问题：当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。常用于数据库的分库分表规则，一般采用预分区的方式，提前根据数据量规划好分区数。</li></ul></li><li>一致性哈希分区<ul><li>一致性哈希分区（Distributed Hash Table）实现思路是为系统中每个节点分配一个token，范围一般在0~$2^{32}$，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点</li><li>一致性哈希分区存在几个问题：①加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此<strong>一致性哈希常用于缓存场景</strong>②当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式<strong>不适合少量数据节点的分布式方案</strong>③普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡。</li></ul></li><li>虚拟分区槽<ul><li>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot），计算公式为<code>slot=CRC16(key)&amp;16383</code>。如Redis Cluster槽范围是0~16383。<strong>槽是集群内数据管理和迁移的基本单位</strong>。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽</li></ul></li></ul><p>Redis 虚拟槽分区的特点：</p><ul><li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li><li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li></ul><h3 id="集群功能限制"><a href="#集群功能限制" class="headerlink" title="集群功能限制"></a>集群功能限制</h3><ol><li>key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于执行mget、mget等操作可能存在于多个节点上因此不被支持。</li><li>key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。</li><li>key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash、list等映射到不同的节点。</li><li>不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即db0。</li><li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li></ol><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><p>搭建集群需要三个步骤：</p><ol><li>准备节点<ul><li>Redis集群一般由多个节点组成，<strong>节点数量至少为6个才能保证组成完整高可用的集群</strong>。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、data、log，分别存放配置、数据和日志相关文件。</li><li>节点 ID 用于唯一标识集群内一个节点，之后很多集群操作都要借助于节点ID来完成。需要注意是，节点ID不同于运行ID。节点ID在集群初始化时只创建一次，节点重启时会加载集群配置文件进行重用，而Redis的运行ID每次重启都会变化。在节点6380执行<code>cluster nodes</code>命令获取集群节点状态。</li><li>Redis 自动维护集群配置文件，不要手动修改，防止节点重启时产生集群信息错误。</li></ul></li><li>节点握手<ul><li>由客服端发起命令<code>cluster meet {ip} {port}</code>建立连接，该命令为异步命令。</li><li>节点建立握手后，集群此时处于下线状态，所有的数据读写都被禁止。可以通过<code>cluster info</code>查看当前集群状态。</li></ul></li><li>分配槽<ul><li>通过<code>cluster addslots</code>命令为节点分配槽。作为一个完整的集群，每个负责处理槽的节点应该具有从节点，保证当它出现故障时可以自动进行故障转移。集群模式下，Reids节点角色分为主节点和从节点。首次启动的节点和被分配槽的节点都是主节点，从节点负责复制主节点槽信息和相关的数据。使用<code>cluster replicate{nodeId}</code>命令让一个节点成为从节点。</li></ul></li></ol><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9i5gd6qalj30n80nowkd.jpg" alt="集群完整结构"></p><p>由于手动创建集群过于繁琐，且随着集群规模的扩大会加大复杂度与运维成本，因此可以通过<code>redis-trib.rb</code>来搭建集群，该工具支持集群创建、检查、修复、均衡等命令行工具。</p><p>当集群创建完成后，我们还需要进行完整性检查。集群完整性指所有的槽都分配到存活的主节点上，只要16384个槽中有一个没有分配给节点则表示集群不完整。可以使用<code>redis-trib.rb check</code>命令检测之前创建的两个集群是否成功，<code>check</code>命令只需要给出集群中任意一个节点地址就可以完成整个集群的检查工作。当持有槽的主节点下线时，从故障发现到自动完成转移期间整个集群是不可用状态，对于大多数业务无法容忍这种情况，因此建议将参数<code>cluster-require-full-coverage</code>配置为no，当主节点故障时只影响它负责槽的相关命令执行，不会影响其他主节点的可用性。</p><h2 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h2><p>常见的元数据维护方式分为：集中式和P2P方式。Redis集群采用P2P的Gossip（流言）协议，Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播。其通信过程如下：</p><ol><li>集群中的每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000。</li><li>每个节点在固定周期内通过特定规则选择几个节点发送ping消息。</li><li>接收到ping消息的节点用pong消息作为响应。</li></ol><blockquote><p>我们经常在网络中使用 ping 作为探活命令，使用 pong 作为响应，这个两个词在一次正好为 ping-pong 乒乓球，可以理解为发送方发出去的球得到响应才认为对方存活。不知道创建这一对命令的人是否也是基于这个理念创建的。</p></blockquote><p>常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息等。</p><ul><li>meet 消息：用于通知新节点加入</li><li>ping 消息：用于检测节点是否在线和交换彼此状态信息。ping 消息发送封装了自身节点和部分其他节点的状态数据。</li><li>pong 消息：作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。</li><li>fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</li></ul><p>所有消息格式划分为消息头和消息体。消息头包含发送节点自身状态数据（如节点id、槽映射、节点标识（主从角色，是否下线）等），接收节点根据消息头就可以获取到发送节点的相关数据；消息体则包含了发送节点所了解的其他节点信息。消息的类型则根据消息头的 type 属性区分。</p><p>消息头结构 clusterMsg 如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">4</span>]; <span class="comment">/* 信号标示 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> totlen; <span class="comment">/* 消息总长度 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ver; <span class="comment">/* 协议版本*/</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type; <span class="comment">/* 消息类型,用于区分meet,ping,pong等消息 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> count; <span class="comment">/* 消息体包含的节点数量，仅用于meet,ping,ping消息类型*/</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch; <span class="comment">/* 当前发送节点的配置纪元 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch; <span class="comment">/* 主节点/从节点的主节点配置纪元 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> offset; <span class="comment">/* 复制偏移量 */</span></span><br><span class="line">    <span class="keyword">char</span> sender[CLUSTER_NAMELEN]; <span class="comment">/* 发送节点的nodeId */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> myslots[CLUSTER_SLOTS/<span class="number">8</span>]; <span class="comment">/* 发送节点负责的槽信息 */</span></span><br><span class="line">    <span class="keyword">char</span> slaveof[CLUSTER_NAMELEN]; <span class="comment">/* 如果发送节点是从节点，记录对应主节点的nodeId */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port; <span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags; <span class="comment">/* 发送节点标识,区分主从角色，是否下线等 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> state; <span class="comment">/* 发送节点所处的集群状态 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mflags[<span class="number">3</span>]; <span class="comment">/* 消息标识 */</span></span><br><span class="line">    <span class="keyword">union</span> clusterMsgData data <span class="comment">/* 消息正文 */</span>;</span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure><p>消息体 clusterMsgData 结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> nodename[CLUSTER_NAMELEN]; <span class="comment">/* 节点的nodeId */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_sent; <span class="comment">/* 最后一次向该节点发送ping消息时间 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pong_received; <span class="comment">/* 最后一次接收该节点pong消息时间 */</span></span><br><span class="line">    <span class="keyword">char</span> ip[NET_IP_STR_LEN]; <span class="comment">/* IP */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port; <span class="comment">/* port*/</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags; <span class="comment">/* 该节点标识, */</span></span><br><span class="line">&#125; clusterMsgDataGossip;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ic768uakj30ho0m8jve.jpg" alt=""></p><p>如果节点间频繁通信，则会加重带宽和计算的负担，过慢又会导致信息更新不及时，因此此Redis集群的Gossip协议需要兼顾信息交换实时性和成本开销。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9icdly6hpj30j30ebq5o.jpg" alt=""></p><p>从Gossip的通信机制中我们看到，影响带宽的主要因素在于通信的节点数与发送的消息数据量，因此，我们从这两方面进行优化：</p><ul><li>选择发送消息的节点数量：集群内每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个节点找出最久没有通信的节点发送ping消息，用于保证Gossip信息交换的随机性。每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于<code>cluster_node_timeout/2</code>，则立刻发送ping消息，防止该节点信息太长时间未更新。根据以上规则得出每个节点每秒需要发送ping消息的数量<code>=1+10*num（node.pong_received&gt;cluster_node_timeout/2</code>，因此<code>cluster_node_timeout</code>参数对消息发送的节点数量影响非常大。当我们的带宽资源紧张时，可以适当调大这个参数。</li><li>消息数据量：消息头主要占用空间的字段是<code>myslots[CLUSTER_SLOTS/8]</code>，占用2KB，这块空间占用相对固定。消息体携带数据量跟集群的节点数息息相关，更大的集群每次消息通信的成本也就更高，因此对于Redis集群来说并不是大而全的集群更好。</li></ul><h2 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h2><p>集群的水平伸缩的上层原理：<strong>集群伸缩 = 槽和数据在节点之间的移动</strong>。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9icgp2fv1j30ju0gwtcv.jpg" alt=""></p><h3 id="扩容集群"><a href="#扩容集群" class="headerlink" title="扩容集群"></a>扩容集群</h3><p>槽迁移数据流程如下：</p><ol><li>对目标节点发送<code>cluster setslot {slot} importing {sourceNodeId}</code>命令，让目标节点准备导入槽的数据。</li><li>对源节点发送<code>cluster setslot {slot} migrating {targetNodeId}</code>命令，让源节点准备迁出槽的数据。</li><li>源节点循环执行<code>cluster getkeysinslot {slot} {count}</code>命令，获取count个属于槽{slot}的键。</li><li>在源节点上执行<code>migrate {targetIp} {targetPort} &quot;&quot; 0 {timeout} keys {keys...}</code>命令，把获取的键通过流水线机制批量迁移到目标节点。</li><li>重复执行步骤3和步骤4直到槽下所有的键值数据迁移到目标节点。</li><li>向集群内所有主节点发送<code>cluster setslot {slot} node {targetNodeId}</code>命令，通知槽分配给目标节点。为了保证槽节点映射变更及时传播，需要遍历发送给所有主节点更新被迁移的槽指向新节点。</li></ol><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jh857qqpj30ji0ehq6u.jpg" alt=""></p><p><code>redis-trib</code>槽重分片功能命令如下：<code>redis-trib.rb reshard host:port --from &lt;arg&gt; --to &lt;arg&gt; --slots &lt;arg&gt; --yes --timeout &lt;arg&gt; --pipeline &lt;arg&gt;</code></p><ul><li><code>host:port</code>：必传参数，集群内任意节点地址，用来获取整个集群信息。</li><li><code>--from</code>：制定源节点的id，如果有多个源节点，使用逗号分隔，如果是all源节点变为集群内所有主节点，在迁移过程中提示用户输入。</li><li><code>--to</code>：需要迁移的目标节点的id，目标节点只能填写一个，在迁移过程中提示用户输入。</li><li><code>--slots</code>：需要迁移槽的总数量，在迁移过程中提示用户输入。</li><li><code>--yes</code>：当打印出reshard执行计划时，是否需要用户输入yes确认后再执行<code>reshard</code>。</li><li><code>--timeout</code>：控制每次migrate操作的超时时间，默认为60000毫秒。</li><li><code>--pipeline</code>：控制每次批量迁移键的数量，默认为10。</li></ul><p>迁移之后建议使用<code>redis-trib.rb rebalance</code>命令检查节点之间槽的均衡性。</p><h3 id="收缩集群"><a href="#收缩集群" class="headerlink" title="收缩集群"></a>收缩集群</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jhell5zkj30gy0hc417.jpg" alt=""></p><ol><li>首先需要确定下线节点是否有负责的槽，如果是，需要把槽迁移到其他节点，保证节点下线后整个集群槽节点映射的完整性。</li><li>当下线节点不再负责槽或者本身是从节点时，就可以通知集群内其他节点忘记下线节点，当所有的节点忘记该节点后可以正常关闭。</li></ol><p>下线节点需要把自己负责的槽迁移到其他节点，原理与之前节点扩容的迁移槽过程一致。在此不做赘述。</p><p>由于集群内的节点不停地通过Gossip消息彼此交换节点状态，因此需要通过一种健壮的机制让集群内所有节点忘记下线的节点。也就是说让其他节点不再与要下线节点进行Gossip消息交换。Redis提供了<code>cluster forget{downNodeId}</code>命令实现该功能，（此处的Gossip对忘记节点造成了阻碍）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jhkc00w3j30he0b3q5k.jpg" alt=""></p><p>当节点接收到<code>cluster forget{down NodeId}</code>命令后，会把nodeId指定的节点加入到禁用列表中，在禁用列表内的节点不再发送Gossip消息。禁用列表有效期是60秒，超过60秒节点会再次参与消息交换。也就是说当第一次forget命令发出后，我们有60秒的时间让集群内的所有节点忘记下线节点。线上操作不建议直接使用<code>cluster forget</code>命令下线节点，需要跟大量节点命令交互，实际操作起来过于繁琐并且容易遗漏forget节点。建议使用<code>redistrib.rb del-node{host:port}{downNodeId}</code>命令，内部实现的伪代码如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def delnode_cluster_cmd(downNode):</span><br><span class="line">    <span class="comment"># 下线节点不允许包含slots</span></span><br><span class="line">    <span class="keyword">if</span> downNode.slots.length != <span class="number">0</span></span><br><span class="line">        <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">    end</span><br><span class="line">    <span class="comment"># 向集群内节点发送cluster forget</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nodes:</span><br><span class="line">        <span class="keyword">if</span> n.id == downNode.id:</span><br><span class="line">            <span class="comment"># 不能对自己做forget操作</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment"># 如果下线节点有从节点则把从节点指向其他主节点</span></span><br><span class="line">        <span class="keyword">if</span> n.replicate &amp;&amp; n.replicate.nodeId == downNode.id :</span><br><span class="line">            <span class="comment"># 指向拥有最少从节点的主节点</span></span><br><span class="line">            master = get_master_with_least_replicas();</span><br><span class="line">            n.cluster(<span class="string">"replicate"</span>,master.nodeId);</span><br><span class="line">        <span class="comment">#发送忘记节点命令</span></span><br><span class="line">        n.cluster(<span class="string">'forget'</span>,downNode.id)</span><br><span class="line"><span class="comment"># 节点关闭</span></span><br><span class="line">downNode.shutdown();</span><br></pre></td></tr></table></figure><p>当下线主节点具有从节点时需要把该从节点指向到其他主节点，因此对于主从节点都下线的情况，建议先下线从节点再下线主节点，防止不必要的全量复制。</p><h2 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h2><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p>在集群模式下，Redis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，通知客户端请求正确的节点。这个过程称为MOVED重定向。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jhv81y3pj30j00jrwhp.jpg" alt=""></p><p>可以通过<code>cluster keyslot{key}</code>命令返回key所对应的槽，该命令采用<code>key_hash_slot()</code>函数实现。<br>使用<code>redis-cli</code>命令时，可以加入<code>-c</code>参数支持自动重定向，简化手动发起重定向操作。</p><p>键命令执行步骤主要分两步：计算槽，查找槽所对应的节点。</p><ol><li>Redis首先需要计算键所对应的槽。根据键的有效部分使用CRC16函数计算出散列值，再取对16383的余数，使每个键都可以映射到0~16383槽范围内。</li><li>节点对于判定键命令是执行还是MOVED重定向，都是借助<code>slots [CLUSTER_SLOTS]</code>数组实现。根据MOVED重定向机制，客户端可以随机连接集群内任一Redis获取键所在节点，这种客户端又叫Dummy（傀儡）客户端，它优点是代码实现简单，对客户端协议影响较小，只需要根据重定向信息再次发送请求即可。但是它的弊端很明显，每次执行键命令前都要到Redis上进行重定向才能找到要执行命令的节点，额外增加了IO开销，这不是Redis集群高效的使用方式。正因为如此通常集群客户端都采用另一种实现：Smart（智能）客户端。Smart客户端通过在内部维护slot→node的映射关系，本地就可实现键到节点的查找，从而保证IO效率的最大化，而MOVED重定向负责协助Smart客户端更新slot→node映射。</li></ol><h4 id="hash-tag"><a href="#hash-tag" class="headerlink" title="hash_tag"></a>hash_tag</h4><p>hash_tag 允许用 key 的部分字符串来计算 hash。当一个 key 包含 {} 的时候，就不对整个 key 做 hash，而仅对 {} 包括的字符串做 hash。</p><p>在集群模式下使用mget等命令优化批量调用时，键列表必须具有相同的slot，否则会报错。这时可以利用hash_tag让不同的键具有相同的slot达到优化的目的。命令如下：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6385</span>&gt; mget <span class="keyword">user</span>:<span class="number">10086</span>:frends <span class="keyword">user</span>:<span class="number">10086</span>:videos</span><br><span class="line">(error) CROSSSLOT Keys <span class="keyword">in</span> request don't hash <span class="keyword">to</span> the same slot</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6385</span>&gt; mget <span class="keyword">user</span>:&#123;<span class="number">10086</span>&#125;:friends <span class="keyword">user</span>:&#123;<span class="number">10086</span>&#125;:videos</span><br><span class="line"><span class="number">1</span>) <span class="string">"friends"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"videos"</span></span><br></pre></td></tr></table></figure><p>Pipeline同样可以受益于hash_tag，由于Pipeline只能向一个节点批量发送执行命令，而相同slot必然会对应到唯一的节点，降低了集群使用Pipeline的门槛。</p><h3 id="ASK-重定向"><a href="#ASK-重定向" class="headerlink" title="ASK 重定向"></a>ASK 重定向</h3><p>当slot对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。例如当一个slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qoovqnpwj30u00vlk0z.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qop67mnjj311m0ti0z1.jpg" alt=""></p><p>ASK与MOVED虽然都是对客户端的重定向控制，但是有着本质区别。ASK重定向说明集群正在进行slot数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新slots缓存。但是MOVED重定向说明键对应的槽已经明确指定到新的节点，因此需要更新slots缓存。</p><p>为了支持ASK重定向，源节点和目标节点在内部的clusterState结构中维护当前正在迁移的槽信息，用于识别槽迁移情况。</p><ul><li>如果键所在的槽由当前节点负责，但键不存在则查找<code>migrating_slots_to</code>数组查看槽是否正在迁出，如果是返回ASK重定向。</li><li>如果客户端发送<code>asking</code>命令打开了<code>CLIENT_ASKING</code>标识，则该客户端下次发送键命令时查找<code>importing_slots_from</code>数组获取<code>clusterNode</code>，如果指向自身则执行命令。<ul><li>需要注意的是，asking命令是一次性命令，每次执行完后客户端标识都会修改回原状态，因此每次客户端接收到ASK重定向后都需要发送asking命令。</li></ul></li><li>ASK重定向对单键命令支持得很完善。当槽处于迁移状态时，批量操作会受到影响。</li></ul><p>使用smart客户端批量操作集群时，需要评估<code>mget/mset</code>、Pipeline等方式在slot迁移场景下的容错性，防止集群迁移造成大量错误和数据丢失的情况。</p><p>集群环境下对于使用批量操作的场景，建议优先使用Pipeline方式，在客户端实现对ASK重定向的正确处理，这样既可以受益于批量操作的IO优化，又可以兼容slot迁移场景。</p><h2 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h2><p>当某个节点被主观下线后，ping/pong消息的消息体会携带集群1/10的其他节点状态数据在集群内传播。当半数以上持有槽的主节点都标记某个节点是主观下线时，触发客观下线流程。</p><p>每个下线报告都存在有效期(<code>cluster-node-time*2</code>)，每次在尝试触发客观下线时，都会检测下线报告是否过期，对于过期的下线报告将被删除。</p><p>如果在<code>cluster-node-time*2</code>时间内无法收集到一半以上槽节点的下线报告，那么之前的下线报告将会过期，也就是说主观下线上报的速度追赶不上下线报告过期的速度，那么故障节点将永远无法被标记为客观下线从而导致故障转移失败。因此不建议将<code>cluster-node-time</code>设置得过小。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qp56c761j30u010847e.jpg" alt=""></p><p>故障恢复流程：</p><ol><li>资格检查</li><li>准备选举时间</li><li>发起选举</li><li>选举投票</li><li>替换主节点</li></ol><p>投票作废：每个配置纪元代表了一次选举周期，如果在开始投票之后的<code>cluster-node-timeout*2</code>时间内从节点没有获取足够数量的投票，则本次选举作废。从节点对配置纪元自增并发起下一轮投票，直到选举成功为止。</p><p>故障转移时间：<code>failover-time(毫秒) ≤ cluster-node-timeout + cluster-node-timeout/2 + 1000</code></p><h2 id="集群运维"><a href="#集群运维" class="headerlink" title="集群运维"></a>集群运维</h2><p>集群倾斜</p><ul><li>数据倾斜<ul><li>节点和槽分配严重不均。可以使用<code>redis-trib.rb info{host:ip}</code>进行定位</li><li>不同槽对应键数量差异过大。键通过CRC16哈希函数映射到槽上，正常情况下槽内键数量会相对均匀。但当大量使用hash_tag时，会产生不同的键映射到同一个槽的情况。特别是选择作为hash_tag的数据离散度较差时，将加速槽内键数量倾斜情况。通过命令<code>cluster countkeysinslot{slot}</code>可以获取槽对应的键数量，识别出哪些槽映射了过多的键。再通过命令<code>clustergetkeysinslot{slot}{count}</code>循环迭代出槽下所有的键。从而发现过度使用hash_tag的键。</li><li>集合对象包含大量元素。</li><li>内存相关配置不一致。</li></ul></li><li>请求倾斜<ul><li>合理设计键，热点大集合对象做拆分或使用hmget替代hgetall避免整体读取。</li><li>不要使用热键作为hash_tag，避免映射到同一槽。</li><li>对于一致性要求不高的场景，客户端可使用本地缓存减少热键调用。</li></ul></li></ul><p>集群模式下从节点不接受任何读写请求，发送过来的键命令会重定向到负责槽的主节点上。当需要使用从节点分担主节点读压力时，可以使用<code>readonly</code>命令打开客户端连接只读状态。<code>readonly</code>命令是连接级别生效，因此每次新建连接时都需要执行<code>readonly</code>开启只读状态。执行<code>readwrite</code>命令可以关闭连接只读状态。</p><h1 id="第-11-章-缓存设计"><a href="#第-11-章-缓存设计" class="headerlink" title="第 11 章 缓存设计"></a>第 11 章 缓存设计</h1><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><h3 id="LRU-LFU-FIFO-算法剔除"><a href="#LRU-LFU-FIFO-算法剔除" class="headerlink" title="LRU/LFU/FIFO 算法剔除"></a>LRU/LFU/FIFO 算法剔除</h3><p>使用场景：剔除算法通常用于缓存使用量超过了预设的最大值时候，如何对现有的数据进行剔除。<br>一致性：要清理哪些数据是由具体算法决定，开发人员只能决定使用哪种算法，所以数据的一致性是最差的。<br>维护成本：算法不需要开发人员自己来实现，通常只需要配置最大<code>maxmemory</code>和对应的策略即可。开发人员只需要知道每种算法的含义，选择适合自己的算法即可。</p><h3 id="超时剔除"><a href="#超时剔除" class="headerlink" title="超时剔除"></a>超时剔除</h3><p>使用场景：如果业务可以容忍一段时间内，缓存层数据和存储层数据不一致，那么可以为其设置过期时间。如一个视频的描述信息，可以容忍几分钟内数据不一致，但是涉及交易方面的业务则不适用。<br>一致性：一段时间窗口内存在一致性问题。<br>维护成本：只需设置<code>expire</code>过期时间即可，维护成本较低。</p><h3 id="主动更新"><a href="#主动更新" class="headerlink" title="主动更新"></a>主动更新</h3><p>使用场景：应用方对于数据的一致性要求高，需要在真实数据更新后，立即更新缓存数据。<br>一致性：一致性最高，但如果主动更新发生了问题，那么这条数据很可能很长时间不会更新，所以<strong>建议结合超时剔除一起使用效果会更好</strong>。<br>维护成本：维护成本较高，开发者需要自己来完成更新，并保证更新操作的正确性。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li>低一致性业务建议配置最大内存和淘汰策略的方式使用。</li><li>高一致性业务可以结合使用超时剔除和主动更新，这样即使主动更新出了问题，也能保证数据过期时间后删除脏数据。</li></ol><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中。造成缓存穿透的基本原因有两个。第一，自身业务代码或者数据出现问题，第二，一些恶意攻击、爬虫等造成大量空命中。</p><h3 id="缓存穿透的解决方案"><a href="#缓存穿透的解决方案" class="headerlink" title="缓存穿透的解决方案"></a>缓存穿透的解决方案</h3><h4 id="1-缓存空对象"><a href="#1-缓存空对象" class="headerlink" title="1. 缓存空对象"></a>1. 缓存空对象</h4><p>缓存空对象会有两个问题：第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;</span><br><span class="line">        <span class="comment">// 从存储中获取</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存非空</span></span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enly0i2dj30g10i1ac8.jpg" alt=""></p><h4 id="2-布隆过滤器拦截"><a href="#2-布隆过滤器拦截" class="headerlink" title="2. 布隆过滤器拦截"></a>2. 布隆过滤器拦截</h4><p>如图所示，在访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截。例如：一个推荐系统有4亿个用户id，每个小时算法工程师会根据每个用户之前历史行为计算出推荐数据放到存储层中，但是最新的用户由于没有历史行为，就会发生缓存穿透的行为，为此可以将所有推荐数据的用户做成布隆过滤器。如果布隆过滤器认为该用户id不存在，那么就不会访问存储层，在一定程度保护了存储层。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enotipdrj30in0hvq5t.jpg" alt=""></p><blockquote><p>可以利用 Redis 的 Bitmaps 实现布隆过滤器。类似开源方案可查看 <a href="https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter" target="_blank" rel="noopener">https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter</a></p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9ens6v1czj30md068q4q.jpg" alt=""></p><h2 id="无底洞优化"><a href="#无底洞优化" class="headerlink" title="无底洞优化"></a>无底洞优化</h2><p>无底洞是指，采用分布式提升缓存的能力，但分布式架构又引发了<code>mget</code>等批量操作命令的多次网络连接造成的性能下降。因此，更多的节点不代表更高的性能，所谓“无底<br>洞”就是说投入越多不一定产出越多。但是分布式又是不可以避免的，因为访问量和数据量越来越大，一个节点根本抗不住，所以如何高效地在分布式缓存中批量操作是一个难点。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enykatrkj30lu0m9tf4.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9enz0x9eaj30mh0jsgr7.jpg" alt=""></p><p>无底洞问题的优化方案：</p><ul><li><p>命令本身的优化，例如优化SQL语句等。</p></li><li><p>减少网络通信次数。</p><ul><li>客户端n次get(串行执行)：n次网络+n次get命令本身。<ul><li>即逐次执行n个get命令，这种操作时间复杂度较高，但实现也最简单。</li></ul></li><li>客户端1次pipeline get(串行I/O)：1次网络+n次get命令本身。<ul><li>Redis Cluster使用CRC16算法计算出散列值，再取对16383的余数就可以算出slot值，同时Smart客户端会保存slot和节点的对应关系，有了这两个数据就可以将属于同一个节点的key进行归档，得到每个节点的key子列表，之后对每个节点执行mget或者Pipeline操作，它的操作时间=node次网络时间+n次命令时间，网络次数是node的个数，很明显这种方案比第一种要好很多，但是如果节点数太多，还是有一定的性能问题。</li></ul></li><li>客户端1次mget(并行I/O)：1次网络+1次mget命令本身。<ul><li>此方案是将方案2中的最后一步改为多线程执行，网络次数虽然还是节点个数，但由于使用多线程网络时间变为$O(1)$，这种方案会增加编程的复杂度。其操作时间为：<code>max_slow(node网络时间)+n次命令时间</code></li></ul></li><li>Redis Cluster的<code>hash_tag</code>可以将多个key强制分配到一个节点上，它的操作时间=1次网络时间+n次命令时间。</li></ul></li><li><p>降低接入成本，例如客户端使用长连/连接池、NIO(Non-blocking I/O)等。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eoakg0wrj30md0g0jty.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eo4ku5pyj30mg095acq.jpg" alt=""></p><h2 id="雪崩优化"><a href="#雪崩优化" class="headerlink" title="雪崩优化"></a>雪崩优化</h2><p>缓存雪崩：如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eobx2323j30m20ed0vb.jpg" alt=""></p><p>优化方案如下：</p><ol><li>保证缓存层服务高可用性。Redis Sentinel和Redis Cluster都实现了高可用。</li><li>依赖隔离组件为后端限流并降级。作为并发量较大的系统，假如有一个资源不可用，可能会造成线程全部阻塞在这个资源上，造成整个系统不可用。降级机制在高并发系统中是非常普遍的：比如推荐服务中，如果个性化推荐服务不可用，可以降级补充热点数据，不至于造成前端页面是开天窗。在实际项目中，我们需要对重要的资源（例如Redis、MySQL、HBase、外部接口）都进行隔离，让每种资源都单独运行在自己的线程池中，即使个别资源出现了问题，对其他服务没有影响。</li><li>提前演练。在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。</li></ol><h2 id="热点key重建优化"><a href="#热点key重建优化" class="headerlink" title="热点key重建优化"></a>热点key重建优化</h2><p>在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。</p><p>解决热点 key 重建的思路：</p><ul><li>减少重建缓存的次数。</li><li>数据尽可能一致。</li><li>较少的潜在危险。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="互斥锁-mutex-key"><a href="#互斥锁-mutex-key" class="headerlink" title="互斥锁(mutex key)"></a>互斥锁(mutex key)</h4><p>此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从Redis中获取数据</span></span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="comment">// 如果value为空，则开始重构缓存</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 只允许一个线程重构缓存，使用nx，并设置过期时间ex</span></span><br><span class="line">        String mutexKey = <span class="string">"mutext:key:"</span> + key;</span><br><span class="line">        <span class="keyword">if</span> (redis.set(mutexKey, <span class="string">"1"</span>, <span class="string">"ex 180"</span>, <span class="string">"nx"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 从数据源获取数据</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            <span class="comment">// 回写Redis，并设置过期时间</span></span><br><span class="line">            redis.setex(key, timeout, value);</span><br><span class="line">            <span class="comment">// 删除key_mutex</span></span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他线程休息50毫秒后重试</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="永不过期"><a href="#永不过期" class="headerlink" title="永不过期"></a>永不过期</h4><p>永不过期包含两层含义：</p><ul><li>从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。</li><li>从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eomw75jpj30lp0lt43y.jpg" alt=""></p><p>作为一个并发量较大的应用，在使用缓存时有三个目标：第一，加快用户访问速度，提高用户体验。第二，降低后端负载，减少潜在的风险，保证系统平稳。第三，保证数据“尽可能”及时更新。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9eol3rlkmj30mz07fq4l.jpg" alt=""></p><h1 id="第-12-章-Devops-的陷阱"><a href="#第-12-章-Devops-的陷阱" class="headerlink" title="第 12 章 Devops 的陷阱"></a>第 12 章 Devops 的陷阱</h1><h2 id="Redis-攻击"><a href="#Redis-攻击" class="headerlink" title="Redis 攻击"></a>Redis 攻击</h2><p>攻击者充分利用Redis的dir和<code>dbfilename</code>两个配置可以使用<code>config set</code>动态设置，以及RDB持久化的特性，将自己的公钥写入到目标机器的<code>/root/.ssh/authotrized_keys</code>文件中，从而实现了对目标机器的攻陷。攻击过程如图。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qrmwcp5ij30il0black.jpg" alt=""></p><h2 id="命令重写"><a href="#命令重写" class="headerlink" title="命令重写"></a>命令重写</h2><p>Redis 中提供了<code>rename-command</code>命令来重命名命令，我们可以通过该命令将一些危险命令改写，如<code>keys</code>、<code>flushall/flushdb</code>、<code>save</code>、<code>debug</code>(<code>debug reload</code>会重启 Redis)、<code>config</code>、<code>shutdown</code>。同时，<code>rename-command</code>不支持<code>config set</code>，如果AOF和RDB文件包含了rename-command之前的命令，Redis将无法启动。</p><p><code>rename-command</code>的最佳实践：</p><ul><li>对于一些危险的命令（例如flushall），不管是内网还是外网，一律使用<code>rename-command</code>配置</li><li>建议第一次配置Redis时，就应该配置<code>rename-command</code>，因为<code>renamecommand</code>不支持<code>config set</code>。</li><li>如果涉及主从关系，一定要保持主从节点配置的一致性，否则存在主从数据不一致的可能性。</li></ul><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>可以使用防火墙限制输入和输出的IP或者IP范围、端口或者端口范围。</p><p>很多开发者在一开始看到bind的这个配置时都是这么认为的：指定Redis只接收来自于某个网段IP的客户端请求，但<strong>事实上bind指定的是Redis和哪个网卡进行绑定</strong>，和客户端是什么网段没有关系。</p><ul><li>如果机器有外网IP，但部署的Redis是给内部使用的，建议去掉外网网卡或者使用bind配置限制流量从外网进入。</li><li>如果客户端和Redis部署在一台服务器上，可以使用回环地址（127.0.0.1）。</li><li>bind配置不支持<code>config set</code>，所以尽可能在第一次启动前配置好</li></ul><h2 id="bigkey"><a href="#bigkey" class="headerlink" title="bigkey"></a>bigkey</h2><p>危害：</p><ul><li>内存空间不均匀</li><li>超时阻塞</li><li>网络拥塞</li></ul><p>bigkey的存在并不是完全致命的，如果这个bigkey存在但是几乎不被访问，那么只有内存空间不均匀的问题存在，相对于另外两个问题没有那么重要紧急，但是如果bigkey是一个热点key（频繁访问），那么其带来的危害不可想象，所以在实际开发和运维时一定要密切关注bigkey的存在。</p><h2 id="查找热点-Key"><a href="#查找热点-Key" class="headerlink" title="查找热点 Key"></a>查找热点 Key</h2><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>客户端</td><td>实现简单</td><td>· 内存泄露隐患<br>· 维护成本高<br>· 只能统计单个客户端</td></tr><tr><td>代理</td><td>代理是客户端和服务端的桥梁，实现最方便最系统</td><td>增加代理端的成本部署开发</td></tr><tr><td>服务端</td><td>实现简单</td><td>· monitor 本身的使用成本和危害，只能短时间使用<br>· 只能统计单个 Redis 节点</td></tr><tr><td>机器</td><td>对于客户端和服务端无侵入和影响</td><td>需要专业的运维团队开发，并且增加了机器的部署成本</td></tr></tbody></table><hr><blockquote><p>读后感：Redis 是一款强有力的生产力工具，像一把瑞士军刀，只有你熟悉自己使用的工具，才能构建出一座坚固漂亮的大厦。使用什么工具决定了你的下限，但怎么使用工具决定了你的上限，你可以用 Redis 来做缓存，也可以用于流量削峰，年会抽奖，社交推荐。所有工具的背后都取决于人，创新产生价值。</p></blockquote><p>Redis 中值得我们关注的地方：</p><ul><li>基础数据类型</li><li>主从复制</li><li>哨兵</li><li>集群</li><li>如何做到高性能、低复杂度</li><li>如何保障主从、哨兵、集群的数据一致性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银联查询银行卡信息</title>
      <link href="/post/get-bank-info-by-unionpay/"/>
      <url>/post/get-bank-info-by-unionpay/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pqhsfuiuj30fa0b40u3.jpg" alt=""></p><a id="more"></a><blockquote><p><em>银联已于 2020 年 1 月下架该页面及功能，本文所提方式已失效。</em></p></blockquote><p>不知道你在用手机银行转账时注意过没有，当你输入卡号时，会自动识别归属银行，识别失败时，则会让用户手动选择。最近在做一个类似银行卡信息需求时，想到应该会有这样的一个接口，Google 后发现还真的有官方接口，而且有体验页面👉<a href="https://open.unionpay.com/tjwx/openapi/cardbin-pc.html" target="_blank" rel="noopener">银行卡信息查询体验</a>，详细的接口信息<a href="https://open.unionpay.com/tjweb/api/interface?apiSvcId=51&id=129" target="_blank" rel="noopener">银行卡信息查询</a>。不过当我注册了开发者时，发现该接口无法使用，提交工单后得到以下回复</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pqlc4u98j31440cywhp.jpg" alt=""></p><p>既然无法通过正常调用使用，那就曲径通幽吧。我们通过分析查询体验页后就有了以下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 获取银行卡的发卡行、发卡行机构代码、卡性质、卡类别、卡种、卡品牌、卡产品、卡等级、卡介质、所属总行机构中文名称、所属总行机构中文简称。</span></span><br><span class="line"></span><br><span class="line">$cardNo = <span class="string">'6227000280070981140'</span>;</span><br><span class="line"></span><br><span class="line">$ch = curl_init(<span class="string">'https://open.unionpay.com/tjwx/api/cardbin/cardinfo'</span>);</span><br><span class="line">curl_setopt_array(</span><br><span class="line">    $ch,</span><br><span class="line">    [</span><br><span class="line">        CURLOPT_POST =&gt; <span class="keyword">true</span>,</span><br><span class="line">        CURLOPT_POSTFIELDS =&gt; http_build_query([<span class="string">'cardNo'</span> =&gt; $cardNo]),<span class="comment">//设定 POST 参数内容</span></span><br><span class="line">        <span class="comment">// CURLOPT_FOLLOWLOCATION =&gt; true,//跟随重定向地址</span></span><br><span class="line">        <span class="comment">// CURLOPT_AUTOREFERER =&gt; true,</span></span><br><span class="line">        CURLOPT_RETURNTRANSFER =&gt; <span class="keyword">true</span>,<span class="comment">//将curl_exec()获取的信息以字符串返回，而不是直接输出。</span></span><br><span class="line">        CURLOPT_USERAGENT =&gt; <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span>,</span><br><span class="line">        CURLOPT_REFERER =&gt; <span class="string">'https://open.unionpay.com/tjwx/openapi/cardbin-pc.html'</span>,<span class="comment">//必填项</span></span><br><span class="line">        CURLOPT_HTTPHEADER =&gt; [<span class="string">"Content-Type: application/x-www-form-urlencoded"</span>, <span class="string">"Accept: application/json, text/javascript, */*; q=0.01"</span>]</span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$resp = curl_exec($ch);</span><br><span class="line"></span><br><span class="line">curl_close($ch);</span><br><span class="line"></span><br><span class="line">$resp_obj = json_decode($resp);</span><br><span class="line"><span class="keyword">if</span> ($resp_obj-&gt;state) &#123;</span><br><span class="line">    <span class="comment">// 发卡行中文名</span></span><br><span class="line">    $bankCnName = $resp_obj-&gt;data-&gt;issNm;</span><br><span class="line">    <span class="comment">// 发卡行中文简称</span></span><br><span class="line">    $bankCnShortName = $resp_obj-&gt;data-&gt;issAbbr;</span><br><span class="line">    <span class="comment">// 发卡行机构代码</span></span><br><span class="line">    $issInsId = $resp_obj-&gt;data-&gt;issInsId;</span><br><span class="line">    <span class="comment">// 卡性质 cardAttr</span></span><br><span class="line">    <span class="comment">// 卡类别 cardCata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些信息对我已经够用了，银联还有很多其它的便捷接口，有些公共信息我们是可以免除用户输入，系统自动抓取相关信息补充，既减少了用户的输入，又能避免错误输入，是一种不错的提升用户体验的思路。不过要考虑到有时候无法正确拉取到结果，对于拉取失败仍需给用户留下手动输入的空间。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【TODO】 自动备份博客图片</title>
      <link href="/post/auto-backup-blog-images/"/>
      <url>/post/auto-backup-blog-images/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8jjsz0gmzj31gy0u0qo5.jpg" alt=""></p><a id="more"></a><p>写博客的都会有图床的问题，使用第三方图床要么是付费问题，要么是倒闭问题。我最早使用的七牛云，后来突然关闭了免费容量，下载都需要绑定备案域名，也不允许查看，导致早期博文图片无法恢复，只能以后抽空重写一下了。现在用的是新浪免费图床，结合 iPic 使用非常便捷，之前新浪有过一次限制，所有图片都访问不了了，后来加了一行代码解决了。但如果未来新浪突然全部封死，那又要重蹈七牛云的覆辙。所以还是需要未雨绸缪。</p><p>现在的 iPic 方式简直不要太方便，白嫖的新浪图床加载速度也很不错，所以还可以继续使用，不过可以写一段脚本，当检测到仓库有新的提交时，就检索该文章下的图片，并下载备份到 NAS 中。当然，在这个工作之前，还需要将原有博文的图片名称补充完，并将历史的图片按时间、文章保存，以便未来图床失效能快速恢复图片。</p><p>使用 <a href="https://github.com/rosell-dk/webp-convert" target="_blank" rel="noopener">webp-convert</a> 将 jpg &amp; png 图片转换为 webp 格式，以节省带宽，加速访问，效果可以在 <a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener">Google PageSpeed Insights</a> 查看</p><p>已验证：新浪图床不支持 webp 格式，webp 上传后会被转为 jpg，似乎会对图片内容进行编码，只储存一份同样内容文件，更换不同的文件名映射，原理类似于百度云。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>群晖NAS自动更换登录页背景</title>
      <link href="/post/nas-auto-change-bgimg/"/>
      <url>/post/nas-auto-change-bgimg/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8iauczkluj30pa0jw4ar.jpg" alt=""></p><a id="more"></a><p>群晖默认的登陆页实在是太单调了，之前看过很多抓取必应图片自动更换的例子，今天也想亲自实战一把应用在群晖登陆页上。于是 Google 到了这样一篇文章<a href="https://03k.org/dsm-bing.html" target="_blank" rel="noopener">巧用计划任务修改群晖登录壁纸</a>，这是一篇发布时间较久的文章，其中的一些信息可能已经失效，但其他地方的很多文章都是拷贝这里的，所以还是决定按图索骥试一试。</p><p>这个文章是用 shell 写的，但我觉得里边的功能用 PHP 也能实现（这怎么会难得住世界上最好的语言呢😜），通过必应首页控制台分析可知，从一个地址<code>https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;nc=1572500909531&amp;pid=hp&amp;FORM=BEHPTB&amp;video=1</code>获取图片 URI，返回完整结果如下。取的图片 URI 后再以 GET 方式获取图片内容。进一步分析可得，URL中的 <code>idx</code> 为 0 时表示返回当天图片，1 为前一天，以此类推，最大有效值为 8。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"images"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"startdate"</span>: <span class="string">"20191031"</span>,</span><br><span class="line">      <span class="attr">"fullstartdate"</span>: <span class="string">"201910311600"</span>,</span><br><span class="line">      <span class="attr">"enddate"</span>: <span class="string">"20191101"</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">"/th?id=OHR.AlbertaOwl_ZH-CN1184867720_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp"</span>,</span><br><span class="line">      <span class="attr">"urlbase"</span>: <span class="string">"/th?id=OHR.AlbertaOwl_ZH-CN1184867720"</span>,</span><br><span class="line">      <span class="attr">"copyright"</span>: <span class="string">"一只坐在白杨树上的大雕鸮，阿尔伯塔 (© Ambre Haller/Getty Images)"</span>,</span><br><span class="line">      <span class="attr">"copyrightlink"</span>: <span class="string">"/search?q=%e5%a4%a7%e9%9b%95%e9%b8%ae&amp;form=HPCAPT&amp;mkt=zh-cn"</span>,</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"quiz"</span>: <span class="string">"/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20191031_AlbertaOwl%22&amp;FORM=HPQUIZ"</span>,</span><br><span class="line">      <span class="attr">"wp"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"hsh"</span>: <span class="string">"a76d074e286a1dd8aa778815fe611e2e"</span>,</span><br><span class="line">      <span class="attr">"drk"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"top"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"bot"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"hs"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"tooltips"</span>: &#123;</span><br><span class="line">    <span class="attr">"loading"</span>: <span class="string">"正在加载..."</span>,</span><br><span class="line">    <span class="attr">"previous"</span>: <span class="string">"上一个图像"</span>,</span><br><span class="line">    <span class="attr">"next"</span>: <span class="string">"下一个图像"</span>,</span><br><span class="line">    <span class="attr">"walle"</span>: <span class="string">"此图片不能下载用作壁纸。"</span>,</span><br><span class="line">    <span class="attr">"walls"</span>: <span class="string">"下载今日美图。仅限用作桌面壁纸。"</span>,</span><br><span class="line">    <span class="attr">"play"</span>: <span class="string">"播放视频"</span>,</span><br><span class="line">    <span class="attr">"pause"</span>: <span class="string">"暂停视频"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们要分析群晖是从何处读取的图片，从查到的文章可知，图片位于<code>/usr/syno/etc/login_background.jpg</code>和<code>/usr/syno/etc/login_background_hd.jpg</code>。所以我们要到终端一探究竟。首先，我们需要在控制面板的终端里开启 ssh 服务<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ia5v9rjqj30j80frwg5.jpg" alt=""></p><p>然后我们以命令<code>ssh username@hostname [-p port]</code>登陆 NAS，由于图片存储位置需要 root 权限，我们还需要用命令<code>sudo -i</code>切换到 root 用户。（如果需要在公网ssh登陆，只需要在路由器上将 NAS 的 ssh 端口转发即可）</p><blockquote><p>小插曲：当我配置了.ssh/config 想要 ssh 免密登陆时，发现 NAS 仍然每次要求密码，使得我一度以为是配置有误，直到我重新给桌角吃灰的树莓派通电，才发现确实是 NAS 系统的问题，最后找到了这样一篇文章<a href="https://soulteary.com/2018/07/20/synology-passwordless-ssh.html" target="_blank" rel="noopener">设置群晖 6.1 以及 6.2 使用证书免密登录</a>，在按照文章重启 sshd 服务尝试修复时，发现 sshd 服务起不来了😅，最后终于在控制面板 ==&gt; 信息中心 ==&gt; 服务 中重新启动服务。嗯，我觉得我还能忍，也就每次登陆的时候多花两秒钟嘛，强迫症要适时低头</p></blockquote><p>当我进入系统后，发现<code>/usr/syno/etc/</code>下并没有<code>login_background*.jpg</code>的文件，然后在控制面板的主题中修改登录页图片，并用<code>ll -t</code>命令观察该目录下的变化，发现出现了这两个文件，时间也是刚刚操作的时间，因此可以判定确实读取该位置的文件。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iaccklxcj30oq0fujuy.jpg" alt=""></p><p>接下来，我们通过代码直接获取图片内容及介绍信息，填充登陆页。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 获取图片信息</span></span><br><span class="line">$img_info = file_get_contents(<span class="string">'https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;pid=hp&amp;FORM=BEHPTB&amp;video=1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求失败时，使用「Server 酱」将错误信息推送至绑定的微信</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span> === $img_info) &#123;</span><br><span class="line">    file_get_contents(<span class="string">'https://sc.ftqq.com/SCg552xxx.send?text='</span> . urlencode(<span class="string">'Get bing wallpaper error!'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$img_obj = json_decode($img_info)-&gt;images[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图片地址</span></span><br><span class="line">$img_url = <span class="string">'https://cn.bing.com'</span> . $img_obj-&gt;url;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图片名</span></span><br><span class="line">$url_params = parse_url($img_url)[<span class="string">'query'</span>];</span><br><span class="line">parse_str($url_params, $result);</span><br><span class="line">$filename = $result[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载图片并保存</span></span><br><span class="line"><span class="comment">// 注意文件路径写为绝对路径，避免出错</span></span><br><span class="line">$img_rsc = file_get_contents($img_url);</span><br><span class="line">file_put_contents(<span class="string">'/var/services/homes/palemoky/work/bing_wallpaper/'</span> . $filename, $img_rsc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将图片复制到目标位置</span></span><br><span class="line">copy(<span class="string">'/var/services/homes/palemoky/work/bing_wallpaper/'</span> . $filename, <span class="string">'/usr/syno/etc/login_background.jpg'</span>);</span><br><span class="line">copy(<span class="string">'/var/services/homes/palemoky/work/bing_wallpaper/'</span> . $filename, <span class="string">'/usr/syno/etc/login_background_hd.jpg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图片描述信息</span></span><br><span class="line"><span class="keyword">list</span>($msg, $title) = explode(<span class="string">'('</span>, rtrim($img_obj-&gt;copyright, <span class="string">')'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改欢迎信息</span></span><br><span class="line">shell_exec(<span class="string">'sed -i "/login_welcome_title/c login_welcome_title=\"'</span> . $title . <span class="string">'\"" /etc/synoinfo.conf'</span>);</span><br><span class="line">shell_exec(<span class="string">'sed -i "/login_welcome_msg/c login_welcome_msg=\"'</span> . $msg . <span class="string">'\"" /etc/synoinfo.conf'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>小插曲：这里我们需要修改系统配置文件<code>/etc/synoinfo.conf</code>，我查询到的 php 修改文件方式都是把整个文件读取出来，然后再把修改后的文件赋值给变量，最后再覆写原来的文件，这种方式不太优雅，我修改一个字符都要读取全部的文件并回写，因此选择使用了 sed 来操作。sed 相同的命令在 Mac 下执行就会报 <code>sed: 1: &quot;synoinfo.conf&quot;: unterminated substitute pattern</code> 的错误，但 Linux 下就完全正常，Unix 和 Linux 系统间还是要注意这些微小的差别，害得我调了半天。</p></blockquote><p>把以上代码保存为文件，由于背景图文件是 root 用户，因此需要使用 root 用户执行<code>php .../bing_wallpaper.php</code>，如果发现在目标位置产生了最新的背景图文件，并在主题设置页生效，则说明代码工作正常。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ibjcc27vj30mv0ewq66.jpg" alt=""></p><p>接下来就是创建计划任务了，离成功只有一步了<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iaflytkuj30km0fjta6.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iai54gl0j30ep06274e.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iaikc1syj30en0epgm6.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iaj7rwt4j30eq09cdgg.jpg" alt=""></p><p>至此，大功告成，来看下效果图。emmmm, not bad.<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ias6kh5dj30vc0mcu0n.jpg" alt=""></p><p>最后，如果你觉得左上角的信息有些无趣，也可以用<a href="https://github.com/chinese-poetry/chinese-poetry" target="_blank" rel="noopener">chinese-poetry</a>每天自动更换古诗词，或者抓取 <a href="http://wufazhuce.com/one/2618" target="_blank" rel="noopener">One·一个</a>的每日一句替换，还可以抓包分析豆瓣的 iOS 每日电影 widget，获取电影台词……更多玩法等待解锁。</p><h2 id="—-2019-11-10-更-—"><a href="#—-2019-11-10-更-—" class="headerlink" title="— 2019.11.10 更 —"></a><center>— 2019.11.10 更 —</center></h2><p>Chrome 首页插件 Momentum 的图片会以 GET 请求<code>https://api.momentumdash.com/feed/bulk?syncTypes=backgrounds&amp;localDate=2019-11-10</code>，<code>header</code>中必须携带<code>authorization</code>参数，其它参数均为可选。URL 中的<code>localDate</code>为必填，但没有实际意义，日期结果由<code>x-momentum-clientdate</code>控制，未设定<code>x-momentum-clientdate</code>则表示为当日日期。</p><p>获取<code>authorization</code>可在页面网络中查看，以下是 Insomnia 的请求及返回<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t24flp6qj31jb0u0k1r.jpg" alt=""></p><p>感谢@<a href="http://www.fridayhaohao.com/" target="_blank" rel="noopener">我的精神家园</a> 提供的 Python 脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"></span><br><span class="line">client_id = <span class="string">''</span>  <span class="comment"># 替换成自己的</span></span><br><span class="line">directory = <span class="string">'/friday'</span></span><br><span class="line">filename = directory + <span class="string">'/bg.jpg'</span></span><br><span class="line">bg_blur = directory + <span class="string">'/bg_blur.jpg'</span></span><br><span class="line">today = time.strftime(<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'authorization'</span>: <span class="string">'Bearer eyJ0eXA...'</span>,  <span class="comment"># 替换</span></span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'api.momentumdash.com'</span>,</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'*/*'</span>,</span><br><span class="line">    <span class="string">'X-Momentum-ClientId'</span>: client_id,</span><br><span class="line">    <span class="string">'x-momentum-clientdate'</span>: <span class="string">'2018-03-16'</span>,</span><br><span class="line">    <span class="string">'X-Momentum-Version'</span>: <span class="string">'0.100.1'</span>,</span><br><span class="line">    <span class="string">'x-momentum-settings-etag'</span>: <span class="string">'0400bf20-0000-0000-0000-5aaf255a0000'</span>,</span><br><span class="line">    <span class="string">'X-Momentum-ClientDate'</span>: today,</span><br><span class="line">    <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, li ke Gecko) Chrome/57.0.2987.133 Safari/537.36'</span>,</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="string">'cookie'</span>: <span class="string">''</span>  <span class="comment"># 替换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://api.momentumdash.com/feed/bulk?syncTypes=backgrounds&amp;localDate='</span> + today, headers=headers)</span><br><span class="line"><span class="comment"># print(r.content)</span></span><br><span class="line"><span class="comment"># print(r.text()print(r.json())</span></span><br><span class="line">image_list = r.json()[<span class="string">'backgrounds'</span>]</span><br><span class="line">image_url = <span class="string">''</span></span><br><span class="line">print(image_list)</span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> image_list:</span><br><span class="line">    <span class="keyword">if</span> image[<span class="string">'forDate'</span>] == today:</span><br><span class="line">        image_url = image[<span class="string">'filename'</span>]</span><br><span class="line">print(image_url)</span><br><span class="line"><span class="keyword">if</span> image_url:</span><br><span class="line">    urlretrieve(image_url, filename)</span><br><span class="line">img = Image.open(filename)</span><br><span class="line">new_img = img.resize((<span class="number">1536</span>, <span class="number">1023</span>), Image.ANTIALIAS)</span><br><span class="line">new_img.save(filename, quility=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker 学习笔记</title>
      <link href="/post/docker-notes/"/>
      <url>/post/docker-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8g071xly2j30xc0kf77g.jpg" alt=""></p><a id="more"></a><p>请不要使用<code>docker commit</code>命令来定制镜像，因为你可能只在容器中修改了很少的内容，但其他相关的很多内容也都随之修改了，一旦执行<code>docker commit</code>生成镜像，则该镜像中的内容将无法再修改，<code>docker commit</code>适用于入侵后保护现场等一些特殊场景，定制镜像请使用<code>Dockerfile</code>。</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><table><thead><tr><th>指令</th><th>形式</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>FROM</code></td><td><code>FROM &lt;image&gt; [AS &lt;name&gt;]</code></td><td></td><td></td></tr><tr><td></td><td><code>FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code></td><td></td><td></td></tr><tr><td></td><td><code>FROM &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</code></td><td></td><td></td></tr><tr><td><code>RUN</code></td><td><code>RUN &lt;command&gt;</code></td><td>以shell 形式运行，Linux 默认为<code>/bin/sh -c</code>，Windows 默认为<code>/S /C</code>。如果不是以<code>/bin/sh</code>运行，则使用<code>RUN [&quot;/bin/bash&quot;, &quot;-C&quot;, &quot;echo hello&quot;]</code>形式</td><td><code>RUN</code>命令在构建镜像期间会执行命令并提交结果，而<code>CMD</code>则不会在构建期间执行任何动作，除非你在构建期间指定了明确的操作（？？？如果没有指定，CMD 当然不会执行任何动作，如果指定了但却没有执行，这不是 bug 吗？这不是一句废话吗？所以二者的区别是什么？附上官方文档原文：Don’t confuse RUN with CMD. RUN actually runs a command and commits the result; CMD does not execute anything at build time, but specifies the intended command for the image.）</td></tr><tr><td></td><td><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></td><td>exec 形式。该形式会被解析为 JSON 格式。需要注意的是，exec 形式不会像 shell 形式调用 shell 命令，这意味着正常的 shell 命令不会被执行。如<code>RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>并不会将<code>$HOME</code>替换为变量。如果你想要处理 shell，则需要使用 shell 形式或者直接执行 shell，例如<code>RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></td><td></td></tr><tr><td><code>CMD</code></td><td><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></td><td>exec 形式, 推荐方式。<br>通<code>RUN</code>命令类似，该形式<code>CMD [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>不会解析<code>$HOME</code>变量，若需解析则使用 shell 形式<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></td><td>一个<code>Dockerfile</code>中只能有一个<code>CMD</code>命令，如果有多个，仅最后一个生效。</td></tr><tr><td></td><td><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code></td><td>作为ENTRYPOINT的默认参数</td><td>如果<code>CMD</code>被用于做<code>ENTRYPOINT</code>的默认参数，则<code>CMD</code>与<code>ENTRYPOINT</code>均需被设定为 JSON 格式</td></tr><tr><td></td><td><code>CMD command param1 param2</code></td><td>shell 形式</td><td>如果用户在<code>docker run</code>时指定了参数，则会覆盖<code>CMD</code>中的参数</td></tr><tr><td><code>ENTRYPOINT</code></td><td><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></td><td>exec 形式，推荐方式。可以用该形式设置不变的命令和参数，然后使用<code>CMD</code>的任一形式来设置可能变更的值</td><td>通过<code>docker run --entrypoint</code>命令覆写<code>ENTRYPOINT</code>指令</td></tr><tr><td></td><td><code>ENTRYPOINT command param1 param2</code></td><td>shell 形式</td><td><code>Dockerfile</code>中有多个<code>ENTRYPOINT</code>时，仅最后一个<code>ENTRYPOINT</code>生效</td></tr><tr><td><code>LABEL</code></td><td><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code><br><br><code>LABEL maintainer=&quot;username@example.com&quot;</code></td><td></td><td><code>LABEL</code>可以读取父级镜像中的值，如果父级与子级存在相同的 LABEL 值，则子级会覆盖父级中的值</td></tr><tr><td><code>EXPOSE</code></td><td><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code></td><td></td><td>若未指定 TCP/UDP，则默认为 TCP。<code>EXPOSE</code>并不会真正发布端口，只是一个预设的端口文档，在运行<code>dokcer run -p</code>时才会发布真正的端口，<code>-P</code>也可以发布<code>EXPOSE</code>预设的端口。<code>docker network</code>支持创建容器间通信的网络，而无需公开或发布特定端口。</td></tr><tr><td><code>ENV</code></td><td><code>ENV &lt;key&gt; &lt;value&gt;</code></td><td>该形式中，第一个字符空格后的所有内容都被视作变量值</td><td><code>ENV myName John Doe</code><br><code>ENV myDog Rex The Dog</code><br><code>ENV myCat fluffy</code><br></td></tr><tr><td></td><td><code>ENV &lt;key&gt;=&lt;value&gt; ...</code></td><td>该形式允许一次设定多个变量值。与命令行解析类似，引号和反斜线<code>\</code>可用于在值中包含空格。二者的区别在于，第一种形式会将变量名之后的整个字符内容作为值，包括空格，适用于定义单个变量；而第二种方式则以引号和<code>\</code>来区分变量的边界，适用于定义多个变量。</td><td><code>ENV myName=&quot;John Doe&quot; myDog=Rex\ The\ Dog \</code><br> <code>myCat=fluffy</code></td></tr><tr><td><code>ARG</code></td><td><code>ARG &lt;name&gt;[=&lt;default value&gt;]</code></td><td>该命令类似于函数的参数，用户可以在使用<code>docker build</code>命令构建镜像时使用<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>来传递变量值。该值的有效范围如函数一样，仅在函数内有效</td><td>在构建镜像时不推荐使用该命令传递任何用户凭证，如 GitHub key，因为任何构建过程中的变量都可以通过<code>docker history</code>命令查看到。<br><br>与<code>ARG</code>命令不同，<code>ENV</code>的值是持久化在镜像中的。<br><br>docker 中也预设了一些<code>ARG</code>变量，如<code>HTTP_PROXY</code>、<code>http_proxy</code>、<code>HTTPS_PROXY``https_proxy</code>、<code>FTP_PROXY</code>、<code>ftp_proxy</code>、<code>NO_PROXY``no_proxy</code><br><br>默认情况下，预设变量会从<code>docker history</code>中排除，以免泄露敏感信息</td></tr><tr><td><code>ADD</code></td><td><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></td><td><code>&lt;dest&gt;</code>是一个绝对路径，或者相对于<code>WORKDIR</code>的相对路径</td><td><code>&lt;src&gt;</code>路径必须是构建上下文的路径；<br><br>如果<code>&lt;src&gt;</code>是一个 URL，并且<code>&lt;dest&gt;</code>不是以<code>/</code>结尾，则文件会从 URL 下载后复制到<code>&lt;dest&gt;</code>；<br><br>如果是以<code>/</code>结尾，则从 url 推断文件名，并将文件下载到 <dest>/<filename>；<br></td></tr><tr><td></td><td><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> (this form is required for paths containing whitespace)</td><td></td><td>如果<code>&lt;src&gt;</code>是一个目录，则该目录下的所有内容都会被复制，包括文件系统的元数据<br><br>如果<code>&lt;src&gt;</code>是一个本地压缩文件，则复制后会进行解压，如果是远程压缩文件，则不会进行解压（请注意，文件是否解压并不依赖于文件后缀，而是文件格式）；<br><br>路径为目录需要用<code>/</code>标明，否则会被认作为文件；<br><br>如果目标路径不存在，则会在复制时自动创建</td></tr><tr><td><code>COPY</code></td><td><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></td><td></td><td></td></tr><tr><td></td><td><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> (this form is required for paths containing whitespace)</td><td></td><td></td></tr><tr><td><code>VOLUME</code></td><td><code>VOLUME [&quot;/data&quot;]</code></td><td></td><td>挂载空间为多个值时为 JSON 数组格式，否则为单值多行格式<br><br><a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">Share Directories via Volumes documentation</a></td></tr><tr><td><code>USER</code></td><td><code>USER &lt;user&gt;[:&lt;group&gt;]</code></td><td></td><td></td></tr><tr><td></td><td><code>USER &lt;UID&gt;[:&lt;GID&gt;]</code></td><td></td><td></td></tr><tr><td><code>WORKDIR</code></td><td><code>WORKDIR /path/to/workdir</code></td><td><code>WORKDIR</code>可在 Dockerfile 中使用多次，如果使用了相对路径，则会相对于上一个<code>WORKDIR</code>的路径。建议全部使用绝对路径。</td><td>如果该目录不存在，则会自动创建</td></tr><tr><td><code>ONBUILD</code></td><td><code>ONBUILD [INSTRUCTION]</code></td><td>该命令被用于当前镜像被用于其它镜像的基础镜像时的触发命令</td><td></td></tr><tr><td><code>STOPSIGNAL</code></td><td><code>STOPSIGNAL signal</code></td><td></td><td></td></tr><tr><td><code>HEALTHCHECK</code></td><td><code>HEALTHCHECK [OPTIONS] CMD command</code></td><td>OPTIONS的值为：<br><code>--interval=DURATION (default: 30s)</code><br><code>--timeout=DURATION (default: 30s)</code><br><code>--start-period=DURATION (default: 0s)</code><br><code>--retries=N (default: 3)</code></td><td>一个 Dockerfile 中有多个<code>HEALTHCHECK</code>指令时，仅最后一个生效</td></tr><tr><td></td><td><code>HEALTHCHECK NONE</code></td><td></td><td></td></tr><tr><td><code>SHELL</code></td><td><code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></td><td></td><td>每个 shell 指令都会覆盖所有先前的 shell 指令，并影响所有后续指令</td></tr></tbody></table><h2 id="CMD-与-ENTRYPOINT-的区别"><a href="#CMD-与-ENTRYPOINT-的区别" class="headerlink" title="CMD 与 ENTRYPOINT 的区别"></a>CMD 与 ENTRYPOINT 的区别</h2><ol><li>Dockerfile 应至少定义一个 <code>CMD</code> 或 <code>ENTRYPOINT</code> 命令</li><li><code>ENTRYPOINT</code> 应该定义于可执行容器</li><li><code>CMD</code> 应该用作定义 <code>ENTRYPOINT</code> 命令或在容器中执行特殊命令的默认参数的方法。</li><li><code>CMD</code> 在运行容器时可被参数覆盖</li></ol><p>下表展示了ENTRYPOINT / CMD 的组合</p><table><thead><tr><th></th><th>No ENTRYPOINT</th><th><code>ENTRYPOINT exec_entry p1_entry</code></th><th><code>ENTRYPOINT [“exec_entry”, “p1_entry”]</code></th></tr></thead><tbody><tr><td>No CMD</td><td>error, not allowed</td><td><code>/bin/sh -c exec_entry p1_entry</code></td><td><code>exec_entry p1_entry</code></td></tr><tr><td><code>CMD [“exec_cmd”, “p1_cmd”]</code></td><td><code>exec_cmd p1_cmd</code></td><td><code>/bin/sh -c exec_entry p1_entry</code></td><td><code>exec_entry p1_entry exec_cmd p1_cmd</code></td></tr><tr><td><code>CMD [“p1_cmd”, “p2_cmd”]</code></td><td><code>p1_cmd p2_cmd</code></td><td><code>/bin/sh -c exec_entry p1_entry</code></td><td><code>exec_entry p1_entry p1_cmd p2_cmd</code></td></tr><tr><td><code>CMD exec_cmd p1_cmd</code></td><td><code>/bin/sh -c exec_cmd p1_cmd</code></td><td><code>/bin/sh -c exec_entry p1_entry</code></td><td><code>exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd</code></td></tr></tbody></table><blockquote><p>注意：如果<code>CMD</code>是在基础镜像中定义的，则设定 <code>ENTRYPOINT</code> 重置 <code>CMD</code> 的值为空值。此时，<code>CMD</code> 必须在当前镜像中重新定义值。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a></li><li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a></li><li><a href="https://www.jianshu.com/p/f0a0f6a43907" target="_blank" rel="noopener">Dockerfile RUN，CMD，ENTRYPOINT 命令区别</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件版本号规范及命名</title>
      <link href="/post/software-version-rule/"/>
      <url>/post/software-version-rule/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8e1gpfct1j31hc0u0jtr.jpg" alt=""></p><p><code>package.json</code>中的版本号都是什么含义呢？</p><a id="more"></a><h2 id="版本号格式"><a href="#版本号格式" class="headerlink" title="版本号格式"></a>版本号格式</h2><p>我们通常使用的是<code>X.Y.Z</code>格式的版本号，它们分别表示主、次、修正版本号。</p><h2 id="版本号的演进"><a href="#版本号的演进" class="headerlink" title="版本号的演进"></a>版本号的演进</h2><table><thead><tr><th align="center">版本号</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">0.1.0</td><td align="left">开发版第一次发布</td></tr><tr><td align="center">0.1.1</td><td align="left">第一次发布修正版</td></tr><tr><td align="center">0.2.0</td><td align="left">开发版重大更新</td></tr><tr><td align="center">1.0.0</td><td align="left">稳定版第一次发布</td></tr><tr><td align="center">1.0.1</td><td align="left">第一次稳定版修正</td></tr><tr><td align="center">1.0.2</td><td align="left">第二次稳定版修正</td></tr><tr><td align="center">1.1.0</td><td align="left">稳定版新功能推出</td></tr><tr><td align="center">2.0.0</td><td align="left">稳定版重大更新</td></tr></tbody></table><h2 id="版本符号说明"><a href="#版本符号说明" class="headerlink" title="版本符号说明"></a>版本符号说明</h2><table><thead><tr><th>版本号符号</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>精确匹配</td><td><code>1.2.3</code></td><td><code>1.2.3</code></td></tr><tr><td>星号</td><td><code>1.0.*</code></td><td><code>&gt;=1.0</code>且<code>&lt;1.1</code></td></tr><tr><td>连字符</td><td><code>1.0-2.0</code></td><td><code>&gt;=1.0.0</code>且<code>&lt;2.1</code></td></tr><tr><td>波浪线</td><td><code>~1.2</code></td><td><code>&gt;=1.2</code>且<code>&lt;2.0</code></td></tr><tr><td>脱字符</td><td><code>^1.2.3</code><br><code>^0.3</code></td><td><code>&gt;=1.2.3</code>且<code>&lt;2.0</code><br><code>&gt;=0.3.0</code>且<code>&lt;0.4.0</code></td></tr><tr><td>版本标识</td><td><code>@stable</code><br><code>@dev</code></td><td><code>dev &gt; alpha &gt; beta &gt; RC &gt; stable</code><br>预设抓取stable，但可用@指定</td></tr></tbody></table><h2 id="Alpha、Beta、RC、GA-版本的区别"><a href="#Alpha、Beta、RC、GA-版本的区别" class="headerlink" title="Alpha、Beta、RC、GA 版本的区别"></a>Alpha、Beta、RC、GA 版本的区别</h2><p>Alpha：是内部测试版，一般不向外部发布，会有很多Bug。一般只有测试人员使用。</p><p>Beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</p><p>RC：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC 版不会再加入新的功能了，主要着重于除错。</p><p>GA:General Availability，正式发布的版本，在国外都是用 GA 来说明release版本的。</p><p>RTM：(Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过 RTM 版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。</p><p>OEM：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。</p><p>RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的。</p><p>EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。</p><p>RTL：Retail(零售版)是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。</p><p>α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本 2.0.0</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群晖NAS 私有云搭建记</title>
      <link href="/post/nas/"/>
      <url>/post/nas/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8ckrzioopj31400u0x6p.jpg" alt=""></p><p>再也不用担心网盘倒闭限速了😎</p><a id="more"></a><p>之前家里的路由器虽然有文件共享及管理功能，但挂载磁盘是 NTFS 的，Mac 很难管理这种格式，创建修改文件夹什么的也非常不方便，在 10.24 晚终于感觉难以忍受，看到京东群晖 DS218+ 正好是最低价，纠结半天后还是剁手了。京东快递很快，晚上下单，第二天早上就收到货了。周五晚上下班后就迫不及待回家开始折腾。</p><p>DS218+ 有两个盘位，最大支持 20TB，内置 2G 内存，但可以扩展到 6GB，支持 4K 解码。但硬盘是需要单独购买的，我之前正好在美亚海淘了一个 10TB 的西数硬盘，查询了一些资料后，发现可以将该硬盘盒拆掉取出硬盘，这正是我想要的。于是我要把拆解后的硬盘插入群晖。</p><p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cksf1t0hj31400u0e82.jpg" alt=""></p><p>在 B 站看了个拆解教程后，大概了解一点内部结构，于是照猫画虎，用银行卡拆了一会儿就打开了。拆完后发现有一个卡扣还是折了😅</p><p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cktlhsomj31400u0x6p.jpg" alt=""></p><p>于是插入群晖准备开始体验一下，安装系统提示我要格式化？但是硬盘已经存储了 2T 的资源，很多都是 4K 的，我手里还有块 1T 的硬盘，但很多资源也得丢掉了，一部剧 500+G，实在是放不下，拷贝还要花很长时间。即便丢弃了很多资源，最后拷贝完也到了凌晨 1 点半，最后终于在 2 点钟成功完成安装。</p><p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cl8q958kj30u01404qq.jpg" alt=""></p><p>群晖的功能还是非常丰富的，应用中心包括 docker、PHP、Python、Tomcat、Apache、Java、MariaDB、WordPress、下载工具、视频播放器、音频播放器、照片管理、文档编辑……不仅可以作为一台小型服务器，还可以随时随地查看硬盘储存的资料，也可以将手机或者电脑的资料随时随地保存到 NAS 中。由于之前的路由器已经做了 DDNS，所以 NAS 我只需要在原来的域名上加上对应的端口号就可以在外网访问了，非常的方便。</p><p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8clehlcuyj31400u0atx.jpg" alt=""></p><p>由于我只有一块硬盘，所以如果硬盘挂了的话，这块硬盘上的所有数据就都丢失了，但群晖可以用多块硬盘组成 RAID，通过冗余的方式来保障数据的安全性，考虑到现在的硬盘空间已经足够，还是以后再说另一块硬盘的事吧。</p><p>对于家里的小米电视来说，之前从路由器读取 4K 视频总是会不时卡顿，现在完全就像本地读取一样，非常流畅。</p><p>btkitty 也挂了，那些宝贵的资源可能再也找不回来了，心痛。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《代码大全》</title>
      <link href="/post/code-completed/"/>
      <url>/post/code-completed/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87bbp4fgij30uk0fa0vg.jpg" alt=""></p><blockquote><p>大道至简，少即是多。</p></blockquote><a id="more"></a><h2 id="第1章-欢迎进入软件构建的世界"><a href="#第1章-欢迎进入软件构建的世界" class="headerlink" title="第1章 欢迎进入软件构建的世界"></a>第1章 欢迎进入软件构建的世界</h2><p>（略）</p><h2 id="第2章-用隐喻来更充分地理解软件开发"><a href="#第2章-用隐喻来更充分地理解软件开发" class="headerlink" title="第2章 用隐喻来更充分地理解软件开发"></a>第2章 用隐喻来更充分地理解软件开发</h2><p>精心计划，并不意味着事无巨细的计划或者过的计划。你可以把房屋的结构性的支撑规划清楚，而在日后再决定是用木地板还是地毯，地面漆成什么颜色，屋顶使用什么材料，等等。</p><p><font color='red'><strong>项目的成败很大程度上在构建活动的开始之前就已经注定了。</strong></font></p><h2 id="第3章-三思而后行：前期准备"><a href="#第3章-三思而后行：前期准备" class="headerlink" title="第3章 三思而后行：前期准备"></a>第3章 三思而后行：前期准备</h2><blockquote><p> 本章内容针对架构师。</p></blockquote><p>错误越早引入软件当中，问题就会越复杂，修正这个错误的代价也就越高，因为错误会牵涉到系统的更多部分。</p><p>程序员是软件食物链的最后一环，架构师吃掉需求，设计师吃掉架构，而程序员则消化设计。</p><p>在软件开发中，如果需求被污染了，那么它就会污染架构，而架构又会污染构建。这样就会导致程序员脾气暴躁，营养失调；开发出的软件具有放射性污染，而且周身都是缺陷。</p><p>在一开始就把事情做好是最合算的。进行非必要的改动的代价是高昂的。<strong>在软件开发过程的上游引入的缺陷通常比那些在下游引入的缺陷具有更广泛的影响力。</strong>这也使得早期的缺陷代价更加高昂。</p><p>如果你不能向一个六岁小孩解释某件事，那么你自己就没有真正理解它。——爱因斯坦</p><p>架构的典型组成部分：</p><ul><li>程序组织</li><li>主要的类</li><li>数据设计</li><li>业务规则</li><li>用户界面设计</li><li>资源管理</li><li>安全性</li><li>性能</li><li>可伸缩性</li><li>互用性</li><li>国际化/本地化</li><li>输入/输出</li><li>错误处理</li><li>容错性</li><li>架构的可行性</li><li>过度工程</li><li>关于“买”还是“造”的决策</li><li>关于复用的决策</li><li>变更策略</li><li>架构的总体质量<ul><li>架构的目标应该清楚的表述</li><li>优秀的软件架构很大程度上是与机器和编程语言无关的</li><li>架构应该踩在对系统“欠描述”和“过度描述”之间的分界线上</li><li>架构应该明确地指出有风险的区域</li><li>架构应该包含多个视角</li><li>最后，你不应该担忧架构的任何部分。<strong>架构不应该包含任何仅仅为了取悦老板的东西</strong>。它不应该包含任何对你而言很难理解的东西。你就是那个实现架构的人，如果你自己都弄不懂，那又怎么实现呢？</li></ul></li></ul><p><em>在软件中，链条的强度不是取决于最薄弱的一环，而是等于所有薄弱环节的乘积。</em></p><p><em>构建活动的准备工作的根本目标在于降低风险。要确认你的准备活动是在降低风险，而非增加风险。</em></p><p>如果你想开发高质量的软件，软件开发过程中必须由始至终关注质量。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大。</p><blockquote><p>优秀的架构不是用更多的东西，而是用更少、更简单的东西来支撑系统。</p></blockquote><h2 id="第4章-关键的“构建”决策"><a href="#第4章-关键的“构建”决策" class="headerlink" title="第4章 关键的“构建”决策"></a>第4章 关键的“构建”决策</h2><blockquote><p>本章内容针对程序员或技术带头人。</p></blockquote><p>本章概述：</p><ul><li>选择编程语言</li><li>编程约定<ul><li>成功编程的关键就在于避免随意的变化，这样你的大脑就可以专注于那些真正需要的变化。</li></ul></li><li>你在技术浪潮中的位置<ul><li>新兴编程语言会让你花很多时间来搞明白它是如何运作的，以及解决很多语言缺陷；成熟的语言则可以用大部分时间稳定持续地编写新功能。</li></ul></li><li>选择主要的构建实践方法</li></ul><p>主要的构建实践：</p><ul><li>编码<ul><li>你有没有确定有多少设计工作需要预先进行，多少工作通过编码完成？</li><li>有没有规定诸如名称、注释、代码格式等“编码约定”？</li><li>有没有规定特定的由软件架构确定的编码实践？如怎样处理错误条件、如何处理安全性事项、对于类接口有哪些约定、可重用的代码遵循哪些标准、在编码时考虑多少性能因素等？</li><li>有没有找到自己在技术浪潮中的位置，并相应调整自己的措施？如果必要，你是否知道如何“深入一种语言去编程”，而不受限于语言？</li></ul></li><li>团队工作<ul><li>有没有定义一套集成工具？即，你有没有定义一套工作流，规定程序员在把代码 check in 到 master 之前，必须完成这些步骤？</li><li>程序员是结对编程还是独自编程？或者是这二者的某种组合？</li></ul></li><li>质量保证<ul><li>程序员在编写代码之前，是否先为之编写测试用例？</li><li>程序员会为自己的代码写单元测试吗？</li><li>程序员在 check in 代码前，会用调试器单步跟踪整个代码流程吗？</li><li>程序员在 check in 代码前，是否进行集成测试？</li><li>程序员会 review 或检查别人的代码吗？</li></ul></li><li>工具<ul><li>你是否选用了某种版本控制工具？</li><li>你是否选定了一种语言，以及语言的版本或编译器版本？</li><li>你是否选定了某个编程框架，或者明确地决定不使用编程框架？</li><li>你是否决定允许使用非标准的语言特性？</li><li>你是否选定并拥有了其他将用到的工具——编辑器、重构工具、调试器、测试框架、语法检查等。</li></ul></li></ul><p>不同的编程语言只是不同的表达方式。</p><h2 id="第5章-软件构架中的设计"><a href="#第5章-软件构架中的设计" class="headerlink" title="第5章 软件构架中的设计"></a>第5章 软件构架中的设计</h2><p><strong>软件的首要技术使命：管理复杂度。</strong></p><h3 id="理想的设计特征"><a href="#理想的设计特征" class="headerlink" title="理想的设计特征"></a>理想的设计特征</h3><ul><li>最小的复杂度</li><li>易于维护</li><li>松散耦合</li><li>可扩展性（增强系统的功能而无需破坏其他底层结构）</li><li>可重用性</li><li>高扇入（大量的类使用该类）</li><li>低扇出（一个类中少量使用其他类）</li><li>可移植性</li><li>精简性</li><li>层次性</li><li>标准技术</li></ul><p>举例来说，在图 5-3 中，你把一个系统划分成 6 个子系统。在没有定义任何规则时，热力学第二定律就会发生作用，整个系统的熵将会增加。熵之所以增加的一种原因是，如果不对子系统间的通信加以任何限制，那么它们之间的通信就会肆意地发生，如图 5-4 所示。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7fahb13zij30ee0gcq72.jpg" alt=""></p><p>你可以把子系统间的连接当做水管。当你想去掉某个子系统时，势必会有不少水管连在上面。你需要断开再重新连接的水管数量越多，弄出来的水就会越多。你肯定想把系统的架构设计成这样：如果想把某个子系统取走重用时，不用重新连接太多水管，重新连接起来也不会太难。</p><p>有先见之明的话，所有这些问题就不会花太多额外的功夫。只有当“确需了解”——最好还有合理的理由——时，才应该允许子系统间的通信。如果你还拿不准该如何设计的话，那么就应该先对子系统之间的通信加以限制，等日后需要时再放开，这要比先不限制，等子系统间已经有了上百个调用时再加以限制要容易得多。图 5-5 展示了施加少量通信规则后可以把图 5-4 中的系统变成的样子：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7faopuc5gj30g6080gne.jpg" alt=""></p><h3 id="使用对象进行设计的步骤"><a href="#使用对象进行设计的步骤" class="headerlink" title="使用对象进行设计的步骤"></a>使用对象进行设计的步骤</h3><ol><li>辨识对象及其属性（方法和数据）</li><li>确定可以对各个对象进行的操作</li><li>确定各个对象能对其他对象进行的操作</li><li>确定对象的哪些部分对其他对象可见——哪些部分可以是公用（<code>public</code>）的，哪些部分应该是私用（<code>private</code>）的</li><li>定义每个对象的公开接口（<code>public interface</code>）</li></ol><h3 id="类的冰山定律"><a href="#类的冰山定律" class="headerlink" title="类的冰山定律"></a>类的冰山定律</h3><p>在设计一个类的时候，一项关键性的决策就是确定类的哪些特性应该对外可见，而那些特性应该隐藏起来。一个类可能有 25 个子程序，但只暴露了其中的 5 个，其余 20 个仅限于在类的内部使用。一个类在内部可能用到了多种数据类型，却不对外暴露有关他们的任何信息。在类的设计中，这一方面也称为“可见性（visibility）”，因为它要确定的就是类的哪些特性对外界是“可见的”或能“暴露”给外界。</p><p>类的接口应该尽可能少地暴露其内部工作机制。类很像冰山：八分之七都是位于水面之下，而你只能看到水面上的八分之一。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7fastbxnmj308w066t8w.jpg" alt=""></p><h3 id="如何应对变化"><a href="#如何应对变化" class="headerlink" title="如何应对变化"></a>如何应对变化</h3><p>一个优秀的设计师应该有对变化的预期能力，好的程序设计所面临的最重要挑战之一就是适应变化。目标应该是把不稳定的区域隔离出来，从而把变化所带来的影响限制在一个子程序、类或者包的内部。可采取以下几点措施：</p><ul><li>找出看起来容易变化的项目</li><li>把容易变化的项目分离出来</li><li>把看起来容易变化的项目隔离开来</li></ul><h4 id="合理使用设计模式"><a href="#合理使用设计模式" class="headerlink" title="合理使用设计模式"></a>合理使用设计模式</h4><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>抽象工厂</td><td>通过制定对象组的种类而非单个对象的类型来支持创建一组相关的对象</td></tr><tr><td>适配器</td><td>把一个类的接口转变成另一个接口</td></tr><tr><td>桥接</td><td>把接口和现实分离开来，使他们可以独立的变化</td></tr><tr><td>组合</td><td>创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无须考虑所有的细节对象</td></tr><tr><td>装饰器</td><td>给一个对象动态地添加职责，而无须为了每一种可能的职责配置情况去创建特定的子类（派生类）</td></tr><tr><td>外观</td><td>为没有提供一致接口的代码提供一个一致的接口</td></tr><tr><td>工厂方法</td><td>做特定基类的派生类的实例化时，除了在工厂方法内部之外均无须了解各派生对象的具体类型</td></tr><tr><td>迭代器</td><td>提供一个服务对象来顺序地访问一组元素中的各个元素</td></tr><tr><td>观察者</td><td>使一组相关对象相互同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象</td></tr><tr><td>单例</td><td>为有且仅有一个实例的类提供一种全局访问功能</td></tr><tr><td>策略</td><td>定义一组算法或者行为，使得他们可以动态地相互替换</td></tr><tr><td>模板方法</td><td>定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类）</td></tr></tbody></table><h4 id="合作的方式"><a href="#合作的方式" class="headerlink" title="合作的方式"></a>合作的方式</h4><p>在设计过程中，三个臭皮匠赛过诸葛亮，而不论组织形式的正式与否。合作可以以下面任意一种方式展开。</p><ul><li>你随便走到一名同事的办公桌前，向他征求一些意见</li><li>你和同事坐在会议室里，在白板上画出可选的设计方案</li><li>你和同事在电脑前用编程语言做出详细的设计，换言之，你们可以采用结对编程（第 21 章“协同构建”中对结对编程有描述）</li><li>你约一名或多名同事来开会，和他们过一遍你的设计和想法</li><li>你按照第 21 章中给出的结构来安排一次正式检查</li><li>你身边没有人能检查你的工作，因此当你做完一些初始工作后，把它们全放进抽屉，一周后再来回顾。这时你会把该忘的都忘了，正好给自己做一次不错的检查</li><li>你向公司外的人求助：如论坛或交流群</li></ul><h2 id="第6章-可以工作的类"><a href="#第6章-可以工作的类" class="headerlink" title="第6章 可以工作的类"></a>第6章 可以工作的类</h2><p>创建高质量的类，第一步，可能也是最重要的一步，就是<font color='red'><strong>创建一个好的接口</strong></font>。这也包括了创建一个可以通过接口来展现的合理的抽象，并确保细节仍被隐藏在抽象背后。<br>类接口的抽象能力非常有价值，因为<em>接口中的每个子程序都在朝着这个一致的目标而工作</em>。</p><p>创建接口的建议</p><ul><li>类的接口应该展现一致的抽象层次</li><li>一定要理解类所实现的抽象是什么</li><li>提供成对的服务（如，开和关，增和减）</li><li>把不相关的信息转移到其他类中</li><li>尽可能让接口编程，而不是语义编程</li><li>谨防在修改时破坏接口的抽象</li><li>不要添加与接口抽象不一致的公用成员</li><li>同时考虑抽象性和内聚性</li></ul><h3 id="良好的封装"><a href="#良好的封装" class="headerlink" title="良好的封装"></a><font color='red'>良好的封装</font></h3><ul><li><font color='red'>尽可能地限制类和成员的可访问性</font></li><li><font color='red'>不要公开暴露成员数据（通过<code>set()</code>和<code>get()</code>获取）</font></li><li><font color='red'>避免把私用的实现细节放入类的接口中</font></li><li><font color='red'>不要对类的使用者做出任何假设（如，请初始化x, y为0 1，否则程序会崩溃）</font></li><li><font color='red'>不要因为一个子程序里仅使用公用子程序，就把它归入公开接口</font></li><li><font color='red'>让阅读代码比编写代码更方便</font></li><li><font color='red'>要格外警惕语义上破坏封装性（语法上只需要将方法设为<code>private</code>，而语义上则需要注意不要再次调用已经初始化中完成的方法）</font></li><li><font color='red'>留意过于紧密的耦合关系（良好的类应该是黑盒子，而不是玻璃盒子）</font></li></ul><p><strong>警惕有超过7个数据成员的类</strong>。研究表明，人们在做其他事情时能记住的离散项目的个数是<code>7±2</code></p><p>使用继承时，需要考虑：</p><ol><li>该方法是否对子类可见，是否可被重写</li><li>该类属性是否对子类可见及重写</li></ol><p>关于类的一些说明</p><ul><li>要么使用继承并进行详细说明，要么就不要用它</li><li>遵循里氏替换原则：派生类必须能通过基类的接口而被使用，且使用者无需了解两者间的差异</li><li>把共用的接口，数据及操作放到继承树中尽可能高的位置</li><li>只有一个实例的类是值得怀疑的</li><li>只有一个派生类的基类也值得怀疑。不要创建任何并非绝对必要的继承结构</li><li>派生后覆盖了某个子程序，但在其中没有做任何操作</li><li>避免让继承体系过深。继承不要超过3层，基类的派生总数不要超过7±2。过深的继承会显著导致错误率的增长。过深的继承层次增加了复杂度，而这恰恰与继承所应解决的问题相反，请确保你在用继承来避免代码重复并使复杂度最小</li><li>尽量使用多态，避免大量的类型检查</li><li>让所有数据都是<code>private</code></li></ul><p>使用类时需要注意的</p><ul><li>如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象</li><li>如果多个类共享行为而非数据，应该让它们从共同的基类继承而来，并在基类里定义共用的子程序</li><li>如果多个类既共享数据也共享行为，应该让它们从一个共同的基类而来，并在基类里定义共用的数据和子程序</li><li><font color='red'>让类中子程序的数量尽可能少。类中子程序越多，出错的概率也越高</font></li><li>禁止隐式地产生你不需要的成员函数和运算符。如构造方法产生的内容</li><li><font color='red'>减少类所调用的不同子程序的数量。同样的，数量越多，越容易出错</font></li><li><font color='red'>对其他类的子程序的间接调用要尽可能的少</font>。即A对象可以任意调用自己的所有子程序，如果A对象创建了一个B对象，也可以 调用任意B对象中的公用子程序，但它应该避免再调用B对象中其他对象的子程序（尽量减少依赖关系）</li><li>尽量减少类与类之间相互合作的范围</li></ul><p>封装是一个比抽象更强的概念。抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度，而封装则强制阻止你看到细节——即便你想这么做。</p><p>成为高效程序员的一个关键就在于，当你开发程序任一部分代码时，都能安全地忽视程序中尽可能多的其余部分。而类就是实现这一目标的首要工具。</p><p>为未来要做的工作着手进行准备的最好方法，并不是去创建几层额外的、“没准以后哪天就能用得上的”基类，而是让眼下的工作成果尽可能地清晰、简单、直截了当。也就是说，不要创建任何非绝对必要的继承结构。</p><p>创建类的原因</p><ul><li>为现实世界中的对象建模</li><li>为抽象的对象建模</li><li><font color='red'>降低复杂度</font></li><li>隔离复杂度。如果在类中出现了错误，只要它还在类的局部而未扩散到其他代码，只需要修改一个地方即可</li><li>隐藏实现细节</li><li>限制变动的影响范围。把经常变动的部分隔离起来，这样就能把变动带来的影响限制在一个或几个类的范围内</li><li>隐藏全局数据。与直接使用全局数据相比，通过访问类的方法来操作全局数据更有好处</li><li>让参数传递更顺畅</li><li>建立中心控制点</li><li>让代码更易于重用</li><li>为程序族做计划</li><li>把相关操作包装到一起</li><li>实现某种特定的重构</li></ul><p>应该避免的类</p><ul><li>避免创建万能类</li><li>消除无关紧要的类。如果一个类只包含数据但不包含行为的话，就应该认真考虑一下它是一个类吗？同时应该考虑把这个类降级，让它的数据成员成为一个或多个其他类的属性</li><li>避免用动词命名的类。只有行为而没有数据的类往往不是真正的类</li></ul><p>本章要点总结：</p><ul><li>类的接口应提供一致的抽象。很多问题都是由于违背该原则而引起的。</li><li>类的接口应隐藏一些信息——如某个系统接口、某项设计决策、或一些实现细节。</li><li>包含往往比继承更为可取——除非你要对 “是一个/is a” 的关系建模</li><li><font color='red'>继承是一种有用的工具，但它却会增加复杂度，这有违于软件的首要技术使命——管理复杂度</font></li><li>类是管理复杂度的首选工具。要在设计类时给予足够的关注，才能实现这一目标。</li></ul><h3 id="本章知识点复习"><a href="#本章知识点复习" class="headerlink" title="本章知识点复习"></a>本章知识点复习</h3><p>抽象数据类型</p><ul><li>你是否把程序中的类都看作是抽象数据类型了？是否从这个角度评估它们的接口了？</li></ul><p>抽象</p><ul><li>类是否有一个中心目的？</li><li>类的命名是否恰当？其名字是否表达了其中心目的？</li><li>类的接口是否展现了一致的抽象？</li><li>类的接口是否能让人清楚明白地知道该如何使用它？</li><li>类的接口是否足够抽象，使你能不必顾虑它是如何实现其服务的？你能把类看做黑盒吗？</li><li>类提供的服务是否足够完整，能让其他类无须修改其内部数据</li><li>是否已从类中去除无关信息？</li><li>是否考虑过把类进一步分解为组件类？是否已尽可能将其分解？</li><li>在修改类时是否维持了其接口的完整性？</li></ul><p>封装</p><ul><li>是否把类的成员的可访问性降到最小？</li><li>是否避免暴露类中的数据成员？</li><li>在编程语言所许可的范围内，类是否已尽可能地对其他的类隐藏了自己的实现细节？</li><li>类是否避免对其他使用者，包括其派生类会如何使用它做了假设？</li><li>类是否不依赖于其他类？它是松散耦合的吗？</li></ul><p>继承</p><ul><li>继承是否只用来建立“是一个/is a”的关系？也就是说，派生类是否遵循 LSP（里氏替换原则）？</li><li>类的文档中是否记述了其继承策略？</li><li>派生类是否避免了“覆盖”不可覆盖的方法？</li><li>是否把公用的接口、数据和行为都放到尽可能高的继承层次中了？</li><li>继承层次是否很浅？</li><li>基类中所有的数据成员是否都被定义为<code>private</code>而非<code>protected</code>的了？</li></ul><p>跟实现相关的其他问题</p><ul><li>类中是否只有大约 7 个或更少的数据成员？</li><li>是否把类直接或间接调用其他类的子程序的数量减到最少了？</li><li>类是否只在绝对必要时才与其他的类相互协作？</li><li>是否在构造函数中初始化了所有的数据成员？</li><li>除非拥有经过测量的、创建浅层副本的理由，类是否都被设计为当做深层副本使用？</li></ul><p>与语言相关的问题</p><ul><li>你是否研究过所用编程语言里和类相关的各种特有问题？</li></ul><h2 id="第7章-高质量的子程序"><a href="#第7章-高质量的子程序" class="headerlink" title="第7章 高质量的子程序"></a>第7章 高质量的子程序</h2><h3 id="子程序应该有"><a href="#子程序应该有" class="headerlink" title="子程序应该有"></a>子程序应该有</h3><ol><li>望文知义的名字</li><li>详细的说明注释</li><li>良好的代码布局</li><li>单一而明确的目的</li><li>合理的参数个数（7个以内）</li><li>防范式编程</li></ol><p>为什么要创建子程序？</p><ol><li>降低复杂度</li><li>避免代码重复。如果在两段子程序内编写相似的代码，就意味着代码分解有问题，此时应该把两段子程序中相同部分放入一个基类，再把不同部分放入派生类中。或者将相同部分封装为一个方法</li><li>支持子类化</li><li>隐藏顺序</li><li>隐藏指针操作</li><li>提高可移植性</li><li>简化复杂的布尔判断</li><li>改善性能。一处优化，处处调用受益</li><li>确保所有的子程序都最小</li></ol><p><font color='red'>编写有效的子程序时，一个最大的心里障碍是不情愿为了一个简单的目的而编写一个简单的子程序，写一个只有两三行代码的子程序可能看起来有些大材小用，但一个小的子程序既能够提高代码的可读性，又能在未来在『简单的操作常常会变成复杂操作』时更好维护。</font></p><p>功能的内聚性是最强也是最好的一种内聚性，也就是让一个子程序仅执行一项操作。</p><p>不良的内聚性包括：</p><ol><li>过程上的内聚性。即根据业务流程来书写的子程序</li><li>逻辑上的内聚性。即若干操作被放在同一个子程序中，通过传入不同的控制标志来选择执行其中的一项操作，这样的子程序可以优化为一个子程序代码仅由一系列 if 或 else 以及调用其他子程序的语句组成，那么这样一个逻辑上的内聚性的子程序通常也是可以的。这种情况下，子程序的唯一功能就是发布命令，其自身并不做任何处理，这种子程序被称为事件处理器</li><li>巧合的内聚性。指子程序各操作间没有任何可以看到的关联</li></ol><p><font color='red'>如果一个子程序具有不良的内聚性，那最好还是花功夫重新编写，使其具有更好的内聚性，而不是再去花精力精确地诊断问题所在了。</font></p><p>与其限制子程序的长度，不如让以下因素——内聚性，嵌套的层次，变量的数量，决策点的数量，解释子程序的注释及其他一些和复杂度相关的考虑——来决定子程序的长度。但子程序的长度尽量控制在200行以内，</p><p>子程序参数应该按照“输入-修改-输出”的顺序排列参数。即先列出仅作为输入用途的参数，然后是既作为输入又作为输出用途的参数，最后才是仅作为输出用途的参数。</p><p><font color='red'>如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致，以便于记忆。反例：php中的 <code>array_map()</code> 和 <code>array_walk()</code></font></p><p><font color='red'>把子程序的参数个数限制在7个以内。</font></p><p>函数是指有返回值的子程序，过程是指没有返回值的子程序</p><p>确保函数无意外的返回值。可以在函数开头设置默认值来避免这一风险。</p><p>不要返回指向局部数据的指针或引用。</p><blockquote><p>好的子程序注释应该只用于说明参数，而非业务逻辑。如果需要在注释中说明了你做了什么，要么是你写的太过于复杂，要么产品经理该炒掉。</p></blockquote><h3 id="子程序命名"><a href="#子程序命名" class="headerlink" title="子程序命名"></a>子程序命名</h3><p>好的子程序名能清晰地描述子程序所做的一切。这里是有效的给子程序命名的一些指导原则：</p><ul><li>描述子程序所做的所有事情</li><li>避免使用无意义的、模糊或表述不清的动词<ul><li>错误的命名：<code>HandleCalculation()</code>, <code>PerformServices()</code>, <code>OutputUser()</code>, <code>ProcessInput()</code>, <code>DelWithOutput()</code></li><li>正确的命名：<code>HandleOutput()</code> ===&gt; <code>FormatAndPrintOutPut()</code></li></ul></li><li>不要仅通过数字来形成不同的子程序名字</li><li>根据需要确定子程序名字长度<ul><li>研究表明，变量名的最佳长度是 9~15 个字符。子程序通常比变量更为复杂，因此，好的子程序名字通常也会更长一些。另一方面，子程序名字通常是跟在对象名字之后，这实际上为其免费提供了一部分名字。总的来说，给子程序命名的重点是尽可能含义清晰，也就是说，子程序名的长短要视该名字是否清晰易懂而定。</li></ul></li><li>给函数命名时要对返回值有所描述</li><li>给过程起名时使用语气强烈的动词加宾语的形式</li><li>准确使用对仗词<ul><li>add/remove</li><li>begin/end</li><li>create/destroy</li><li>first/last</li><li>get/put</li><li>get/set</li><li>increment/decrement</li><li>insert/delete</li><li>lock/unlock</li><li>mix/max</li><li>next/previous</li><li>old/new</li><li>open/close</li><li>show/hide</li><li>source/target</li><li>start/stop</li><li>up/down</li></ul></li><li>为常用操作确立命名规则</li></ul><h2 id="第8章-防范式编程"><a href="#第8章-防范式编程" class="headerlink" title="第8章 防范式编程"></a>第8章 防范式编程</h2><p>在防御式驾驶中要建立这样一种思维，那就是你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。防御式编程的主要思想是：子程序应该不因传入错误数据而被破坏，哪怕是由于其他子程序产生的错误数据。</p><p>如何做到防范式编程？</p><ul><li>检查所有来源于外部的数据值</li><li>检查内部程序的传入参数</li><li>决定如何处理错误的输入数据</li></ul><h2 id="第9章-伪代码编程过程"><a href="#第9章-伪代码编程过程" class="headerlink" title="第9章 伪代码编程过程"></a>第9章 伪代码编程过程</h2><p>伪代码能让你从更宏观的层次了解你即将编写的项目，划定你的开发计划，避免在开发途中逐渐偏离主航道。同时，伪代码也能较为清晰的看出设计方案的缺陷，让错误及早发现和纠正。</p><p>请在确信代码是正确的时候执行，避免先东拼西凑，然后通过运行来查看代码是否正常的怪圈，这种方式总是让你花费更多的时间。</p><h2 id="第10章-使用变量的一般事项"><a href="#第10章-使用变量的一般事项" class="headerlink" title="第10章 使用变量的一般事项"></a>第10章 使用变量的一般事项</h2><ul><li>在靠近第一次使用的位置声明和初始化变量</li><li>特别注意计数器和累加器<code>i、j、k、sum</code>和<code>total</code>等变量常用做计数器或累加器，在下一次使用这些变量前忘记重置其值也是一种常见错误。</li><li>在类的构造函数中初始化该类的数据成员</li><li>检查是否需要重新初始化，比如<code>foreach</code>循环中的值</li><li>检查输入参数的合法性</li><li>尽可能将变量的引用集中起来，以提高程序的可读性</li><li>开始时采用最严格的可见性，然后根据需要扩展变量的作用域。把一个<code>protected</code>数据转换为<code>private</code>难度比反向要大，因此应该选择变量所能具有的最小的作用域。</li><li><strong>应该把每个变量定义成只对需要看到它的、最小范围的代码段可见</strong>。如果能把变量的作用于限定到一个单独的循环或者子程序，那最好不过了。如果你无法把作用域限定在一个子程序里，那就把可见性限定到某个类内部的子程序。如果无法你把变量的作用域限定在最该变量承担的最主要的责任的那个类里面，那么就创建一些访问器子程序来让其他类共享该变量的数据。</li><li>每个变量只用于单一用途，且变量含义明确</li></ul><p>减小作用域的一般原则</p><ul><li>在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量</li><li>直到变量即将被使用时再为其赋值</li><li>把相关语句放到一起</li><li>把相关语句组提取成单独的子程序</li></ul><h2 id="第11章-变量名的力量"><a href="#第11章-变量名的力量" class="headerlink" title="第11章 变量名的力量"></a>第11章 变量名的力量</h2><p>为变量命名时最重要的考虑事项是：该名字要完全、准确地描述出该变量所代表的事物。通常，对变量的描述就是最佳的变量名，这种名字很容易阅读，而且没有歧义。</p><p><strong>变量名长度在12个左右为宜。</strong></p><p>取变量名时，应该以问题为导向，如一条员工的记录可以称作<code>inputRec</code>或<code>employeeData</code>，前者反映的是输入、记录这些计算概念的计算机术语，后者则直指问题领域，与计算机世界无关。当表示一个打印机状态的位域时，<code>bitFlag</code> 要比 <code>printerReady</code>更具有计算机特征。</p><h3 id="变量名中的计算值限定词"><a href="#变量名中的计算值限定词" class="headerlink" title="变量名中的计算值限定词"></a>变量名中的计算值限定词</h3><p>很多程序都有表示计算结果的变量：总额、平均值、最大值等等。如果你要用类似于 Total、Sum、Average、Max、Min、Record、String、Pointer 这样的限定词来修改某个名字，那么请记住把限定词加到名字的最后。</p><p>这种方法有狠毒偶有点。首先，变量名中最终的那部分，即为这一变量赋予主要含义的部分应当位于最前面，这样，这一部分就可以显得最为突出，炳辉被首先阅读到。其次，采纳了这一规则，你将避免由于同时在程序中使用 totalRevenue 和 revenueTotal 而产生的歧义。这些名字在语义上是等价的，上述规则可以避免将他们当做不同的东西使用。还有，类似 revenueTotal、expenseTotal、revenueAverage、expenseAverage 这组名字的变量具有非常优雅的对称性。而从 totalRevenue、expenseTotal、revenueAverage、averageExpense 这组名字中则看不出什么规律来。总之，一致性可以提高可读性，简化维护工作。</p><p>把计算的量放在名字最后的这条规则也有例外，那就是 Num 限定词的位置已经是约定俗成的。Num 放在变量名的开始位置代表一个总数：numCustomers 表示的是员工的总数。Num 放在变量名的结束位置代表一个下标：customerNum 表示的是当前员工的序号。通过 numCustomers 最后代表复数的 s 也能看出这两种应用之间的区别。然而，由于这样使用的 Num 常常会带来麻烦，因此可能最好的办法是避开这些问题，用 Count 或 Total 来代表员工的总数，用 Index 来指代某个特定员工。这样，customerCount 就代表员工的总数，customerIndex 代表某个特定的员工。</p><h3 id="变量中常用的对仗词"><a href="#变量中常用的对仗词" class="headerlink" title="变量中常用的对仗词"></a>变量中常用的对仗词</h3><ul><li>begin/end</li><li>first/last</li><li>locked/unlocked</li><li>min/max</li><li>next/previous</li><li>old/new</li><li>opened/closed</li><li>visible/invisible</li><li>source/target</li><li>source/destination</li><li>up/down</li></ul><h2 id="第12章-基本数据类型"><a href="#第12章-基本数据类型" class="headerlink" title="第12章 基本数据类型"></a>第12章 基本数据类型</h2><p><strong>避免使用“神秘数值”</strong>。神秘数值会导致无法望文知意，相同数值在不同位置含义不同等问题，而使用具名常量来替代则会让代码维护起来更轻松。一条很好的经验法则是：<strong>程序主体中仅能出现的数值就是 0 和 1。任何其他数值都应该转换为具名常量</strong>。如订单状态等场景。</p><p>用枚举类型来提高可读性与可靠性，如<code>chosenColor = 1</code>用<code>chosenColor = Color_Red</code>来替代会更清晰、准确。</p><h2 id="第13章-不常见的数据类型"><a href="#第13章-不常见的数据类型" class="headerlink" title="第13章 不常见的数据类型"></a>第13章 不常见的数据类型</h2><h3 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h3><p>如何解释内存中某个位置的内容，是由指针的基类型(base type)决定的。如果某指针指向整数，这就意味着编译器会把该指针所指向内存位置的数据解释为一个整数。当然，你可以让一个整数指针、一个字符串指针和一个浮点数指针都指向同一个内存位置，但其中（最多）只有一个指针能正确地解释该位置的内容。</p><h3 id="使用指针的一般技巧"><a href="#使用指针的一般技巧" class="headerlink" title="使用指针的一般技巧"></a>使用指针的一般技巧</h3><p>对解决很多类型的程序错误来说，最容易的一部分是定位错误，而难的是更正错误。然而指针错误的情况则有所不同。通常，指针错误都产生于指针指向了它不应该指向的位置。当你通过一个坏了的指针变量赋值时，会把数据写入本不该写值的内存区域。这称为“内存破坏”。有时内存破坏会导致可怕、严重的系统崩溃：有时它会篡改程序其他部分的计算结果。有时它会只是你的程序不可预知地跳过某些子程序；而有时候它又什么事情都不做。在最后一种情况下，这种指针错误就像一颗滴答作响的定时炸弹，等着你把程序演示给最重要客户的前 5 分钟时引爆。指针错误的症状常常与引起指针错误的原因无关。因此，更正指针错误的大部分工作量便是找出它的位置。</p><p>正确地使用指针要求程序员采用一种双向策略。第一，要首先避免造成指针错误。指针错误很难发现，因此采取一些预防性措施是值得的。其次，在编写代码之后尽快地检测出指针错误来。指针错误的症状飘忽不定，采取一些额外措施来使得这些症状可被预测是非常值得的。</p><ul><li>把指针操作限制在子程序或者类里面。如不要通过手动操作指针去宾利链表，应该编写一组诸如<code>NextLink()</code>、<code>PreviousLink()</code>、<code>InsertLink()</code>、<code>DeleteLink()</code>这样的访问器子程序来完成操作更好些。</li><li>同时声明和定义指针。在靠近变量声明的位置为该变量赋初始值通常是一项好的编程实践。</li><li>在与指针分配相同的作用域中删除指针</li><li>在使用指针之前检查指针</li><li>先检查指针所引用的变量在使用它</li><li>用狗牌字段来检测损毁的内存。标记字段（tag flag）或者狗牌（dog tag）是指你加入结构体内的一个仅仅用于检测错误的字段。在分配一个变量的时候，把一个应该保持不变的数值放在它的标记字段里。当你使用该结构的时候——特别是当你释放其内存的时候——检测这个标记字段的取值。如果这个标记字段的取值与预期不符，那么这个数据就被破坏了。在删除指针的时候，就破坏这个字段。把狗牌放置在你所分配的内存区域的开始位置，让你能检查是否多执行了释放该内存的操作，而无需去维护一个包含你所分配的全部内存区域的列表。把狗牌放置在内存区域的后面，让你能检查是否做过超出该内存块末位的覆盖数据操作。你可以同时在前面和后面放狗牌，以便同时达到上述两个目的。</li><li>增加明显的冗余。另一种代替标记字段的方案，就是某些特定字段重复两次。如果位于冗余字段中的数据不匹配，你就可以确定数据已经被破坏了。如果你直接操作指针，这么做会带来很高的成本。然而，如果你把指针操作限制在子程序里面，那么就只需要少数几处重复的代码。</li><li>用额外的指针变量来提高代码清晰度。一定不要节约使用指针变量，即不要把同一个变量用于多种用途。这一点对指针变量来说尤为重要。</li><li>简化复杂的指针表达式</li><li>画一个图</li><li>按照正确的顺序删除链表中的指针。在使用动态分配链表时，经常遇到的一个问题是，如果先释放了链表中的第一个指针，就会导致下一个指针无法访问。为了避免这一问题，在释放当前指针前，要确保已经有指向链表中下一个元素的指针。</li><li>分配一片保留的内存后备区域。如果在你的程序中使用了动态内存，就需要避免发生程序内存忽然被耗尽、用户和数据被丢在 RAM 里的尴尬场景。</li><li>粉碎垃圾数据</li><li>在删除或者释放指针之后把它们设置为空值</li><li>在删除变量之前检查非法指针</li><li>跟踪指针分配情况</li><li>编写覆盖子程序，集中实现避免指针问题的策略</li><li>采用非指针技术</li></ul><h3 id="全局数据"><a href="#全局数据" class="headerlink" title="全局数据"></a>全局数据</h3><p><strong>使用全局数据的风险比使用局部数据大。</strong></p><p>使用全局数据的一些问题：</p><ul><li>无意间修改了全局数据</li><li>在多个线程运行时全局数据保证不会被修改</li><li>阻碍代码复用。将A程序代码移植到B代码需要一并移植A的全局数据。</li><li>全局数据破坏了模块化和智力上的可管理性。创建超过几百行代码的程序的核心便是管理复杂度。你能够在智力上管理一个大型程序的唯一方法就是把它拆分成几部分，从而可以只在同一时间只考虑一部分。模块化就是你手中可以使用的最强大的工具。全局数据使得你的模块化大打折扣。如果你使用了全局数据，你不得不关注一个子程序，以及使用了同样全局数据的其他所有子程序。尽管全局数据并没有完全破坏模块化，但却削弱了它。</li></ul><p><strong>只有万不得已的时候才使用全局数据。</strong></p><p>当使用全局数据时，一个好的习惯是，将所有全局数据都冠以<code>_g</code>前缀，并且用访问器子程序来管理全局数据，除了该变量的访问器子程序以外，所有的代码都不可以访问<code>_g</code>前缀的变量。其他代码均通过访问器子程序来存取该数据。另外，全局数据再设置时，先将每个变量设置为局部变量，仅当必须时再修改为全局。犹如类中先设为<code>private</code>，再设为<code>public</code>。</p><p>不要把所有的全局数据扔在一起。如果把所有的全局数据都堆在一起，然后为它编写一些访问器子程序，你可以消灭所有与全局数据有关的问题，但这也使代码丧失了信息隐藏和抽象数据类型所带来的好处。既然已经在编写访问器子程序，就请花一些时间考虑每一个全局数据所属的类，然后把该数据和它访问器子程序以及其他数据和子程序打包放入那个类。</p><p>如何解决全局数据再多线程运行时不会被意外修改呢？我们可以通过锁来控制对全局变量的访问。</p><p><strong>在许多情况下，全局数据事实上就是没有设计好或者没有实现好的类中的数据。在少数情况下，一些数据的确需要作为全局数据，但是可以使用访问器子程序对其进行封装，从而最大限度减少发生问题的几率。在剩余的极少数情况下，你真的需要使用全局数据。</strong></p><h2 id="第14章-组织直线型代码"><a href="#第14章-组织直线型代码" class="headerlink" title="第14章 组织直线型代码"></a>第14章 组织直线型代码</h2><p><strong>要让程序易于自上而下阅读，而不是让读者目光跳来跳去。</strong>如果有人在阅读你代码时不得不搜索整个程序来找到所需信息，那么就应该重新组织下你的代码了。</p><p>直线型代码要把相关的语句组织到一起，好的相关代码结构应该像左侧一样，方块间不会有重叠。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872vdz390j30mi0bc0u7.jpg" alt=""></p><h2 id="第15章-使用条件语句"><a href="#第15章-使用条件语句" class="headerlink" title="第15章 使用条件语句"></a>第15章 使用条件语句</h2><h3 id="使用-if-语句时，请遵循下述指导原则"><a href="#使用-if-语句时，请遵循下述指导原则" class="headerlink" title="使用 if 语句时，请遵循下述指导原则"></a>使用 if 语句时，请遵循下述指导原则</h3><ul><li>首先写正常代码逻辑，再处理不常见情况</li><li>确保对于等量判断正确。请不要用<code>&gt;</code>代替<code>&gt;=</code>或用<code>&lt;</code>代替<code>&lt;=</code>，在循环中，要仔细考虑避免犯偏差 1 的错误</li><li>把正常情况的处理放在 if 里而不是在 else 中</li><li>让 if 中跟一个有意义的语句</li><li>考虑是否真的需要 else 语句</li><li>检查 if 与 else 是否弄反了</li></ul><h3 id="使用-if-else-时请注意"><a href="#使用-if-else-时请注意" class="headerlink" title="使用 if-else 时请注意"></a>使用 if-else 时请注意</h3><ul><li>利用布尔函数调用简化复杂的检测</li><li>把最常见的情况放在最前面。易于阅读，执行效率高。</li><li>确保所有的情况都考虑到了</li><li>复杂的 if-else 请使用 case 替代</li></ul><h3 id="使用-case-语句时排序的窍门"><a href="#使用-case-语句时排序的窍门" class="headerlink" title="使用 case 语句时排序的窍门"></a>使用 case 语句时排序的窍门</h3><ul><li><strong>按照字母顺序或者数字顺序排列各种情况</strong>。如果所有情况的重要性都相同，那么就把他们按字母顺序排列，以便提高可读性。</li><li><strong>把正常的情况放在前面</strong>。如果有一个正常的情况和多个异常情况，那么就把那个正常的情况放在最前面。用注释来说明它是正常情况，而其他的属于非正常情况。</li><li><strong>按执行频率排列case子句</strong>。把最经常执行的情况放在最前面，最不常执行的放在最后。</li></ul><h3 id="使用-case-语句的诀窍"><a href="#使用-case-语句的诀窍" class="headerlink" title="使用 case 语句的诀窍"></a>使用 case 语句的诀窍</h3><ul><li>简化每种情况对应的操作。如果某种情况的操作非常复杂，就写一个子程序，并在该情况对应的 case 字句中调用它，而不要把代码本身放进这一 case 子句中。</li><li>不要为了使用 case 语句而刻意制造一个变量。case语句应该用于处理简单的、容易分类的数据。如果你的数据并不简单，那么就使用 if-then-else 语句串。为使用case而刻意构造出的变量很容易把人搞糊涂，你应该避免使用这种变量。.</li><li><strong>把 default 用于检查真正的默认情况，而不要用于最后需要处理的情况</strong>，这会让人很迷惑并难以维护。</li><li>利用 default 检查错误</li></ul><h2 id="第16章-控制循环"><a href="#第16章-控制循环" class="headerlink" title="第16章 控制循环"></a>第16章 控制循环</h2><p>在代码进入循环时使用下述指导原则：</p><ul><li>只从一个位置进入循环</li><li>把初始化代码紧放在循环前面</li><li>用 <code>while(true)</code>表示无限循环，而非<code>for i = 1 to 999999</code></li><li>在适当的情况下多使用for循环。for 循环将控制代码都集中在一处，从而有助于写出可读性强的循环。修改 while 循环时，常常容易只修改了头部的初始化代码，而忘记修改退出代码，而 for 循环的初始化与退出则都在一起</li><li>在 while 更适用时，不要使用 for 循环</li></ul><p>高效程序员与低效程序员的差别在于：高效程序员会在脑海中模拟程序的执行，并会手动计算来减少差错。而低效程序员则在不停的试验，寻找一种看上去能工作的组合，这样做最终可能会碰出正确的组合来，也可能把原有的错误改成了另一个更微妙的错误。即使这样随意的开发过程能够产生出一个正确的程序，这些程序员也不明白为什么这个程序是正确的。<strong>你需要真正理解你的代码是如何工作的，而不是瞎猜。</strong></p><p>循环下标尽量使其具有可读性，避免使用<code>i</code>、<code>j</code>、<code>k</code>，以及在嵌套循环中重复使用相同的下标名。</p><h3 id="循环应该有多长？"><a href="#循环应该有多长？" class="headerlink" title="循环应该有多长？"></a>循环应该有多长？</h3><ul><li>循环要尽可能的短，以便能够一目了然</li><li>把嵌套限制在 3 层以内</li><li>把长循环的内容移到子程序里</li><li>要让长循环格外清晰</li></ul><h2 id="第17章-不常见的控制结构"><a href="#第17章-不常见的控制结构" class="headerlink" title="第17章 不常见的控制结构"></a>第17章 不常见的控制结构</h2><p>使用递归的技巧：</p><ul><li>确认递归能够停止</li><li>使用安全计数器放置出现无穷递归</li><li>把递归限制在一个子程序内</li><li>留心栈空间</li><li>不要用递归去计算阶乘或者斐波那契数列（<a href="https://blog.csdn.net/code_see/article/details/6327472" target="_blank" rel="noopener">为什么用 递归 计算“阶乘”和“斐波那契数列”是不合适的？</a>）</li></ul><h2 id="第18章-表驱动法"><a href="#第18章-表驱动法" class="headerlink" title="第18章 表驱动法"></a>第18章 表驱动法</h2><p>（略）</p><h2 id="第19章-一般控制问题"><a href="#第19章-一般控制问题" class="headerlink" title="第19章 一般控制问题"></a>第19章 一般控制问题</h2><p>如何简化复杂的表达式？</p><ul><li>编写肯定的布尔表达式，尽可能减少诸如<code>if(!status)</code>这样的否定判断</li><li>用括号使布尔表达式更清晰</li></ul><p>编程中，0 是一个数值，是空指针的取值，是枚举的第一个元素的取值，是逻辑表达式中的 false，既然它有这么多的用途，因此在代码中应该彰显 0 的明确含义。</p><h3 id="与-0-比较的指导原则"><a href="#与-0-比较的指导原则" class="headerlink" title="与 0 比较的指导原则"></a>与 0 比较的指导原则</h3><ul><li>隐式地比较逻辑变量</li><li>把数字和 0 比较时，应写作 <code>if(balance != 0)</code>而非<code>if(!balance)</code></li><li>在 C 中显示地比较字符和零终止符（<code>&#39;\0&#39;</code>）</li><li>指针与 NULL 比较</li></ul><p><em>在进行条件判断时，我们常常可能因少写了一个<code>=</code>而将<code>==</code>写作赋值，因此我们可以把常量写在表达式的左侧，这样，当我们少写了一个<code>=</code>时，编译器就会及时捕获到错误。</em></p><h3 id="避免深层嵌套"><a href="#避免深层嵌套" class="headerlink" title="避免深层嵌套"></a>避免深层嵌套</h3><ul><li>将深层嵌套的判断条件合并</li><li>将判断条件转换为 if-else 结构</li><li>使用 case 语句判断</li><li>将复杂的深层嵌套代码抽取为单独的子程序</li><li>使用对象和多态</li><li>用状态变量重写代码</li><li>重新设计深层嵌套代码</li></ul><p><strong>复杂的代码表明你还没有充分理解你的程序</strong>，所以无法简化它。深层嵌套是一个警告，它说明你要么应该拆分出一个子程序，要么应该重新设计那部分复杂的代码。</p><p><strong>结构化编程的核心思想是指，一个应用程序应该只采用一些单入单出的控制结构</strong>。单入单出的控制结构是指一个代码块，它只能从一个位置开始执行，并且只能结束于一个位置，除此之外再无其他入口或出口。一个结构化的程序将按照一种有序的且有规则的方式执行，不会做不可预知的随便跳转。结构化编程和结构化的、自上而下的设计不完全一样，前者只适用于具体编码层。</p><p>程序复杂度的一个衡量标准是，为了理解应用程序，你必须在同一时间记住的实体的数量。有能力的程序员会充分地认识到自己的大脑容量是多么有限，所以他们会非常谦卑地处理编程任务。</p><h3 id="控制结构的相关事宜"><a href="#控制结构的相关事宜" class="headerlink" title="控制结构的相关事宜"></a>控制结构的相关事宜</h3><ul><li>表达式中用的是true和false，而不是1和0吗?</li><li>布尔值和true以及false做比较是隐式进行的吗?</li><li>对数值做比较是显式进行的吗?</li><li>有没有通过增加新的布尔变量、使用布尔函数和决策表来简化表达式?</li><li>布尔表达式是用肯定形式表达的吗?</li><li>括号配对吗?</li><li>在需要用括号来明确的地方都使用了括号吗?</li><li>把逻辑表达式全括起来了吗?</li><li>判断是按照数轴顺序编写的吗?</li><li>如果适当的话，Java 中的判断用的是<code>a.equals(b)</code>方式， 而没有用<code>a==b</code>方式吗?</li><li>空语句表述得明显吗?</li><li>用重新判断部分条件、转换成if-then-else 或者case 语句、把嵌套代码提取成单独的子程序、换用一种更面向对象的设计或者其他的改进方法来简化嵌套语句了吗?</li><li>如果一个子程序的决策点超过10个，那么能提出不重新设计的理由吗?</li></ul><h2 id="第20章-软件质量概述"><a href="#第20章-软件质量概述" class="headerlink" title="第20章 软件质量概述"></a>第20章 软件质量概述</h2><h3 id="软件质量特性"><a href="#软件质量特性" class="headerlink" title="软件质量特性"></a>软件质量特性</h3><ul><li><p>外在特性</p><ul><li><strong>正确性(Correctness)</strong>。指系统规范、设计和实现方面的错误的稀少程度。</li><li><strong>可用性(Usability)</strong>，指用户学习和使用一个系统的容易程度。</li><li><strong>效率 (Efficiency)</strong>。指软件是否尽可能少地占用系统资源，包括内存和执行时间。</li><li><strong>可靠性(Reliability)</strong>。指在指定的必需条件下，一个系统完成所需要功能的能力——应该有很长的平均无故障时间。</li><li><strong>完整性(Integrity)</strong>。指系统阻止对程序或者数据进行未经验证或者不正确访问的能力。这里的完整性除了包括限制未经授权用户的访问外，还包括确保数据能够正确访问。</li><li><strong>适应性(Adaptability)</strong>。指为特定的应用或者环境设计的系统，在不做修改的情况下，能够在其他应用或者环境中使用的范围。</li><li><strong>精确性(Accuracy)</strong>。指对于一个已经开发出的系统，输出结果的误差程度,尤其在输出的是数量值的时候。精确性和正确性的不同在于，前者是用来判断系统完成工作的优劣程度，而后者则是判断系统是否被正确开发出来。</li><li><strong>健壮性( Robustness)</strong>。这指的是系统在接收无效输入或者处于压力环境时继续正常运行的能力。</li></ul></li><li><p>内在特性</p><ul><li><strong>可维护性(Maintainability)</strong>。指是否能够很容易对系统进行修改，改变或者增加功能，提高性能，以及修正缺陷。</li><li><strong>灵活性(Flexibility)</strong>。指假如一个系统是为特定用途或者环境而设计的,那么当该系统被用于其他目的或者环境的时候，需要对系统做修改的程度。</li><li><strong>可移植性(Portability)</strong>。指为了在原来设计的特定环境之外运行，对系统所进行修改的难易程度。</li><li><strong>可重用性(Reusability)</strong>。指系统的某些部分可被应用到其他系统中的程度,以及此项工作的难易程度。</li><li><strong>可读性(Readability)</strong>。指阅读并理解系统代码的难易程度，尤其是在细节语句的层次上。</li><li><strong>可测试性(Testabiity)</strong>。指的是你可以进行何种程度的单元测试或者系统测试，以及在何种程度上验证系统是否符合需求。</li><li><strong>可理解性(Understandability)</strong>。指 在系统组织和细节语句的层次上理解整个系统的难易程度。与可读性相比，可理解性对系统提出了更高的内在一致性要求。</li></ul></li></ul><p>外在特性与内在特性并不完全割裂，在某些层次上内在特性会影响外在特性。</p><p>要让所有特性都能表现得尽善尽美是绝无可能的。需要根据一组互相竞争的目标寻找出一套优化的解决方案，正是这种情况使软件开发成为一个真正的工程学科。</p><h3 id="改善软件质量的方法"><a href="#改善软件质量的方法" class="headerlink" title="改善软件质量的方法"></a>改善软件质量的方法</h3><ul><li>设定质量目标。根据上一节所提到的软件质量特性，明确定义出软件质量的目标，并要求开发者朝着目标努力。</li><li>明确定义质量保证工作</li><li>测试策略</li><li>软件工程指南</li><li>非正式技术复查</li><li>正式技术复查</li><li>外部审查</li></ul><h3 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h3><ul><li><strong>对变更进行控制的过程</strong>。实现软件质量目标的拦路虎之一就是失控的变更。需求变更的失控可能使设计和编码工作前功尽弃；设计变更的失控则会造成代码与需求背离，或代码自相矛盾，或是程序员为达到变更后的设计要求，不得不耗费比推进项目更多的时间来修改代码。代码变更的失控则可能造成内部冲突，程序员无法确定哪些代码已经过完全复查和测试，而哪些没有。变来变去的自然影响就是质量不稳定和恶化，因此，<strong>有效地管理变更是实现高质量的一个关键</strong>。</li><li><strong>结果的量化</strong>。除非质量保证计划的结果经过实际测量，否则你将完全不知道这个计划是否有实效。量化结果能告诉你计划成功与否，并且允许你用可控的方式来调整你的计划，去看你能如何改善它。你也可以度量各种质量特性本身——正确性、可用性以及效率等，这么做是很有用的。</li><li><strong>制作原型(Prototyping)制作</strong>。原型是指开发出系统中关键功能的实际模型。对一个开发者来说，开发出一部分用户界面的原型可以判断系统的可用性，开发出关键算法的原型可以确定功能的执行时间，开发出典型数据集的原型能知道程序的内存需求。构建原型能产生更完善的设计，更贴近用户的需求，以及更好的可维护性。</li></ul><h3 id="不同质量保障技术的相对效能"><a href="#不同质量保障技术的相对效能" class="headerlink" title="不同质量保障技术的相对效能"></a>不同质量保障技术的相对效能</h3><p>通过结合多种bug 检测方式来有效降低 bug 率，如代码 review、单元测试、集成测试、回归测试等。</p><p><strong>检查代码发现 bug 比测试出 bug 的成本更小</strong>，因此，当开发完新功能时，需要先通读本次的开发代码，然后自己进行流程测试。</p><p>似乎修正相同 bug 的成本是相同的，但事实并非如此。因为<strong>一个bug 存在的时间越长，消除它的代价也就越大</strong>，因此能够尽早发现错误的检测方法可以降低修正 bug 的成本。</p><p>在一个由超过400名程序员创建的 70 万行代码程序中，代码复查的成本效益比测试高出好几倍——前者的回报率为 1.38，后者仅为 0.17。</p><p>一个有效的软件质量项目的底线，必须包括在开发的所有阶段联合使用多种技术，下面是一套推荐阵容，通过它们可以获取高于平均水平的质量：</p><ul><li>对所有的需求、架构以及系统关键部分的设计进行正式检查</li><li>建模或者创建原型</li><li>代码阅读或者检查</li><li>执行测试</li></ul><p><strong>质量保障工作应该贯穿于整个项目周期中，尤其是调研与架构设计阶段，在项目初期引入缺陷，这个缺陷会像核辐射一样污染整个项目。</strong></p><p><strong>软件产品的业界平均生产效率大约是每人每天 10~50 行最终交付代码，那么每天剩下的时间是怎么度过的呢？</strong>绝大多数项目最大规模的一种活动就是调试以及修正那些无法正常工作的代码。调试和与此相关的重构或者其他返工工作，在传统的不成熟的软件开发周期当中可能消耗大约50%的时间。只要避免引入错误，就可以减少试时间，从而提高生产力。因此，<strong>效果最明显的缩短开发周期的办法就是改善产品的质量，由此减少花费在调试和软件返工上面的时间总量</strong>。更多质量保证工作能降低 bug 率，但不会增加开发的总成本。IBM的一个研究也得到了类似的结论：<strong>缺陷最少的软件项目的开发计划时间最短，并拥有最高的开发生产率….消除软件缺陷实际上是最昂贵且最耗时的一种软件工作</strong>(Jones2000)。</p><blockquote><p>所有的“功能先上线，优化后期做”都是伪命题。随着项目的发展，越来越多的 bug 引入项目中，导致后期的开发不断被反馈的 bug 打断，无法专注开发，从而造成正在开发功能的 bug，形成恶性循环……</p></blockquote><h3 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h3><ul><li>开发高质量代码最终并没有要求你付出更多，只是你需要对资源进行重新分配，以低廉的成本来防止缺陷出现，从而避免代价高昂的修正工作。</li><li><strong>并非所有的质量保证目标都可以全部实现。明确哪些目标是你希望达到的</strong>，并就这些目标和团队成员进行沟通。</li><li>没有任何一种错误检测方法能够解决全部问题，测试本身并不是排除错误的最有效方法。成功的质量保证计划应该使用多种不同的技术来检查各种不同类型的错误。</li><li>在构建期间应当使用一些有效的质量保证技术，但在这之前，一些具有同样强大功能的质量保证技术也是必不可少的。<strong>错误发现越早，它与其余代码的纠缠就越少，由此造成的损失也越小</strong>。</li><li>软件领域的质量保证是面向过程的。软件开发与制造业不一样，在这里并不存在会影响最终产品的重复的阶段，因此，最终产品的质量受到开发软件所用的过程的控制。</li></ul><h2 id="第21章-协同构建"><a href="#第21章-协同构建" class="headerlink" title="第21章 协同构建"></a>第21章 协同构建</h2><p>“协同构建”包括结对编程、正式检查、非正式技术复查、文档阅读，以及让其他开发人员共同承担创建代码及其他工作产品责任的技术。</p><p>协同构建的首要目的就是改善软件的质量。另一个好处是，它可以缩短开发周期，从而减低开发成本。</p><h3 id="代码-review-的一些研究案例及收益"><a href="#代码-review-的一些研究案例及收益" class="headerlink" title="代码 review 的一些研究案例及收益"></a>代码 review 的一些研究案例及收益</h3><ul><li>IBM发现，一小时的代码检查能够节省大约100小时的相关工作(测试和缺陷修正)(Holland 1999)。</li><li>对一些大型程序的一项研究发现，在正式检查上面花一个小时，平均可以避免33个小时的维护工作,并且检查的效能是测试的20倍以上(Russell1991)。</li><li>同一组人员开发了11个程序，并将它们发布到产品当中。其中的前5个没有进行复查，其平均每百行代码存在4.5个错误。另外6个经过了代码检查，平均每百行代码只有0.82 个错误。复查消灭了超过80% 的错误(Freedman and Weinberg 1990)。</li></ul><h3 id="协同构建有利于传授公司文化以及编程专业知识"><a href="#协同构建有利于传授公司文化以及编程专业知识" class="headerlink" title="协同构建有利于传授公司文化以及编程专业知识"></a>协同构建有利于传授公司文化以及编程专业知识</h3><p>软件标准可以写下来并发布出去，但是如果无人去讨论它们，也不鼓励使用这些标准，那么就不会有人去按照这些标准做事情。<strong>复查是一个很重要的机制，它可以让程序员得到关于他们自己代码的反馈。代码、标准以及让代码符合标准的理由等，都是复查讨论中的好主题。</strong></p><p>程序员除了需要得到他们是否很好地遵循了标准的反馈之外，还需要得到程序设计主观方面的回馈，例如格式、注释、变量名、局部变量和全局变量的使用、设计方法以及“我们这里采用的解决方法(the- way-we-do-things-around-here)”等。刚出道的编程人员需要那些有更丰富知识的前辈给予指导，而资深程序员们往往太忙而没时间同他人分享他们的知识。复查为这两种人提供了一个技术交流的平台，所以，无论在未来还是现在，<strong>复查都是培养新人以提高其代码质量的好机会</strong>。</p><p>一个采用正式检查的团队报告称，<strong>复查可以快速地将所有开发者的水平提升到最优秀的开发者的高度</strong>(Tackett and Van Doren 1999)。</p><h3 id="集体所有权适用于所有形式的协同构建"><a href="#集体所有权适用于所有形式的协同构建" class="headerlink" title="集体所有权适用于所有形式的协同构建"></a>集体所有权适用于所有形式的协同构建</h3><p>在集体所有权下，所有的代码都属于团队而不是某一个人，并且团队中的所有成员都可以对其进行访问和修改。这会带来一些很有价值的好处。</p><ul><li>众多双眼睛的检查，以及众多程序员的协力编写，可以使代码的质量变得更好。</li><li>某个人离开项目所造成的影响更小了，因为每段代码都有多个人熟悉它。</li><li>总体上缺陷修正周期变短了，因为几个程序员中的任何一个有空，就能随时被指派去修正缺陷。</li></ul><blockquote><p>协同构建的思想同样适用于评估、计划、需求、架构、测试以及维护工作等阶段。</p></blockquote><h3 id="结对编程的好处"><a href="#结对编程的好处" class="headerlink" title="结对编程的好处"></a>结对编程的好处</h3><ul><li>与单独开发相比，结对能够使人们在压力之下保持更好的状态。结对编程鼓励双方保持代码的高质量，即使在出现了让人不得不飞快地编写代码的压力时仍然如此。</li><li>它能够改善代码质量。代码的可读性和可理解性都倾向于上升至团队中最优秀程序员的水平。</li><li>它能缩短进度时间表。结对往往能够更快地编写代码，代码的错误也更少。这样一来，项目组在项目后期花费在修正缺陷的时间会更少。</li><li>它还具有协同构建的其他常见好处，包括传播公司文化，指导初级程序员，以及培养集体归属感。</li></ul><p><strong>任何处于开发阶段的代码评审均不应作为员工的表现评审，而应该是基于最终的产品。如果对员工表现进行排名，则应该警告那些处于最低标准以下的员工，而非末位员工。</strong></p><h3 id="正式检查"><a href="#正式检查" class="headerlink" title="正式检查"></a>正式检查</h3><p>进行详查的目的是发现设计或者代码中的缺陷，而不是探索替代方案，或者争论谁对谁错，其目的绝不应该是批评作者的设计或者代码。对于作者来说，详查的过程应该是正面的，在这一过程中的团队参与使程序得到了明显改善，对所有参与者都是一个学习的过程。这一过程不应该让作者认为团队里面某些人是白痴,或者认为自己应该另谋高就。</p><p>有效的详查：</p><ul><li>你是否有一个核对表，能让评论员将注意力集中于曾经发生过问题的领域?</li><li>你是否专注于找出错误，而不是修正它们?</li><li>你是否考虑制定某些视角或者场景，以帮助评论员在准备工作的时候集中注意力?</li><li>你是否给予评论员足够的时间在详查会议之前进行准备，是否每一个人都做了准备?</li><li>是否每一个参与者都扮演一个明确的角色——主持人、评论员及记录员等?</li><li>会议是否以某种高效的速度进行?</li><li>会议是否限制在两个小时以内?</li><li>是否所有详查会议的参与者都接受了如何进行详查的针对性培训，是否主持人接受了有关主持技巧方面的针对性培训?</li><li>是否将每次详查所发现的错误数据都收集起来，使你能调整本组织以后使用的核对表?</li><li>是否收集了准备速度和详查速度方面的数据，以便你去优化以后的准备和详查工作?</li><li>是否每次详查中被指派下去的活动都被正确跟进了，无论是通过主持人自己还是一次重新详查?</li><li>管理层是否理解他们不应该参与详查会议?</li><li>是否有一个用于保证修正正确性的跟进计划?</li></ul><p>NASA 的一项研究表明，通过阅读代码，每小时能发现 3.3 个 bug，而测试只能发现 1.8 个，在整个项目点生命周期中，代码 review 能比各种测试方法多发现20%~60%的错误。</p><p>代码 review 相比于会议形式的代码评审而言，能让评审者更专注于代码的独立复查，而非会议本身。<strong>在会议中，每个人只在一部分时间做贡献。</strong></p><h2 id="第22章-开发者测试"><a href="#第22章-开发者测试" class="headerlink" title="第22章 开发者测试"></a>第22章 开发者测试</h2><h3 id="测试包括"><a href="#测试包括" class="headerlink" title="测试包括"></a>测试包括</h3><ul><li>单元测试</li><li>组件测试</li><li>集成测试</li><li>回归测试</li><li>系统测试</li></ul><p>很多项目将测试作为软件质量的唯一组成部分，这是非常错误的做法，因为各种形式的协同开发时间都表现出比测试更高的错误检测率，而且发现一条错误的成本不到测试的二分之一。</p><p>你必须期望在你的代码里有错误。尽管这种期望似乎有悖常理，但是你应该期望找到这个错误的人是你，而不是别人。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872vsqju0j31080j040x.jpg" alt=""></p><blockquote><p>如何开发出高质量的程序？</p></blockquote><ol><li>对开发的功能搭建原型框架，判断是否存在缺陷</li><li>采用单元测试</li><li><strong>开发完成自我 review 代码</strong>，这通常能发现很多问题，避免这些问题在测试中浪费时间。</li><li>对开发的功能测试</li><li>寻求更有经验的人 review</li><li>提交测试</li></ol><p>假如你正在写几个子程序，那么你应该一个一个地对它们进行测试。独立进行子程序的测试不是一件容易的事情，但是单独调试它们，比集成之后再进行测试要简单得多。如果将几个没有经过测试的子程序放到一起，结果发现了一个错误，那么这几个子程序都有嫌疑。假如每次只将一个子程序加入到此前经过测试的子程序集合中，那么一旦发现了新的错误，你就会知道这是新子程序或者其接口所引发的问题，调试工作就轻松多了。</p><p>完全测试（测试程序每一种可能的输入值）是不可能，也没必要的。我们可以选择那些最有可能找到错误的测试用例。</p><p>几种较好的测试数据类型：</p><ul><li>正常情况下的数据</li><li>正常情况的最小值</li><li>正常情况的最大值</li><li>与旧数据的兼容性</li></ul><p>绝大多数错误往往与少数几个具有严重缺陷的子程序有关。<strong>80%的错误存在于20%的类或子程序当中。</strong></p><p><strong>错误并非平均分布在所有的子程序里，而是集中在少数几个子程序中。</strong></p><p>软件质量的普遍原则：<strong>提高质量就能缩短开发周期，同时降低开发成本。</strong></p><h3 id="错误的分类启示"><a href="#错误的分类启示" class="headerlink" title="错误的分类启示"></a>错误的分类启示</h3><ul><li>大多数错误的影响范围是相当有限的</li><li>许多错误发生在构建之外。如：缺乏应用领域知识、频繁变动且相互矛盾的需求，以及沟通和协调的失败。</li><li>大多数的构建期错误是有开发者造成的</li><li>拼写错误是一个常见的问题根源</li><li>开发者错误理解设计经常发生</li><li>大多数错误都很容易修正。大约85%的错误可以在几小时内修正，15%的错误在几小时到几天内可以修正，只有大约1%的错误需要花更长的时间修复。</li><li>总结所在组织中对付错误的经验</li></ul><h3 id="测试记录应该包括"><a href="#测试记录应该包括" class="headerlink" title="测试记录应该包括"></a>测试记录应该包括</h3><ul><li>缺陷的管理方面描述(报告日期、报告人、描述或标题、生成编号以及修正错误的日期等)</li><li>问题的完整描述</li><li>复现错误所需要的步骤</li><li>绕过该问题的建议</li><li>相关的缺陷</li><li>问题的严重程度——例如致命的、严重的或者表面的</li><li>缺陷根源:需求、设计、编码还是测试</li><li>对编码缺陷的分类: off-by-one 错误、错误赋值、错误数组下标，以及子程序调用错误等</li><li>修正错误所改变的类和子程序</li><li>缺陷所影响的代码行数</li><li>查找该错误所花的小时数</li><li>修正错误所花费的小时数</li></ul><p>通过测试记录可以</p><ul><li>对每一个类中的缺陷数目统计，从最糟糕的类到最好的类依次列出，如果类的规模不同，可能需要对这一数字进行归一化处理</li><li>按照同样的方式列出每个子程序中的缺陷数，也可能需要根据子程序大小归一化处理</li><li>发现一个错误平均所需要花费的测试时间</li><li>每个测试用例所发现缺陷的平均数</li><li>修正一个缺陷花费的平均编程时间</li><li>全部测试用例的代码覆盖率</li><li>在各个严重级别中未处理缺陷的数量</li></ul><p><strong>测试数据本身出错的密度往往比被测代码还要高</strong>。查找这种错误完全是浪费时间，又不能对代码有所改善，因此测试数据里面的错误更加让人烦恼。要像写代码一样小心地开发测试用例，这样才能避免产生这种问题。</p><h2 id="第23章-调试"><a href="#第23章-调试" class="headerlink" title="第23章 调试"></a>第23章 调试</h2><p><strong>请不要通过反复尝试编程！！！</strong></p><h3 id="你可以从-bug-中获得以下好处"><a href="#你可以从-bug-中获得以下好处" class="headerlink" title="你可以从 bug 中获得以下好处"></a>你可以从 bug 中获得以下好处</h3><ul><li><strong>理解你正在编写的程序</strong>。如果你确实已经透彻地理解了它，这个程序就不应该还有bug。</li><li><strong>明确你犯了哪种类型的错误</strong>。一旦你发现了错误，请问问自己为什么会犯这样的错误。你如何才能更快地发现这个错误？你如何才能预防此类错误的发生？代码里面还有类似的错误么？你能在这些错误造成麻烦之前改正它们么？</li><li><strong>从代码阅读者的角度分析代码质量</strong>。代码易读么？它怎样才能更好？用你的结论重构你现在的代码，并让自己下次编写的代码更好。</li><li><strong>审视自己解决问题的方法</strong>。你自己解决调试问题时用到的方法使你感到自信吗？你的方法管用么？你能够很快地发现缺陷么？或者正是你的方法导致调试工作成效很差？调试过程中你有痛苦和挫败感么？你是在胡乱猜测么？你的调试方法需要改进么？花点时间来分析并改进你的调试方法，可能就是减少程序开发时间的最有效方法。</li><li><strong>审视自己修正缺陷的方法</strong>。解决方法是否治标不治本呢？是否应该从系统角度进行修正，通过精确的分析对问题的根本原因对症下药呢？</li></ul><p>调试其实是一片极其富饶的土地，它孕育着你进步的种子。这片土地也是所有软件构建之路所交织的地方：可靠性、设计、软件质量，凡是你能想到的无所不包。这几乎等同于编写优秀代码所得到的回报。如果你能精于此道，你甚至无须频繁调试。</p><h3 id="调试之魔魂指南"><a href="#调试之魔魂指南" class="headerlink" title="调试之魔魂指南"></a>调试之魔魂指南</h3><ul><li><strong>凭猜测找出缺陷</strong>。要找出缺陷，请把print语句随机地散布在程序中。检查这些语句的输出来确定缺陷到底在哪里。如果通过print语句还是不能找到缺陷，那么就在程序中修改点什么，直到有些东西好像能干活了。不要备份程序的原始版本，也不要记录你做了哪些改变。只有在你无法确定自己的程序正在干什么的时候，编程才比较刺激。请提早准备一些可乐和糖果，因为你会在显示器前度过一个漫漫长夜。</li><li><strong>不要把时间浪费在理解问题上</strong>。出现的问题不值一提，要解决它们并不需要彻底弄懂程序。只要找出问题就行了。</li><li><strong>用最唾手可得的方式修正错误</strong>。与其把时间浪费在一个庞大、雄心万丈的，甚至可能影响整个程序的修正工作上，还不如直接去解决你所面对的那个特殊问题。下面是一个完美的例子，如果在这里写一段特例处理代码就可以解决问题，谁会去对<code>Compute()</code>寻根究底，弄清与值17有关的棘手问题究竟是什么。<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">x</span> = Compute(<span class="symbol">y</span>)</span><br><span class="line"><span class="keywords">if</span> (<span class="symbol">y</span> = <span class="number">17</span>) </span><br><span class="line"><span class="symbol">x</span> = $<span class="number">25.15</span> <span class="comment">// 当 y=17 时，Compute()没有起作用，因此需要修改</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="迷信式编程"><a href="#迷信式编程" class="headerlink" title="迷信式编程"></a>迷信式编程</h3><p><em>毎个团队里都也许有这样一个程序员，他总会遇到无穷的问题：不听话的机器，奇怪的编译器错误，月圆时オ会出现的编程语言的隐藏缺陷，失效的数据，忘记做的重要改劫，一个不能正常保存程序的疯狂的编辑器。</em></p><p>要知道，<strong>如果你写的程序出了问题，那就是你的原因</strong>，不是计算机的，也不是编译器的。程序不会每次都产生不同的结果。它不是自己写出来的，是你写的，所以，请对它负责。即使某个错误初看似乎不能归咎于你，但出于你自身的利益，最好还是假设它是由你产生的。这样的假设将有助于你的调试。同时避免你先指责别人犯了错，最终却发现错误其实由你而生的尴尬场景。</p><p><strong>在大多数情况下，查找 bug 并理解 bug 通常占用了整个调试工作的 90%。</strong></p><h3 id="科学的调试方法"><a href="#科学的调试方法" class="headerlink" title="科学的调试方法"></a>科学的调试方法</h3><ol><li>确保 bug 可以稳定复现</li><li>确定 bug 位置</li><li>1 收集产生 bug 的相关数据</li><li>2 分析所收集的数据，并作出 bug 产生的假设</li><li>3 确定如何证实或证伪该假设，可以对程序测试或检查代码</li><li>4 通过 2.3 方法对假设作出最终结论</li><li>修复 bug</li><li>对修复结果测试</li><li>查找是否存在类似错误</li></ol><h3 id="查找-bug-的一些建议"><a href="#查找-bug-的一些建议" class="headerlink" title="查找 bug 的一些建议"></a>查找 bug 的一些建议</h3><ul><li>如果一个错误无法重现，这通常是一个初始化错误，或者是一个同时间有关的问题，或者是悬空指针问题。</li><li>如果出现了一个难于确诊的新错误，这个错误通常是同那些最新修改的代码相关。</li><li>增量式集成。当你每次只对系统添加一个代码片段，调试将变得很容易。如果在这一过程中出现错误，则应将所添加的代码提取出来单独测试。</li><li><strong>将所有可能的情况罗列出来，并逐一验证，避免在某一种困境中呆的太久。</strong></li><li>缩小代码嫌疑。通过打印输出、日志、请求链跟踪等方式进一步精确问题可能发生的位置。</li><li>扩大嫌疑代码。如果在某个代码范围内没能找到问题，请考虑问题是否的确不在该代码段内。</li><li><strong>对之前出现过问题的类与子程序保持警惕，它们很可能再次“作案”。</strong></li><li>同其他人讨论。<strong>当你向别人解释自己的程序时，常常能发现自己犯下的错误。</strong></li><li>抛开问题，休息一下。<strong>如果你调试了很久却毫无进展，只要你尝试完所有的可能，把问题放在一边吧！</strong>出去散散步，做一些其他的事情。回家休息一天，让你的神经在潜意识中释放出问题的解决方案。</li></ul><h3 id="修复-bug"><a href="#修复-bug" class="headerlink" title="修复 bug"></a>修复 bug</h3><p>一项调查显示，<strong>第一次对 bug 的修复有 50% 的几率出错</strong>。以下是一些减少出错的建议：</p><ul><li>在动手前先理解问题</li><li>理解程序本身，而不仅仅是问题。对项目的了解越多，越不容易出错；过于庞大的项目至少要了解 bug 的上下文。</li><li>验证对错误的分析。确定你找到的真正的 bug</li><li><strong>越是紧急情况下越容易出现问题</strong>。如赶火车前突然发现的问题，一个非常小的紧急 bug 不经测试便发布。经验告诉我们，越是慌乱，越容易出问题，如果你无法泰然处之，请与同事一起处理。</li><li>休息一下。如果你无法确定是否彻底解决了问题，并且时间允许，请放松一下，正确解决问题远比匆忙错误解决问题重要。</li><li>保存最初的源代码。如果你的修改没有奏效，或者引发了新的问题，请比对一下修改是否正确。</li><li>治本，而不是治标。如果没有彻底理解问题，就不要去修改代码。如果仅仅治标，你只会把代码搞得更糟糕。</li><li>一次只做一个改动</li><li>检查自己的改动</li><li>增加能暴露问题的单元测试</li><li>搜索类似的缺陷。如果你想不出如何查找类似缺陷，这就意味着你还没有完全理解问题。</li></ul><p>不要让你的代码被特例所纠缠。</p><h2 id="第24章-重构"><a href="#第24章-重构" class="headerlink" title="第24章 重构"></a>第24章 重构</h2><p>软件演化就像生物进化一样，有些突变是对物种有益的，另一些则是有害的。良性的软件演化使代码得到了发展。</p><p>软件演化的基本准则：演化应当提升程序的内在质量。</p><h3 id="重构的理由"><a href="#重构的理由" class="headerlink" title="重构的理由"></a>重构的理由</h3><ul><li>代码重复</li><li>冗长的子程序</li><li>循环过长或嵌套过深。循环内部复杂的子程序通常具备转换为子程序的潜质。</li><li>内聚性太差的类</li><li>类的接口未能提供层次一致的抽象</li><li>拥有太多参数的参数列表。如果一个子程序被分解的很好，那么它的子程序应当小巧、定义精确，且不需要庞大的参数列表。</li><li>变化导致对多个类的相同修改</li><li>对继承体系同样的修改</li><li>case 语句需要做相同的修改</li><li>同时使用的相关数据并未以类的方式进行组织</li><li>成员函数使用其他类的特征比使用自身类的特征还要多</li><li>过多使用基本数据类型。基本数据类型可用于表示真实世界中实体的任意数量。如果程序中使用了整型这样的数据类型表示某种常见的实体，如货币，请考虑创建一个简单的 money 类，这样编译器就可以对 money 变量执行类型检查，你也可以对赋给 money 的值添加安全检查等功能。</li><li>某个类无所事事</li><li>一些列传递流浪数据（数据只是被传来传去而不做任何数据）的子程序</li><li>如果看到某个类中的绝大部分代码只是去调用其他类中的成员函数，请考虑是否应该把这样的中间人去掉，转而去直接调用其他的类</li><li><strong>某个类同其他类关系过于亲密</strong>。类的作用是使程序具备更强的可管理行，并最大限度地减少更改代码对周围的连带影响。</li><li>子程序命名不恰当</li><li>数据成员被设置为公用</li><li>某个派生类仅使用了基类的很少一部分成员函数。更完善的封装应该是，把派生类相对于基类的关系从“is-a”转变为“has-a”。即把基类转换为原来的派生类的数据成员，然后仅仅为原来的派生类提供所需要的成员函数。</li><li>注释被用于解释难懂的代码。“<strong>不要为拙劣的代码编写文档——应当重写代码。</strong>”</li><li>使用了全局变量</li><li>程序中的一些代码似乎是在将来的某个时候才会用到。<strong>“超前设计”的代码是画蛇添足</strong>，增加了程序的复杂性，带来了额外的测试、修补缺陷等工作量。对未来需求有所准备的办法并不是去编写空中楼阁式的代码，而是尽可能满足当前需求的代码清晰直白地表现出来，使未来的程序员理解这些代码到底完成了什么功能，没有完成什么功能，从而根据他们的需要进行修改。</li></ul><blockquote><p>当一段代码需要用文档才能描述清楚时，要么是你没有理解你所写的代码，要么是你的实现方式过于复杂，此时你应该优化代码，而不是新增文档，文档应该仅用于描述复杂的业务逻辑，或者无法简化的代码。</p><p>文档看似是万金油，但文档也会有各种弊端，如维护总是滞后、每个人的思维方式不同导致阅读者与表达者无法信息对等、花费更多的时间、维护意愿低，需要强制执行等。当我们发现一件事需要用文档才能描述清楚时，需要考虑一下这件事是不是做复杂了？一个需要读说明书的游戏是没有人会玩儿的。</p></blockquote><p>数据级的重构</p><ul><li>用具名常量替代神秘数值</li><li>使变量的名字更为清晰且传递更多信息</li><li>把一个中间变量换成给它赋值的那个表达式本身</li><li>用函数来替代表达式</li><li>引入中间变量</li><li>替换i、j、k等同名多用途变量名</li><li>在局部用途中使用局部变量而不是参数</li><li>将基础数据类型转换为类。如果一个基础数据类型需要额外的功能或额外的数据，那么就该把数据转换为一个对象，然后再添加你所需要的类行为。</li><li><strong>将一组类型码转换为类或枚举类型</strong>。如<code>const int SCREEN = 0;</code>，与其定义这些单独的常量，不如定义一个类，这样你就可以享受严格类型检查所带来的好处。</li><li>将一组类型码转换为一个基类及其相应派生类。如果与不同类型相关联的不同代码片段有着不一样的功能，请考虑为该类型创建一个基类，然后针对每个类型码创建派生类。如对 OutputType 基类，就可以创建 Screen、Printer 和 File 这样的派生类。</li><li>把数组转换为对象。如果正在使用一个数组，其中的不同元素具有不同的类型，那么就应该用一个对象来替代它。将数组中的各个元素转化为该类的各个成员。</li><li>把数据集封装起来。如果一个类返回一个数据集，到处散布的多个数据集实例将会带来同步问题。请让你的类返回一个只读数据集，并且提供相应的为数据集添加和删除元素的子程序。</li><li>用数据类来代替传统记录。建立一个包含记录成员的类。这样你可以集中完成对记录的错误检查、持久化和其他与该记录相关的操作。</li></ul><p>语句级的重构</p><ul><li>分解布尔表达式。通过引入命名准确的中间变量来简化复杂的布尔表达式，通过变量名更好地说明表达式的含义。</li><li>将复杂布尔表达式转换成命名准确的布尔函数</li><li>合并条件语句不同部分中的重复代码片段</li><li>使用 break 或 retum 而不是循环控制变量</li><li>在嵌套的 if-then-else 语句中一旦知道答案就立即返回，而不是去赋一个返回值。一旦知道返回值就迅速退出子程序，这样的代码最容易分析，也不容易出错。如果设置一个返回值，再通过啰嗦的逻辑判断退出循环，你的代码就会难于理解。</li><li>用多态来替代条件语句(尤其是重复的case语句)。结构化程序里很多的case语句中的逻辑都可以被放到继承关系中，通过多态函数调用实现。</li><li>创建和使用null对象而不是去检测空值。</li></ul><p>子程序级重构</p><ul><li>提取子程序或者方法</li><li>如果子程序的程序体很简单，且含义不言自明，那么就在使用的时候直接使用这些代码。</li><li>将冗长的子程序转换为类。</li><li>用简单算法替代复杂算法。</li><li>如果子程序需要从调用方获得更多的信息，可以增加它的参数从而为其提供信息。</li><li>删除冗余参数</li><li>将查询操作从修改操作中独立出来。查询操作不应改变对象的状态。</li><li>合并相似的子程序，通过参数区分它们的功能</li><li><strong>将行为取决于参数的子程序拆分开来</strong>。如果一个子程序根据输入参数的值执行了不同的代码，请考虑将它拆分成可几个以被单独调用的、无须传递特定参数的子程序。</li><li>传递整个对象而非特定成员。如果发现有同一对象的多个值被传递给了一个子程序，考虑是否可修改其接口使之接收整个对象。</li><li>传递特定成员而非整个对象。如果发现创建对象的唯一理由只是你需要将它传入某个子程序，那么就考虑一下 是否可以修改这个子程序，使之接收特定数据成员而非整个对象。</li><li>包装向下转型的操作。通常当子程序返回一个对象时，应当返回其已知的最精确的对象类型。这尤其适用于返回迭代器、群集、群集元素等的情况。</li></ul><p>类接口的重构</p><ul><li>将成员函数放到另一个类中</li><li>明确类的职责，拆分承担多个职责的单类</li><li>删除冗余的类</li><li>去除委托关系与中间人。A ==&gt; B ==&gt; C，三者的调用关系链是否必须？</li><li>用委托代替继承。如果某类需要用到另一个类，但又打算获取对该类接口更多的控制权，那么可以让基类成为原派生类的一个成员，并公开它的一组成员函数，以完成一种内聚的抽象。（？？？）</li><li>用继承代替委托。如果某个类公开了委托类（成员类）所有的成员函数，那么该类应该从委托类继承而来，而不是使用该类。（？？？）</li><li>引入外部的成员函数。当你调用了一个无法修改的类的额外成员函数时，就可以在调用类中创建新的成员函数方式来提供此功能</li><li>引入扩展类</li><li>对暴露在外的成员变量进行封装</li><li>对于不能修改的类成员，删除相关的 set() 成员函数</li><li>隐藏那些不会在类之外被用到的成员函数</li><li>封装不适用的成员函数</li><li>合并那些实现非常类似的基类和派生类</li></ul><h3 id="安全的重构"><a href="#安全的重构" class="headerlink" title="安全的重构"></a>安全的重构</h3><p>重构是一种改善代码质量的强有力的技术,如果使用不当，重构给你带来的麻烦会比它所带来的好处还要多。</p><ul><li>保存初始代码</li><li>重构的步伐请小一些</li><li>同一时间只做一项重构</li><li>把要做的事情列出来</li><li>如果在一次重构中发现需要另一次的重构，你最好先将未来需要重构的地方列出来</li><li>多使用检查点</li><li>利用编译器的警告信息</li><li>重新测试</li><li>增加测试用例</li><li>检查对代码的修改。<strong>研究表明，相对于大规模修改，小的改动更容易出错</strong>。原因很简单：程序员们对于很小的修改常常不以为然。他们不会用纸和笔来推敲程序，也不会让其他人来检查代码。有时甚至根本不会运行这些代码来验证修改工作的正确性。</li><li>根据重构风险级别来调整重构方法。对于那些有一定风险的重构，<strong>谨慎才能避免出错</strong>。务必一次只处理一项重构。除了完成通常要做的编译检查和单元测试之外，还应该让其他人来检查你的重构工作，或是针对重构采用结对编程。 </li></ul><h3 id="不宜重构的情况"><a href="#不宜重构的情况" class="headerlink" title="不宜重构的情况"></a>不宜重构的情况</h3><ul><li><strong>不要把重构当做先写后改的代名词</strong>。重构的含义是在不影响程序行为的前提下改进可运行的代码。那些修补破烂代码的程序员们不是在重构，而是在拼凑代码。</li><li>避免重构代替重写。如果发现自己处于大规模的重构之中，就应该问问自己是否应该把这部分代码推倒重来，重新设计，重新开发。</li></ul><h3 id="重构策略"><a href="#重构策略" class="headerlink" title="重构策略"></a>重构策略</h3><p>对任何特定程序都能带来好处的重构方法本应是无穷无尽的。和其他的编程行为一样，重构同样受制于收益递减定律，同样也符合二八法则。</p><ul><li>在增加子程序时进行重构。检查相关的子程序是否都被合理地组织起来了。</li><li>在添加类的时候进行重构。</li><li>在修补缺陷的时候进行重构</li><li>关注易于出错的模块。烫手的山芋彻底解决才是有效的重构策略。</li><li>关注高度复杂的模块</li><li><strong>在维护代码时，确保代码在离开你的时候比来之前更健康</strong></li><li>定义清楚干净代码和拙劣代码之间的边界，然后尝试把代码移过这条边界</li></ul><p>Key Points</p><ul><li>修改是程序一生都要面对的事情，不仅包括最初的开发阶段，还包括首次发布之后。</li><li>在修改中软件的质量要么改进，要么恶化。软件演化的首要法则就是代码演化应当提升程序的内在质量。</li><li>重构成功之关键在于程序员应学会关注那些标志着代码需要重构的众多的警告或“代码臭味”。</li><li><strong>开发阶段的重构是提升程序质量的最佳时机</strong>，因为你可以立刻让刚刚产生的改变梦想变成现实。请珍惜这些开发阶段的天赐良机！</li></ul><h2 id="第25章-代码-性能-调整策略"><a href="#第25章-代码-性能-调整策略" class="headerlink" title="第25章 代码(性能)调整策略"></a>第25章 代码(性能)调整策略</h2><p>在极少情况下，程序员能正确确定出程序的瓶颈。但他们可能对这一部分代码痛下重手而顾此失彼，让另一部分代码成为制约性能的关键因素。这样，最终的结果是性能的下降。而如果优化放在整个系统完成之后，那么程序员就可以明确各个问题域以及各自的相对重要性,从而有效地对全部优化所用时间进行分配。（<strong>性能调整放在系统完成后处理</strong>）</p><p>在最初的开发阶段中，程序员老是把目光集中在优化上面会干扰自己对其他程序目标的理解和判断,让自己沉浸在那些最终并没有为用户提供多大价值的算法分析和晦涩的讨论中，把对正确性、信息隐藏、可读性等的考虑放到了第二位。实际上，在重视这些之后会更容易实施性能优化。如果首先考虑前者，那么后期优化工作通常只会影响到不足5%的程序代码。你是愿意回过头去处理5%代码的效能，还是去改善100%的程序的可读性?</p><p>过早的性能优化会对软件的整体质量产生严重威胁，受到影响的甚至包括软件的性能。</p><p><strong>4%的代码造成了50%甚至更多的性能瓶颈。</strong></p><p>常见的效率低下之源：</p><ul><li>I/O。尽可能在内存中操作数据，避免磁盘与网络 I/O 操作。</li><li>内存分页。引发操作系统交换内存页面的运算会比在内存同一页中进行的运算慢很多。</li><li>系统调用。调用系统子程序的代价常常是十分可观的。这些调用通常会涉及系统的上下文切换——保存程序状态、恢复内核状态，以及相反的操作。</li><li>解释型语言</li><li>错误。这些错误可能是没有去掉调试代码、忘记释放内存、数据表库设计失误、轮询并不存在的设备直到超时等</li></ul><p>尽管几乎不可能从一种方法中获得十倍的性能改进，但你可以将多种方法有效地结合起来，效果经常是惊人的。</p><h3 id="程序整体性能提升的方法"><a href="#程序整体性能提升的方法" class="headerlink" title="程序整体性能提升的方法"></a>程序整体性能提升的方法</h3><ul><li>修改需求</li><li>修改程序设计</li><li>修改类的设计</li><li>减少程序与操作系统的交互</li><li>避免冗余 I/O 操作</li><li>使用编译型语言替换解释型语言</li><li>使用更好的编译器优化</li><li>使用不同硬件提升性能</li><li>是否将代码调整看做性能优化的最后一招？</li></ul><p>Key Points</p><ul><li>性能只是软件整体质量的一个方面，通常不是最重要的。相对于代码本身的效率而言，程序的架构、细节设计以及数据结构和算法选择对程序的运行速度和资源占用的影响通常会更大。</li><li>定量测量是实现性能最优化的关键。定量测量需要找出能真正决定程序性能的部分，在修改之后,应当通过重复测量来明确修改是提高还是降低了软件的性能。</li><li><strong>绝大多数的程序都有那么一小部分代码耗费了绝大部分的运行时间</strong>。如果没有测量，你不会知道是哪一部分代码。</li><li>代码调整需要反复尝试，这样才能获得理想的性能提高。</li><li>为性能优化工作做好准备的最佳方式就是在最初阶段编写清晰的代码,从而使代码在后续工作中易于理解和修改。</li></ul><h2 id="第26章-代码调整技术"><a href="#第26章-代码调整技术" class="headerlink" title="第26章 代码调整技术"></a>第26章 代码调整技术</h2><p>优化循环的几个方面</p><ul><li><strong>编写高效循环的关键在于尽可能减少循环内部所做的工作</strong>。如果你可以在循环外面计算某语句或某部分语句，而在循环内部只是使用计算结果，那么就把它们放到外面。这是一种很好的编程实践，在很多情况下还可以改善程序的可读性。</li><li>把循环次数最多的循环放在最内层</li><li>用更高效的方式运算，如用移位代替乘除，将金额以分为单位进行整型运算，而非浮点数</li><li>数组维度尽可能浅</li><li>利用代数的恒等替换。如用<code>x&lt;y</code>判断替换<code>sqrt(x)&lt;sqrt(y)</code></li><li>尽可能将运行前就可确定的值确定下来，以加快运算速度。如一天的秒数固定为 86400s，无需每次运行时计算。</li></ul><h2 id="第27章-程序规模对构建的影响"><a href="#第27章-程序规模对构建的影响" class="headerlink" title="第27章 程序规模对构建的影响"></a>第27章 程序规模对构建的影响</h2><p>如果你习惯于开发小项目，那么你的第一个中大型项目有可能严重失控，它不会像你憧憬那样成功，而会变成一头无法控制的野兽。如果你已经习惯于开发大型项目，那么你所用的方法可能对小项目来说太正规了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872w9izp2j314k0t2wjr.jpg" alt=""></p><p><strong>项目越大越容易出错</strong>。这包含成员间复杂的沟通、需求评估的准确性、架构设计的合理性、组织结构、生产效率以及错误率等，你需要比小型项目花费更多的精力才能获得与小型项目一样的错误率。</p><p>在软件开发中，人越多，效率就越低！合适的人，合适的配置才能提高效率。高效的大型项目是建立一个分工明确、合作有序的「外科手术式的队伍」。外科手术中，有主刀医生、第一助手、麻醉医生、护士等，软件项目也应该有首席程序员、其他的程序员、管理者，文档编辑人员等。这样，既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。</p><blockquote><p>关于大型项目管理请参看《人月神话》<br>一点想法：如何评估编程管理是否合理？查看程序员的每天高质量的代码行数以及 bug 率。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872wpk2uhj30yc0h0act.jpg" alt=""></p><h2 id="第28章-管理构建"><a href="#第28章-管理构建" class="headerlink" title="第28章 管理构建"></a>第28章 管理构建</h2><p><strong>由一位受人尊敬的架构师来制定标准</strong>。有时项目的架构师只是一名在项目中待的时间非常长的资深闲杂人士，他已经不再接触与产品编码有关的事务了。由这种“架构师”定义出来的标准是会受到程序员怨恨的，因为他根本不了解程序员正在做的工作。</p><h3 id="鼓励良好的编码实践技术"><a href="#鼓励良好的编码实践技术" class="headerlink" title="鼓励良好的编码实践技术"></a>鼓励良好的编码实践技术</h3><ul><li>给项目的每一部分分派两个人。如果每行代码都由两个人共同完成，那么你可以保证至少有两个人认为这段代码是能工作的，而且是可读的。两人组队的办法有结对编程、导师带学生、复审等。</li><li>逐行复查代码。除了能为“原程序员离开项目”这一情况提供一层安全保障外，复查还能改善代码的质量，因为程序员知道会有其他人阅读他的代码。</li><li>要求代码签名。在认定代码完成之前，高级技术人员必须在代码清单上签字。</li><li>安排一些好的代码示例供人参考。你可以用一份清楚的样例说明自己的质量目标。类似的，编码标准手册里也可以主要包含一份“最佳代码清单”。这种手册更新起来要比文档容易的多，而且它能很容易地将编码风格中的细微之处表达清楚。</li><li>强调代码是公有财产。这会让开发者有意识的注意自己的代码质量。</li><li>奖励好代码。在开发你的激励机制时，请将以下方面考虑进去：<ul><li>所给予的奖励应该是程序员想要的</li><li><strong>只有非常出色的代码才应得到奖励</strong>。至于这位程序员是否有良好的合作态度或者上班是否准时都不重要，<strong>如果你的奖励不符合技术标准，你将失去信誉</strong>。如果你的技术水平还没有高到足以判断代码的优劣，那么就不要判断！这时候千万不要奖励，或者让你的团队来选择该奖励谁。</li><li>将奖励设置为每月一次，这样<strong>开发者的努力回报不会因为太久而放弃</strong>，促使大家都在努力提升自己。</li></ul></li><li>一份简单的标准。如果你正在管理一个编程项目，并且你具有一定的编程背景，那么有一种方法可以简单有效地获得好的工作成果——你只需要求“<strong>我必须能阅读并理解这个项目里的所有代码</strong>”。管理者不是技术专家这一事实反而有助于阻止产生“聪明的”或者难以理解的代码。</li></ul><blockquote><p>小思考：为什么优秀的开源程序的质量很高？<br>贡献者在开源前会优化代码的可读性，测试自己的代码质量，开源后会有其他开发者一同审视、运行代码、反馈问题，从而得到正向循环的优化。</p></blockquote><p>控制设计变更的指导原则</p><ul><li>遵循某种系统化的变更控制手续</li><li>成组地处理变更请求。当你在开发中有变更想法时，请将它记录下来，集中注意在开发工作中，在开发结束后统一处理这些变更。这避免你的开发工作被打断、不必要的变更，以及错过一些好的变更。</li><li>评估每项变更的成本。变更控制的实质是确定什么最重要，所以要确定变更的收益与成本是划算的。</li><li>提防大量的变更请求。尽管变更在一定程度上是不可避免的，<strong>变更请求的数量太大仍然是一个很关键的警报信号，它表明需求、架构或者上层设计做得不够好，从而无法有效地支持构建活动</strong>。对需求或者架构进行返工也许看上去代价昂贵，但是与“多次构建软件”或者“扔掉不需要的功能的代码”的高昂代价相比,还是值得考虑的。</li><li>成立变更控制委员会或者类似机构</li><li>警惕官僚主义，但也不要因为害怕官僚主义而排斥有效的变更控制</li></ul><h3 id="软件评估的方法"><a href="#软件评估的方法" class="headerlink" title="软件评估的方法"></a>软件评估的方法</h3><ul><li>建立目标。评估中是否包含会议、休假、节假日、培训以及其他非项目相关的活动？什么样的评估准确度才能达到你的目标？乐观评估与悲观评估会产生截然不同的结果吗？</li><li>为评估留出时间，并作出计划</li><li>清楚地说明软件需求。当要做的事情还没有确定时，谁也无法做出准确的评估。</li><li>在底层细节层面进行评估</li><li>使用若干不同的评估方法，并且比较其结果。小孩们很早就知道，如果分别向父母索要冰激凌，比仅向父亲或母亲索要的成功率要高，而且可能要到两份。</li><li>定期做重新评估。项目越接近完成，评估的准确度应该越高。要不时地将评估结果和实际结果进行比价衡量，用这一衡量结果来改善你对项目剩余部分的评估。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872uxkjruj31680u00yo.jpg" alt=""></p><p>一位妇女怀胎十月诞下一子，并不意味着十位妇女能只用一个月时间生下一个孩子。因此，对于某些无法拆分的任务，在落后时添加人手只会让项目延期更久，因为新手需要先熟悉项目才能产出，而熟悉项目又占用了已受训的开发者时间。仅仅增加人员还会导致交流的复杂度和数据也增加。此时，如果可以延长开发时间当然是最好的，如果不能，那就保留必须的功能，或者原有功能的简化版本。</p><h3 id="工作环境与生产效率的关系"><a href="#工作环境与生产效率的关系" class="headerlink" title="工作环境与生产效率的关系"></a>工作环境与生产效率的关系</h3><p>生产力与工作环境间有着很强的关联性。如果开发者旁边坐着电话销售或者售后，他们是无论如何都无法产出高质量代码的。</p><blockquote><p>管理者应该关注提升员工的有效生产力。如果能通过一次投入的改善环境来持续提升生产力，何乐而不为呢？比如针对开发者设置格子间办公，自由的工作时间，每周允许员工两天远程办公等。只要员工能够按时高质量完成工作，我觉得工作形式不必拘泥。</p></blockquote><blockquote><p>关于远程办公与办公室办公的一些讨论：远程办公有优势有劣势，对于独立性强的工作、或者个人能力超强的人，这比较合适；但是对于协同非常频繁、或者需要大量组织管理工作的人来说，这只会降低生产力。如果每周允许几天的远程办公，既可以节省上下班时间，又可以提升员工的幸福感。如果完全远程办公，则会导致团队协作效率低下，团队氛围差等问题。</p></blockquote><blockquote><p>关于开放式办公与格子间办公的一些讨论：开放式办公导致噪音污染与视觉混乱，无法集中注意力、影响独立思考，以及剥夺隐私等问题。真正便于员工创造价值的设计在于空间的“可选择性”，即赋予员工更多的自主选择权。员工可以在不同类型的功能区内选择适合自己工作方式的位置，需要静下心来工作时可以独辟一个区域办公，需要沟通合作时围坐在一起协同工作。</p></blockquote><h3 id="管理你的管理者"><a href="#管理你的管理者" class="headerlink" title="管理你的管理者"></a>管理你的管理者</h3><p>在软件开发中，非技术出身的管理者随处可见，具有技术经验但却落后于这个时代十年以上的管理者也比比皆是。技术出色并且其技术与时俱进的管理者实属凤毛麟角。如果你正在为一位这样的管理者工作，那么就尽可能地保住你的工作吧。这可是非常难得的待遇。</p><p>如果你的管理者是很典型的那种，那么你将不得不肩负一项不值得羡慕的责任——管理你的管理者。“管理你的管理者”意味着，你需要告诉他应该这样做而不应该那样做。其要诀在于，你要表现得使你的管理者认为他仍然在管理你。<br>下面就是一些应对管理者的方法:</p><ul><li>把你希望做什么的念头先藏起来，等着你的管理者组织一场有关你的想法的头脑风暴集体讨论。</li><li>把做事情的正确方法传授给你的管理者。这是一项需要持之以恒的工作，因为管理人员经常会被提升、调迁或者解聘。</li><li>关注你的管理者的兴趣，按照他的真正意图去做，而不要用些不必要的实现细节来分散其注意力。(请把它设想成是对你工作的一种“封装”。)</li><li>拒绝按照你的管理者所说的去做，坚持用正确的方法做自己的事。</li><li>换工作。<br>最佳的长远的解决方案是教育你的管理者。这样做通常很难，但是你可以通过阅读卡内基的《人性的弱点》一书来做好必要的准备。</li></ul><h2 id="第29章-集成"><a href="#第29章-集成" class="headerlink" title="第29章 集成"></a>第29章 集成</h2><h3 id="从集成中，我们可以获得："><a href="#从集成中，我们可以获得：" class="headerlink" title="从集成中，我们可以获得："></a>从集成中，我们可以获得：</h3><ul><li>更容易诊断缺陷</li><li>缺陷更少</li><li>脚手架更少</li><li>花费更少的时间获得第一个能工作的产品</li><li>更短的整体开发进度表</li><li>更好的顾客关系</li><li>增强士气</li><li>增加项目完成的机会</li><li>更可靠地估计进度表</li><li>更准确的现状报告</li><li>改善代码质量</li><li>较少的文档</li></ul><h3 id="增量集成的益处"><a href="#增量集成的益处" class="headerlink" title="增量集成的益处"></a>增量集成的益处</h3><ul><li>易于定位错误</li><li>及早在项目里取得系统级的成果</li><li>改善对进度的监控</li><li>改善客户关系。客户喜欢看到产品在一点点的前进</li><li>更加充分地测试系统中的各个单元</li><li>能在更短的开发进度计划内构造出整个系统</li></ul><h3 id="每日构建与冒烟测试"><a href="#每日构建与冒烟测试" class="headerlink" title="每日构建与冒烟测试"></a>每日构建与冒烟测试</h3><ul><li>项目需要每日构建。可以将每日构建视为项目的脉搏。</li><li>检查失败的构建</li><li>每天进行冒烟测试。冒烟测试应该从头到尾演练整个系统。它不必做到毫无遗漏，但是应该能够暴露主要问题。冒烟测试应该足够彻底：如果这一构建通过了测试，那么就能假定它已经足够稳定，可以接受更加彻底的测试了。</li><li>让冒烟测试与时俱进。随着系统的开发，冒烟测试变得更加彻底。</li><li>将每日构建与冒烟测试自动化</li><li>成立构建小组</li><li>仅当有意义时，才将修订加入构建中</li><li>但别等太久才将修订加入进来。如果某个开发人员接连两三天都不checkin他做的改动，那么这名开发人员所做的工作就是有风险的。频繁的集成有时迫使你将单一功能的构建分为若干阶段进行。这一额外开销是可接受的，是为“减小集成的风险、改善项目状况的能见度、改善可测试性，以及频繁集成的其他益处”而付出的代价。</li><li>要求开发人员在把他的代码添加到系统之前，进行冒烟测试</li><li>为即将添加到构建的代码准备一块暂存区。“每日构建过程的成功”部分取决于“知晓哪些构建是好的，哪些是坏的”。在测试自己的代码时，开发人员需要依赖“好的系统”。大多数团队解决这个问题的办法是，为开发人员认为“已准备好添加到构建中”的代码准备一块暂存区。新的代码进入暂存区，构建出新的构建，如果新的构建是可接受的，那么将新的代码合并到主源码中。在小型和中型项目中，版本控制系统可提供这一功能。开发人员将新的代码check in到版本控制系统中。对于那些想要使用已知是好的构建的开发人员，他们只需在checkout文件时设置一个日期选项，让版本控制系统根据所设日期取回上次的好的构建。</li><li>惩罚破坏构建的人</li><li>在早上发布构建。这样可以在工作时间处理构建中发现的问题，避免加班时相关人员不在，或者匆忙解决问题。</li><li>即使有压力,也要进行每日构建和冒烟测试。当进度压力变大时，维护每日构建所需的工作看起来就像是奢侈的额外开销了。其实相反的观点才是对的。每日构建强调了纪律，并让处于高压锅里的项目不出轨。代码仍然会有变混乱的倾向，不过构建过程每天都在把这种倾向拉回来。</li></ul><p>项目越大，增量集成越重要。</p><h2 id="第30章-开发工具"><a href="#第30章-开发工具" class="headerlink" title="第30章 开发工具"></a>第30章 开发工具</h2><p>编程未来会被 AI 替代吗？<br>答案是不会的。因为编程从根本上说就是困难的——即便有好的工具支援。 无论能用到哪些工具，程序员都必须与凌乱的真实世界较力；我们须得严密地思考前后次序、依赖关系、异常情况；而且我们还要与无法说清楚自己想法的最终用户交往。我们始终要应对连接到其他软件或硬件的定义不清的接口，还要解决规章制度、业务规则以及其他复杂性之源，这些复杂性来自计算机编程之外的世界。</p><h2 id="第31章-布局与风格"><a href="#第31章-布局与风格" class="headerlink" title="第31章 布局与风格"></a>第31章 布局与风格</h2><p>实际上，着重逻辑表现通常并不会做出难看的代码——除非代码的逻辑原本就很丑陋。</p><p>编程工作量的一小部分是写让机器读的程序，大部分工作是写能让他人看懂的程序。</p><p>你无法想象会有这样一本书：其中没有空格隔开单词，不分段落，也没有章节之分。这样的书或许从头至尾还是可以读的，但几乎不可能翻阅去找到某个关键句，或者定位某个重要的段落。更致命的大概是，书的这种布局不能对读者展示作者打算如何组织信息，而作者的组织方法正是理解有关主题逻辑结构的最重要线索。<br>将书分成一些章节、段落以及句子，就向读者展现出了作者组织主题的思路。如果这一组织不够明确，读者就必须自己去摸索，这将极大地增加读者的负担，或许他们自始至终都无法搞清有关主题的组织方式。<br>程序里包含的信息密度超过多数书籍里的信息密度。你也许一两分钟就能读完并理解书的一页内容，大部分程序员却不能以类似的速度看懂未经修饰的程序代码清单。程序应该比书提供更多的组织线索，而不是相反。</p><h2 id="第32章-自说明代码"><a href="#第32章-自说明代码" class="headerlink" title="第32章 自说明代码"></a>第32章 自说明代码</h2><p>对于精心编写的代码而言，注释不过是美丽衣裳外的小饰物而已。</p><p>类</p><ul><li>你的类接口体现出某种一致的抽象吗?</li><li>你的类名有意义吗，能表明其中心意图吗?</li><li>你的类接口对于如何使用该类显而易见吗?</li><li>你的类接口能抽象到不需考虑其实现过程吗?能把类看成是黑盒吗?</li></ul><p>子程序</p><ul><li>你的每个子程序名都能准确地指示该子程序确切干些什么吗?</li><li>你的各子程序的任务明确吗?</li><li>若各子程序中自成一体后更有用，你都将其各自独立出来了吗?</li><li>每个子程序的接口都清晰明了吗?</li></ul><p>数据名</p><ul><li>类型名描述有助于说明数据声明吗?</li><li>你的变量名有意义吗?</li><li>变量只用在其名字所代表意义的场合吗?</li><li>你的循环变量名能给出更多信息，而不是i、j、k之类的吗?</li><li>你用了名字有意义的枚举类型，而非临时拼凑的标识或者布尔变量吗?</li><li>用具名常量代替神秘数值或者字符串了吗?</li><li>你的命名规范能区分类型名、枚举类型、具名常量、局部变量、类变量以及全局变量吗?</li></ul><p>数据组织</p><ul><li>你根据编程清晰的需要，使用了额外变量来提高清晰度吗?</li><li>你对某变量的引用集中吗?</li><li>数据类型简化到了最低复杂度吗?</li><li>你是通过抽象访问子程序(抽象数据类型)来访问复杂数据吗?</li></ul><p>控制</p><ul><li>代码中的正常执行路径很清晰吗?</li><li>相关语句放在一起了吗?</li><li>相对独立的语句组打包为子程序了吗?</li><li>正常情况的处理位于if语句之后，而非在else子句中吗?</li><li>控制结构简单明了，以使复杂度最低吗?</li><li>每个循环完成且仅完成一个功能，是像定义良好的子程序那么做吗?</li><li>嵌套层次是最少吗?</li><li>逻辑表达式通过额外添加布尔变量、布尔函数和功能表简化了吗? </li></ul><p>布局</p><ul><li>程序的布局能表现出其逻辑结构吗?</li></ul><p>设计</p><ul><li>代码直截了当吗?是不是避免了自作聪明或新花样?</li><li>实现细节尽可能隐藏了吗?</li><li>程序是尽可能采用问题领域的术语，而非按照计算机科学或者编程语言的术语编写的吗?</li></ul><h3 id="注释的种类"><a href="#注释的种类" class="headerlink" title="注释的种类"></a>注释的种类</h3><ul><li>重复代码。重复性注释只是用不同文字把代码的工作又描述一次。它除了给读者增加阅读量外，没有提供更多信息。</li><li>解释代码。解释性注释通常用于解释复杂、敏感的代码块。在这些场合它们能派上用场，但通常正是因为代码含混不清，才体现出这类注释的价值。<strong>如果代码过于复杂而需要解释，最好是改进代码，而不是添加注释</strong>。使代码清晰后再用概述性注释或者意图性注释。</li><li>代码标记。用于提醒开发者某处的工作未做完或者某些注意事项，如TODO。代码标记最好有统一的风格，以便后期统一检索处理。</li><li>概述代码。将若干代码行的意思以一两句话说出来。这种注释比重复性注释强多了，因为读者读注释能比读代码更快。概述性注释对于要修改你代码的其他人来说尤其有用。</li><li>代码意图说明。目的性注释用来指明一段代码的意图，它指出要解决为问题，而非解决的方法，如<code>//get current employee information</code></li><li>传达代码无法表达的信息。某些信息不能通过代码来表达，但又必须包含在源代码中。这种注释包括版权声明、保密要求、版本号等杂项信息；与代码设计有关的注意事项；相关要求或者架构文件的索引；联机参考链接；优化注记：诸如Javadoc、Doxygen 等编辑器要求有的注释，等等。</li></ul><p>对于完工的代码，只允许有的三种注释类型：代码无法表述的信息、目的性注释和概述性注释。</p><h3 id="高效注释"><a href="#高效注释" class="headerlink" title="高效注释"></a>高效注释</h3><p>高效注释并不费时。注释太多并不比注释太少好，你很容易达到折中点。</p><p>注释占用太多时间通常归因于两点。一是，注释的风格可能耗时或枯燥乏味。如果这样，请另谋新的风格。需要庞大工作量的注释风格维护起来也会令人头痛。如果注释不便修改，人们就不愿意修改。于是乎，注释就会变得不准确，起到误导作用，反而还不如没有注释。二是因为说明程序干什么的话不好想出来，所以写注释太难。这通常是你没有真正理解程序的信号。“写注释”所占用的时间其实都用在了更好地理解程序上面，而不管你写不写注释，这些时间注定是得花的。</p><ul><li>不要使用<code>-</code>，<code>...</code>等符号来对齐使注释美观，在修改这样的注释时会平添大量工作。如果话大量时间增删横线只是为了对齐注释，你就不是在编程，而是在浪费时间。去找个高效点的风格吧。有个办法是采取固定长度的横线，不管注释内容有多长。这样的横线不必维护，还能用 IDE 的宏命令方便地添加。<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//Variable</span>      Meaning</span><br><span class="line"><span class="string">//--------</span>      <span class="params">-------</span></span><br><span class="line"><span class="string">//xPos</span> <span class="string">........</span> XCorrdinate Position</span><br><span class="line"><span class="string">//yPos</span> <span class="string">........</span> YCorrdinate Position</span><br><span class="line"><span class="string">//psblScrMax</span> <span class="string">..</span> Possible Score Maximum</span><br></pre></td></tr></table></figure></li><li>用伪代码编程法减少注释时间。假如写代码前以注释先勾勒出代码，你就会占尽先机。完成代码之日，也是注释写好之时，不必再去专门花时间注释。由于在填充低层次的编程语言代码前，就已写出高层次的伪代码，因而可以获得所有设计方面的好处。</li><li>养成边写代码边写注释的好习惯，而不是在编写完代码后再去补注释</li><li>注释应表达代码的意图</li><li>代码本身应尽力做好说明</li><li>注释代码段时应注重“为何做（why）”而不是“怎么做（how）”</li><li>用注释为后边的内容做铺垫</li><li>让每个注释都有用。太多的注释只会把阐述的代码搞得含混不清。<strong>与其写很多注释，不如对代码本身的可读性下功夫</strong>。</li><li>说明非常规做法。如果你用不常用的方法以求提升性能，请用注释说明常用方法是如何实现，并量化你的方法提升了多少性能</li><li>不要使用缩略语。注释不应有歧义，应该易读且无需猜测缩写的含义。</li></ul><h3 id="最佳注释量"><a href="#最佳注释量" class="headerlink" title="最佳注释量"></a>最佳注释量</h3><p>IBM 研究指出，约每十条语句有一个注释，这样的密度时程序清晰度最高，过高或过低的 密度都会使代码难以理解。</p><p>如果熟练运用伪代码编程法，日久天长你就会每几行有个注释。不过，注释数目对方法本身起到副作用。与其操心注释数目，倒不如倾力于检查每个注释有无效用。如果注释说明了写某代码的来由，又符合本章确立的各原则，这样的注释就足够了。</p><h3 id="注释数据声明"><a href="#注释数据声明" class="headerlink" title="注释数据声明"></a>注释数据声明</h3><ul><li>注释数值单位。如果某数值表示长度，请指明长度单位是英寸、英尺、米还是千米。不要觉得单位不言自明——新手不知道。比较好的一种方式是，很多情况下可以<strong>将单位写进变量名，而不再用注释</strong>。表达式<code>distanceToSurface = marsLanderAltidude</code>也许正确，但<code>distanceToSurfaceInMeters = marsLanderAltidudeInFeet</code>则明显不对。</li><li>对数值的允许范围给出注释。如果变量值有一个期望范围，就应该说明这个范围。</li><li>注释编码含义。如 1001 表示用户认证错误，1002 表示服务配置错误等</li><li>注释对输入数据的限制。采用这种方法更能让代码具有自检能力。</li><li>注释“位标志”。如果变量用作位域，就应该说明每个数据位的含义</li><li>注释全局数据。如果使用了全局数据，要在其声明处做出注释。注释要指出该数据的目的、为何必须是全局数据。在使用此数据的每一处，都突出它是全局数据。好的命名规范是凸显变量全局性的首选办法，如果欠缺这样的规范，则可以用注释代劳。</li></ul><h3 id="注释子程序"><a href="#注释子程序" class="headerlink" title="注释子程序"></a>注释子程序</h3><ul><li>注释应靠近其说明的代码</li><li>在子程序上边用一两句话说明。如果不能用一两句话说清楚，有必要考虑你到底想让子程序做什么。</li><li>在声明参数处注释这些参数。注释并非说明的唯一形式，变量名取的足够好就能省掉注释。</li><li>利用诸如 Javadoc 之类的代码说明工具</li><li>分清输入与输入数据</li><li>注释接口假设。写子程序时，若意识到自己在做接口假设，应立即将其记录下来</li><li>对子程序的局限性做注释。如果子程序提供数值结果，请指出结果的精确度；要是某些条件下的计算没有定义，请标注这些条件；假定子程序碰到麻烦时有默认行为，请说明此行为；若希望子程序只工作于特定大小的数组或表格，请指出这一情况；如果你知道对程序做某些修改会损坏此子程序，请说明是哪些修改；如若开发子程序时想起什么问题，也请注释出来。</li><li>说明子程序的全局效果。如果子程序会修改全局数据，要确切描述它对全局数据做了些什么。</li><li>记录所用算法的来源。如果用了从一本书或杂志上得来的算法，请注释其出处的卷号和页码。如果是自行开发的算法，要指出在何处读者可以找到对其的解释。</li><li>用注释标记程序的各个部分</li></ul><h3 id="标注类的一般原则"><a href="#标注类的一般原则" class="headerlink" title="标注类的一般原则"></a>标注类的一般原则</h3><ul><li>说明局限性、用法假设等</li><li>注释类接口。其他程序员不看类实现就能明白类的用法吗？如果不是，类的封装就有严重问题。类接口应该包含别人使用该类时所需的全部信息。</li><li>不要在类接口处说明实现细节封装。最重要的一个规则是仅公开那些“需要，知道”的信息。若拿不定是否应公开某项信息，就隐藏之。因此，类接口文件应当只有类的用法信息，而不应有需要实现或维护类内操作的信息。</li></ul><h3 id="注释文件的一般原则"><a href="#注释文件的一般原则" class="headerlink" title="注释文件的一般原则"></a>注释文件的一般原则</h3><ul><li>说明各文件的意图和内容。如果文件包含多个类，请解释为何这些类需要放到一个文件中。假如将程序划分为多个源文件并非出于模块化的考虑，则对各文件用意的说明将对修改程序的程序员更有帮助。如果别人要找出做某事的子程序在哪儿，文件头注释有助于确定该文件含不含此子程序吗？</li><li>将姓名、邮件及电话号码等放到注释块中</li><li>包含版本控制标记</li><li>将文件命名为与其内容相关的名字</li></ul><p>Key Points</p><ul><li>该不该注释是个需要认真对待的问题。差劲的注释只会浪费时间，帮倒忙；好的注释才有价值。</li><li>源代码应当含有程序大部分的关键信息。只要程序依然在用，源代码比其他资料都能保持更新，故而将重要信息融入代码是很有用处的。</li><li>好代码本身就是最好的说明。如果代码太糟，需要大量注释，应先试着改进代码，直至无须过多注释为止。</li><li>注释应说出代码无法说出的东西——例如概述或用意等信息。</li><li>有的注释风格需要许多重复性劳动，应舍弃之，改用易于维护的注释风格。</li></ul><h2 id="第33章-个人性格"><a href="#第33章-个人性格" class="headerlink" title="第33章 个人性格"></a>第33章 个人性格</h2><p><strong>代码是70%的时间在阅读，30%的时间在运行；20%的时间在开发，80%的时间在维护。</strong><br>编程首先是与人交流，其次才是与计算机交流。</p><p>不要用8小时来维护2小时不在状态时写的代码。</p><p>承认自己的智力有限并通过学习来弥补，你会成为更好的程序员。<strong>你越是谦虚，进步就越快</strong>。</p><p>经过大量而长期的零零碎碎的工作，我们才成为实践与科学领域的权威专家。如果你能<strong>满怀信心地每天辛勤工作</strong>，早晚有一天会发现自己已成为这代人的佼佼者。    — 威廉 · 詹姆斯</p><p>犯错不是罪过，从中学不到什么才是罪过。</p><p>学习编程的一个特别好的途径是研究高手的程序。</p><p>技术带头人会为人写代码，而非机器。真正的高手所写的代码，像水晶一样晶莹剔透，还配有文档。他们可不会浪费其宝贵的脑力，去重新组织用一句注释就能说清楚的某块代码逻辑。</p><p>诚实：</p><ul><li>不是高手时不要假装是高手<ul><li>（如果你不懂装懂，还怎么学习新东西呢？最好还是装作自己啥都不懂，听听别人咋说，从他们那里学到新内容，并能了解他们是否真的清楚所讨论的东西）</li></ul></li><li>乐于承认错误</li><li>力图理解编译器的警告，而非置之不理</li><li>透彻理解自己的程序，而不要只是编译看看能否运行<ul><li>（请确保在将程序丢给编译器之前，你已经对其有了较大的把握）</li></ul></li><li>提供实际的状况报告</li><li>提供显示的进度方案，在上司面前坚持自己的意见<ul><li>（认真评估项目所需时间，将真实情况汇报，如果上司要求缩短时间，请坚持自己的意见，要么投入更多的人力，要么去掉一部分功能）</li></ul></li></ul><p>偷懒表现在一下方面：</p><ul><li>拖延不喜欢的任务</li><li>迅速做完不喜欢的任务，以摆脱之</li><li>编写某个工具来完成不喜欢的任务，以便再也不用做这样的事情了<ul><li>一劳永逸的懒，无疑是最具产值的偷懒形式</li></ul></li></ul><p><strong>有效编程中最重要的工作是<em>思考</em></strong>，而人思考时通常看上去不会很忙，如果和我共事的程序员总是忙个不停，我会认为他并非优秀的程序员，因为他没有用最有价值的工具——自己的脑袋。</p><p>多数时候软件开发中坚持其实就是没有好处的“固执”。当在某段新代码上卡壳时，坚持很难让人称道。不妨另辟蹊径，尝试重新设计类，或者绕过去，以后回头再试试。当一种办法行不通时，正好可以换个办法试试。</p><p>调试时，花 4 个小时干掉某个错误肯定会很有满足感；但通常最好只要有一段时间没有进展，比如 15 分钟，就该放弃排错过程，让潜意识仔细品品。想个其他法子将问题绕开：从头编写有麻烦的代码段；清理思绪后再来做。和计算机错误斗气是不明智的，更好的方法是避开它们。</p><p>知道何时放弃很难，但这是必须面对的问题。当你遭受挫折时，提出此问题正是时候。提出并不是说这是就放弃，而是该为目前的行为设置底线了：“要是这个方法30分钟内还不能解决问题，我就会花十分钟想些其他办法，再用一个小时尝试最可行的办法”。</p><p>任何日后出色的程序员前几年就做得很好。从那以后，程序员好坏就定型了。——比尔 · 盖茨</p><p>Key Point</p><ul><li>人的个性对其编程能力有直接影响</li><li>最有关系的性格为：谦虚、求知欲、诚实、创造性和纪律，以及高明的偷懒</li><li>程序员高手的性格与天分无关，而任何事都与个人发展相关</li><li>出乎意料的是，小聪明、经验、坚持和疯狂既有助也有害</li><li>很多程序员不愿主动吸收新的知识和技术，只依靠工作时偶尔接触新的信息。如果能抽出少量时间阅读和学习编程知识，要不了多久就能鹤立鸡群</li><li>好性格与培养正确的习惯关系甚大。要成为杰出的程序员，先要养成良好习惯，其他自然水到渠成</li></ul><h2 id="第34章-软件工艺的话题"><a href="#第34章-软件工艺的话题" class="headerlink" title="第34章 软件工艺的话题"></a>第34章 软件工艺的话题</h2><h3 id="征服复杂性"><a href="#征服复杂性" class="headerlink" title="征服复杂性"></a>征服复杂性</h3><p>软件开发的核心是降低系统的复杂度</p><ul><li>如果采用定义良好的一致的类接口，就无须操心类的实现细节，从而简化自己的工作。</li><li>采用编码规范主要也是为了降低复杂度。</li><li>各种形式的抽象对于管理复杂度都是很强大的工具。计算机科学最了不起的成就就是从机器语言跃进到高级语言（程序员不再操心特定的硬件细节，而能专心于编程），子程序的想法则是另一个巨大的进步，随后的进步是类和程序包。</li><li>以功能对变量命名能提升抽象层次。</li></ul><h3 id="精选开发过程"><a href="#精选开发过程" class="headerlink" title="精选开发过程"></a>精选开发过程</h3><ul><li>对于小项目，程序员的个人才能对软件质量影响最大；对于多人协作的项目，组织性的重要超过了个人技能。</li><li>需求失误的成本远高于构建错误</li><li>打好地基后再盖房子</li><li>软件开发中，质量一开始就要逐步建立起来。那种先拼凑代码，再通过测试提出缺陷的思路是完全错误的。</li><li>不成熟的优化是另一个过程性错误。行之有效的开发过程是在开始时粗调，后来再进行精调。如果你是个雕刻匠，应在打磨细节前就将大致的轮廓刻画出来。过早优化浪费时间，因为你会花时间去精雕细琢原本不必做的代码段。你可能会打磨本已足够短小足够快速的代码段；你可能会润色日后将要丢弃的代码。</li><li>如果遵照写伪代码再对其填充代码的步骤，就能享受到自上而下的设计好处。你也应确保向代码中加入注释，而不是以后再添加进去。</li></ul><h3 id="首先为人写程序，其次才是机器"><a href="#首先为人写程序，其次才是机器" class="headerlink" title="首先为人写程序，其次才是机器"></a>首先为人写程序，其次才是机器</h3><p>差的程序：好似迷宫一样令人摸不清方向，夹杂着各种花招和无关注释。<br>好的程序：算法精准，结构紧凑，性能好，注释清晰得体。</p><ul><li>好的程序在以下方面都有正面影响：<ul><li>可理解性</li><li>容易复查</li><li>错误率</li><li>调试</li><li>可修改性</li><li>开发时间——上述因素之综合</li><li>外在质量——上述因素之综合</li></ul></li><li>可读的代码写起来并不比含糊的代码多花时间，运行时至少不比后者慢。如果你能轻松阅读自己写的代码，确保该代码能工作也会更容易。</li><li>使代码可读性好并非是开发过程中的可有可无部分，为了节省编写代码的时间而不顾阅读它的时间，是不经济的。你应该努力写好代码,这可以一次做到的；这远比你努力去读坏代码划算，因为那不得不一次次地反复做。</li><li>提高可读性的方法：好的类名(及子程序名、变量名)、精心的布局、短小的子程序；将复杂的逻辑测试隐藏在布尔函数中；把中间结果赋值给变量，以使复杂运算清晰化等等。任何单一的技术对程序可读性的改善都是些许的，但许多微小的改进迭加起来，就能使程序面貌一新。</li></ul><h3 id="借助规范集中注意力"><a href="#借助规范集中注意力" class="headerlink" title="借助规范集中注意力"></a>借助规范集中注意力</h3><ul><li>规范能够精确地传达重要信息。采用命名规范后，区区一个字符就可以区分局部变量、类变量和全局变量；大小写字母能精确区别类型、具名常量和变量;对齐规范能够精确指示出语句间的关系。</li><li>规范可以使你免除各种风险。通过建立禁止使用危险做法的规范，可以在需要用它们时限制这些做法，或者防范它们可能的危险。例如，通过禁止全局变量或在一行里写多条语句，避免这些危险的用法。通过要求对复杂表达式加括号、在指针被删除后要置空以防误用，防范可能的危险。</li><li>规范增加了对底层工作的可预见性。对存储器请求、错误、输入/输出和类接口有规范的处理，能够为代码加入有意义的结构，便于其他程序员弄懂你的程序。全局变量让读者变得没有把握。有了好的规范，你和你的读者就有了更好的默契，就能减少必须消化的细节数量，反过来又进一步加深了对程序的理解。</li><li>在大型项目工作中，有时程序员们会规范过了头。由于设立许多规范和原则,光是记住这些东西都颇花时间。但小型项目的程序员常常缺少规范，则是因为没有充分体会到自觉遵守规范时的好处。应理解其真正价值，并充分利用规范；使用规范以提供所需的结构。</li></ul><h3 id="当心落石"><a href="#当心落石" class="headerlink" title="当心落石"></a>当心落石</h3><ul><li>一天写了一大堆代码，之后花两个星期去调试不是巧妙的办法</li><li>深入一个程序时，应注意那些指示程序中某些地方设计欠佳的警告信息。不容易写注释，不容易命名变量，不容易将问题分解成接口清晰的几个类，都说明编码前还需要再考虑设计。无聊的命名或者无法在注释中精确地描述一段代码的意思，同样是不好的信号。到你对设计胸有成竹时，底层的细节代码就会如泉涌而来。</li><li>警惕程序出现难以理解的迹象。任何不安都是暗示。要是连你都觉得难，以后的程序员就更不用提了。如果你能费神地改进程序，他们会感激你的。不是看懂代码，而是靠猜测来理解代码，同样也说明代码太复杂。有难度就说明有问题，所以应设法简化之。</li><li>找不到错误最常见的原因常常是因为忽视错误，这些错误在测试输出中能够看到，却没有人注意。</li><li>关注警告信息与否也直接影响到最终产品的质量。</li></ul><hr><blockquote><p>读后感：在编程的世界里，虽然各种语言百花齐放，但我们所遇到的大部分的问题都是相似的。幸好我们处在了技术语言的成熟期，而且所遇到的 99% 的问题 Google 都已经有了答案。</p><p>在编程中最困难的问题仍然是人的问题，比如团队协作、代码风格、代码质量等。任何竞争的本质都是人的竞争，而人在做任何工作时都要勤于思考，互联网的普及让每个人更加便捷的获取知识。我们只有不断向优秀的人学习，持续思考，才能让每一天都不一样。当我们在向上看到语言框架百花齐放时，更需要向下关注计算机基础，并且不要让自己局限在一门语言中。没有最好的工具，只有最合适的工具。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用命令 FAQ</title>
      <link href="/post/git-faq/"/>
      <url>/post/git-faq/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7blak7yufj30wk09gmyk.jpg" alt="git图解"></p><a id="more"></a><p>在开始前，让我们先来讲几个概念，这将更好的让我们理解接下来的内容：</p><h4 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h4><p>我们正在编辑的内容就是在工作区，上图中的 workspace。</p><h4 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h4><p>我们将工作区的内容通过<code>git add</code>命令就提交到了暂存区。 上图中的 index</p><h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4><p>我们将暂存区的内容通过<code>git commit</code>就提交到了本地仓库。内容的修改从工作区 ==&gt; 暂存区 ==&gt; 本地仓库是顺序执行的。上图中的 repository</p><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>Git 是一个分布式管理工具，所以当我们将修改的内容提交到本地仓库后，就可以通过<code>git push</code>命令推送到远程仓库与他人协作完成项目。</p><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>分支可以理解为像树枝一样来管理我们的代码，分支很好的解决了多人协作的问题。当我们需要开发一个新的功能时，从稳定分支（通常是 master 或者 release）新建分支开发，当开发完成并测试通过后，再通过<code>git merge</code>合并入稳定分支发布。</p><h1 id="FAQ"><a href="#FAQ" class="headerlink" title=" FAQ "></a><center> FAQ </center ></h1><h2 id="工作区-1"><a href="#工作区-1" class="headerlink" title="工作区"></a>工作区</h2><h3 id="怎样将工作区中的内容提交到暂存区？"><a href="#怎样将工作区中的内容提交到暂存区？" class="headerlink" title="怎样将工作区中的内容提交到暂存区？"></a>怎样将工作区中的内容提交到暂存区？</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> [./filename]</span></span><br></pre></td></tr></table></figure><h3 id="我在工作区修改了一些文件用于调试，完成后想丢弃所有修改"><a href="#我在工作区修改了一些文件用于调试，完成后想丢弃所有修改" class="headerlink" title="我在工作区修改了一些文件用于调试，完成后想丢弃所有修改"></a>我在工作区修改了一些文件用于调试，完成后想丢弃所有修改</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout .</span><br></pre></td></tr></table></figure><h3 id="我想丢弃某个文件的修改"><a href="#我想丢弃某个文件的修改" class="headerlink" title="我想丢弃某个文件的修改"></a>我想丢弃某个文件的修改</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --<span class="string">[filename]</span></span><br></pre></td></tr></table></figure><h3 id="我想暂存这些调试的代码"><a href="#我想暂存这些调试的代码" class="headerlink" title="我想暂存这些调试的代码"></a>我想暂存这些调试的代码</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git stash</span><br></pre></td></tr></table></figure><h3 id="我想看看有哪些暂存的内容"><a href="#我想看看有哪些暂存的内容" class="headerlink" title="我想看看有哪些暂存的内容"></a>我想看看有哪些暂存的内容</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="built_in">list</span></span><br></pre></td></tr></table></figure><h3 id="我想将某个暂存的内容复制到工作区"><a href="#我想将某个暂存的内容复制到工作区" class="headerlink" title="我想将某个暂存的内容复制到工作区"></a>我想将某个暂存的内容复制到工作区</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply <span class="symbol">stash@</span>&#123;n&#125;</span><br></pre></td></tr></table></figure><h3 id="我想将某个暂存的内容剪切到工作区"><a href="#我想将某个暂存的内容剪切到工作区" class="headerlink" title="我想将某个暂存的内容剪切到工作区"></a>我想将某个暂存的内容剪切到工作区</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">pop</span> stash@&#123;n&#125;</span><br></pre></td></tr></table></figure><h3 id="我想删除某个暂存"><a href="#我想删除某个暂存" class="headerlink" title="我想删除某个暂存"></a>我想删除某个暂存</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash drop <span class="symbol">stash@</span>&#123;n&#125;</span><br></pre></td></tr></table></figure><h3 id="我想删除所有暂存内容"><a href="#我想删除所有暂存内容" class="headerlink" title="我想删除所有暂存内容"></a>我想删除所有暂存内容</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="built_in">clear</span></span><br></pre></td></tr></table></figure><h3 id="我想将-git-中的某个文件取消跟踪，并保留本地文件"><a href="#我想将-git-中的某个文件取消跟踪，并保留本地文件" class="headerlink" title="我想将 git 中的某个文件取消跟踪，并保留本地文件"></a>我想将 git 中的某个文件取消跟踪，并保留本地文件</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached <span class="string">[filename]</span></span><br></pre></td></tr></table></figure><h3 id="已跟踪的文件也要每次-add-后-commit-吗？"><a href="#已跟踪的文件也要每次-add-后-commit-吗？" class="headerlink" title="已跟踪的文件也要每次 add 后 commit 吗？"></a>已跟踪的文件也要每次 add 后 commit 吗？</h3><p>不需要，可以使用 <code>git commit -am &#39;msg&#39;</code> 合并两个命令</p><h3 id="我回退到了某个提交，如何再重新回到最新的提交？"><a href="#我回退到了某个提交，如何再重新回到最新的提交？" class="headerlink" title="我回退到了某个提交，如何再重新回到最新的提交？"></a>我回退到了某个提交，如何再重新回到最新的提交？</h3><p><code>git reflog</code>命令记录了你的操作记录，在这里你可以找到最新的提交，使用<code>git reset [commit-id]</code>即可回到未来。</p><h2 id="暂存区-1"><a href="#暂存区-1" class="headerlink" title="暂存区"></a>暂存区</h2><h3 id="我想将暂存区的文件还原到工作区"><a href="#我想将暂存区的文件还原到工作区" class="headerlink" title="我想将暂存区的文件还原到工作区"></a>我想将暂存区的文件还原到工作区</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="meta">reset</span> ./<span class="meta">filename</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>git reset</code>中，有<code>--mixed</code>（默认）, <code>--soft</code>，<code>--hard</code>三个可选参数，它们间有什么区别呢？其实是他们的修改作用域不同，具体可看下表。需要注意的是，请谨慎使用<code>--hard</code>，这会使你工作区的内容被覆盖！</p></blockquote><table><thead><tr><th align="center"></th><th align="center">工作区</th><th align="center">暂存区</th><th align="center">本地仓库</th></tr></thead><tbody><tr><td align="center"><code>--soft</code></td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td></tr><tr><td align="center"><code>--mixed</code></td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center"><code>--hard</code></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr></tbody></table><h3 id="我想对比工作区域暂存区的某个文件差异"><a href="#我想对比工作区域暂存区的某个文件差异" class="headerlink" title="我想对比工作区域暂存区的某个文件差异"></a>我想对比工作区域暂存区的某个文件差异</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff <span class="string">[filename]</span></span><br></pre></td></tr></table></figure><h3 id="我想对比暂存区与仓库某个文件的差异"><a href="#我想对比暂存区与仓库某个文件的差异" class="headerlink" title="我想对比暂存区与仓库某个文件的差异"></a>我想对比暂存区与仓库某个文件的差异</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">diff </span>--<span class="keyword">cached </span>[filename]</span><br></pre></td></tr></table></figure><h3 id="我想比较工作区与本地仓库的差异"><a href="#我想比较工作区与本地仓库的差异" class="headerlink" title="我想比较工作区与本地仓库的差异"></a>我想比较工作区与本地仓库的差异</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git diff HEAD</span><br></pre></td></tr></table></figure><h3 id="我想比较当前提价与某个历史提交的差异"><a href="#我想比较当前提价与某个历史提交的差异" class="headerlink" title="我想比较当前提价与某个历史提交的差异"></a>我想比较当前提价与某个历史提交的差异</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff [<span class="keyword">commit</span>-<span class="keyword">id</span>]</span><br></pre></td></tr></table></figure><h2 id="本地仓库-1"><a href="#本地仓库-1" class="headerlink" title="本地仓库"></a>本地仓库</h2><h3 id="怎么将远程仓库克隆到本地，并命名为proj？"><a href="#怎么将远程仓库克隆到本地，并命名为proj？" class="headerlink" title="怎么将远程仓库克隆到本地，并命名为proj？"></a>怎么将远程仓库克隆到本地，并命名为proj？</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">[repo_url</span>] [proj]</span><br></pre></td></tr></table></figure><h3 id="怎么更新本地仓库？"><a href="#怎么更新本地仓库？" class="headerlink" title="怎么更新本地仓库？"></a>怎么更新本地仓库？</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch <span class="variable">&amp;&amp;</span> git <span class="meta">merge</span></span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git pull</span><br></pre></td></tr></table></figure><h3 id="子模块功能怎么用？"><a href="#子模块功能怎么用？" class="headerlink" title="子模块功能怎么用？"></a>子模块功能怎么用？</h3><p>添加子模块</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">submodule </span><span class="keyword">add </span>url repo_name</span><br></pre></td></tr></table></figure><p>初始化子模块</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">submodule </span>init</span><br></pre></td></tr></table></figure><p>更新子模块</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">submodule </span>update</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="我想查看所有的标签"><a href="#我想查看所有的标签" class="headerlink" title="我想查看所有的标签"></a>我想查看所有的标签</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br></pre></td></tr></table></figure><h3 id="我想列出1-8-5系列的标签"><a href="#我想列出1-8-5系列的标签" class="headerlink" title="我想列出1.8.5系列的标签"></a>我想列出1.8.5系列的标签</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-l</span> 'v1.<span class="number">8.5</span>*'</span><br></pre></td></tr></table></figure><h3 id="我要查看某个标签信息"><a href="#我要查看某个标签信息" class="headerlink" title="我要查看某个标签信息"></a>我要查看某个标签信息</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show <span class="string">[tagname]</span></span><br></pre></td></tr></table></figure><h3 id="怎么创建一个标签？"><a href="#怎么创建一个标签？" class="headerlink" title="怎么创建一个标签？"></a>怎么创建一个标签？</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> [tagname] -m <span class="string">"message"</span></span><br></pre></td></tr></table></figure><blockquote><p>该形式是附注标签，包含了创建标签者姓名、email、时间以及标签信息。另外有一种轻量标签<code>git tag [tagname]</code>，该标签类型由于包含了较少的信息，所以不被推荐。</p></blockquote><h3 id="怎么推送标签到远程仓库？"><a href="#怎么推送标签到远程仓库？" class="headerlink" title="怎么推送标签到远程仓库？"></a>怎么推送标签到远程仓库？</h3><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 </p><p>推送单个标签：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> [tagname]</span><br></pre></td></tr></table></figure><p>将所有不在远程仓库的标签全部推送：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span><br></pre></td></tr></table></figure><h3 id="怎么删除标签？"><a href="#怎么删除标签？" class="headerlink" title="怎么删除标签？"></a>怎么删除标签？</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> [tagname]</span><br></pre></td></tr></table></figure><blockquote><p>注意：该命令并不会从任何远程仓库中移除这个标签，你必须使用 <code>git push [remote] :refs/tags/[tagname]</code> 来更新你的远程仓库。</p></blockquote><h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>变基的命令：<code>git rebase -i [要修改 commit 的上一个 commit]</code></p><blockquote><p>请注意！变基是一把利剑，合理的使用会让你的分支更加简洁和灵活，滥用则会导致分支的混乱。请谨慎使用 rebase，尤其是团队合作项目，因为它会修改历史信息，导致信息冲突<br>在危险操作前可以先在副本分支进行操作，确认结果是预期后再行操作。</p></blockquote><blockquote><p>变基的概念可能难以理解，你可以到<a href="https://git-scm.com/book/zh/v2/Git-分支-变基" target="_blank" rel="noopener">这里</a>学习一下。</p></blockquote><p>当我们使用<code>git rebase -i 5f2452b2  8f33126c</code>调出了变基窗口时，会看到以下内容，请注意其中的 Commands 部分，每个命令后都有说明，我们只需要按照说明操作即可。如果不明白其实际动作和结果，请创建一个测试仓库演练一下。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pick cacc52da <span class="keyword">add</span><span class="bash">: qrcode</span></span><br><span class="line">pick f072ef48 update: indexeddb hack</span><br><span class="line">pick <span class="number">4</span>e84901a feat: <span class="keyword">add</span><span class="bash"> indexedDB floder</span></span><br><span class="line">pick <span class="number">8</span>f33126c feat: <span class="keyword">add</span><span class="bash"> test2.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 5f2452b2..8f33126c onto 5f2452b2 (4 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick = use commit</span></span><br><span class="line"><span class="comment"># r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup = like "squash", but discard this commit's log message</span></span><br><span class="line"><span class="comment"># x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># d, drop = remove commit</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure><h3 id="我想修改某次提交信息"><a href="#我想修改某次提交信息" class="headerlink" title="我想修改某次提交信息"></a>我想修改某次提交信息</h3><p><code>r</code></p><h3 id="我想将多个提交合并"><a href="#我想将多个提交合并" class="headerlink" title="我想将多个提交合并"></a>我想将多个提交合并</h3><p><code>s</code></p><h3 id="我想删除某次提交"><a href="#我想删除某次提交" class="headerlink" title="我想删除某次提交"></a>我想删除某次提交</h3><p><code>d</code></p><h3 id="我想将-A-分支变基到-B-分支上（移花接木）"><a href="#我想将-A-分支变基到-B-分支上（移花接木）" class="headerlink" title="我想将 A 分支变基到 B 分支上（移花接木）"></a>我想将 A 分支变基到 B 分支上（移花接木）</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -<span class="selector-tag">i</span> A B</span><br></pre></td></tr></table></figure><h3 id="我更换了邮箱，想修改历史提交的邮箱"><a href="#我更换了邮箱，想修改历史提交的邮箱" class="headerlink" title="我更换了邮箱，想修改历史提交的邮箱"></a>我更换了邮箱，想修改历史提交的邮箱</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">filter</span>-branch <span class="comment">--commit-filter '</span></span><br><span class="line">        <span class="keyword">if</span> [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">                GIT_AUTHOR_NAME="Scott Chacon";</span><br><span class="line">                GIT_AUTHOR_EMAIL="schacon@example.com";</span><br><span class="line">                git <span class="keyword">commit</span>-tree "$@";</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                git <span class="keyword">commit</span>-tree "$@";</span><br><span class="line">        fi<span class="string">' HEAD</span></span><br></pre></td></tr></table></figure><h3 id="我想在所有分支删除某个文件，如-password-txt"><a href="#我想在所有分支删除某个文件，如-password-txt" class="headerlink" title="我想在所有分支删除某个文件，如 password.txt"></a>我想在所有分支删除某个文件，如 password.txt</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">filter</span>-branch --<span class="keyword">all</span> --tree-<span class="built_in">filter</span> <span class="string">'rm -f passwords.txt'</span> HEAD</span><br></pre></td></tr></table></figure><h3 id="变基冲突解决后我该做什么？"><a href="#变基冲突解决后我该做什么？" class="headerlink" title="变基冲突解决后我该做什么？"></a>变基冲突解决后我该做什么？</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --<span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h3 id="变基过程中我想放弃变基"><a href="#变基过程中我想放弃变基" class="headerlink" title="变基过程中我想放弃变基"></a>变基过程中我想放弃变基</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git rebase --<span class="keyword">abort</span></span><br></pre></td></tr></table></figure><h2 id="分支-1"><a href="#分支-1" class="headerlink" title="分支"></a>分支</h2><h3 id="怎么切换分支？"><a href="#怎么切换分支？" class="headerlink" title="怎么切换分支？"></a>怎么切换分支？</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="string">[branch name]</span></span><br></pre></td></tr></table></figure><h3 id="怎么切换到上一个分支？"><a href="#怎么切换到上一个分支？" class="headerlink" title="怎么切换到上一个分支？"></a>怎么切换到上一个分支？</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout -</span><br></pre></td></tr></table></figure><h3 id="我当前在test分支，并想将ver1-0合并到test分支"><a href="#我当前在test分支，并想将ver1-0合并到test分支" class="headerlink" title="我当前在test分支，并想将ver1.0合并到test分支"></a>我当前在<code>test</code>分支，并想将<code>ver1.0</code>合并到<code>test</code>分支</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mrege ver1<span class="number">.0</span></span><br></pre></td></tr></table></figure><h3 id="我想取消合并"><a href="#我想取消合并" class="headerlink" title="我想取消合并"></a>我想取消合并</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git merge --<span class="keyword">abort</span></span><br></pre></td></tr></table></figure><h3 id="怎么查看已经合并的分支？"><a href="#怎么查看已经合并的分支？" class="headerlink" title="怎么查看已经合并的分支？"></a>怎么查看已经合并的分支？</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="comment">--merged</span></span><br></pre></td></tr></table></figure><h3 id="怎么查看还未合并的分支？"><a href="#怎么查看还未合并的分支？" class="headerlink" title="怎么查看还未合并的分支？"></a>怎么查看还未合并的分支？</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch --<span class="keyword">no</span>-merged</span><br></pre></td></tr></table></figure><h3 id="我想新建一个分支"><a href="#我想新建一个分支" class="headerlink" title="我想新建一个分支"></a>我想新建一个分支</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>[<span class="keyword">branch </span>name]</span><br></pre></td></tr></table></figure><h3 id="我想新建并切换到新分支"><a href="#我想新建并切换到新分支" class="headerlink" title="我想新建并切换到新分支"></a>我想新建并切换到新分支</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-<span class="keyword">b </span>[<span class="keyword">branch </span>name]</span><br></pre></td></tr></table></figure><h3 id="我想删除已合并的分支"><a href="#我想删除已合并的分支" class="headerlink" title="我想删除已合并的分支"></a>我想删除已合并的分支</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d [<span class="keyword">branch </span>name]</span><br></pre></td></tr></table></figure><h3 id="我想强制删除未合并的分支"><a href="#我想强制删除未合并的分支" class="headerlink" title="我想强制删除未合并的分支"></a>我想强制删除未合并的分支</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-D [<span class="keyword">brnach </span>name]</span><br></pre></td></tr></table></figure><h3 id="我想将另一个分支的某次提交应用到当前分支"><a href="#我想将另一个分支的某次提交应用到当前分支" class="headerlink" title="我想将另一个分支的某次提交应用到当前分支"></a>我想将另一个分支的某次提交应用到当前分支</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick [<span class="keyword">commit</span>-<span class="keyword">id</span>]</span><br></pre></td></tr></table></figure><h3 id="怎么修改分支名？"><a href="#怎么修改分支名？" class="headerlink" title="怎么修改分支名？"></a>怎么修改分支名？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -m [<span class="built_in">old</span> <span class="type">name</span>] [<span class="built_in">new</span> <span class="type">name</span>]</span><br></pre></td></tr></table></figure><h3 id="怎么将本地分支与远程分支建立跟踪关系？"><a href="#怎么将本地分支与远程分支建立跟踪关系？" class="headerlink" title="怎么将本地分支与远程分支建立跟踪关系？"></a>怎么将本地分支与远程分支建立跟踪关系？</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -t <span class="string">[branch name]</span> <span class="string">[remote-branch]</span></span><br></pre></td></tr></table></figure><h3 id="怎么查看远程分支？"><a href="#怎么查看远程分支？" class="headerlink" title="怎么查看远程分支？"></a>怎么查看远程分支？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-r</span><br></pre></td></tr></table></figure><h3 id="我本地没有别人新推送的远程分支"><a href="#我本地没有别人新推送的远程分支" class="headerlink" title="我本地没有别人新推送的远程分支"></a>我本地没有别人新推送的远程分支</h3><p>请使用<code>git fetch</code>命令更新一下</p><h3 id="远程仓库名为origin，怎么将本地的-A-分支推送到远程并建立同名分支？"><a href="#远程仓库名为origin，怎么将本地的-A-分支推送到远程并建立同名分支？" class="headerlink" title="远程仓库名为origin，怎么将本地的 A 分支推送到远程并建立同名分支？"></a>远程仓库名为origin，怎么将本地的 A 分支推送到远程并建立同名分支？</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> -u <span class="built_in">origin</span> A:B</span><br></pre></td></tr></table></figure><h3 id="远程仓库名为origin，我想删除origin的分支B"><a href="#远程仓库名为origin，我想删除origin的分支B" class="headerlink" title="远程仓库名为origin，我想删除origin的分支B"></a>远程仓库名为origin，我想删除origin的分支B</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git push -u origin <span class="symbol">:B</span></span><br></pre></td></tr></table></figure><h3 id="我将-5-个提交推送到了远程仓库，但发现第3个提交需要撤回，我该如何操作？"><a href="#我将-5-个提交推送到了远程仓库，但发现第3个提交需要撤回，我该如何操作？" class="headerlink" title="我将 5 个提交推送到了远程仓库，但发现第3个提交需要撤回，我该如何操作？"></a>我将 5 个提交推送到了远程仓库，但发现第3个提交需要撤回，我该如何操作？</h3><p>此时，你应该使用<code>git revert [commit-id]</code>，无论这个提交在log的哪个位置，都不会影响上下的提交，而且它会将撤销的作为一个新的提交，因此<code>revert</code>命令主要用于推送到远程仓库的修改。</p><p>如果你使用了<code>git reset</code>会有什么不同呢？</p><p>如果一个提交在log的中间位置，那么reset这个提交之后的提交有可能都会消失掉！尤其在多人协作中，你将后两个提交删除，并推送到远程，而别人本地还是 5 个提交，这将导致分支的混乱，请清楚你的每一步操作与后果，谨慎使用每个命令。</p><h2 id="远程仓库-1"><a href="#远程仓库-1" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="怎么查看所有关联的远程仓库名称"><a href="#怎么查看所有关联的远程仓库名称" class="headerlink" title="怎么查看所有关联的远程仓库名称"></a>怎么查看所有关联的远程仓库名称</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span><br></pre></td></tr></table></figure><h3 id="我想查看远程仓库的地址"><a href="#我想查看远程仓库的地址" class="headerlink" title="我想查看远程仓库的地址"></a>我想查看远程仓库的地址</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote -v</span><br></pre></td></tr></table></figure><h3 id="我想将本地已有仓库与远程仓库关联"><a href="#我想将本地已有仓库与远程仓库关联" class="headerlink" title="我想将本地已有仓库与远程仓库关联"></a>我想将本地已有仓库与远程仓库关联</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="keyword">add</span><span class="bash"> 本地远程仓库名 url|path</span></span><br></pre></td></tr></table></figure><h3 id="我想取消远程仓库的关联"><a href="#我想取消远程仓库的关联" class="headerlink" title="我想取消远程仓库的关联"></a>我想取消远程仓库的关联</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote rm 本地远程仓库名</span><br></pre></td></tr></table></figure><h3 id="我想重命名远程仓库"><a href="#我想重命名远程仓库" class="headerlink" title="我想重命名远程仓库"></a>我想重命名远程仓库</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="keyword">rename</span> [<span class="built_in">old</span> <span class="type">name</span>] [<span class="built_in">new</span> <span class="type">name</span>]</span><br></pre></td></tr></table></figure><h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><h3 id="我想在项目中查找某个关键词，并输出所在行号"><a href="#我想在项目中查找某个关键词，并输出所在行号" class="headerlink" title="我想在项目中查找某个关键词，并输出所在行号"></a>我想在项目中查找某个关键词，并输出所在行号</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git grep <span class="string">[-n]</span> <span class="string">[keyword]</span></span><br></pre></td></tr></table></figure><h3 id="我想查看搜索结果所属方法或函数"><a href="#我想查看搜索结果所属方法或函数" class="headerlink" title="我想查看搜索结果所属方法或函数"></a>我想查看搜索结果所属方法或函数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git grep -<span class="selector-tag">p</span> [keyword]</span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><code>git log</code>中有很多参数能够帮助我们增强筛选，常用的选项如下表</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code></td><td>按补丁格式显示每个更新之间的差异。</td></tr><tr><td><code>--stat</code></td><td>显示每次更新的文件修改统计信息。</td></tr><tr><td><code>--shortstat</code></td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td><code>--name-only</code></td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td><code>--name-status</code></td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td><code>--abbrev-commit</code></td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td><code>--relative-date</code></td><td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td><code>--graph</code></td><td>显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td><code>--pretty</code></td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr></tbody></table><p><code>git log --pretty=format</code> 常用的选项如下表：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>%H</code></td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td><code>%h</code></td><td>提交对象的简短哈希字串</td></tr><tr><td><code>%T</code></td><td>树对象（tree）的完整哈希字串</td></tr><tr><td><code>%t</code></td><td>树对象的简短哈希字串</td></tr><tr><td><code>%P</code></td><td>父对象（parent）的完整哈希字串</td></tr><tr><td><code>%p</code></td><td>父对象的简短哈希字串</td></tr><tr><td><code>%an</code></td><td>作者（author）的名字</td></tr><tr><td><code>%ae</code></td><td>作者的电子邮件地址</td></tr><tr><td><code>%ad</code></td><td>作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td><code>%ar</code></td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td><code>%cn</code></td><td>提交者（committer）的名字</td></tr><tr><td><code>%ce</code></td><td>提交者的电子邮件地址</td></tr><tr><td><code>%cd</code></td><td>提交日期</td></tr><tr><td><code>%cr</code></td><td>提交日期，按多久以前的方式显示</td></tr><tr><td><code>%s</code></td><td>提交说明</td></tr></tbody></table><p>限制 <code>git log</code> 输出的选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-(n)</code></td><td>仅显示最近的 n 条提交</td></tr><tr><td><code>--since, --after</code></td><td>仅显示指定时间之后的提交。</td></tr><tr><td><code>--until, --before</code></td><td>仅显示指定时间之前的提交。</td></tr><tr><td><code>--author</code></td><td>仅显示指定作者相关的提交。</td></tr><tr><td><code>--committer</code></td><td>仅显示指定提交者相关的提交。</td></tr><tr><td><code>--grep</code></td><td>仅显示含指定关键字的提交</td></tr><tr><td><code>-S</code></td><td>仅显示添加或移除了某个关键字的提交</td></tr></tbody></table><h3 id="我想查看某次提交信息"><a href="#我想查看某次提交信息" class="headerlink" title="我想查看某次提交信息"></a>我想查看某次提交信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">show</span> [<span class="keyword">commit</span>-<span class="keyword">id</span>]</span><br></pre></td></tr></table></figure><h3 id="我想查看某次提交修改的文件列表"><a href="#我想查看某次提交修改的文件列表" class="headerlink" title="我想查看某次提交修改的文件列表"></a>我想查看某次提交修改的文件列表</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show <span class="params">--pretty=</span><span class="string">""</span> <span class="params">--name-only</span> [commit-id]</span><br></pre></td></tr></table></figure><h3 id="查看某次提交的变更内容"><a href="#查看某次提交的变更内容" class="headerlink" title="查看某次提交的变更内容"></a>查看某次提交的变更内容</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">show</span> <span class="comment">--pretty="" [commit-id]</span></span><br></pre></td></tr></table></figure><h3 id="我想查看某个文件的所有提交信息"><a href="#我想查看某个文件的所有提交信息" class="headerlink" title="我想查看某个文件的所有提交信息"></a>我想查看某个文件的所有提交信息</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> -p [filename]</span><br></pre></td></tr></table></figure><h3 id="我想查看最近两次的提交信息"><a href="#我想查看最近两次的提交信息" class="headerlink" title="我想查看最近两次的提交信息"></a>我想查看最近两次的提交信息</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> -p <span class="number">-2</span></span><br></pre></td></tr></table></figure><h3 id="我想查看某个文件的所有变动及统计信息"><a href="#我想查看某个文件的所有变动及统计信息" class="headerlink" title="我想查看某个文件的所有变动及统计信息"></a>我想查看某个文件的所有变动及统计信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged --<span class="built_in">stat</span> [filename]</span></span><br></pre></td></tr></table></figure><h3 id="我想修改最近一次提交信息"><a href="#我想修改最近一次提交信息" class="headerlink" title="我想修改最近一次提交信息"></a>我想修改最近一次提交信息</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure><h3 id="某行代码有问题，我想查看谁最后修改了这里"><a href="#某行代码有问题，我想查看谁最后修改了这里" class="headerlink" title="某行代码有问题，我想查看谁最后修改了这里"></a>某行代码有问题，我想查看谁最后修改了这里</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame [-L <span class="built_in">start</span>-<span class="built_in">line</span>, <span class="keyword">end</span>-<span class="built_in">line</span>] filename</span><br></pre></td></tr></table></figure><h3 id="我想查看某个用户在某个时间段内的所有提交，并仅输出简短hash与提交说明"><a href="#我想查看某个用户在某个时间段内的所有提交，并仅输出简短hash与提交说明" class="headerlink" title="我想查看某个用户在某个时间段内的所有提交，并仅输出简短hash与提交说明"></a>我想查看某个用户在某个时间段内的所有提交，并仅输出简短hash与提交说明</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log <span class="attribute">--pretty</span>=<span class="string">"%h - %s"</span> <span class="attribute">--author</span>=Rock <span class="attribute">--since</span>=<span class="string">"2008-10-01"</span> <span class="attribute">--before</span>=<span class="string">"2008-11-01"</span></span><br></pre></td></tr></table></figure><h3 id="我想用图形的方式查看分支的变化"><a href="#我想用图形的方式查看分支的变化" class="headerlink" title="我想用图形的方式查看分支的变化"></a>我想用图形的方式查看分支的变化</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--oneline --graph</span></span><br></pre></td></tr></table></figure><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><ul><li><code>**/*.go</code> 忽略所有目录中的扩展名为go的文件</li><li><code>*/*/temp*</code>忽略二级目录下以temp开头的所有文件</li><li><code>temp?</code>忽略以temp开头的文件名，如<code>tempa</code>和<code>tempb</code></li><li><code>!README.md</code>感叹号(<code>!</code>)表示不忽略该文件</li></ul><h2 id="版本控制最佳实践"><a href="#版本控制最佳实践" class="headerlink" title="版本控制最佳实践"></a>版本控制最佳实践</h2><h3 id="鼓励频繁提交"><a href="#鼓励频繁提交" class="headerlink" title="鼓励频繁提交"></a>鼓励频繁提交</h3><p>频繁提交，而不要等到代码没有问题了再一次性提交。对于可能损坏主干原则的代码，不要直接提交到主干，而是创建一个分支，在分支中频繁提交。</p><h3 id="定义主干原则，并且坚守它"><a href="#定义主干原则，并且坚守它" class="headerlink" title="定义主干原则，并且坚守它"></a>定义主干原则，并且坚守它</h3><p>“主干的代码必须是可以发布并且不会产生bug的”，如果不能保证新增或修改的代码符合这一原则，就在分支提交代码。</p><h3 id="不要把逻辑的修改和代码格式化操作混在一起"><a href="#不要把逻辑的修改和代码格式化操作混在一起" class="headerlink" title="不要把逻辑的修改和代码格式化操作混在一起"></a>不要把逻辑的修改和代码格式化操作混在一起</h3><p>如果你做了一些代码格式化的操作，就单独提交这次修改，然后再做一些逻辑的修改后提交，这样可以在出现问题时容易追溯。</p><h3 id="不相干的代码分开提交"><a href="#不相干的代码分开提交" class="headerlink" title="不相干的代码分开提交"></a>不相干的代码分开提交</h3><p>也就是说不要在一次提交里修复两个bug</p><hr><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol><li><a href="https://blog.shixinyu.space/post/git-notes/">Git 常用命令总结</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈PHP中的static关键字</title>
      <link href="/post/php-static/"/>
      <url>/post/php-static/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cm4yvhsgj30ci05kt99.jpg" alt=""></p><a id="more"></a><h2 id="static-的几种使用情况："><a href="#static-的几种使用情况：" class="headerlink" title="static 的几种使用情况："></a>static 的几种使用情况：</h2><h3 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1. 静态变量"></a>1. 静态变量</h3><p>静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。看看下面的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> $val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">echo</span> $val;</span><br><span class="line">    $val++;</span><br><span class="line">&#125;</span><br><span class="line">testStatic();   <span class="comment">//output 1</span></span><br><span class="line">testStatic();   <span class="comment">//output 2</span></span><br><span class="line">testStatic();   <span class="comment">//output 3</span></span><br></pre></td></tr></table></figure><p>如果不声明<code>static</code>，则每次<code>$val</code>的值都会初始化为1。这是由于<code>static</code>关键字会在请求初始化时存储与静态存储区，并存在于整个请求生命周期内，而普通变量则存在于栈区，函数执行结束时这些存储单元自动被释放。</p><h3 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2. 静态属性"></a>2. 静态属性</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $age;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">roster</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">roster</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-后期静态绑定"><a href="#4-后期静态绑定" class="headerlink" title="4. 后期静态绑定"></a>4. 后期静态绑定</h3><p>首先，后期静态绑定这个词怎么理解，官方手册对这个解释的很清楚，这里引用一下：『“后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但<strong>不限于</strong>）静态方法的调用。』</p><p>接下来，让我们用几个例子来具体说明一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::who(); <span class="comment">// 后期静态绑定从这里开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test();</span><br></pre></td></tr></table></figure><p>这段代码的最终输出是什么？<code>A</code>还是<code>B</code>？</p><p>让我们来运行一下，发现结果是<code>B</code>。这是为什么呢？</p><p>因为当我们调用<code>B</code>中的静态方法<code>test()</code>时，B 中不存在，于是向上查找（调用查找顺序依次为 当前类 ==&gt; trait ==&gt; 父类），当在父类<code>A</code>中找到时，执行<code>static::who()</code>。（这里的<code>static</code>与我们常用的<code>self</code>关键字不同，如果是<code>self</code>，则只会向上查找，而<code>static</code>则会向下查找，具体调用方法也是在运行时确定的）因此接下来调用的是<code>B</code>中的 <code>who()</code>，而非<code>A</code>中的<code>who()</code>，最终也就自然输出为<code>B</code>。</p><p>需要注意的是，后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止(即最下层可执行的方法)。另一方面，如果静态调用使用 <code>parent::</code> 或者 <code>self::</code> 将转发调用信息。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::who();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A::foo();</span><br><span class="line">        <span class="keyword">parent</span>::foo();</span><br><span class="line">        <span class="keyword">self</span>::foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::test();<span class="comment">// A C C</span></span><br></pre></td></tr></table></figure><h2 id="What-amp-When"><a href="#What-amp-When" class="headerlink" title="What &amp; When"></a>What &amp; When</h2><p>现在，让我们来看一下什么是<code>static</code>，以及什么时候该使用<code>static</code>。</p><h3 id="什么是static？"><a href="#什么是static？" class="headerlink" title="什么是static？"></a>什么是static？</h3><p>如果我们在代码中声明了<code>static</code>关键字，代码在初始化阶段会与常量、全局变量一同存储在一段连续空间内（静态存储区），这会存在于整个请求周期，除非我们手动销毁。</p><p>由于这些值是在初始化时确定的，相比于在运行时确定的值，就是“静态”(<code>static</code>)的。</p><h3 id="什么时候用？"><a href="#什么时候用？" class="headerlink" title="什么时候用？"></a>什么时候用？</h3><p>由于是一段连续的空间，相比于运行时的碎片化产生的内容读取效率更高，所以，我们应将一些常用基础工具类设为静态，既避免了实例化时的资源消耗，有提升了书写体验。但要注意不能滥用<code>static</code>，曾经的一家知名公司内部项目model层全部是<code>static</code>方法，你能想象到这维护起来有多么让人崩溃。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.php.net/manual/zh/language.variables.scope.php" target="_blank" rel="noopener">使用静态变量 - PHP手册</a></li><li><a href="https://www.php.net/manual/zh/language.oop5.late-static-bindings.php" target="_blank" rel="noopener">后期静态绑定 - PHP手册</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈php闭包/匿名函数</title>
      <link href="/post/php-closure/"/>
      <url>/post/php-closure/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cm61t85qj30bo06o3ym.jpg" alt=""></p><p>闭包(Closure)是我们在编程中经常遇到的一个概念，但闭包究竟是什么？又有什么用呢？</p><a id="more"></a><p>在编程中，闭包与匿名函数（又名lambda表达式）其实是不同的概念，但两者经常同时使用。在 PHP 中，二者的概念不做区分，下文均以闭包指代。</p><h2 id="I-闭包是什么？"><a href="#I-闭包是什么？" class="headerlink" title="I. 闭包是什么？"></a>I. 闭包是什么？</h2><h3 id="闭包的常用类型"><a href="#闭包的常用类型" class="headerlink" title="闭包的常用类型"></a>闭包的常用类型</h3><p>闭包又名匿名函数，也就是没有函数名称的函数。我们先来看下常用类型</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个闭包，并把它赋给变量 $closure</span></span><br><span class="line">$closure = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用闭包也很简单</span></span><br><span class="line">$closure(); <span class="comment">//这样就调用了闭包，输出 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要即时调用闭包，我们也可以这样写</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="number">7</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然更多的时候是把闭包作为参数(回调函数)传递给函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testClosure</span> <span class="params">(Closure $callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $closure 作为参数传递给函数 testClosure，如果是普通函数是没有办法作为testClosure的参数的</span></span><br><span class="line">testClosure($closure);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接将定义的闭包作为参数传递，而不用提前赋给变量</span></span><br><span class="line">testClosure (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包不止可以做函数的参数，也可以作为函数的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClosure</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">7</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$c = getClosure(); <span class="comment">// 函数返回的闭包就复制给 $c 了</span></span><br><span class="line">$c(); <span class="comment">// 调用闭包，返回 7</span></span><br></pre></td></tr></table></figure><h3 id="闭包类"><a href="#闭包类" class="headerlink" title="闭包类"></a>闭包类</h3><p>定义一个闭包函数，其实是产生了一个闭包类（Closure）的对象，Closure 类摘要如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Closure &#123;</span><br><span class="line">    <span class="comment">// 用于禁止实例化的构造函数</span></span><br><span class="line">    __construct ( void )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制一个闭包，绑定指定的$this对象和类作用域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> bind ( Closure $closure , object $newthis [, mixed $newscope = <span class="string">'static'</span> ] ) : Closure</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制当前闭包对象，绑定指定的$this对象和类作用域</span></span><br><span class="line">    <span class="keyword">public</span> bindTo ( object $newthis [, mixed $newscope = <span class="string">'static'</span> ] ) : Closure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>var_dump($c instanceof Closure);</code>看到，闭包确实是<code>Closure</code>的一个实例，通过<code>var_dump(is_callable($c));</code>看到，闭包是<code>Callable</code>的数据类型。</p><h4 id="Closure-bind-实例"><a href="#Closure-bind-实例" class="headerlink" title="Closure::bind() 实例"></a><code>Closure::bind()</code> 实例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $cat = <span class="string">"cat"</span>;  </span><br><span class="line">    <span class="keyword">private</span> $dog = <span class="string">"dog"</span>;  </span><br><span class="line">    <span class="keyword">public</span> $pig = <span class="string">"pig"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 获取Animal类静态私有成员属性 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">$cat = <span class="keyword">static</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> Animal::$cat;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 获取Animal实例私有成员属性 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">$dog = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;dog;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 获取Animal实例公有成员属性 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">$pig = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;pig;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$bindCat = Closure::bind($cat, <span class="keyword">null</span>, <span class="keyword">new</span> Animal());<span class="comment">// 给闭包绑定了Animal实例的作用域，但未给闭包绑定$this对象。这是由于静态闭包不能有绑定的对象（ newthis 参数的值应该设为 NULL）(详情请查看手册[Closure::bindTo页面文档](https://www.php.net/manual/zh/closure.bindto.php))</span></span><br><span class="line"></span><br><span class="line">$bindCat = Closure::bind($cat, <span class="keyword">new</span> Animal(), <span class="string">'Animal'</span>);<span class="comment">// 若$cat不是静态闭包时有效</span></span><br><span class="line"></span><br><span class="line">$bindDog = Closure::bind($dog, <span class="keyword">new</span> Animal(), <span class="string">'Animal'</span>);<span class="comment">// 给闭包绑定了Animal类的作用域，同时将Animal实例对象作为$this对象绑定给闭包  </span></span><br><span class="line"></span><br><span class="line">$bindPig = Closure::bind($pig, <span class="keyword">new</span> Animal());<span class="comment">// 将Animal实例对象作为$this对象绑定给闭包,保留闭包原有作用域  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $bindCat(),PHP_EOL;<span class="comment">// 根据绑定规则，允许闭包通过作用域限定操作符获取Animal类静态私有成员属性  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $bindDog(),PHP_EOL;<span class="comment">// 根据绑定规则，允许闭包通过绑定的$this对象(Animal实例对象)获取Animal实例私有成员属性  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $bindPig(),PHP_EOL;<span class="comment">// 根据绑定规则，允许闭包通过绑定的$this对象获取Animal实例公有成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bindTo与bind类似，是面向对象的调用方式，这里只举一个，其他类比就可以</span></span><br><span class="line">$bindCat = $cat-&gt;bindTo(<span class="keyword">null</span>, <span class="string">'Animal'</span>);<span class="comment">// 同样的，静态闭包不能绑定对象，因此$newthis为 null</span></span><br><span class="line"><span class="keyword">echo</span> $bindCat(); <span class="comment">// cat</span></span><br></pre></td></tr></table></figure><blockquote><p>如果未能指定作用域的范围，绑定后的闭包只能访问<code>public</code>属性的值。</p></blockquote><h4 id="Closure-bindTo-实例"><a href="#Closure-bindTo-实例" class="headerlink" title="Closure::bindTo() 实例"></a><code>Closure::bindTo()</code> 实例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getClosure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//returns closure bound to this object and scope</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;val; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ob1 = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">$ob2 = <span class="keyword">new</span> A(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">$cl = $ob1-&gt;getClosure();</span><br><span class="line"><span class="keyword">echo</span> $cl(), PHP_EOL;<span class="comment">// 1</span></span><br><span class="line">$cl = $cl-&gt;bindTo($ob2);<span class="comment">// 它与当前对象的函数体相同、绑定了同样变量，但可以绑定不同的对象，也可以绑定新的类作用域</span></span><br><span class="line"><span class="keyword">echo</span> $cl(), PHP_EOL;<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="II-闭包有什么用？"><a href="#II-闭包有什么用？" class="headerlink" title="II. 闭包有什么用？"></a>II. 闭包有什么用？</h2><h3 id="1-储存变量"><a href="#1-储存变量" class="headerlink" title="1. 储存变量"></a>1. 储存变量</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHelloWorld</span><span class="params">($name)</span> </span>&#123; </span><br><span class="line">    $i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="title">use</span> <span class="params">($name, &amp;$i)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> $name; $i++; <span class="keyword">echo</span> $i.<span class="string">"\n"</span>; &#125;; </span><br><span class="line">&#125; </span><br><span class="line">$hello1 = makeHelloWorld(<span class="string">"wuying"</span>); </span><br><span class="line">$hello2 = makeHelloWorld(<span class="string">"wuying1"</span>); </span><br><span class="line">$hello1(); <span class="comment">//wuying1</span></span><br><span class="line">$hello1(); <span class="comment">//wuying2</span></span><br><span class="line">$hello1(); <span class="comment">//wuying3</span></span><br><span class="line">$hello2(); <span class="comment">//wuying11</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>$hello1 = makeHelloWorld(&quot;wuying&quot;);</code>的作用是将参数<code>wuying1</code>传递给<code>makeHelloWorld()</code>，并接收其中的闭包作为返回值，因此，<code>$hello1</code>便成为了闭包，当我们执行<code>$hello1()</code>时，闭包开始执行。由于引用了闭包外的变量<code>$i</code>，所以每次的执行都修改了<code>$i</code>，所以最后依次输出了<code>wuying1</code>、<code>wuying2</code>、<code>wuying3</code>。</p><p>那么，为什么闭包可以存储变量呢？这是因为在没有闭包的语言中，变量的生命周期只限于创建它的环境。但在有闭包的语言中，只要有一个闭包引用了这个变量，它就会一直存在。</p><blockquote><p>另一种在局部函数中储存变量的方式是使用<code>static</code>关键字，其原理是将变量存储于静态存储区，而非普通变量存储的栈区，详见另一篇文章<a href="http://blog.shixinyu.space/2019/09/18/浅谈PHP中的static关键字/">浅谈PHP中的static关键字</a>。</p></blockquote><h3 id="2-延时执行函数"><a href="#2-延时执行函数" class="headerlink" title="2. 延时执行函数"></a>2. 延时执行函数</h3><p>比如，我们在 JavaScript 中每隔 1 秒钟输出一个随机数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">Math</span>.random())&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们对闭包进行了多次调用，而且不是调用时即时执行。</p><h3 id="3-对处理逻辑封装，形成更好的一体封装"><a href="#3-对处理逻辑封装，形成更好的一体封装" class="headerlink" title="3. 对处理逻辑封装，形成更好的一体封装"></a>3. 对处理逻辑封装，形成更好的一体封装</h3><p>如果在有闭包前，我们需要单独创建具名函数，然后使用名称引用这个函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$func = <span class="function"><span class="keyword">function</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $value * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">print_r(array_map($func, range(<span class="number">1</span>, <span class="number">5</span>)));</span><br></pre></td></tr></table></figure><p>但这样把回调与使用分离，而闭包的出现就很好的解决了这个问题。</p><p>而由于闭包的封装性，闭包内无法访问包外变量，但我们可以通过<code>use</code>关键字来引入外部变量，如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$quantity = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">($price)</span> <span class="title">use</span> <span class="params">($quantity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $price * $quantity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个例子，使用闭包打印斐波那契数列。我们知道斐波那契数列有下面的规律：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># f(<span class="built_in">n</span>) 表示数列中第 <span class="built_in">n</span> 个数的值</span><br><span class="line">f(<span class="built_in">n</span>) = <span class="number">0</span>; (<span class="built_in">n</span> = <span class="number">0</span>)</span><br><span class="line">f(<span class="built_in">n</span>) = <span class="number">1</span>; (<span class="built_in">n</span> = <span class="number">1</span>)</span><br><span class="line">f(<span class="built_in">n</span>) = f(<span class="built_in">n</span>-<span class="number">1</span>)+f(<span class="built_in">n</span>-<span class="number">2</span>); (<span class="built_in">n</span> &gt;= <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>使用递归的方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(int $n)</span>: <span class="title">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci($n<span class="number">-1</span>) + fibonacci($n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> fibonacci(<span class="number">10</span>), <span class="string">"\n"</span>; <span class="comment">// 55</span></span><br></pre></td></tr></table></figure><p>如果打印数列，那每一次都需要重复计算前面已经计算过的数据（只需要前两个就好）。可以使用闭包保存上一次的运行环境。</p><p>php 版本</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$fibonacci = <span class="function"><span class="keyword">function</span> <span class="params">()</span>: <span class="title">callable</span> </span>&#123;</span><br><span class="line">    $x = <span class="number">0</span>;</span><br><span class="line">    $y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">(&amp;$x, &amp;$y)</span>: <span class="title">int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">list</span>($x, $y) = [$y, $x+$y];</span><br><span class="line">        <span class="keyword">return</span> $x;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$f = $fibonacci();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">10</span>; $i++) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $f() , <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js 版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">        [x, y] = [y, x+y];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = fibonacci();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(f());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合理使用闭包，能够让我们的代码更加清晰、更加灵活。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://xueyuanjun.com/post/4341.html/page/2#comments" target="_blank" rel="noopener">闭包和匿名函数 - 学院君</a></li><li><a href="https://www.bilibili.com/video/av67412371" target="_blank" rel="noopener">闭包的编程思想 - B站</a></li><li><a href="https://zh.wikipedia.org/wiki/闭包_(计算机科学)" target="_blank" rel="noopener">闭包-维基百科</a></li><li><a href="https://www.php.net/manual/zh/class.closure.php" target="_blank" rel="noopener">Closure类 - PHP手册</a></li><li><a href="https://www.php.net/manual/zh/language.types.callable.php" target="_blank" rel="noopener">Callable - PHP手册</a></li><li><a href="https://learnku.com/articles/4625/php-closure-closure" target="_blank" rel="noopener">PHP 闭包（Closure）- LearKu</a></li><li><a href="https://learnku.com/articles/7469/learn-the-closure-function-closures" target="_blank" rel="noopener">学习一下闭包函数 - LearKu</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 导出 Excel 问题</title>
      <link href="/post/excel-export/"/>
      <url>/post/excel-export/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g93qzm4y04j30im09bwf0.jpg" alt=""></p><a id="more"></a><p>我们在工作中经常会遇到 Excel 导出的问题，比如：</p><ol><li>表格内容的填充</li><li>下载数据过大执行超时、内存溢出</li><li>异步导出</li></ol><p>那么，这些问题应该怎样解决呢？</p><h1 id="1-表格内容的填充"><a href="#1-表格内容的填充" class="headerlink" title="1. 表格内容的填充"></a>1. 表格内容的填充</h1><p>我们知道，在 PHP 中，<a href="https://www.php.net/manual/en/function.ord.php" target="_blank" rel="noopener"><code>ord()</code></a>可将字符转换为 ASCII 码，<a href="https://www.php.net/manual/en/function.chr.php" target="_blank" rel="noopener"><code>chr()</code></a>则可以将 ASCII 码转换为对应字符，二者为互补函数。</p><p>通过查看 Excel，我们知道一个 sheet 中，列序号是 <code>A1, B1, C1 ...</code>递增的，而行序号是<code>A2, A3, A4...</code>递增的。下面，就让我们用代码来生成一下Excel 中的列。</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$rawData = [</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'张三'</span>,</span><br><span class="line">        <span class="string">'gender'</span> =&gt; <span class="string">' 男'</span>,</span><br><span class="line">        <span class="string">'age'</span> =&gt; <span class="number">19</span>,</span><br><span class="line">        <span class="string">'birthday'</span> =&gt; <span class="string">'2000-01-01'</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'李四'</span>,</span><br><span class="line">        <span class="string">'gender'</span> =&gt; <span class="string">'男'</span>,</span><br><span class="line">        <span class="string">'age'</span> =&gt; <span class="number">29</span>,</span><br><span class="line">        <span class="string">'birthday'</span> =&gt; <span class="string">'1990-01-01'</span></span><br><span class="line">    ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼装导出数据</span></span><br><span class="line">$sheetData = [</span><br><span class="line">    <span class="string">'姓名'</span> =&gt; array_column($rawData, <span class="string">'name'</span>),</span><br><span class="line">    <span class="string">'性别'</span> =&gt; array_column($rawData, <span class="string">'gender'</span>),</span><br><span class="line">    <span class="string">'年龄'</span> =&gt; array_column($rawData, <span class="string">'age'</span>),</span><br><span class="line">    <span class="string">'生日'</span> =&gt; array_column($rawData, <span class="string">'birthday'</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$excelObj = <span class="keyword">new</span> \PHPExcel();</span><br><span class="line">$sheet    = $excelObj-&gt;getActiveSheet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成导出表格</span></span><br><span class="line">$i = <span class="number">65</span>;<span class="comment">//A 在 ASCII 中的十进制为 65</span></span><br><span class="line"><span class="keyword">foreach</span> ($sheetData <span class="keyword">as</span> $title =&gt; $datum) &#123;</span><br><span class="line">    <span class="comment">//填充表头</span></span><br><span class="line">    $row = chr($i++);</span><br><span class="line">    $sheet-&gt;setCellValue($row . <span class="string">'1'</span>, $title);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充内容</span></span><br><span class="line">    $j = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($datum <span class="keyword">as</span> $item) &#123;</span><br><span class="line">        $sheet-&gt;setCellValueExplicit($row . $j++, $item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：可随导出内容自适应，扩展性强</p><p>缺点：表头只能兼容到<code>A1~Z1</code>，超过<code>Z1</code>则会触发 bug 而无法导出</p><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>针对方案一的缺点，我们来扩展表头的容量，利用PHP中的字符串递增来生成表头。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span>($i = <span class="string">'A'</span>; $i &lt;= <span class="string">'Z'</span>; $i++) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $i . <span class="string">'1'</span>, PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：简单快速生成表头</p><p>缺点：只能兼容到<code>YZ1</code></p><p>在 Microsoft Office 365 2019 中，最大列为<code>XFD</code>，所以，如果要满足 Excel 的导出，我们可以这样完全兼容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$alphabet = [];</span><br><span class="line"><span class="keyword">for</span>($i = <span class="string">'A'</span>; $i &lt; <span class="string">'ZZZ'</span>; $i++) &#123;</span><br><span class="line">    $alphabet[] = $i . <span class="string">'1'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在我们已经能够完全满足 Excel 的列需求了，但这里还有一点小瑕疵：我们生成的所有数据都存储在数组中，这显然是对内存的极大浪费，应该按需存取。我们再来尝试另一种新的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlphabet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="string">'A'</span>; $i &lt; <span class="string">'ZZZ'</span>; $i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (getAlphabet() <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $letter . <span class="string">'1'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在优雅了许多。但这种方式和上一种有什么区别呢？<br>请注意这段代码中的<code>yield</code>关键字，这是迭代生成器。我们可以理解为每当 CPU 执行到<code>yield</code>关键字时，就会暂存当前的上下文，并将控制权交回<code>foreach</code>，而不像普通函数一次调用结束后销毁上下文（所以我们需要将函数所产生的变量进行返回），这让我们得以在每次需要到这段函数时，都可以从上次停下的位置继续，而无需暂存整个函数的处理结果，从而节省了内存空间。通过<code>memory_get_usage()</code>函数可以看到，上一种实现方式需要<code>1.9MB</code>，而<code>yield</code>只需要<code>287.6KB</code>，二者的空间复杂度分别为<code>O(n)</code>和<code>O(1)</code>。</p><h1 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h1><p>虽然上述两种方案已经能够满足正常的需求，而且实现也足够简单。但我们还是要探索一下是否能够解决上述缺陷的方式，这样，这个问题就演变成了二十六进制的字符计数器。</p><p>思路：我们常见的有二进制、八进制、十进制、十六进制，所以我们就可以照猫画虎，写一个二十六进制。通过观察，这些进制均是末位递增，当末位为最大值时，向上一位进位，并将低位复位。那就让我们把想法转换为代码吧：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlphabet</span><span class="params">($data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $letter = [];</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">65</span>, $count = <span class="number">0</span>; $i &lt; <span class="number">95</span>; $i++) &#123;</span><br><span class="line">        <span class="comment">// 末位递增处理</span></span><br><span class="line">        <span class="keyword">if</span> ($i &gt; <span class="number">64</span> &amp;&amp; $i &lt; <span class="number">91</span>) &#123;</span><br><span class="line">            $lastPlace = chr($i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进位处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">90</span> === $i) &#123;</span><br><span class="line">            $letter[] = substr(end($letter), <span class="number">0</span>, <span class="number">-1</span>) . chr($i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 所有位均为Z时，位数+1</span></span><br><span class="line">            <span class="keyword">if</span> (substr_count(end($letter), <span class="string">'Z'</span>) === strlen(end($letter))) &#123;</span><br><span class="line">                $letter[] = implode(<span class="string">''</span>, [<span class="string">'A'</span>, str_repeat(<span class="string">'A'</span>, strlen(end($letter)))]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 同位数下递增</span></span><br><span class="line">                $letter[] = chr(ord(substr(end($letter), <span class="number">0</span>, <span class="number">1</span>)) + <span class="number">1</span>) . <span class="string">'A'</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 此种情况下如何进行递增检测处理？如 AXZ 递增后应为 AYA，如何保证随着位数的递增不会消耗更多的时间？</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进位完成后将计数器归位</span></span><br><span class="line">            $i = <span class="number">65</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 递增低位</span></span><br><span class="line">            $letter[] = substr_replace(end($letter), $lastPlace, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>($letter)) &#123;</span><br><span class="line">            $letter[] = <span class="string">'A'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($count &gt; count($data)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $letter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> json_encode(getAlphabet(range(<span class="number">1</span>,<span class="number">100</span>)));</span><br></pre></td></tr></table></figure><p>emmmm，看起来离我们的目标又近了一步：可以连续生成一段字母，并且可以根据我们的数据长度自适应，但是！多位进位如何处理，如何保障多进位处理的性能问题？关于这个问题，目前的想法是参照<a href="https://www.ruanyifeng.com/blog/2011/03/4-bit_computer.html" target="_blank" rel="noopener">计算机的进位实现思想</a>，先挖个坑，等搞清楚来填 :)</p><h1 id="2-导出内容过大"><a href="#2-导出内容过大" class="headerlink" title="2. 导出内容过大"></a>2. 导出内容过大</h1><p>很多项目初期的数据量很小，Excel 导出非常快，但随着数据量的增加，导出越来越慢，直到超时、内存溢出。怎样才能一劳永逸呢？<br>我们知道，PHPExcel（新版为 PhpSpreadsheet)支持向 Excel 中追加内容，所以，我们依然可以使用<code>yield</code>来保证内存：比如内存可以承载 1 万条数据的容量，我们就可以使用 yield 先处理 1 万条暂存于内存中，然后再将这 1 万条追加入磁盘的 Excel 文件，这样既保证了内存的使用，有保证了处理效率。</p><h1 id="3-异步导出"><a href="#3-异步导出" class="headerlink" title="3. 异步导出"></a>3. 异步导出</h1><p>众所周知，PHP 是阻塞式语言，从而导致一些交互后产生的长时间执行的任务难以处理。如果对于一些小型的异步任务通过 crontab 执行，则可能导致后期的定时任务越来越多而难以管理，而 PHP 中的<a href="https://www.php.net/manual/en/function.fastcgi-finish-request.php" target="_blank" rel="noopener"><code>fastcgi_finish_request()</code></a>可以使客户端结束连接后，需要大量时间运行的任务能够继续运行，正好满足我们轻量的异步执行需求。但该方式也会有一些问题，如该方式无错误重试机制。如果有大量需要异步处理的任务需要执行，建议使用 swoole 或者支持异步执行的语言。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://www.laruence.com/2010/07/30/1682.html" target="_blank" rel="noopener">注意PHP对字符串的递增运算</a></li><li><a href="https://www.php.net/manual/zh/class.generator.php" target="_blank" rel="noopener">生成器 - PHP手册</a></li><li><a href="https://www.php.net/manual/zh/language.generators.syntax.php" target="_blank" rel="noopener">yield关键字 - PHP手册</a></li><li><a href="https://www.ruanyifeng.com/blog/2011/03/4-bit_computer.html" target="_blank" rel="noopener">四位计算机的原理及实现 - 阮一峰</a></li><li><a href="https://tyloafer.github.io/posts/63198/" target="_blank" rel="noopener">PHP如何读取大文件</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】鲜为人知的 PHP range() 函数</title>
      <link href="/post/php-range-function/"/>
      <url>/post/php-range-function/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cm9sq38lj309v03yjrd.jpg" alt=""></p><p>PHP中有哪些冷门但很实用的函数？</p><a id="more"></a><p>作为一个 PHPer ，如果想要你生成 <code>[1,31]</code> 区间的 31 个数字，你一般会怎么做？</p><p>仔细想想，好好回忆一下，你第一时间想到的，会不会是使用一个 for 循环来生成，就像下面这样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$days = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">1</span>; $i &lt;= <span class="number">31</span>; $i++ ) &#123;</span><br><span class="line">    $days[] = $i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想，应该，很少人会使用 <code>range()</code> 函数来生成<code>$days = range(1,31,1);</code></p><p>我不知道这是不是我们 PHPer 的悲剧，因为，似乎，很少有教程会交代可以使用 <code>foreach(range())</code> 的方式来代替 <code>for</code> 循环。</p><p>其实，PHP 中的 <code>range()</code> 函数比 Python 中的 <code>range()</code> 强大多了，除了没有使用生成器的方式。</p><h1 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h1><p>根据官方文档，<code>range()</code> 函数被归纳为 「 数组函数 」，因为它的结果就是产生一个数组，一个普通数组。</p><p><code>range()</code> 函数的原型如下</p><p><code>array range ( mixed $start , mixed $end [, number $step = 1 ] )</code><br>range() 函数根据范围 <code>[$start,$end]</code> 创建一个数组，步长为 <code>$step</code> ，默认步长为 <code>1</code></p><blockquote><p>注意： 返回的区间是一个左闭右闭的区间，也就是包含了 $start 和 $end 两个值。</p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>start</td><td>返回的数组区间序列的第一个值</td></tr><tr><td>end</td><td>返回的数组区间序列结束于 end 的值</td></tr><tr><td>step</td><td>如果设置了步长 step，会被作为单元之间的步进值。step 应该为 正值。不设置 step 则默认为 1。</td></tr></tbody></table><h1 id="用法一-：-start-和-end-参数都是整数"><a href="#用法一-：-start-和-end-参数都是整数" class="headerlink" title="用法一 ： $start 和 $end 参数都是整数"></a>用法一 ： $start 和 $end 参数都是整数</h1><ol><li><p>返回整数区间 [0,12] 且步长为 1 的数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">0</span>, <span class="number">12</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回整数区间 [0,100] 且步长为 10 的数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回整数区间 [0,99] 且步长为 10 的数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(0, 10, 20, 30, 40, 50, 60, 70, 80, 90)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">0</span>, <span class="number">99</span>, <span class="number">10</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number, <span class="string">" "</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：返回的数组的最后一个值为 90 ，因为 100 &lt; 99 ，所以不满足条件</p></blockquote><ol start="4"><li><p>如果步长为负数，那么会取该步长的绝对值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(0, 2, 4, 6, 8, 10, 12)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">0</span>, <span class="number">12</span>，<span class="number">2</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果 $start &lt; $end，那么返回的数组会从大到小</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12, 10, 8, 6, 4, 2, 0)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12</span>, <span class="number">0</span>，<span class="number">2</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果步长 $step 为 0 ，会抛出一个异常</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: range(): step exceeds the specified range</span></span><br><span class="line">var_dump(range(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li><li><p>如果步长为字符串，那么会使用 <code>intval()</code> 转换为整数，如果转换后的结果为 0，则参考 6</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12, 10, 8, 6, 4, 2, 0)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12</span>, <span class="number">0</span>，<span class="string">'2a'</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="用法二-：-start-和-end-参数可以是整数也可以是浮点数，-step-也可以是浮点数"><a href="#用法二-：-start-和-end-参数可以是整数也可以是浮点数，-step-也可以是浮点数" class="headerlink" title="用法二 ： $start 和 $end 参数可以是整数也可以是浮点数，$step 也可以是浮点数"></a>用法二 ： <code>$start</code> 和 <code>$end</code> 参数可以是整数也可以是浮点数，<code>$step</code> 也可以是浮点数</h1><ol><li><p><code>$start</code> 和 <code>$end</code> 是浮点数，而 <code>$step</code> 是整数，结果和整数是类似的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12.8, 10.8, 8.8, 6.8, 4.8, 2.8)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12.8</span>, <span class="number">2.2</span>，<span class="number">2</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>$start</code> 和 <code>$end</code> 是浮点数，且 <code>$step</code> 也是浮点数，结果和整数也是类似的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12.8, 10.3, 7.8, 5.3, 2.8)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12.8</span>, <span class="number">2.2</span>，<span class="number">2.5</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果步长为字符串，那么会使用 <code>doubleval()</code> 转换为浮点数，如果步长为 <code>0.0</code> 那么将抛出异常</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12.8, 10.3, 7.8, 5.3, 2.8)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12.8</span>, <span class="number">2.2</span>，<span class="string">'2.5'</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>转换后步长为 0 则抛出异常</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: range(): step exceeds the specified range</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12.8</span>, <span class="number">2.2</span>，<span class="string">'a2.5'</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用法三-：-start-和-end-如果有一个是整数或者浮点数"><a href="#用法三-：-start-和-end-如果有一个是整数或者浮点数" class="headerlink" title="用法三 ： $start 和 $end 如果有一个是整数或者浮点数"></a>用法三 ： <code>$start</code> 和 <code>$end</code> 如果有一个是整数或者浮点数</h1><p><code>$start</code> 和 <code>$end</code> 如果有一个是整数或者浮点数，而另一个是字符串，那么会将另一个也转换为整数或者浮点数</p><ol><li><p>一个是整数而另一个是字符串整数，那么会将另一个转换为整数，结果和都是整数是类似的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(0, 2, 4, 6, 8, 10, 12)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">0</span>, <span class="string">'12'</span>，<span class="number">2</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个是浮点数而另一个是字符串整数或浮点数，那么会将另一个转换为浮点数，结果和都是整数是类似的</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12.8, 10.8, 8.8, 6.8, 4.8, 2.8)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12.8</span>, <span class="string">'2'</span>, <span class="number">2</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用法四-：-start-和-end-如果全部是字符串"><a href="#用法四-：-start-和-end-如果全部是字符串" class="headerlink" title="用法四 ： $start 和 $end 如果全部是字符串"></a>用法四 ： <code>$start</code> 和 <code>$end</code> 如果全部是字符串</h1><p><code>$start</code> 和 <code>$end</code> 如果全部是字符串，那么会取两个字符串的第一个字母，并按照 ASCII 字母顺序表，取步长对应的值</p><ol><li><p>如果 <code>$start</code> 和 <code>$end</code> 都是单个字母，那么直接按照 ASCII 顺序取步长的值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i');</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="string">'a'</span>, <span class="string">'i'</span>) <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $letter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果按照 ASCII 顺序，<code>$start</code> 大于 <code>$end</code> ，那么会反向步长取值，这个和整数是类似的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array('c', 'b', 'a');</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="string">'c'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $letter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>$start</code> 或 <code>$end</code> 任意一个字符串长度大于 1 ，那么只会取第一个字母</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i');</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="string">'abc'</span>, <span class="string">'i'</span>) <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $letter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果两个都是字符串，而其中一个是整数字符串或者浮点数字符串，那也会当作普通字符串来处理</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> implode(<span class="string">""</span>,range(<span class="string">"9 "</span>,<span class="string">"Q"</span>));  <span class="comment">//space after the 9</span></span><br><span class="line"><span class="comment">// prints 9:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQ</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>那么，我们如何使用<code>range()</code>来输出 <a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII</a> 的所有可见字符呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> json_encode(range(<span class="string">' '</span>, <span class="string">'~'</span>)); </span><br></pre></td></tr></table></figure><p>输出是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">" "</span>,<span class="string">"!"</span>,<span class="string">"\""</span>,<span class="string">"#"</span>,<span class="string">"$"</span>,<span class="string">"%"</span>,<span class="string">"&amp;"</span>,<span class="string">"'"</span>,<span class="string">"("</span>,<span class="string">")"</span>,<span class="string">"*"</span>,<span class="string">"+"</span>,<span class="string">","</span>,<span class="string">"-"</span>,<span class="string">"."</span>,<span class="string">"\/"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">":"</span>,<span class="string">";"</span>,<span class="string">"&lt;"</span>,<span class="string">"="</span>,<span class="string">"&gt;"</span>,<span class="string">"?"</span>,<span class="string">"@"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"F"</span>,<span class="string">"G"</span>,<span class="string">"H"</span>,<span class="string">"I"</span>,<span class="string">"J"</span>,<span class="string">"K"</span>,<span class="string">"L"</span>,<span class="string">"M"</span>,<span class="string">"N"</span>,<span class="string">"O"</span>,<span class="string">"P"</span>,<span class="string">"Q"</span>,<span class="string">"R"</span>,<span class="string">"S"</span>,<span class="string">"T"</span>,<span class="string">"U"</span>,<span class="string">"V"</span>,<span class="string">"W"</span>,<span class="string">"X"</span>,<span class="string">"Y"</span>,<span class="string">"Z"</span>,<span class="string">"["</span>,<span class="string">"\\"</span>,<span class="string">"]"</span>,<span class="string">"^"</span>,<span class="string">"_"</span>,<span class="string">"`"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>,<span class="string">"j"</span>,<span class="string">"k"</span>,<span class="string">"l"</span>,<span class="string">"m"</span>,<span class="string">"n"</span>,<span class="string">"o"</span>,<span class="string">"p"</span>,<span class="string">"q"</span>,<span class="string">"r"</span>,<span class="string">"s"</span>,<span class="string">"t"</span>,<span class="string">"u"</span>,<span class="string">"v"</span>,<span class="string">"w"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>,<span class="string">"&#123;"</span>,<span class="string">"|"</span>,<span class="string">"&#125;"</span>,<span class="string">"~"</span>] </span><br></pre></td></tr></table></figure></blockquote><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://www.twle.cn/c/yufei/phpmiss/phpmiss-basic-range.html" target="_blank" rel="noopener">https://www.twle.cn/c/yufei/phpmiss/phpmiss-basic-range.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度网盘分享密码暴力破解</title>
      <link href="/post/crack-pwd-of-baidu-netdisk/"/>
      <url>/post/crack-pwd-of-baidu-netdisk/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cm8wum14j30wq0fc3zg.jpg" alt=""></p><p>前几天阅读了一篇<a href="https://thezerohack.com/hack-any-instagram" target="_blank" rel="noopener">文章</a>，作者通过枚举重置密码的手机验证码来修改任意用户的账号密码。这种方式被普遍应用，但我们确实比较少的关心这可能存在漏洞，纯数字的验证码只要在失效前通过程序枚举很快就能被破解。受此启发，也想尝试下百度网盘的分享密码破解试验。</p><a id="more"></a><p>百度网盘的分享密码为4个字符，因此，我们可以通过调用认证接口来暴力破解。</p><p>通过 Chrome 的网络请求分析，结合 POSTMAN 模拟请求，我们得知，网盘密码认证主要参数有</p><ol><li>分享链接识别码</li><li>毫秒时间戳</li><li>http 的 refer 头</li><li>post 方式发送的密码</li></ol><p>于是，我们有了以下的一段代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crackBaiduNetdiskPwd</span><span class="params">($url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $shareCode = ltrim(strstr($url, <span class="string">'/1'</span>),<span class="string">'/1'</span>);</span><br><span class="line">    $baseUrl = <span class="string">'https://pan.baidu.com/share/verify?'</span>;</span><br><span class="line">    $get_params = [</span><br><span class="line">        <span class="string">'surl'</span> =&gt; $shareCode,</span><br><span class="line">        <span class="string">'t'</span> =&gt; intval(microtime(<span class="keyword">true</span>) * <span class="number">1000</span>),</span><br><span class="line">        <span class="string">'channel'</span> =&gt; <span class="string">'chunlei'</span>,</span><br><span class="line">        <span class="string">'web'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">        <span class="string">'clienttype'</span> =&gt; <span class="number">0</span>,</span><br><span class="line">        <span class="string">'app_id'</span> =&gt; <span class="number">123456</span>,</span><br><span class="line">        <span class="string">'bdstoken'</span> =&gt; <span class="string">''</span>,</span><br><span class="line">        <span class="string">'logid'</span> =&gt; <span class="string">'MTU2Njc5MTgzODkyNzAuNjM3NzgzODMwMzQ1MjE3NQ=='</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    $requestUrl = $baseUrl.http_build_query($get_params);</span><br><span class="line"></span><br><span class="line">    $pwd = <span class="string">'77wk'</span>;<span class="comment">//todo 生成密码</span></span><br><span class="line">    $post_params = [</span><br><span class="line">        <span class="string">'pwd'</span> =&gt; $pwd,</span><br><span class="line">        <span class="string">'vscode'</span> =&gt; <span class="string">''</span>,</span><br><span class="line">        <span class="string">'vscode_str'</span> =&gt; <span class="string">''</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    $ch = curl_init($requestUrl);</span><br><span class="line">    curl_setopt_array(</span><br><span class="line">        $ch,</span><br><span class="line">        [</span><br><span class="line">            CURLOPT_POST =&gt; <span class="keyword">true</span>,</span><br><span class="line">            CURLOPT_POSTFIELDS =&gt; http_build_query($post_params),<span class="comment">//设定 POST 参数内容</span></span><br><span class="line">            <span class="comment">// CURLOPT_FOLLOWLOCATION =&gt; true,//跟随重定向地址</span></span><br><span class="line">            <span class="comment">// CURLOPT_AUTOREFERER =&gt; true,</span></span><br><span class="line">            CURLOPT_RETURNTRANSFER =&gt; <span class="keyword">true</span>,<span class="comment">//将curl_exec()获取的信息以字符串返回，而不是直接输出。</span></span><br><span class="line">            CURLOPT_USERAGENT =&gt; <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span>,</span><br><span class="line">            CURLOPT_REFERER =&gt; <span class="string">'https://pan.baidu.com/share/init?surl='</span>.$shareCode<span class="comment">//必填项</span></span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//todo 并发请求 https://www.php.net/manual/zh/function.curl-multi-init.php#118142</span></span><br><span class="line">    $response = curl_exec($ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(! json_decode($response)-&gt;errno) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'破解成功，密码为：'</span>.$pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">crackBaiduNetdiskPwd(<span class="string">'https://pan.baidu.com/s/1gftmNyb'</span>);</span><br></pre></td></tr></table></figure><p>至此，单次请求已经成功，但剩余的工作还有：</p><ol><li>我们需要生成纯字母、字母数字、纯数字三种类型的密码，且这三类的权重依次降低，三类中的重复密码（如：<code>aaaa</code>，<code>6666</code>）权重最低</li><li>给定密码区间段和类型，如何生成指定长度的密码，如，怎样生成<code>aaaa ~ zzzz</code>的密码？（现有思路：将字母转换为 ASCII 对应的数字，共 4 个位，将其转换为数组。如果第0位值达到<code>z</code>，则向高位进位，低位归位处理）</li><li>php 实现并发请求</li><li>添加IP代理，避免单一IP请求被封禁</li><li>添加日志，支持断点续破</li><li>记录每次破解的耗时与次数，用于后期分析</li></ol><p>—2019-09-19更新—</p><p>生成<code>aaaa ~ zzzz</code>的密码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlphabet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="string">'aaaa'</span>; $i &lt; <span class="string">'zzzz'</span>; $i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> $i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'zzzy'</span> === $i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">yield</span> get4Z();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get4Z</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'zzzz'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (getAlphabet() <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $letter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成字母数字的密码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlphanumeric</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li>如果需要获取更高精度的时间戳，可以调整<code>php.ini</code>中的<code>precision</code>的值。</li><li><code>curl_setopt_array</code>中的 key 是预设常量，如果写作字符串（如<code>&#39;CURLOPT_POSTFIELDS&#39;</code>），则会有<code>curl_setopt_array(): Array keys must be CURLOPT constants or equivalent integer values in</code>的错误</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【转】对PHP后期静态绑定的理解</title>
      <link href="/post/late-static-binding/"/>
      <url>/post/late-static-binding/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8clz2qre3j30jg0b5q59.jpg" alt=""></p><a id="more"></a><h1 id="什么是后期静态绑定"><a href="#什么是后期静态绑定" class="headerlink" title="什么是后期静态绑定"></a>什么是后期静态绑定</h1><p>在看一些框架源码或者是某个项目的代码时，经常能看到后期静态绑定的用法，比如下面这段：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_null(<span class="keyword">static</span>::$instance)) &#123;</span><br><span class="line">        <span class="keyword">static</span>::$instance = <span class="keyword">new</span> <span class="keyword">static</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static</span>::$instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到的就是后期静态绑定。那么，什么是后期静态绑定？</p><p>“后期绑定” 的意思是说，<code>static::</code>不再被解析为定义当前方法所在的类，而是在运行时计算的。这里要先说两个概念，一个是转发调用，另一个是非转发调用。</p><ul><li><p>转发调用<br>所谓的 “转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：<code>self::</code>, <code>parent::</code>, <a href="https://www.php.net/manual/zh/language.oop5.static.php" target="_blank" rel="noopener"><code>static::</code></a> 以及 <a href="https://www.php.net/manual/zh/function.forward-static-call.php" target="_blank" rel="noopener"><code>forward_ static _call()</code></a>。即<strong>在进行静态调用时未指明类名的调用属于转发调用</strong>。</p></li><li><p>非转发调用<br>非转发调用其实就是明确指定类名的静态调用（<code>foo::bar()</code>）和非静态调用 (<code>$foo-&gt;bar()</code>)。即<strong>明确地指定类名的静态调用和非静态调用</strong>。</p></li></ul><p>顾名思义，<strong>非转发调用前面有类名所以调用的函数一定是属于 “这个类的”，不需要转到别的类。转发调用就是由于前期的静态绑定导致在后面调用静态方法时可能 “转发到其他的类”</strong></p><p>在 PHP 的官方文档里，对于后期静态绑定是这样说的：后期静态绑定工作原理是存储了在上一个 “非转发调用”（non-forwarding call）中的类名。意思是<strong>当我们调用一个转发调用的静态调用时，实际调用的类是上一个非转发调用的类</strong>。</p><p>来看两个例子：</p><p>例子1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::who(); <span class="comment">// 后期静态绑定从这里开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test();</span><br></pre></td></tr></table></figure><p>以上代码会输出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::who();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A::foo();</span><br><span class="line">        <span class="keyword">parent</span>::foo();</span><br><span class="line">        <span class="keyword">self</span>::foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::test();</span><br></pre></td></tr></table></figure><p>以上代码会输出</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span></span><br><span class="line">C</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>在这里主要分析下例 2。</p><ol><li><code>C::test()</code>，这是一个非转发调用，因为：：前面有类名 C。</li><li>进入 <code>test()</code> 方法，有三个静态调用 <code>A::foo()</code>,<code>parent::foo()</code>,<code>self::foo()</code>, 对于这三个静态调用来说，他们的非转发调用类就是 C。</li><li>现在执行 <code>A::foo()</code>, 这是一个非转发调用。<code>A::foo()</code> 中的代码是 <code>static::who()</code>, 这是一个转发调用，对于这个转发调用来说他的非转发调用类就是不再是 C 而是 A（因为之前执行了 <code>A::foo()</code>）。因此执行的结果为 A</li><li>现在执行 <code>parent::foo()</code>, 这是一个转发调用，转发到哪里呢？就是它的上一个非转发调用的类，也就是类 C（在步骤 2 中提到的）。在这里一定要注意虽然在这之前执行了 <code>A::foo()</code>, 但是 <code>parent::foo()</code> 的上一个非转发调用的类任然是类 C。因此执行的结果是 C.</li><li>现在执行 <code>self::foo()</code>, 这个和 <code>parent::foo()</code> 一样都是转发调用，因此也输出 C。</li></ol><blockquote><p>想要搞清楚后期静态绑定，就是要知道 <code>static</code> 是哪个类。</p></blockquote><h1 id="使用后期静态绑定的好处"><a href="#使用后期静态绑定的好处" class="headerlink" title="使用后期静态绑定的好处"></a>使用后期静态绑定的好处</h1><p>后期静态绑定目前我看到较多的是用于对象实例化中，在实例化对象时，<code>static</code> 会根据运行时调用的类来决定实例化对象，而 <code>self</code> 则是根据所在位置的类来决定实例化对象。当我们只想实例化子类，并且不希望后续在对子类的使用中由于父类的变化对子类产生影响时，后期静态绑定就能发挥它的作用了。</p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国家图书馆自习不完全指南</title>
      <link href="/post/the-national-library-guide/"/>
      <url>/post/the-national-library-guide/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87clzenr2j30ph0cw0y0.jpg" alt=""></p><a id="more"></a><p>无论是工作之余充电，还是赶制论文，国家图书馆都是一个非常好的选择，一方面是有很多免费的自习空位，另一方面在这样的氛围中容易集中注意力、高效学习，最重要的是，借阅区的书籍只要不带出馆区，都可以免费借阅。但国图也有一些缺点：比如免费 WiFi 由于使用人数较多，速度非常慢，所以如果你非常依赖网络，建议使用手机热点。</p><h1 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h1><p>地铁 4 号线国家图书馆站，毗邻动物园。</p><h1 id="开放时间"><a href="#开放时间" class="headerlink" title="开放时间"></a>开放时间</h1><p>总馆北区：周一至周五9：00–21：00，周六和周日9：00–17：00<br>古籍馆：周一至周五9：00–17：00<br>少年儿童馆：周一至周日9：00–17：00 （北区一层东侧）</p><blockquote><p>相比于火爆的北区，古籍馆相对冷清许多。北区 10 点多到可能就找不到插座能用的座位了，而且中午吃完饭回来座位还可能被占，但古籍馆一整天都会有空位，而且自习的人相对较少，也更加的安静</p></blockquote><h1 id="存取包"><a href="#存取包" class="headerlink" title="存取包"></a>存取包</h1><p>国图不允许携带自己的图书与书包进入，可以在存包处将书包存好。如果携带了电脑，则需更换网兜。</p><h1 id="出入须知"><a href="#出入须知" class="headerlink" title="出入须知"></a>出入须知</h1><p>每次出入均需刷身份证或者读者卡</p><h1 id="关于借阅"><a href="#关于借阅" class="headerlink" title="关于借阅"></a>关于借阅</h1><ol><li>借阅前须办理读者证并缴纳押金，中文图书 100 元，外文图书 1000 元。</li><li>如需查询借阅图书状态与位置，可在馆内的开放计算机查询，或者在 <a href="http://opac.nlc.cn/F?RN=737257934" target="_blank" rel="noopener">http://opac.nlc.cn/F?RN=737257934</a> 查询</li><li>但国图借书的人实在是太多了，我之前想借的基本书，一直都是外借状态，后来就放弃退押金了</li></ol><h1 id="关于吃饭"><a href="#关于吃饭" class="headerlink" title="关于吃饭"></a>关于吃饭</h1><p>国图附近餐厅较少，没有太多的选择，北区背后有家国图小馆，价格味道都还可以，我经常去。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP也有Day</title>
      <link href="/post/php-has-day/"/>
      <url>/post/php-has-day/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006tNc79ly1g4rr5qi6qxj3097064t8y.jpg" alt=""></p><a id="more"></a><h1 id="1-精通-PHP-錯誤處理，讓除錯更自在"><a href="#1-精通-PHP-錯誤處理，讓除錯更自在" class="headerlink" title="1. 精通 PHP 錯誤處理，讓除錯更自在"></a>1. <a href="https://www.youtube.com/watch?v=QYjklJz5ed0&list" target="_blank" rel="noopener">精通 PHP 錯誤處理，讓除錯更自在</a></h1><p>PHP错误设定</p><ul><li>PHP 预设为<code>E_ALL &amp; ~E_NOTICE</code>，即显示除 Notice 外的所有错误</li><li>在开发过程中，建议将错误级别设置为 E_ALL 或 -1，开发者应该处理所有可能的 Warning &amp; Notice，不要让任何可能的 Bug 有机会出现。</li><li>老旧系统运行时，可以考虑设置为 0，避免用户看到大量的 Notice信息。</li><li>生产环境中，可以设置为 0，但将所有重要错误记录进 log。</li></ul><p><code>set_error_handler()</code> 方法可以自定义错误处理，该方法会覆盖系统的标准错误处理。<br><code>error_log()</code> 可用于记录执行的错误信息</p><p>可以使用 <a href="https://github.com/Seldaek/monolog" target="_blank" rel="noopener">Monolog</a> 来管理日志信息。<br>如果公司采用微服务，可以考虑将单台服务器用作日志服务器，以免日志空间不足。</p><p>PHP 7的 Exceptions<br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4rqg01lb0j30nf0h9dh4.jpg" alt="PHP 7的 Exceptions"></p><p>异常状况的处理示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($jobs <span class="keyword">as</span> $job) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Queue::process($job);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (QueueException $e) &#123;</span><br><span class="line">        Mailer::send(<span class="string">'A queue job error'</span>, $message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各系统包管理工具及常用系统命令</title>
      <link href="/post/package-managment-tools/"/>
      <url>/post/package-managment-tools/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cm0hhup6j308c06c0st.jpg" alt=""></p><p>常见包管理工具总结</p><a id="more"></a><h1 id="macOS-之-Homebrew"><a href="#macOS-之-Homebrew" class="headerlink" title="macOS 之 Homebrew"></a>macOS 之 Homebrew</h1><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>brew search &lt;package-name&gt;</code></td><td>搜索软件</td></tr><tr><td><code>brew install &lt;package-name&gt;</code></td><td>安装软件</td></tr><tr><td><code>brew uninstall &lt;package-name&gt;</code></td><td>卸载软件</td></tr><tr><td><code>brew list</code></td><td>列出已安装软件</td></tr><tr><td><code>brew info &lt;package-name&gt;</code></td><td>显示软件信息，包括版本信息、依赖信息、启动命令等</td></tr><tr><td><code>brew outdated</code></td><td>检查可更新软件</td></tr><tr><td><code>brew update</code></td><td>更新待更新的软件</td></tr><tr><td><code>brew cleanup</code></td><td>清理软件安装包</td></tr><tr><td><code>brew services list</code></td><td>查看brew安装软件的开机启动项</td></tr><tr><td><code>brew services cleanup</code></td><td>清除无效的开机启动项</td></tr><tr><td><code>brew switch &lt;package-name&gt; &lt;version&gt;</code></td><td>切换同一软件的不同版本</td></tr><tr><td><code>brew doctor</code></td><td>查看是否有软件配置异常</td></tr></tbody></table><h1 id="macOS-之-Homebrew-Cask"><a href="#macOS-之-Homebrew-Cask" class="headerlink" title="macOS 之 Homebrew Cask"></a>macOS 之 Homebrew Cask</h1><p>Homebrew Cask 是一个类似于 App Store 的终端软件安装工具，命令与 <code>brew</code> 相似，其常用命令如下：</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>brew cask search &lt;app-name&gt;</code></td><td>搜索软件</td></tr><tr><td><code>brew cask install &lt;app1&gt; &lt;app2&gt; ...</code></td><td>安装软件</td></tr><tr><td><code>brew cask uninstall &lt;app1&gt; &lt;app2&gt; ...</code></td><td>卸载软件</td></tr><tr><td><code>brew cask info &lt;app-name&gt;</code></td><td>查看软件信息</td></tr><tr><td><code>brwe cask list</code></td><td>列出已安装软件</td></tr></tbody></table><h1 id="CentOS-之-yum"><a href="#CentOS-之-yum" class="headerlink" title="CentOS 之 yum"></a>CentOS 之 yum</h1><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>yum search &lt;package-name&gt;</code></td><td>搜索软件包</td></tr><tr><td><code>yum install &lt;package-name&gt;</code></td><td>安装软件</td></tr><tr><td><code>yum remove &lt;package-name&gt;</code></td><td>卸载软件</td></tr><tr><td><code>yum update &lt;package-name&gt;</code></td><td>更新软件</td></tr><tr><td><code>yum check-update</code></td><td>检查可更新软件</td></tr><tr><td><code>yum provides &lt;command&gt;</code></td><td>查看支持某个命令的包</td></tr></tbody></table><h1 id="Ubuntu-Debian-之-apt"><a href="#Ubuntu-Debian-之-apt" class="headerlink" title="Ubuntu/Debian 之 apt"></a>Ubuntu/Debian 之 apt</h1><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>apt search &lt;package-name&gt;</code></td><td>搜索软件包</td></tr><tr><td><code>apt install &lt;package-name&gt;</code></td><td>安装软件</td></tr><tr><td><code>apt remove &lt;package-name&gt;</code></td><td>卸载软件</td></tr><tr><td><code>apt info &lt;package-name&gt;</code></td><td>查看软件信息</td></tr><tr><td><code>apt update</code></td><td>更新软件</td></tr><tr><td><code>apt list --upgradeable</code></td><td>检查可更新软件</td></tr><tr><td><code>apt list --installed</code></td><td>列出已安装软件</td></tr><tr><td><code>apt upgrade</code></td><td>升级软件</td></tr><tr><td><code>apt autoclean</code></td><td>删除所有软件缓存</td></tr><tr><td><code>apt autoremove</code></td><td>删除系统不再使用的孤立软件</td></tr></tbody></table><h1 id="CentOS-之-systemctl"><a href="#CentOS-之-systemctl" class="headerlink" title="CentOS 之 systemctl"></a>CentOS 之 systemctl</h1><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>systemctl list-unit-files</code></td><td>列出所有可用服务</td></tr><tr><td><code>systemctl list-units</code></td><td>列出所有运行中的服务</td></tr><tr><td><code>systemctl --failed</code></td><td>列出所有失败的服务</td></tr><tr><td>systemctl list-unit-files &#124; grep enable</td><td>查看自启动的软件</td></tr><tr><td><code>systemctl is-enabled &lt;service-name&gt;</code></td><td>查看某个服务是否开机启动</td></tr><tr><td><code>systemctl status &lt;service-name&gt;</code></td><td>查看服务状态</td></tr><tr><td><code>systemctl start &lt;service-name&gt;</code></td><td>启动某个服务</td></tr><tr><td><code>systemctl restart &lt;service-name&gt;</code></td><td>重启某个服务</td></tr><tr><td><code>systemctl stop &lt;service-name&gt;</code></td><td>停止某个服务</td></tr><tr><td><code>systemctl daemon-reload</code></td><td>重载服务配置文件</td></tr><tr><td><code>systemctl reload &lt;service-name&gt;</code></td><td>重载服务</td></tr><tr><td><code>systemctl enable &lt;service-name&gt;</code></td><td>设置开机自启动</td></tr><tr><td><code>systemctl disable &lt;service-name&gt;</code></td><td>关闭开机自启动</td></tr><tr><td><code>systemctl kill &lt;service-name&gt;</code></td><td>杀死服务</td></tr></tbody></table><p>Systemd 设置示例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=Laravel<span class="built_in"> queue </span>worker</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="attribute">User</span>=www-data</span><br><span class="line"><span class="attribute">Group</span>=www-data</span><br><span class="line"><span class="attribute">Restart</span>=on-failure</span><br><span class="line"><span class="attribute">ExecStart</span>=/usr/bin/php/path/to/laravel/artisan queue:work <span class="attribute">--sleep</span>=3 <span class="attribute">--tries</span>=3</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><h1 id="Ubuntu-Debian-之-supervisorctl"><a href="#Ubuntu-Debian-之-supervisorctl" class="headerlink" title="Ubuntu/Debian 之 supervisorctl"></a>Ubuntu/Debian 之 supervisorctl</h1><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>supervisorctl start &lt;service-name&gt;</code></td><td>启动服务</td></tr><tr><td><code>supervisorctl stop &lt;service-name&gt;</code></td><td>停止服务</td></tr><tr><td><code>supervisorctl restart &lt;service-name&gt;</code></td><td>重启服务</td></tr><tr><td><code>supervisorctl status &lt;service-name&gt;</code></td><td>查看服务状态</td></tr><tr><td><code>supervisorctl update</code></td><td>更新服务</td></tr></tbody></table><p>Supervisord 设置示例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:laravel-worker]</span><br><span class="line">process_ <span class="attribute">name</span>=%(program_name)s_%(processnum)02d</span><br><span class="line"><span class="attribute">command</span>=/usr/bin/php/path/to/laravel/artisan <span class="attribute">--sleep</span>=3 <span class="attribute">--tries</span>=3</span><br><span class="line"><span class="attribute">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">user</span>=www</span><br><span class="line"><span class="attribute">numprocs</span>=8</span><br><span class="line">redirect_ <span class="attribute">stderr</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">stdout_logfile</span>=/var/www/html/storage/logs/worker.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程学习方法</title>
      <link href="/post/how-to-learn-programming/"/>
      <url>/post/how-to-learn-programming/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87codalcgj319i0h2jt4.jpg" alt=""></p><p>一天很长，一生很短。</p><a id="more"></a><ol><li>不断练习<br>Learn by doing!</li><li>官方文档<br>快速、准确、高效</li><li>O’Reilly 等经典书籍<br>体系化知识，行业大牛多年经验，站在巨人的肩膀上。</li><li>GitHub<br>优秀开源项目让你事半功倍<br>GitHub Trending 让你了解当前行业热点</li><li>Google<br>你所遇到的 99% 的问题 Google 都知道答案</li><li>YouTube<br>来自世界各地的视频教程与分享</li><li>Stack Overflow<br>高效解决问题</li><li>Hacker News<br>来自全球的行业最新资讯</li><li>reddit<br>互联网首页</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树莓派从零安装 Docker</title>
      <link href="/post/install-docker-on-pi/"/>
      <url>/post/install-docker-on-pi/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4d44ll1ydj31a90ijjuz.jpg" alt=""></p><p>Write Once, Run Everywhere.</p><a id="more"></a><p>今天树莓派刚刚发布了<a href="https://www.raspberrypi.org/blog/raspberry-pi-4-on-sale-now-from-35/" target="_blank" rel="noopener">树莓派 4</a>，以下是本次升级的主要变化：</p><ul><li>A 1.5GHz quad-core 64-bit ARM Cortex-A72 CPU (~3× performance)</li><li>1GB, 2GB, or 4GB of LPDDR4 SDRAM</li><li>Full-throughput Gigabit Ethernet</li><li>Dual-band 802.11ac wireless networking</li><li>Bluetooth 5.0</li><li>Two USB 3.0 and two USB 2.0 ports</li><li>Dual monitor support, at resolutions up to 4K</li><li>VideoCore VI graphics, supporting OpenGL ES 3.x</li><li>4Kp60 hardware decode of HEVC video</li><li>Complete compatibility with earlier Raspberry Pi products</li></ul><p>虽然真香，但想起我还在吃灰的 3B，于是打算先把 3B 用起来。那我们就从头开始吧。</p><p>树莓派是基于ARM架构的，和与PC不同。所以一些树莓派上的镜像无法在PC上运行，反之亦然。如果需要找树莓派专用的镜像，在 Dockerhub 上搜索 ARM 或 Rpi 等相关关键词即可。</p><p>我们讲解两种 docker 安装方式：</p><h1 id="方式一：手动安装"><a href="#方式一：手动安装" class="headerlink" title="方式一：手动安装"></a>方式一：手动安装</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><blockquote><p>macOS 10.14.5<br>Raspberry 3B<br>Pi OS Version: Raspbian Buster Lite<br>balenaEtcher Version: 1.5.50</p></blockquote><h2 id="Step-1-下载系统"><a href="#Step-1-下载系统" class="headerlink" title="Step 1 下载系统"></a>Step 1 下载系统</h2><p>前往树莓派官网<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">下载</a>所需系统，由于手头只有一张 16G 的内存卡，同时为了将系统资源用在执行任务而非桌面上，因此我选择的是 Raspbian Buster Lite。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4d3gmin6rj30rk0fmac7.jpg" alt=""></p><p>系统下载完成后，解压 zip 包，我们会得到一个后缀为 .img 的镜像包。</p><h2 id="Step-2-烧录系统"><a href="#Step-2-烧录系统" class="headerlink" title="Step 2 烧录系统"></a>Step 2 烧录系统</h2><p>前往 <a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">https://www.balena.io/etcher/</a> 下载烧录工具，该工具支持 Mac、Windows、Linux 系统（终于不用在虚拟机里处理了），接下来，打开 balenaEtcher，插入内存卡，选择上一步的 img 镜像包，点击 Flash 按钮，等待烧录完成</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4d3ihshskj30ma0b9aan.jpg" alt=""></p><blockquote><p>注意：如果直接将解压的镜像包内容拷贝到内存卡中，会出现无法安装的问题。我试了最新的两个 Lite 安装包，一个出现<code>cma_alloc alloc failed</code>的错误，另一个光标一直在屏幕左上角闪烁。最后通过该烧录软件顺利完成。<br>参考资料 <a href="https://www.youtube.com/watch?v=y5SOuBOy2ZQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=y5SOuBOy2ZQ</a></p></blockquote><h2 id="Step-3-安装系统"><a href="#Step-3-安装系统" class="headerlink" title="Step 3 安装系统"></a>Step 3 安装系统</h2><p>当烧录完成后，将内存卡弹出，然后插入树莓派，并连接 HDMI 接口的显示器与键盘。当以上工作都完成后，对树莓派进行供电，此时，系统会自动执行安装操作</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4d3lmipe3j30ma0jq0w5.jpg" alt=""></p><p>当最后出现 login 时，表示系统已经安装完成。树莓派的默认用户名为 pi，密码为 raspberry。root 用户需要通过命令 <code>sudo passwd root</code> 激活并设置密码。</p><h2 id="Step-4-系统设置"><a href="#Step-4-系统设置" class="headerlink" title="Step 4 系统设置"></a>Step 4 系统设置</h2><p>输入命令<code>sudo raspi-config</code>进入系统配置页。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4d3qh6emrj314m0loq6p.jpg" alt=""></p><p>此处可设置 WiFi 网络、ssh、时区等相关信息。</p><h2 id="Step-5-安装-Docker"><a href="#Step-5-安装-Docker" class="headerlink" title="Step 5 安装 Docker"></a>Step 5 安装 Docker</h2><p>根据 Docker <a href="https://docs.docker.com/install/linux/docker-ce/debian/" target="_blank" rel="noopener">官方文档</a>，在树莓派中安装 docker，支持以下3种方式：</p><ol><li>通过设置 Docker 仓库安装，该方式为 debian 的推荐安装方式，但<strong>不支持树莓派</strong>。</li><li>通过下载 deb 包手动安装与升级，适用于无网络状态。</li><li>通过<a href="https://docs.docker.com/install/linux/docker-ce/debian/#install-using-the-convenience-script" target="_blank" rel="noopener">官方脚本</a>安装，适用于测试与开发环境，<strong>切勿用于生产环境</strong>，且该方式<strong>仅支持树莓派</strong>安装。</li></ol><p>海外用户可通过以下两个教程安装：</p><ol><li><a href="https://pcmac.biz/Docker_Raspberrypi.html" target="_blank" rel="noopener">https://pcmac.biz/Docker_Raspberrypi.html</a></li><li><a href="https://blog.docker.com/2019/03/happy-pi-day-docker-raspberry-pi/" target="_blank" rel="noopener">https://blog.docker.com/2019/03/happy-pi-day-docker-raspberry-pi/</a></li></ol><p>大陆用户可通过以下教程安装：</p><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/install/raspberry-pi.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/install/raspberry-pi.html</a><br>大陆由于网络原因，需要将树莓派的仓库镜像源更换为<a href="https://mirror.tuna.tsinghua.edu.cn/help/raspbian/" target="_blank" rel="noopener">国内镜像源</a><br>在执行<code>get-docker.sh</code>时，也需要指定为阿里云<code>$ sudo sh get-docker.sh --mirror Aliyun</code>加速。</li></ul><blockquote><p>需要注意的是，当前树莓派刚更新为 debian 最新版本 buster，但 docker 尚未支持 buster，因此当执行<code>curl -sSL https://get.docker.com | sh</code>时会遇到错误 <code>E: The repository &#39;https://download.docker.com/linux/raspbian 10 Release&#39; does not have a Release file.</code>。</p><p>通过输出可知，脚本获取了当前的最新版本，并写入了文件<code>/etc/apt/sources.list.d/docker.list</code>，但现在尚不支持最新版本，因此可以我们需要修改<code>get-docker.sh</code>指定脚本为可支持的版本: </p><p><code>$sh_c &quot;echo \&quot;$apt_repo\&quot; &gt; /etc/apt/sources.list.d/docker.list&quot;</code><br>为<br><code>$sh_c &quot;echo \&quot;deb [arch=armhf] https://mirrors.aliyun.com/docker-ce/linux/raspbian stretch stable\&quot; &gt; /etc/apt/sources.list.d/docker.list&quot;</code>，<br>然后验证<code>/etc/apt/sources.list.d/docker.list</code>的内容是否与脚本一致，一致就可以执行脚本并安装了。</p></blockquote><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4d8wb2n9xj30u00vtdop.jpg" alt=""></p><p>经过一上午的折腾，终于成功安装了 docker！</p><h2 id="Step-6-安装-Docker-Compose"><a href="#Step-6-安装-Docker-Compose" class="headerlink" title="Step 6 安装 Docker Compose"></a>Step 6 安装 Docker Compose</h2><p>安装完 docker 后，我们还需要安装 docker compose。我们可以通过<code>sudo apt install python-pip</code>来安装 Python 的包管理工具，安装成功后，执行命令<code>pip install docker-compose</code>安装 docker compose，安装过程时间较长（可使用<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple docker-compose</code>来临时使用清华 pypi 镜像源），也可能因网络原因出现多次中断的情况，请耐心等待。</p><blockquote><p>注意：<code>sudo apt install python3-pip</code> 安装 pip3 会有很多的问题，因此我们通过安装 pip2 来解决。</p></blockquote><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>使用 HypriotOS 而非树莓派官方系统。<a href="https://blog.hypriot.com/faq/" target="_blank" rel="noopener">这里</a>介绍了什么是 HypriotOS。</p><p>虽然使用该方式可以快速安装 docker 及 docker-compose，但存在一个致命的问题——WiFi 无法使用，查询了大量的资料后，都是说修改 <code>user-data</code> 文件的以下内容，但我发现在未启用这段代码前，使用默认的用户名和密码可以正常登陆，但启用后，即使你没有修改默认的用户名和密码，仍然无法登陆。原因未知，在经过一番折腾后，我决定弃坑了。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4du26o13wj30g609v75c.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> raspberry pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaravelConf Taiwan</title>
      <link href="/post/laraconf-taiwan/"/>
      <url>/post/laraconf-taiwan/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4d4cfzp7cj310c0e9wh8.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from &#123;&#123;$idea&#125;&#125; to &#123;&#123;$production&#125;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="LaravelConf-2019"><a href="#LaravelConf-2019" class="headerlink" title="LaravelConf 2019"></a>LaravelConf 2019</h1><h2 id="1-Laravel-在高併發下的系統架構與效能優化-陳光賢-Albert"><a href="#1-Laravel-在高併發下的系統架構與效能優化-陳光賢-Albert" class="headerlink" title="1 Laravel 在高併發下的系統架構與效能優化 - 陳光賢 (Albert)"></a>1 Laravel 在高併發下的系統架構與效能優化 - 陳光賢 (Albert)</h2><p>高并发分为两种场景，依据不同场景有不同的解决方案：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zjqspfj0j311w0l90yx.jpg" alt=""></p><p>缓存使用注意事项<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zjvcummvj311x0l8ago.jpg" alt=""></p><p>当 DB 中的数据更新时，缓存同样需要更新，在 Laravel 中，通过观察者模式来实现同步更新，这是一个很好的应用场景。</p><p>根据“二八定律”，DB 在 20% 的时间写入，80% 的时间读取。(DB 主从)</p><p>通过 SQL Proxy，可以自动识别 SQL 的读写，也可以隔离具体的 DB，但同时也可能限制一些 SQL 函数的使用。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zk2ku5t8j311x0l90xl.jpg" alt=""></p><p>抢购的特点：</p><ul><li>持续时间短</li><li>瞬时高并发</li><li>响应缓慢造成用户发起更多的请求，形成恶性循环</li></ul><p>抢购的一些解决方案：</p><ul><li>对抢购的商品热点数据提前预热至 Redis 中</li><li>通过 Redis 的<code>set setnx</code>限制用户的重复提交</li><li>采用消息队列处理 DB 写入</li><li>当请求接近最大负载时，拒绝服务响应，触发熔断自我保护机制</li><li>过滤请求</li></ul><p>高并发的核心问题就是，如何将当前服务无法承载的请求降低到可以承受的范围内？<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zk76jaetj30mb0j9q59.jpg" alt=""></p><p>架构设计时需要注意保留有弹性，再随着业务的发展堆叠。</p><h1 id="LaravelConf-2018"><a href="#LaravelConf-2018" class="headerlink" title="LaravelConf 2018"></a>LaravelConf 2018</h1><h2 id="1-站点国际化"><a href="#1-站点国际化" class="headerlink" title="1 站点国际化"></a>1 <a href="https://www.youtube.com/watch?v=IOrOCBkrADw&list=PLVBnNBXRHG-jCJ8e2vfiCJCS2ipfX9-Rf&index=3" target="_blank" rel="noopener">站点国际化</a></h2><p>我们可通过用户的 Session、IP、设定偏好等方式来确定用户的位置，并呈现出本地化信息，如语言、时间、币种等。<br>geoip2/geoip2 可以通过 IP 获取到相关的地区、时区、语言等信息</p><h3 id="1-1-语言"><a href="#1-1-语言" class="headerlink" title="1.1 语言"></a>1.1 语言</h3><p>在 Laravel 5.x 中，可设定<code>/config/app.php</code>中的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$local = App::getLocale();</span><br><span class="line">App::setLocale($locale);</span><br></pre></td></tr></table></figure><p>Locale 的名称需要与 lang 目录的名称相同<br><code>en =&gt; /resources/lang/en</code></p><p>可以一种语言对应一个 view 目录，也可以多种语言对应一个 view(如 en-us 与 en-uk 对应 en)</p><p>php可以使用<code>mcamara/laravel-localization</code>来处理本地化问题：</p><ol><li>如果语言在网址中没有携带，则可以依据此包中的设定，决定使用<code>app.php</code>中的默认语言，还是浏览器请求头中的<code>Accept-Language</code></li><li>将没有请求语言的网址自动 301 到设定的默认语言</li></ol><h3 id="1-2-网址"><a href="#1-2-网址" class="headerlink" title="1.2 网址"></a>1.2 网址</h3><h4 id="1-2-1-以国家做区分"><a href="#1-2-1-以国家做区分" class="headerlink" title="1.2.1 以国家做区分"></a>1.2.1 以国家做区分</h4><p><a href="http://example.com/cn" target="_blank" rel="noopener">http://example.com/cn</a><br>相关ISO标准：ISO-3166-1<br>示例：Apple、Google</p><h4 id="1-2-2-以语言做区分"><a href="#1-2-2-以语言做区分" class="headerlink" title="1.2.2 以语言做区分"></a>1.2.2 以语言做区分</h4><p><a href="http://example.com/zh" target="_blank" rel="noopener">http://example.com/zh</a><br>相关ISO标准：ISO-639-1<br>示例：LINE</p><h3 id="1-3-时间"><a href="#1-3-时间" class="headerlink" title="1.3 时间"></a>1.3 时间</h3><p>大多跨境网站的时区设定为 UTC<br>时区设定为 UTC，存储时间信息时可以通过以下两种方式</p><ol><li>前端请求的时间转换为 UTC 后发送给后端</li><li>前端请求中携带时区信息，由后端转换为 UTC</li></ol><blockquote><p>注意夏令时对同一时区的时间影响。</p></blockquote><p>php中可以使用<code>nesbot/carbon</code>来处理时间问题</p><h3 id="1-4-币种"><a href="#1-4-币种" class="headerlink" title="1.4 币种"></a>1.4 币种</h3><p>问题一：该平台允许交易的币种有哪些？<br>问题二：如果支持多种币种，是否可以设定基础币种<br>问题三：使用固定汇率还是浮动汇率？</p><p>可使用<code>moneyphp/money</code>、<code>webpatser/laravel-countries</code>与<code>torann/currency</code></p><h3 id="1-5-数据格式"><a href="#1-5-数据格式" class="headerlink" title="1.5 数据格式"></a>1.5 数据格式</h3><p>手机号、地址<br><code>giggsey/libphonenumber-for-php</code>可处理手机号信息、如格式化、获取国家、运营商等<br><code>commerceguys/addressing</code> 可用于处理地址信息</p><h2 id="2-小项目的制作与推广"><a href="#2-小项目的制作与推广" class="headerlink" title="2 小项目的制作与推广"></a>2 <a href="https://www.youtube.com/watch?v=OqwwOpVuImY&list=PLVBnNBXRHG-jCJ8e2vfiCJCS2ipfX9-Rf&index=6" target="_blank" rel="noopener">小项目的制作与推广</a></h2><ol><li>很多功能可能并不确定是否会有好的反响，此时应该先快速做一个基础功能推出，根据用户使用情况再决定方向。</li><li>网站可通过捐赠或者出售，或者为客户定制化来盈利（定制化可将基础功能开源，然后对搭建与维护系统进行收费）</li><li>Laravel module 与 Git tree 可以管理多个相似定制化的项目</li></ol><h2 id="3-工程师的职业规划"><a href="#3-工程师的职业规划" class="headerlink" title="3 工程师的职业规划"></a>3 工程师的职业规划</h2><h3 id="3-1-Junior（毕业5年内）"><a href="#3-1-Junior（毕业5年内）" class="headerlink" title="3.1 Junior（毕业5年内）"></a>3.1 Junior（毕业5年内）</h3><ul><li>寻找方向，融入行业（加入大型稳定公司，学习高效行事能力、行业规范及职业价值观）</li></ul><h3 id="3-2-Senior（毕业5-10年）"><a href="#3-2-Senior（毕业5-10年）" class="headerlink" title="3.2 Senior（毕业5~10年）"></a>3.2 Senior（毕业5~10年）</h3><ul><li><strong>挑好的产品、好的团队文化加入</strong>（加入有潜力、正在快速成长的公司，积累很多经验。最好是面向普通用户型产品的精英团队。<em>在下份工作时，要找自己感兴趣的 C 端产品，询问公司的加班文化及自由度，比如：我们通常的上下班时间？贵公司对经常加班怎么看？是否会允许远程工作？是否会有经常会有凌晨上线？</em>）</li></ul><h3 id="3-3-接案者"><a href="#3-3-接案者" class="headerlink" title="3.3 接案者"></a>3.3 接案者</h3><ul><li>自由，但极需自律与严谨</li></ul><p>无法转换为产品的技术没有价值。<br>一个优秀的工程师不会只会一种语言，不会只能写业务代码。</p><h3 id="3-4-职业生涯怎么走"><a href="#3-4-职业生涯怎么走" class="headerlink" title="3.4 职业生涯怎么走"></a>3.4 <a href="https://www.youtube.com/watch?v=jEe1zOCtPCk&list=PLVBnNBXRHG-jCJ8e2vfiCJCS2ipfX9-Rf&index=7" target="_blank" rel="noopener">职业生涯怎么走</a></h3><p>钱？前途？自己喜欢的事？</p><p>钱很重要，但什么时候变现更重要</p><p>在职业后期，更需要将技术转换为产品，一个了解技术和用户的产品会有绝对优势。<br>在开发一些不认同的功能时，可以询问产品与运营，看看他们的思维角度与方式。</p><p>架构师与了解产品的技术是市面很缺乏的人才。</p><p>简历可以写的更富有创意，比如 json 格式，面试语言代码等。至少在简历筛选关能获得较高的通过率</p><h2 id="4-Laravel-與-Swoole-的整合之路"><a href="#4-Laravel-與-Swoole-的整合之路" class="headerlink" title="4 Laravel 與 Swoole 的整合之路"></a>4 <a href="https://www.youtube.com/watch?v=wTrUOWuJBl0&list=PLVBnNBXRHG-jCJ8e2vfiCJCS2ipfX9-Rf&index=12" target="_blank" rel="noopener">Laravel 與 Swoole 的整合之路</a></h2><p>首先，我们来看下一个 PHP 请求的生命周期</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4l6gcvhs2j30si0g1myj.jpg" alt="PHP&#39;s Lifecycle"></p><p>如图所示，在一个 PHP 请求中，需要加载相关的依赖文件，并进行语法验证与解析、编译等过程，而我们都知道，I/O 是最大的性能瓶颈，这就是为什么php性能较低的原因了。</p><p>接下来，我们通过<code>get_included_requires()</code>看下 Laravel 的一个请求需要载入多少文件。经实验得知，纯净 Laravel 加载文件数量在 218 个，如果加载了其他 vendor，数量会更多。</p><p>加载了这么多的文件，那 Laravel 的生命周期是怎样的呢？</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4hvdq3v5kj31840outc8.jpg" alt="Laravel&#39;s Lifecycle"></p><p>现在，我们找到了拖慢 Laravel 的原因：</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4l6l1095hj30sj0g176h.jpg" alt="What Makes Laravel Slow?"></p><p>我既想要 Laravel 的优雅，又想要高性能，该怎么做呢？还好，已经有前人做了 swoole 这样的工具，为 php 插上翅膀，我们要做的工作就是把 Laravel 和 swoole 结合起来。我们先来了解下 Swoole 的模型：</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4hvzuxa0sj31840osjuw.jpg" alt="Swoole&#39;s Model"></p><blockquote><p>在 Linux 中，使用 Epoll 方式处理异步，在 BSD 中，则使用 Kqueue。</p></blockquote><p>了解了 swoole 后，我们自然会想到如下的几种集成方案：</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4hw1t0pgyj31820osjux.jpg" alt="集成方案"></p><p>但是，我们在集成中会遇到以下的问题：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4hwefdz7ij317y0osgos.jpg" alt="集成所存在的问题"></p><p>我们先来了解下 Laravel 的容器服务机制：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4hwfh8dkcj31820omq6a.jpg" alt="Laravel&#39;s Service Container"></p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4hwgvwzdej31860ouq72.jpg" alt="Laravel&#39;s Facades"></p><p>如果我们将那些重复的工作只在第一次启动 Laravel 完成，在之后的请求不就可以直接跳过那些不必要的流程了吗？但这样会带来一个问题：如果上次请求的结果未能及时清除，可能会污染到后续的请求(尤其是那些静态变量、全局变量等），那我们将每次请求隔离在沙箱中不就解决了吗？</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4hwi82qgcj31820outc9.jpg" alt="Sandbox App Container"></p><p>但并非所有的实例都需要在每次请求时加载，完全可以读取共享文件，如 db, session, config, cache …</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4hwjigmdgj31ha0u0tdt.jpg" alt="Instances Outside of Sanbox"></p><p>在沙箱模型中，我们的请求流程就变成了这样：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4hwkk3ddfj31hg0u00xf.jpg" alt="Sandbox App Container"></p><p>到目前为止，似乎我们的已经完成了所有的工作，但 Laravel 中复杂的容器机制让我们还有新的挑战需要去克服：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4la15xjd3j31840ow776.jpg" alt="Redirection of App Container"></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4la9l8l0nj30th0fgwgk.jpg" alt=""></p><p>现在，Laravel 的生命周期就变为了这样：<br><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4la84ngz8j317y0ouq6w.jpg" alt="Laravel&#39;s New Lifecycle"></p><p>接下来，让我们看下 Laravel Swoole 的优势有哪些：</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lacgomaxj31800owae5.jpg" alt="Laravel Swoole Advantage"></p><p>以前，我们在 Laravel 中这样使用 Websocket<br><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lafnkbg0j31800osacv.jpg" alt="Websocket in Laravel"></p><p>现在，我们在 Laravel 中这样使用 Websocket<br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4lahh5grwj31840naq5n.jpg" alt="Websocket in Laravel Swoole"></p><p>在 Swoole 4.0+ 中，异步方式被协程所取代，我们可以通过协程来加速应用</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lakuc4nbj31860nctc8.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4lamrocopj31800newhr.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4lano5e27j317y0natb6.jpg" alt="MySQL Coroutine"></p><blockquote><p>关于 Laravel 集成 Swoole 的相关文章：<br>Part 1 <a href="https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-1/" target="_blank" rel="noopener">https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-1/</a><br>Part 2 <a href="https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-2/" target="_blank" rel="noopener">https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-2/</a><br>Part 3 <a href="https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-3/" target="_blank" rel="noopener">https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-3/</a><br>Part 4 <a href="https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-4/" target="_blank" rel="noopener">https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-4/</a></p></blockquote><blockquote><p>Swoft 框架中相关信息说明<br><a href="https://www.swoft.org/docs/2.x/zh-CN/ready/tradition.html" target="_blank" rel="noopener">Nginx + php-fpm 模式</a><br><a href="https://www.swoft.org/docs/2.x/zh-CN/ready/io.html" target="_blank" rel="noopener">Linux 中 I/O 多路复用的说明</a><br><a href="https://www.swoft.org/docs/2.x/zh-CN/ready/swoole.html" target="_blank" rel="noopener">Swoole 中的协程</a></p></blockquote><blockquote><p>关于协程的概念讲解：<a href="https://www.itcodemonkey.com/article/4620.html" target="_blank" rel="noopener">漫画：什么是协程？</a></p><p>协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，<strong>一个线程也可以拥有多个协程</strong>。最重要的是，<strong>协程不是被操作系统内核所管理，而完全是由程序所控制</strong>（也就是在用户态执行）。</p></blockquote><blockquote><p>扩展阅读<br><a href="https://zhuanlan.zhihu.com/p/62766037" target="_blank" rel="noopener">什么是CPU密集型、IO密集型？</a><br><a href="https://www.zhihu.com/question/19903344/answer/96081382" target="_blank" rel="noopener">CPU 和 GPU 的区别是什么？</a><br>总的来说，由于动态解释型语言的执行效率不高，但开发效率较高，CPU大部分时间都在等待 I/O，因此适合做 I/O 密集型业务，而不适合做 CPU 密集型业务。相反，静态语言的执行效率高，因此适合做 CPU 密集型，如 C 语言。 GPU 相比 CPU 而言，运算能力更强，但逻辑处理能力较低，因此 GPU 适合做简单的密集型计算，比如图形渲染，密码暴力破解等。</p></blockquote><h2 id="5-打造自己的粉专客服机器人"><a href="#5-打造自己的粉专客服机器人" class="headerlink" title="5 打造自己的粉专客服机器人"></a>5 打造自己的粉专客服机器人</h2><p>PHP版本的机器学习库<a href="https://github.com/php-ai/php-ml" target="_blank" rel="noopener">php-ml</a><br>一个较为成熟的机器人接口<a href="http://www.turingapi.com" target="_blank" rel="noopener">图灵机器人</a></p><h2 id="6-快速打造定制化管理后台"><a href="#6-快速打造定制化管理后台" class="headerlink" title="6 快速打造定制化管理后台"></a>6 快速打造定制化管理后台</h2><p>使用 <a href="https://laravelvoyager.com/" target="_blank" rel="noopener">Voyager</a> 可以快速搭建管理后台，该工具实现了</p><ol><li>媒体管理</li><li>菜单管理</li><li>数据库管理</li><li>站点设置</li><li>…</li></ol><h2 id="7-网站信息安全"><a href="#7-网站信息安全" class="headerlink" title="7 网站信息安全"></a>7 网站信息安全</h2><ol><li>不要相信任何外部信息来源</li><li>管理平台不要泄露在任何一个前端节点</li><li>不要让用户上传的文件成为可执行文件</li><li>务必遵循最小权限原则</li><li>写代码的时间远小于被黑客攻击的损失</li></ol><h2 id="8-如何正确部署-Laravel"><a href="#8-如何正确部署-Laravel" class="headerlink" title="8 如何正确部署 Laravel"></a>8 如何正确部署 Laravel</h2><ul><li>php &gt;= 7.1</li><li>Extension<ul><li>OpenSSL</li><li>PDO</li><li>mbstring</li><li>Tokenizer</li><li>XML</li><li>Ctype</li><li>JSON</li><li>opcache</li><li>gd</li><li>bcmath</li><li>pcntl</li><li>zip</li></ul></li></ul><p>使用 Crontab 时，尽量<strong>避免</strong>使用时区的功能，<strong>最好</strong>设定 cache 使用。<br><a href="https://github.com/phpredis/phpredis" target="_blank" rel="noopener">phpredis</a> 性能更好，<a href="https://github.com/nrk/predis" target="_blank" rel="noopener">predis</a> 开发更便捷。</p><h2 id="9-代码质量"><a href="#9-代码质量" class="headerlink" title="9 代码质量"></a>9 代码质量</h2><p>代码风格工具：<a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer" target="_blank" rel="noopener">PHP-CS-Fixer</a>, <a href="https://github.com/squizlabs/PHP_CodeSniffer" target="_blank" rel="noopener">PHP_CodeSniffer</a><br>php 静态分析：<a href="https://github.com/phpstan/phpstan" target="_blank" rel="noopener">phpstan</a>, <a href="https://github.com/vimeo/psalm" target="_blank" rel="noopener">psalm</a><br>CI 工具：<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>, <a href="https://styleci.io/" target="_blank" rel="noopener">StyleCI</a></p><h1 id="LaravelConf-2017"><a href="#LaravelConf-2017" class="headerlink" title="LaravelConf 2017"></a>LaravelConf 2017</h1><hr><p><em>未完待续……</em></p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用 ISO 标准列表</title>
      <link href="/post/standard-list/"/>
      <url>/post/standard-list/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cm36p6cnj30m80b475l.jpg" alt=""></p><p>这是一个熵增的世界，唯有秩序方能重建世界。</p><a id="more"></a><p>著名的国际化标准组织已经制定了一些列的标准，常用的标准如下：</p><ul><li><a href="https://zh.wikipedia.org/wiki/ISO_639" target="_blank" rel="noopener">ISO-639</a> 语言名称<ul><li>ISO 639-1 的中文为<code>zh</code>，英文为<code>en</code></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/ISO_690" target="_blank" rel="noopener">ISO-690</a> 学术论著参考书目格式</li><li><a href="https://zh.wikipedia.org/wiki/ISO_1000" target="_blank" rel="noopener">ISO-1000</a> 国际单位制<ul><li>如七个国际基本单位分别是：米(m)、千克(kg)、秒(s)、安培(A)、开尔文(K)、摩尔(mol)、坎德拉(cd)</li></ul></li><li><a href="https://zh.wikipedia.org/wiki/ISO_3166-1" target="_blank" rel="noopener">ISO-3166</a> 国家名称代码<ul><li>ISO 3166-1 分为二位和三位字母代码，如中国为<code>CN</code>和<code>CHN</code>，美国为<code>US</code>和<code>USA</code></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/ISO_4217" target="_blank" rel="noopener">ISO-4217</a> 货币及基金代码<ul><li>如<code>CNY</code>代表人民币、<code>USD</code>代表美元、<code>HKD</code>代表港币、<code>EUR</code>代表欧元、<code>JPY</code>代表日圆等</li></ul></li><li><a href="https://zh.wikipedia.org/wiki/ISO_5218" target="_blank" rel="noopener">ISO-5218</a> 人类性别表示<ul><li>如 <code>1</code> 为男性，<code>2</code> 为女性，<code>0</code> 为未知。我国身份证第十七位采用了同样的规则来表示性别：奇数为男性，偶数为女性。</li></ul></li><li><a href="https://zh.wikipedia.org/wiki/ISO_6709" target="_blank" rel="noopener">ISO-6709</a> 地理点位置的纬度、经度和海拔高度</li><li><a href="https://zh.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO-8601</a> 日期和时间的表示方法<ul><li>如 UTC 的日期与时间表示为<code>2019-12-04T13:49:18 +00:00</code></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/ISO_9000" target="_blank" rel="noopener">ISO-9000</a> 品质管理系统</li></ul><p>另外，我国也有由民政部划分的<a href="http://www.mca.gov.cn/article/sj/xzqh/2019/" target="_blank" rel="noopener">行政区划代码</a>，该代码即为身份证的前六位，很好的表示了省市区的层级关系，对于数据存储读取也非常的方便，相比常用的 MySQL 父子 ID 关联而言，这种方式不仅能与身份证对应，而且具有权威性、时效性好，对于层级关系的构建也非常快速方便。仓库<a href="https://github.com/cn/GB2260" target="_blank" rel="noopener">cn/GB2260</a> 有各种语言的实现版本，可以便捷使用。</p><p>建议在项目之初，尽可能使用标准化，避免使用自增 ID 独自维护关系。大量 ID 在不同场景有不同的含义，会极大增加 bug 率及维护成本，像省市区、部门等层级关系，每两位数字表示一级，其容量为 100，如果两位不够用，可能需要考虑下层级关系划分是否合理。</p><hr><p>参考资料：</p><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E6%A8%99%E6%BA%96%E5%8C%96%E7%B5%84%E7%B9%94" target="_blank" rel="noopener">国际标准化组织 - Wikipedia</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ISO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel 生命周期</title>
      <link href="/post/laravel-life-cycle/"/>
      <url>/post/laravel-life-cycle/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4hvdq3v5kj31840outc8.jpg" alt=""></p><a id="more"></a><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">'/../vendor/autoload.php'</span>;</span><br></pre></td></tr></table></figure><h3 id="2-创建-Laravel-应用实例"><a href="#2-创建-Laravel-应用实例" class="headerlink" title="2. 创建 Laravel 应用实例"></a>2. 创建 Laravel 应用实例</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">require_once</span> <span class="keyword">__DIR__</span>.<span class="string">'/../bootstrap/app.php'</span>;</span><br></pre></td></tr></table></figure><h4 id="2-1-创建-Laravel-实例"><a href="#2-1-创建-Laravel-实例" class="headerlink" title="2.1 创建 Laravel 实例"></a>2.1 创建 Laravel 实例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">new</span> Illuminate\Foundation\Application(</span><br><span class="line">    $_ENV[<span class="string">'APP_BASE_PATH'</span>] ?? dirname(<span class="keyword">__DIR__</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="2-1-1-设定项目路径信息"><a href="#2-1-1-设定项目路径信息" class="headerlink" title="2.1.1 设定项目路径信息"></a>2.1.1 设定项目路径信息</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">bindPathsInContainer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path'</span>, <span class="keyword">$this</span>-&gt;path());                     <span class="comment">//app_path()        app 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.base'</span>, <span class="keyword">$this</span>-&gt;basePath());            <span class="comment">//base_path()       项目根目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.lang'</span>, <span class="keyword">$this</span>-&gt;langPath());</span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.config'</span>, <span class="keyword">$this</span>-&gt;configPath());        <span class="comment">//config_path()     config 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.public'</span>, <span class="keyword">$this</span>-&gt;publicPath());        <span class="comment">//public_path()     public 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.storage'</span>, <span class="keyword">$this</span>-&gt;storagePath());      <span class="comment">//storage_path()    storage 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.database'</span>, <span class="keyword">$this</span>-&gt;databasePath());    <span class="comment">//database_path()   database 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.resources'</span>, <span class="keyword">$this</span>-&gt;resourcePath());   <span class="comment">//resource_path()   resource 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.bootstrap'</span>, <span class="keyword">$this</span>-&gt;bootstrapPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-注册基础绑定"><a href="#2-1-2-注册基础绑定" class="headerlink" title="2.1.2 注册基础绑定"></a>2.1.2 注册基础绑定</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerBaseBindings</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>::setInstance(<span class="keyword">$this</span>);                                             <span class="comment">//实例化 Application</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'app'</span>, <span class="keyword">$this</span>);                                          <span class="comment">//将 Application 注册到容器中 ???</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(Container::class, <span class="keyword">$this</span>);                               <span class="comment">//将 ???</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;singleton(Mix::class);                                           <span class="comment">//实例化 Mix 类 ???</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(PackageManifest::class, <span class="keyword">new</span> PackageManifest(            <span class="comment">//将文件路径注册到容器中 ???</span></span><br><span class="line">        <span class="keyword">new</span> Filesystem, <span class="keyword">$this</span>-&gt;basePath(), <span class="keyword">$this</span>-&gt;getCachedPackagesPath()</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-3-注册基础服务提供者"><a href="#2-1-3-注册基础服务提供者" class="headerlink" title="2.1.3 注册基础服务提供者"></a>2.1.3 注册基础服务提供者</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerBaseServiceProviders</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;register(<span class="keyword">new</span> EventServiceProvider(<span class="keyword">$this</span>));       <span class="comment">//注册事件服务提供者</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;register(<span class="keyword">new</span> LogServiceProvider(<span class="keyword">$this</span>));         <span class="comment">//注册日志服务提供者</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;register(<span class="keyword">new</span> RoutingServiceProvider(<span class="keyword">$this</span>));     <span class="comment">//注册路由服务提供者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-4-注册内核容器别名"><a href="#2-1-4-注册内核容器别名" class="headerlink" title="2.1.4 注册内核容器别名"></a>2.1.4 注册内核容器别名</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">registerCoreContainerAliases</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ([</span><br><span class="line">        <span class="string">'app'</span>                  =&gt; [\Illuminate\Foundation\Application::class, \Illuminate\Contracts\Container\Container::class, \Illuminate\Contracts\Foundation\Application::class,  \Psr\Container\ContainerInterface::class],</span><br><span class="line">        <span class="string">'auth'</span>                 =&gt; [\Illuminate\Auth\AuthManager::class, \Illuminate\Contracts\Auth\Factory::class],</span><br><span class="line">        <span class="string">'auth.driver'</span>          =&gt; [\Illuminate\Contracts\Auth\Guard::class],</span><br><span class="line">        <span class="string">'blade.compiler'</span>       =&gt; [\Illuminate\View\Compilers\BladeCompiler::class],</span><br><span class="line">        <span class="string">'cache'</span>                =&gt; [\Illuminate\Cache\CacheManager::class, \Illuminate\Contracts\Cache\Factory::class],</span><br><span class="line">        <span class="string">'cache.store'</span>          =&gt; [\Illuminate\Cache\Repository::class, \Illuminate\Contracts\Cache\Repository::class],</span><br><span class="line">        <span class="string">'config'</span>               =&gt; [\Illuminate\Config\Repository::class, \Illuminate\Contracts\Config\Repository::class],</span><br><span class="line">        <span class="string">'cookie'</span>               =&gt; [\Illuminate\Cookie\CookieJar::class, \Illuminate\Contracts\Cookie\Factory::class, \Illuminate\Contracts\Cookie\QueueingFactory::class],</span><br><span class="line">        <span class="string">'encrypter'</span>            =&gt; [\Illuminate\Encryption\Encrypter::class, \Illuminate\Contracts\Encryption\Encrypter::class],</span><br><span class="line">        <span class="string">'db'</span>                   =&gt; [\Illuminate\Database\DatabaseManager::class],</span><br><span class="line">        <span class="string">'db.connection'</span>        =&gt; [\Illuminate\Database\Connection::class, \Illuminate\Database\ConnectionInterface::class],</span><br><span class="line">        <span class="string">'events'</span>               =&gt; [\Illuminate\Events\Dispatcher::class, \Illuminate\Contracts\Events\Dispatcher::class],</span><br><span class="line">        <span class="string">'files'</span>                =&gt; [\Illuminate\Filesystem\Filesystem::class],</span><br><span class="line">        <span class="string">'filesystem'</span>           =&gt; [\Illuminate\Filesystem\FilesystemManager::class, \Illuminate\Contracts\Filesystem\Factory::class],</span><br><span class="line">        <span class="string">'filesystem.disk'</span>      =&gt; [\Illuminate\Contracts\Filesystem\Filesystem::class],</span><br><span class="line">        <span class="string">'filesystem.cloud'</span>     =&gt; [\Illuminate\Contracts\Filesystem\Cloud::class],</span><br><span class="line">        <span class="string">'hash'</span>                 =&gt; [\Illuminate\Hashing\HashManager::class],</span><br><span class="line">        <span class="string">'hash.driver'</span>          =&gt; [\Illuminate\Contracts\Hashing\Hasher::class],</span><br><span class="line">        <span class="string">'translator'</span>           =&gt; [\Illuminate\Translation\Translator::class, \Illuminate\Contracts\Translation\Translator::class],</span><br><span class="line">        <span class="string">'log'</span>                  =&gt; [\Illuminate\Log\LogManager::class, \Psr\Log\LoggerInterface::class],</span><br><span class="line">        <span class="string">'mailer'</span>               =&gt; [\Illuminate\Mail\Mailer::class, \Illuminate\Contracts\Mail\Mailer::class, \Illuminate\Contracts\Mail\MailQueue::class],</span><br><span class="line">        <span class="string">'auth.password'</span>        =&gt; [\Illuminate\Auth\Passwords\PasswordBrokerManager::class, \Illuminate\Contracts\Auth\PasswordBrokerFactory::class],</span><br><span class="line">        <span class="string">'auth.password.broker'</span> =&gt; [\Illuminate\Auth\Passwords\PasswordBroker::class, \Illuminate\Contracts\Auth\PasswordBroker::class],</span><br><span class="line">        <span class="string">'queue'</span>                =&gt; [\Illuminate\Queue\QueueManager::class, \Illuminate\Contracts\Queue\Factory::class, \Illuminate\Contracts\Queue\Monitor::class],</span><br><span class="line">        <span class="string">'queue.connection'</span>     =&gt; [\Illuminate\Contracts\Queue\Queue::class],</span><br><span class="line">        <span class="string">'queue.failer'</span>         =&gt; [\Illuminate\Queue\Failed\FailedJobProviderInterface::class],</span><br><span class="line">        <span class="string">'redirect'</span>             =&gt; [\Illuminate\Routing\Redirector::class],</span><br><span class="line">        <span class="string">'redis'</span>                =&gt; [\Illuminate\Redis\RedisManager::class, \Illuminate\Contracts\Redis\Factory::class],</span><br><span class="line">        <span class="string">'request'</span>              =&gt; [\Illuminate\Http\Request::class, \Symfony\Component\HttpFoundation\Request::class],</span><br><span class="line">        <span class="string">'router'</span>               =&gt; [\Illuminate\Routing\Router::class, \Illuminate\Contracts\Routing\Registrar::class, \Illuminate\Contracts\Routing\BindingRegistrar::class],</span><br><span class="line">        <span class="string">'session'</span>              =&gt; [\Illuminate\Session\SessionManager::class],</span><br><span class="line">        <span class="string">'session.store'</span>        =&gt; [\Illuminate\Session\Store::class, \Illuminate\Contracts\Session\Session::class],</span><br><span class="line">        <span class="string">'url'</span>                  =&gt; [\Illuminate\Routing\UrlGenerator::class, \Illuminate\Contracts\Routing\UrlGenerator::class],</span><br><span class="line">        <span class="string">'validator'</span>            =&gt; [\Illuminate\Validation\Factory::class, \Illuminate\Contracts\Validation\Factory::class],</span><br><span class="line">        <span class="string">'view'</span>                 =&gt; [\Illuminate\View\Factory::class, \Illuminate\Contracts\View\Factory::class],</span><br><span class="line">    ] <span class="keyword">as</span> $key =&gt; $aliases) &#123;</span><br><span class="line">        <span class="keyword">foreach</span> ($aliases <span class="keyword">as</span> $alias) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;alias($key, $alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-内核绑定"><a href="#2-2-内核绑定" class="headerlink" title="2.2 内核绑定"></a>2.2 内核绑定</h4><p>接下来，我们需要绑定一些重要接口到容器中，以使我们在需要时能够从容器中解析。内核服务可以处理来自 web 与 cli 的请求。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Http\Kernel::class,</span><br><span class="line">    App\Http\Kernel::class</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Console\Kernel::class,</span><br><span class="line">    App\Console\Kernel::class</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Debug\ExceptionHandler::class,</span><br><span class="line">    App\Exceptions\Handler::class</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="3-从容器中解析-Kernel"><a href="#3-从容器中解析-Kernel" class="headerlink" title="3. 从容器中解析 Kernel"></a>3. 从容器中解析 Kernel</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);</span><br></pre></td></tr></table></figure><h3 id="4-接收请求并处理"><a href="#4-接收请求并处理" class="headerlink" title="4. 接收请求并处理"></a>4. 接收请求并处理</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$response = $kernel-&gt;handle(</span><br><span class="line">    $request = Illuminate\Http\Request::capture()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="5-响应请求"><a href="#5-响应请求" class="headerlink" title="5. 响应请求"></a>5. 响应请求</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$response-&gt;send();</span><br></pre></td></tr></table></figure><h4 id="6-终止程序"><a href="#6-终止程序" class="headerlink" title="6. 终止程序"></a>6. 终止程序</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$kernel-&gt;terminate($request, $response);</span><br></pre></td></tr></table></figure><hr><p><em>未完待续……</em></p>]]></content>
      
      
      <categories>
          
          <category> 软件编程，PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在毕业季</title>
      <link href="/post/graduation/"/>
      <url>/post/graduation/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g48hfo0bj8j30zk0nnwif.jpg" alt=""></p><p>四年前的今天，我离开了学校。</p><a id="more"></a><p>还记得小学毕业时，有很多无话不谈的玩伴，如今却在寒暄之后突然安静；初中毕业时，很多同学都在同学录上的梦想一栏写下了「环游世界」，不知道他们现在是否还记得；高中毕业时，很多同学写道「有事没事常联系」，但很多人已经在列表沉寂多年；大学毕业时，酒桌上觥筹交错，有人酒后诉说着离别之殇，有人走出饭馆便吐了一地，有人忙碌的照顾着大家……望着他们相扶着摇摇晃晃走进校园的背影，你不禁会想：当明天的太阳升起时，各自开始收拾自己的行囊，踏上未所知的前路……</p><p>在岁月流转间，早已模糊了少年。那时所奢望的金钱，却忽略了自己所拥有最宝贵的财富——时间。在日复一日的迷茫中，终日无所事事，在不知不觉间就走到了 2015 年的夏天。那个夏天与往年并没有什么不同，只是当年所羡慕的毕业照主角变成了自己。随着离校日期的临近，各种各样的饭局随之而来，我记得当时还在调侃说“这散伙饭都吃了一个月还没散伙”。在学校最后的日子里，428 宿舍没日没夜的麻将，430 凌晨还在 DOTA 中奋战……这些声音犹在耳畔，但模样却已渐渐模糊。</p><p>到了拍毕业照那天，我们班在校门口拍了一张堪称海报的毕业集体照，之后的自由拍照时间便是我拙劣的 PS 大显神通的时候了。</p><p>离校那天，虽然我家距离学校只有一小时车程，但我因无法承受空荡荡的宿舍所带来的离别之情而第一个离开。彼时的我可能想过此去经年，却未曾感受过物是人非、相见无言。</p><p>虽然科技的发展让沟通更加的便捷，但并没有让我的联系人列表更加地活跃；虽然发达的交通让我们一日千里，但我可能会点个外卖，在抖音中一窥我未曾到过的地方。在被生活裹挟着的波涛中，可能是时候放下手机，走出家门，会会老友，看看世界。</p><p>还记得在毕业时的自我评价上写道“虽然今天走出了校园，但我刚刚踏入了社会这所大学，还有很多东西需要不断地学习。人可以不上学，但不可以不学习。”。毕业的这些年，走过低谷，走过平淡，走过欣喜，也走过迷茫，好在无论什么样的日子，最后都挺了过来，<br>庆幸自己仍不忘初心，没有被时间和现实所打败。感谢 3 年前那个刚过完 24 岁生日的少年，在众人的反对声中，毅然踏上开往北京的火车，因为他明白：可怕的不是有想法，而是不再有想法。</p><p>在安逸的生活中，会让人丧失斗志，将宝贵的时间消磨在抖音的欢笑中，明星的绯闻中以及在沉迷之后的空虚迷茫中。当你觉得最好的时候，可能是你最坏的时候：你的斗志开始麻痹，眼前的繁荣开始蒙蔽双眼；当你觉得最坏的时候，可能是你最好的时候，因为你已经意识到了问题，并开始着力改正。居安思危，高瞻远瞩，方能决胜未来。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变</title>
      <link href="/post/change/"/>
      <url>/post/change/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g43xynalhaj30kf0b4dil.jpg" alt=""></p><p>今天看到中国政务平台服务在微信和支付宝都上线了，还有很多地方的服务名取的都很文雅，颇有一些感触，故作此文。</p><a id="more"></a><p>信息革命将许多线下活动搬到了线上，消灭了许多低效重复的工作。小时候觉得，课本上写的“足不出户，尽知天下事”离我们还很远，但如今，我们却早已习惯，似乎认为这个世界本来就是这样。</p><p>信息革命不仅带来了便捷，也带来了更大的贫富差距。新技术的不断涌现取代了大量的重复劳动，不断提升就业门槛，让那些小学初中毕业的人随着年龄的增长越来越难以就业，随着 AI 的到来，将会有更多的职业将会被机器所取代。</p><p>在洪水般的资讯与杂讯间，怎样才能高效获取到资讯？你是一年过了 365 天，还是过了 1 天重复了 364 天？随着移动互联网的普及，越来越多的人放下报纸和图书，拿起手机进入直播间。而那些知道自己要去往何方并吧不为途中花香所动的人，终将主宰这个世界。</p><p>在人类历史的长河中，过去的数万年都在平缓的发展，在工业革命之后，人类进入爆炸式增长的时代，而且增长速度越来越快，谁能高瞻远瞩，谁就能在未来掌控话语权。</p><p>5G 大战一触即发，下一个十年，会比过去的十年变化更为剧烈。一日千里即将到来，历史会无情地将那些狂妄自大的人抛弃，唯有变革，才能占领未来高地。</p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43xl49hg6j30u01qrac7.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>切尔诺贝利</title>
      <link href="/post/chernobyl/"/>
      <url>/post/chernobyl/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic4.zhimg.com/v2-d83325c04c1aa47d115a9919e1d96c5e_1200x500.jpg" alt=""></p><blockquote><p>What is the cost of lies?</p><a id="more"></a><p>It’s not that we’ll mistake them for the truth.</p><p>The real danger is that if we hear enough lies, then we no longer recognize the truth at all.</p><p>What can we do then?</p><p>What else is left but to abandon even the hope of truth and content ourselves instead with stories?</p></blockquote><p>当你要被爆头时，真相还重要吗？</p><p>在谎言与真相之间，那些勇敢站出来的勇士，用生命为黑暗送来一束阳光，不懈的坚持最终拯救了数万人的生命。</p><p>谎言可以麻痹，真相不会消失。总有一天，灾难会带来所有真相送来的礼物。</p><p>在灾难面前，我是否能像消防员、水夫、矿工、列加索夫、谢尔比纳一样冲锋陷阵，勇敢站出来说出真相？我不知道。只是从内心由衷的敬佩他们。</p><p>历史不会远去，历史每天都在上演。如果不是苏联倒台，这件事中无数的英雄都将被埋没，那些罪魁祸首也会飘散在历史的风中，而真相则逐渐被人们所遗忘……</p><p>你所了解的，只是他们想让你了解的。</p>]]></content>
      
      
      <categories>
          
          <category> 影像志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一城一味·烟台</title>
      <link href="/post/yantai/"/>
      <url>/post/yantai/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wri08odj314q0u01cs.jpg" alt=""></p><p>去过他人太多去过的远方，此刻只愿撷取他人未曾到过的宁静之隅。</p><a id="more"></a><p>烟台，一座海滨城市，虽久闻大名，但一提到看海，脑海中首先浮现还是青岛，大连等，提起烟台，似乎没有太多如雷贯耳的风景。但老家是烟台的同事极力推荐，正好端午节也可以出去放松一下，免得在家维护世界和平。说走就走，提前半个月已经抢不到火车票，只好转而购买汽车票，然后开始规划行程。6 月 6 日下午，高考前夕我踏上了烟台之旅。</p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wjw5ne7j30u01901kg.jpg" alt="Sunshine 100"></p><p>我所预定的客栈在阳光 100，距离火车站和汽车站步行路程差不多都在十分钟。<br>烟台公交可均可刷微信、支付宝乘车码<br>烟台景点的优惠票都是在检票口验明证件。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>上午可以视情况休息或者出去游玩。烟台市区内的烟台山、各国使馆遗址、滨海景区均有不错的风景。而且均相距不远。</p><h3 id="使馆遗址"><a href="#使馆遗址" class="headerlink" title="使馆遗址"></a>使馆遗址</h3><p>票价：免费<br>从 1862 年英法在烟台建立了使馆后，先后共有 17 个国家建立了使馆，不同风格的使馆也是一大看点。</p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wow5e8aj31900u0b2a.jpg" alt=""></p><h3 id="烟台山"><a href="#烟台山" class="headerlink" title="烟台山"></a>烟台山</h3><p>票价：免费<br>从客栈到烟台山步行距离 2 公里左右。除了登烟台山灯塔需要 10 元外，整个公园内没有其他门票项目。不过推荐在灯塔眺望周围海景与烟台市区，这个价格绝得值得。</p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wlmtimjj31900u0qv5.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wpj9n65j31900u0u0x.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wsipuawj31400u04qs.jpg" alt=""></p><h3 id="滨海景区"><a href="#滨海景区" class="headerlink" title="滨海景区"></a>滨海景区</h3><p>票价：免费<br>海风拂动发梢、海浪亲吻着脚丫、儿童们堆着沙滩城堡、还有一群年轻人在广场练习着滑板……如此惬意的午后阳光，多么希望时光就此凝结……</p><p>如果晚上还有精力，可以继续看下夜景。由于我早上 4 点半到了后就没有休息，晚上实在太累了，没能看到夜景，一大遗憾啊。</p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wm52jcoj31900u0npd.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/middle/006tNc79ly1g43wmcv8yuj31900u0qv5.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/middle/006tNc79ly1g43wmlxsp5j31900u0kjl.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wlbsf05j316a0u0thg.jpg" alt="City on Bubble"></p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wmvcgzyj30u01404ls.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43woomamyj30u0190k4v.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/middle/006tNc79ly1g43wp8cgm6j31900u0kjl.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wx12qdlj31900u0b29.jpg" alt=""></p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>提前购买烟台到蓬莱与返程的动车，单程票价 20 元，行程半小时。</p><h3 id="蓬莱阁"><a href="#蓬莱阁" class="headerlink" title="蓬莱阁"></a>蓬莱阁</h3><p>票价：120 元/人，优惠价半价<br>线路：火车站 3、7 路均可直达<br>快艇：50 元/人<br>游艇：200 元/人<br>6 点半左右抵达蓬莱站，随后乘坐 3、7 路公交到达蓬莱阁（大约 1 小时），吃过早饭后前往购票。<br>首先进入的是龙王宫、天后宫等古刹群，游玩完毕后可通过西门到达蓬莱冰宫、横山广场、灯塔、黄渤海分界线等景区，在金龟探海处可乘坐游艇前往八仙过海，游艇上可以投喂海鸥，也是一大乐趣。</p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wpylyyxj31900u0e82.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wq3b4ujj31900u0x6p.jpg" alt=""></p><h3 id="八仙过海"><a href="#八仙过海" class="headerlink" title="八仙过海"></a>八仙过海</h3><p>票价：80 元/人，优惠 70 元/人<br>八仙过海主要就是了解下八仙过海的故事，整个景区为葫芦的形状，我们游艇登陆的是景区的后门，所以不太感兴趣的话可以选择一侧从前门出去，比较节约时间。<br>该景区内可以登会仙阁眺望整个景区和海景，时而会有一群海鸥从眼前略过，风景还蛮不错的。</p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wqjg9mwj31900u0e81.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wqqedzbj30u0190npd.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/middle/006tNc79ly1g43wr2jiluj31400u0e81.jpg" alt=""></p><p>在蓬莱阁、八仙过海、三仙山任一景点购买别处景点门票可凭门票免费乘坐观光车抵达。我们在八仙过海购买了极地海洋世界的门票。此时时间 11 点多，我们就在周边的沙滩玩了一会儿，又吃过午饭后，1 点钟到达海洋馆。</p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wrc000vj31400u04da.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wri08odj314q0u01cs.jpg" alt=""></p><h3 id="极地海洋世界"><a href="#极地海洋世界" class="headerlink" title="极地海洋世界"></a>极地海洋世界</h3><p>票价：150 元/人，优惠 130 元/人</p><p>海洋馆中有各色金鱼、鲨鱼、乌龟、水母等，看得眼花缭乱，这种动物都有自己生存的拿手本领：电鳗的瞬时电压可达 240V+，吸盘鱼通过吸附其它大型鱼类或小船搭顺风车来节省自己的体力……还有焦躁不安的北极熊，貌似正处在发情期的海狮等，都留下了很深刻的印象，不得不感叹大自然的鬼斧神工，各种生物的生存本领真实八仙过海，各显神通。</p><p>海洋世界中全天定时有美人鱼和海豚、海狮的表演，都还蛮不错的。海豚、海狮表演位于最顶层，看到这里海洋馆之行也就结束了，出口的路线几乎就都是各种商品了。</p><p>从海洋馆出来时才 4 点半，出门右转 200 米就有 3  路公交车，可以直达火车站候车休息返程了。如果晚上回去精力还不错，还可以在烟台市区看看夜景 :-)</p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wrw8x35j31900u0e82.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43ws4iv9kj31900u0u0x.jpg" alt=""></p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><h3 id="养马岛"><a href="#养马岛" class="headerlink" title="养马岛"></a>养马岛</h3><p>票价：免费<br>养马岛为逆时针单行线，推荐自驾，岛中也有共享电动车与自行车可供租赁，但电动车价格可以说是很贵了。</p><p>乘坐游 1 或 61 路转 617 路可以到达养马岛，行程大约 1 小时。在天马广场下车后，可以快速游览一下天马广场，然后直行 2 公里左右到靠近黄海的海岸线，这里的水真的是清澈见底，有的地方石头是褐色为主，有的则是黑白相间，还有的海岸一条条的绿色海藻带，非常漂亮。沙滩上还有五颜六色的破碎的贝壳。这里没有太浓的商业气息，仍有渔民养殖海参等海产品，这里的商业带来了交通与食宿的便捷，又没有过多的破坏这里本该有的自然风景，在我去过为数不多的景区中，可以算作是一股清流了。许多景点在越来越浓的商业化运作中变得面目全非，如果你想要了解当地人真实的生活，或许你应该去公园看看广场舞，去博物馆看看这座城市的过往，坐公交车看看普通人的日常，到大学蹭一顿廉价的美味午餐。</p><p>在养马岛吹着海风、翻找着贝壳、嬉戏着清澈的海水，眺望着对面弱音若现的城市，此刻，我真正理解了“流连忘返”这个词，对于这样的美景，只好尽收快门。你不知道下次来是否还会有同样的感受，可能开始收门票了，也可能商业化运作更成熟了，也有可能这里什么都没变，而你站在相同的位置再也没有了相同的感受。想做的事，就现在。</p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wszlnalj31900u0hdi.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wugy1ifj31900u0kjm.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wvxefe4j31900u0x6q.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43ww8ba2pj31900u0qv6.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/middle/006tNc79ly1g43wweq27gj31900u0e81.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wwp4w4ej31900u0hdt.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wxagkcmj31900u07wi.jpg" alt=""></p><h3 id="烟台大学"><a href="#烟台大学" class="headerlink" title="烟台大学"></a>烟台大学</h3><p>由于养马岛太好玩了，没能来得及去烟大，只好下次再去了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>烟台多年被评为宜居城市果然名不虚传，初来此处便爱上了这里，如果有机会，我会再游烟台。果然最赚钱的方法都写在刑法里，最美的风景不一定在景区内。<br>人类是健忘的，镜头只能记录瞬间的故事，让你记忆深刻的故事，不在镜头中，而在用心所看到你未曾看到的地方。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三和大神</title>
      <link href="/post/sanhe-job-market/"/>
      <url>/post/sanhe-job-market/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g3y482cfbgj31hc0u0u0z.jpg" alt=""></p><p>火车站，一个梦想开始与结束的地方。</p><a id="more"></a><p>每个人的人生都是一场轮回，从婴儿到孩童、再到青年、中年、老年，直至最后变成一抔黄土。历史的车轮在不断的前进，有些人在历史中熠熠生辉，更多的人则消散在历史的尘埃中，仿佛从未造访过这个世界。如果说我们都逃不过这样的轮回，那我们能做的可能只是改变轮回的半径。</p><p>我们每个人都有自己的生活圈子，当你在和朋友讨论五一去哪儿浪的时候，有的人可能正趁着城市的夜色在垃圾箱中翻找着瓶子，有的人还在为孩子下个学期的学费奔波，也有的人在一次次的奋斗挣扎过后，向现实低下了骄傲的头颅……我们每个人都是“近视眼”，很多人无法理解为什么拼多多这样的公司也能大获成功？怎么会有人过着今朝有酒今朝醉的生活？为什么会有人花几百万美元和一个老头子吃一顿午饭？这个世界并不完全是你所看到的样子，在你眼里所受够了的生活，可能正是别人所梦想的生活。我们每个人都需要跳出自己的生活圈，用望远镜来看看世界，看看自己。</p><p>我认为，三和大神是时代的产物：</p><ol><li>中国城市化的快速发展，促使许多农民放下耕地和孩子，前往城市务工。留守儿童缺少看护与教育。</li><li>新一代年轻人生活观念发生很大变化。由于改革开放的发展，人口与信息流动越来越频繁，年轻人接触到各种新鲜事物与观念，与传统观念中的成家立业、传宗接代不同，现在年轻人更多看重的是活在当下。</li><li>工厂的长时间劳动，导致工人变得如行尸走肉。我曾经做过一段时间的暑期工，每天工作 12 个小时，工作时间都是站立，中午也几乎没有休息时间。宿舍是十几个人挤在一间屋子里，通风条件很差，夏天的晚上热的睡不着，但第二天还要早起照常上班。每天除了工作 12 小时外，上下班路程、洗漱休息时间除外，真正能睡觉的时间并不多，可能也就六七个小时。那时我每天都觉得很累，第一次感觉到一天 24 小时真的不够用。有一天我在下班回去的路上，站了一天的脚实在是太累了，加之前一天晚上没休息好，那时，我真的切身体会到了以前在《读者》中读到的“拖着疲惫的身体”，“双腿像灌了铅似的”，我甚至产生了直接躺在路上睡觉的想法……每天按时上下班，超长时间的重复劳作，当我看着厂房的铁窗时，感觉就像一只被囚禁的鸟儿，我当时只想尽快逃离这里，希望未来远离这般行尸走肉的生活。</li></ol><p>在影片中，有人在断臂后用另一条臂膀撑起一个家庭，有人在四肢健全下放弃希望。我相信每个人都有自己的故事，但不是每个故事都是辛酸的。很多人不是被这个世界所放弃，而是他自己。这个世界本来就是不公的，你无法改变这个世界，那你只能改变自己。正如片中的辍学大学生所说：在现在的状态下，我要么是就此一蹶不振，成为三和大神，要么就是走出现在的困境，在今后的日子里更加的珍惜生命、热爱生命。</p><p>在信息自动化高速发展的今天，技术革命将淘汰掉越来越多的重复劳作岗位，让资本家用更短的时间创造更多的财富，让一无所有的人变得更加难以生存。资产家和无产者间的鸿沟不会因技术而消失，只会形成更强的马太效应，让生活在底层的人翻身的机会更加渺茫。</p><p>在故事的最后，即将成为三和大神的东东决定离开深圳，前往东莞追寻新的梦想。在去往东莞的车站，又有许多手提行李箱的年轻人刚刚踏上这座城市……</p>]]></content>
      
      
      <categories>
          
          <category> 影像志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>周计划</title>
      <link href="/post/week-schedule/"/>
      <url>/post/week-schedule/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3bekghzsxj30q40bzmya.jpg" alt=""></p><a id="more"></a><h3 id="想做的事太多？"><a href="#想做的事太多？" class="headerlink" title="想做的事太多？"></a>想做的事太多？</h3><p>游戏？电视？旅行？美食？理财……<br>虽说技多不压身，但更需要一专多长</p><h3 id="三分钟热度？"><a href="#三分钟热度？" class="headerlink" title="三分钟热度？"></a>三分钟热度？</h3><p>人生是一项长跑比赛，你却把它当做是百米赛跑。<br>长征路上，你只要确保方向正确，然后埋头前行。<br>很多事情不是有了希望才坚持，而是坚持了才有希望。</p><h3 id="诱惑太多？"><a href="#诱惑太多？" class="headerlink" title="诱惑太多？"></a>诱惑太多？</h3><p>电视剧看两集就必须看完才能停下来？游戏玩两局就必须玩到强制下线才能放下手机？<br>当你知道一扇大门后的东西你无法控制时，最好的方式就是不要打开这扇门。</p><h3 id="早睡早起"><a href="#早睡早起" class="headerlink" title="早睡早起"></a>早睡早起</h3><p>早睡早起精神好</p><p>冰冻三尺，非一日之寒。骐骥一跃，不能十步。今始制定每周计划，从 0 到 1 是最难的部分。</p><blockquote><p>To Be Strong</p><p>入职现在这家公司已经一年半，这一年半以来，自以为在技术方面没有什么成长，甚至不如入职前的学习动力，只是在处理问题、自信、对一些事物的认知、交流沟通方面有了很多的成长。</p><p>现在的工作终日沉浸在忙碌之中，但一年到头，却感觉似乎什么都没有做，那时间都去哪儿了呢？在这段时间里，随着对手头工作的熟悉，自己也越来越松懈，经常会有通宵上线，自己也养成了熬夜的坏习惯，恶性循环到第二天没有什么工作状态。有时会一整天都没有工作状态，不写一行代码，最多的时候这样的情况能持续一周。在这种熬夜加班写 bug，第二天修复 bug 又引入新的 bug 的状态中，对精神与肉体造成双重的摧残。</p><p>虽说当前的公司也是小有名气，但我所在项目组却感觉没有什么开发规范，很多的问题解决方案都是直接粗暴：调用方法都是静态方法，刚开始在项目中使用 composer，在 HTML 页面中夹杂 PHP 代码，页面慢了上缓存（似乎 Redis 的存在只是为了缓存）。自己一个项目做了一年，但也不敢说对业务与代码了如指掌，很多地方自己觉得别人代码写的太烂不想看，业务逻辑懒得了解，这真的不是一种好的工作态度，工作就是需要对负责的部分掌控全局、如数家珍。</p><p>最近看到之前写的代码实在是看不下去了，想用设计模式等较好的解决方式优化一下，却发现自己空有想法，却无法实现，于是开始看 GitHub Trending，关注一些优秀的开源框架，一些有趣的小项目，想认真的了解一下自己在之前工作中所遇到的很多不求甚解的问题。不看则以，一看则欲望也越来越大，产生了各种各样想要尝试的想法，比如自动发送微博、微信自动发送情话、爬取数据分析、脚本监控商品价格等等。我知道这可能只是一时脑热，三天后又走原路，因此在此记录，只管设定目标，然后低头执行，无关路上的风雨月。</p><p>我想，是时候做出改变了，让自己变得更强，找寻自己存在的意义与价值，让成就感充满每一天。</p><h3 id="长期知识技能图"><a href="#长期知识技能图" class="headerlink" title="长期知识技能图"></a>长期知识技能图</h3><ul><li>❌Laravel 框架源码研究</li><li>❌PHP 框架运行机制和流程</li><li>❌xDebug 调试</li><li>❌PhpStorm 的工具使用</li><li>❌消息队列（RabbitMQ，Kafaka）</li><li>❌ElasticSearch</li><li>❌Nginx 的配置</li><li>❌Redis 的多场景使用</li><li>❌Docker 镜像封装与容器运行</li><li>❌k8s </li><li>❌GraphQL</li><li>❌MongoDB 的使用场景</li><li>❌CI 自动分析代码质量(phpinsights、codeception)，单元测试，性能分析，部署代码</li><li>❌Python 爬取与分析数据</li><li>❌Go 静态语言的高并发处理</li><li>❌Node.js 的多线程</li><li>❌系统架构部署（<a href="https://github.com/xingshaocheng/architect-awesome）" target="_blank" rel="noopener">https://github.com/xingshaocheng/architect-awesome）</a></li></ul><h3 id="图书"><a href="#图书" class="headerlink" title="图书"></a>图书</h3><ul><li>❌《HTTP 权威指南》</li><li>❌《代码大全》</li><li>❌《深入理解计算机原理》</li></ul><h3 id="其他软技能"><a href="#其他软技能" class="headerlink" title="其他软技能"></a>其他软技能</h3><p><a href="https://www.zhihu.com/question/49502870/answer/673390166" target="_blank" rel="noopener">PPT 技能</a></p></blockquote><h3 id="19Y21W"><a href="#19Y21W" class="headerlink" title="19Y21W"></a>19Y21W</h3><ul><li>✅翻译完成<a href="https://github.com/kamranahmedse/design-patterns-for-humans" target="_blank" rel="noopener">通俗讲解设计模式</a></li><li>❌iTerm 终端美化</li><li>❌廖雪锋Python教程</li><li>✅周末一天世园会，一天图书馆</li></ul><h3 id="19Y22W"><a href="#19Y22W" class="headerlink" title="19Y22W"></a>19Y22W</h3><ul><li>✅完成头像分析</li><li>✅完成比喻示例</li><li>✅完成设计模式翻译</li></ul><h3 id="19Y24W"><a href="#19Y24W" class="headerlink" title="19Y24W"></a>19Y24W</h3><ul><li>✅LightRoom 教程</li><li>✅照片筛选处理</li></ul><h3 id="19Y25W"><a href="#19Y25W" class="headerlink" title="19Y25W"></a>19Y25W</h3><ul><li>❌分析入职离职曲线</li><li>❌京东有货地区</li><li>❌微信情话</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件定律及原则</title>
      <link href="/post/hacker-laws/"/>
      <url>/post/hacker-laws/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g39pcz3brtj30hs0cgab6.jpg" alt=""></p><p>Repo <a href="https://github.com/nusr/hacker-laws-zh" target="_blank" rel="noopener">💻📖 hacker-laws</a> </p><a id="more"></a><h2 id="定律"><a href="#定律" class="headerlink" title="定律"></a>定律</h2><h3 id="1-阿姆达尔定律"><a href="#1-阿姆达尔定律" class="headerlink" title="1. 阿姆达尔定律"></a>1. 阿姆达尔定律</h3><blockquote><p><em>向执行程序的系统添加多个处理器只能获得有限的好处，它可以极大地提升并行程序的速度，串行部分的速度将保持不变。</em><br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g391y0tu7wj30hs0dwjs0.jpg" alt=""></p></blockquote><h3 id="2-布鲁克斯法则"><a href="#2-布鲁克斯法则" class="headerlink" title="2. 布鲁克斯法则"></a>2. 布鲁克斯法则</h3><blockquote><p><em>软件开发后期，添加人力只会是项目开发得更慢。</em></p></blockquote><p>无论多少个女人，孕育一个生命也需要九个月。</p><h3 id="3-康威定律"><a href="#3-康威定律" class="headerlink" title="3. 康威定律"></a>3. 康威定律</h3><blockquote><p><em>软件架构反映了组织结构。</em></p></blockquote><h3 id="4-侯世达定律"><a href="#4-侯世达定律" class="headerlink" title="4. 侯世达定律"></a>4. 侯世达定律</h3><blockquote><p><em>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。</em></p></blockquote><h3 id="5-技术成熟度曲线"><a href="#5-技术成熟度曲线" class="headerlink" title="5. 技术成熟度曲线"></a>5. 技术成熟度曲线</h3><blockquote><p><em>我们倾向于过高估计技术在短期内的影响，并低估长期效应。</em><br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g391wbrqtbj30sg0iiab9.jpg" alt=""></p></blockquote><h3 id="6-隐式接口定律"><a href="#6-隐式接口定律" class="headerlink" title="6. 隐式接口定律"></a>6. 隐式接口定律</h3><blockquote><p><em>你在合同中的承诺并不重要： 你系统的所有可观察行为将取决于其他人。</em></p></blockquote><p>应该是指：即使你某些方法仅限内部使用，但仍然会有些人将这些方法用于外部调用</p><h3 id="7-摩尔定律"><a href="#7-摩尔定律" class="headerlink" title="7. 摩尔定律"></a>7. 摩尔定律</h3><blockquote><p><em>集成电路中的晶体管数量大约每两年翻一番。</em></p></blockquote><h3 id="8-帕金森定理"><a href="#8-帕金森定理" class="headerlink" title="8. 帕金森定理"></a>8. 帕金森定理</h3><blockquote><p><em>在工作能够完成的时限内，工作量会一直增加，直到所有可用时间都被填满为止。</em></p></blockquote><h3 id="9-普特定律"><a href="#9-普特定律" class="headerlink" title="9. 普特定律"></a>9. 普特定律</h3><blockquote><p><em>技术由两类人主导，一类是纯粹的管理人员， 一类是纯粹的技术人员。</em></p></blockquote><p>没太看明白，是指技术领导长期不接触一线代码导致技术能力下降吗？</p><h3 id="10-复杂性守恒定律"><a href="#10-复杂性守恒定律" class="headerlink" title="10. 复杂性守恒定律"></a>10. 复杂性守恒定律</h3><blockquote><p><em>系统中存在着一定程度的复杂性，并且不能减少。</em></p></blockquote><h3 id="11-漏洞抽象定律"><a href="#11-漏洞抽象定律" class="headerlink" title="11. 漏洞抽象定律"></a>11. 漏洞抽象定律</h3><blockquote><p><em>在某种程度上，所有非平凡的抽象都是漏洞。</em></p></blockquote><p>定义太拗口了，直接看例子吧。</p><p>我过去遇到过一个问题，就是 Photoshop 启动缓慢，有时需要几分钟。问题好像是 Photoshop 启动时，会读取当前默认打印机的一些信息。但是，如果该打印机实际上是一台网络打印机，则可能需要很长的时间。将网络打印机与本地打印机当作同样的抽象，导致连接不良的情况下出现问题。</p><h3 id="12-帕金森琐碎定理"><a href="#12-帕金森琐碎定理" class="headerlink" title="12. 帕金森琐碎定理"></a>12. 帕金森琐碎定理</h3><blockquote><p><em>群体将给予更多的时间和注意力来处理琐碎的问题，而不是用来处理严肃而实质性的问题。</em></p></blockquote><p>常见的虚构例子是委员会批准核电站的计划，他们大部分时间都在讨论自行车棚的结构，而不是电厂本身等更为重要的设计。</p><h3 id="13-Unix-哲学"><a href="#13-Unix-哲学" class="headerlink" title="13. Unix 哲学"></a>13. Unix 哲学</h3><blockquote><p><strong>*做一件事，做好它</strong>。将小而简单以及定义良好的单元组合在一起，而不是使用大而复杂的多用途程序，可以更轻松地构建系统。*</p></blockquote><ul><li>小即是美</li><li>让程序只做好一件事</li><li>尽可能早地建立原型</li><li>可移植性比效率更重要</li><li>数据应该保存为文本文件</li><li>尽可能地榨取软件的全部价值</li><li>使用shell脚本来提高效率和可移植性</li><li>避免使用可定制性低下的用户界面</li><li>所有程序都是数据的过滤器</li></ul><h3 id="14-Spotify-模型"><a href="#14-Spotify-模型" class="headerlink" title="14. Spotify 模型"></a>14. Spotify 模型</h3><blockquote><p><em>团队围绕功能而非技术进行组织。</em></p></blockquote><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><h3 id="1-鲁棒性原则"><a href="#1-鲁棒性原则" class="headerlink" title="1. 鲁棒性原则"></a>1. 鲁棒性原则</h3><blockquote><p><em>在自己所做的事情上要保守, 在接受别人的事情上要自由。</em></p></blockquote><p>通常应用于服务器应用程序开发中，该原则指出，你发送给其他人的内容应尽可能最小且符合要求，并且处理不符合要求的输入。</p><h3 id="2-SOLID"><a href="#2-SOLID" class="headerlink" title="2. SOLID"></a>2. SOLID</h3><ul><li>S：单一功能原则 (The Single Responsibility Principle)</li><li>O：开闭原则 (The Open/Closed Principle)</li><li>L：里氏替换原则 (The Liskov Substitution Principle)</li><li>I：接口隔离原则 (The Interface Segregation Principle)</li><li>D：依赖反转原则 (The Dependency Inversion Principle)</li></ul><h4 id="2-1-单一功能原则"><a href="#2-1-单一功能原则" class="headerlink" title="2.1 单一功能原则"></a>2.1 单一功能原则</h4><blockquote><p><em>每个模块或者类只应该有一项功能。</em></p></blockquote><p>理论上讲，这使代码更健壮，更容易更改。知道正在更改的组件只有一个功能，这意味着测试更改更容易。</p><h4 id="2-2-开闭原则"><a href="#2-2-开闭原则" class="headerlink" title="2.2 开闭原则"></a>2.2 开闭原则</h4><blockquote><p><em>软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。</em></p></blockquote><h4 id="2-3-里氏替换原则"><a href="#2-3-里氏替换原则" class="headerlink" title="2.3 里氏替换原则"></a>2.3 里氏替换原则</h4><blockquote><p><em>子类对象可以在程式中代替其基类（超类）对象</em></p></blockquote><h4 id="2-4-接口隔离原则"><a href="#2-4-接口隔离原则" class="headerlink" title="2.4 接口隔离原则"></a>2.4 接口隔离原则</h4><blockquote><p><em>接口应提供给客户端仅需必需信息。</em></p></blockquote><p>接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们需要的方法。接口隔离原则的目的是系统解开耦合，从而容易重构，更改和重新部署。</p><h4 id="2-5-依赖反转原则"><a href="#2-5-依赖反转原则" class="headerlink" title="2.5 依赖反转原则"></a>2.5 依赖反转原则</h4><p>高层次的模块不应该依赖于低层次的模块，两者均应依赖于抽象接口。<br>抽象接口不应依赖于具体实现，而应具体实现依赖于抽象接口</p><h3 id="3-DRY"><a href="#3-DRY" class="headerlink" title="3. DRY"></a>3. DRY</h3><blockquote><p><em>系统中，每一块知识都必须是单一、明确而权威的。</em></p></blockquote><p>这个原则旨在帮助开发人员减少代码的重复性，并将公共代码保存在一个地方。</p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac 下解压与 Excel 乱码解决方案</title>
      <link href="/post/extract-excel-garbled-on-mac/"/>
      <url>/post/extract-excel-garbled-on-mac/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g25mhnmgeij30g204qdhb.jpg" alt=""></p><a id="more"></a><h1 id="解压文件乱码"><a href="#解压文件乱码" class="headerlink" title="解压文件乱码"></a>解压文件乱码</h1><p>Mac 系统默认的解压软件是系统自带的 Archive Utility，但这个软件对于文件的编码方式识别有问题，使用 The Unarchiver 就可以完美解决。在任一的压缩文件右键查看简介（Get Info）=&gt; 打开方式 =&gt; 选择The Unarchiver =&gt; 应用全部，即可将 The Unarchiver 设置为默认的解压软件。</p><img src="https://ws3.sinaimg.cn/middle/006tNc79ly1g25qtlxfemj30ek0iq75p.jpg" height="70%"><h1 id="Excel-内容乱码"><a href="#Excel-内容乱码" class="headerlink" title="Excel 内容乱码"></a>Excel 内容乱码</h1><p>菜单栏Excel =&gt; Preferences =&gt; East Asian Languages =&gt; Select a language =&gt; Simplified Chines</p><p><img src="https://ws3.sinaimg.cn/middle/006tNc79ly1g25mszawekj30k00c775f.jpg" alt=""></p><h1 id="【转】文件转码"><a href="#【转】文件转码" class="headerlink" title="【转】文件转码"></a>【转】文件转码</h1><h2 id="查看文件编码"><a href="#查看文件编码" class="headerlink" title="查看文件编码"></a>查看文件编码</h2><p>在Linux中查看文件编码可以通过以下几种方式：</p><h3 id="1-在Vim中可以直接查看文件编码"><a href="#1-在Vim中可以直接查看文件编码" class="headerlink" title="1. 在Vim中可以直接查看文件编码"></a>1. 在Vim中可以直接查看文件编码</h3><p><code>:set fileencoding</code><br>即可显示文件编码格式。如果你只是想查看其它编码格式的文件或者想解决用Vim查看文件乱码的问题，那么你可以在 <code>~/.vimrc</code> 文件中添加以下内容：<br><code>set encoding=utf-8 fileencodings=ucs-bom,utf-8,cp936</code><br>这样，就可以让vim自动识别文件编码（可以自动识别UTF-8或者GBK编码的文件），其实就是依照 fileencodings 提供的编码列表尝试，如果没有找到合适的编码，就用latin-1(ASCII)编码打开。</p><h3 id="2-enca-查看文件编码"><a href="#2-enca-查看文件编码" class="headerlink" title="2. enca 查看文件编码"></a>2. enca 查看文件编码</h3><p>(如果你的系统中没有安装这个命令，可以用<code>sudo yum install -y enca</code>安装 )<br>Mac 下可以用 brew 安装<br><code>sudo brew install enca</code><br>查看命令如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ enca filename</span><br><span class="line">filename: Universal transformation <span class="built_in">format</span> <span class="number">8</span> bits; UTF<span class="number">-8</span> <span class="literal">CRLF</span> <span class="built_in">line</span> terminators</span><br></pre></td></tr></table></figure><p>需要说明一点的是，enca对某些GBK编码的文件识别的不是很好，识别时会出现：<code>Unrecognized encoding</code></p><h3 id="3-查看文件编码-file-命令"><a href="#3-查看文件编码-file-命令" class="headerlink" title="3. 查看文件编码 file 命令"></a>3. 查看文件编码 file 命令</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file ip.txt</span><br><span class="line">ip.txt: UTF<span class="number">-8</span> Unicode <span class="type">text</span>, <span class="keyword">with</span> <span class="keyword">escape</span> <span class="keyword">sequences</span></span><br></pre></td></tr></table></figure><h2 id="文件编码转换"><a href="#文件编码转换" class="headerlink" title="文件编码转换"></a>文件编码转换</h2><h3 id="1-在Vim中直接转换文件编码"><a href="#1-在Vim中直接转换文件编码" class="headerlink" title="1. 在Vim中直接转换文件编码"></a>1. 在Vim中直接转换文件编码</h3><p><code>:set fileencoding=utf-8</code> //将一个文件转换成utf-8格式</p><h3 id="2-enconv-转换文件编码"><a href="#2-enconv-转换文件编码" class="headerlink" title="2. enconv 转换文件编码"></a>2. enconv 转换文件编码</h3><p><code>enconv -L zh_CN -x UTF-8 filename</code> // 将一个GBK编码的文件转换成UTF-8编码</p><h3 id="3-iconv-转换，iconv的命令格式如下："><a href="#3-iconv-转换，iconv的命令格式如下：" class="headerlink" title="3. iconv 转换，iconv的命令格式如下："></a>3. iconv 转换，iconv的命令格式如下：</h3><p><code>iconv -f encoding -t encoding inputfile</code></p><p>比如将一个UTF-8 编码的文件转换成GBK编码<br><code>iconv -f UTF-8 -t GBK file1 -o file2</code></p><h4 id="一、利用iconv命令进行编码转换文件内容编码转换"><a href="#一、利用iconv命令进行编码转换文件内容编码转换" class="headerlink" title="一、利用iconv命令进行编码转换文件内容编码转换"></a>一、利用iconv命令进行编码转换文件内容编码转换</h4><p>iconv命令用于转换指定文件的编码，默认输出到标准输出设备，亦可指定输出文件。查了下iconv命令用法如下：<br><code>iconv [选项...] [文件...]</code><br>有如下选项可用:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入/输出格式规范：</span><br><span class="line"><span class="deletion">-f, --from-code=名称 原始文本编码</span></span><br><span class="line"><span class="deletion">-t, --to-code=名称 输出编码</span></span><br><span class="line"></span><br><span class="line">信息：</span><br><span class="line"><span class="deletion">-l, --list 列举所有已知的字符集</span></span><br><span class="line"></span><br><span class="line">输出控制：</span><br><span class="line"><span class="deletion">-c 从输出中忽略无效的字符</span></span><br><span class="line"><span class="deletion">-o, --output=FILE 输出文件</span></span><br><span class="line"><span class="deletion">-s, --silent 关闭警告</span></span><br><span class="line"><span class="deletion">--verbose 打印进度信息</span></span><br></pre></td></tr></table></figure><p>例子:<br><code>iconv -f utf-8 -t gb2312 aaa.txt &gt; bbb.txt</code><br>这个命令读取aaa.txt文件，从utf-8编码转换为gb2312编码,其输出定向到bbb.txt文件。</p><h4 id="二、文件名编码转换"><a href="#二、文件名编码转换" class="headerlink" title="二、文件名编码转换"></a>二、文件名编码转换</h4><p>因为现在用Linux，原来在Windows里的文件都是用GBK编码的。所以copy到linux下是乱码，文件内容可以用<code>iconv</code>来转换，可是好多中文的文件名还是乱码，找到个可以转换文件名编码的命令，就是<code>convmv</code>。<br>convmv命令详细参数 例如<br><code>convmv -f GBK -t UTF-8 *.mp3</code><br>不过这个命令不会直正的转换，你可以看到转换前后的对比。如果要直正的转换要加上参数 <code>--notest</code><br><code>convmv -f GBK -t UTF-8 --notest *.mp3</code><br><code>-f</code> 参数是指出转换前的编码，-t 是转换后的编码。这个千万不要弄错了。不然可能还是乱码哦。还有一个参数很有用。就是 <code>-r</code> 这个表示递归转换当前目录下的所有子目录。</p><p>Linux 需要安装 convmv-1.10-1.el5.noarch.rpm</p><p>Mac 下用brew 安装<code>sudo brew install convmv</code></p><h4 id="三、更好的傻瓜型命令行工具enca"><a href="#三、更好的傻瓜型命令行工具enca" class="headerlink" title="三、更好的傻瓜型命令行工具enca"></a>三、更好的傻瓜型命令行工具enca</h4><p>它不但能智能的识别文件的编码，而且还支持成批转换。 　　</p><h5 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装 　　"></a>1.安装 　　</h5><p><code>$sudo apt-get install enca</code><br>Mac 下 <code>sudo brew install enca</code></p><h4 id="2-查看当前文件编码"><a href="#2-查看当前文件编码" class="headerlink" title="2.查看当前文件编码"></a>2.查看当前文件编码</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enca -L zh_CN ip.txt     </span><br><span class="line">Simplified Chinese <span class="type">National</span> Standard; GB2312     </span><br><span class="line">Surrounded <span class="keyword">by</span>/intermixed <span class="keyword">with</span> non-<span class="type">text</span> data  　　</span><br><span class="line">`</span><br></pre></td></tr></table></figure><h5 id="3-转换"><a href="#3-转换" class="headerlink" title="3.转换 　　"></a>3.转换 　　</h5><p>命令格式如下 　　<br><code>$enca -L 当前语言 -x 目标编码 文件名</code><br>-L zh_CN 一般也可以不用指定。</p><p>例如要把当前目录下的所有文件都转成utf-8 　　<br><code>enca -L zh_CN -x utf-8 *</code> 或 <code>enca -x utf-8 *</code></p><p>检查文件的编码　<br><code>enca -L zh_CN file</code></p><p>将文件编码转换为”UTF-8”编码　<br><code>enca -L zh_CN -x UTF-8 file</code></p><p>如果不想覆盖原文件可以这样<br><code>enca -L zh_CN -x UTF-8 &lt; file1 &gt; file2</code></p><hr><p>Reference</p><ol><li><a href="https://www.zhihu.com/question/20562901/answer/138922102" target="_blank" rel="noopener">Office for Mac 打开 Excel 文件全是乱码</a></li><li><a href="https://segmentfault.com/a/1190000007073776" target="_blank" rel="noopener">Linux（Mac）下查看文件编码及修改编码</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>脚本书写及执行注意事项</title>
      <link href="/post/script-notes/"/>
      <url>/post/script-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87cq9pnx6j30mu0cu75u.jpg" alt=""></p><p>怎样写出健壮友好的脚本？</p><a id="more"></a><p>工作中经常会写一些脚本来批量处理一些数据，有时一个脚本的执行时间可能长达数小时，而且中间随时可能出错中断，这可能是脚本对某些情况考虑不够全面，也可能是脏数据的问题。那么，如何才能写出健壮的脚本，让整个任务一气呵成呢？以下就根据我丰(cai)富(guo)的(de)经(keng)验来谈一谈。</p><ol start="0"><li><strong>数据备份</strong>。避免脚本异常执行所导致数据无法恢复。</li><li><strong>异常处理</strong>。当异常发生时，我们可以视情况决定是终止脚本，还是记录失败的数据继续执行，但无论哪种方式，都需要记录发生异常的位置和上下文信息，便于快速定位问题，并在修复问题后继续执行。尤其需要注意的是，有些数据二次执行会引发问题，因此正确记录异常位置，实现“断点续传”非常重要</li><li><strong>日志记录</strong>。对于被执行的内容需要详细的记录，这样可以在发生异常或者在脚本结束时查看整个执行过程。需要注意的是，日志记录是追加而不是覆写，而且要注意日志的换行。</li><li><strong>统计信息</strong>。记录脚本的开始、结束时间，内存消耗情况，以及执行统计信息，如：共需执行m条数据，成功执行n条，执行失败x条，执行总耗时y等信息，还可以根据统计信息在脚本健壮执行后再进一步优化</li><li><strong>脚本测试</strong>。在真实数据执行前，一定要先在 mock 数据上验证一下脚本，有时数据量的不同也会导致脚本执行异常，所以 mock 数据量也要接近真实环境</li><li><strong>结果通知</strong>。执行完成通过邮件等方式通知，不必一直盯着脚本</li><li><strong>Server 执行</strong>。服务器相比个人电脑性能和网络方面等更有优势，执行环境更快、更稳定。之前我一个脚本 Mac 执行20分钟，Server 执行2分钟😂</li><li><strong>会话保持</strong>。使用<code>screen</code>或者<code>tmux</code>，远程登录服务器 ==&gt; 创建会话 ==&gt; 会话分离 ==&gt; 退出服务器 ==&gt; do somethin ==&gt; 收到结果通知 ==&gt; 重新登录服务器 ==&gt; 会话恢复 ==&gt; 查看执行结果</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refactorData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        $timeStart = microtime(<span class="keyword">true</span>);</span><br><span class="line">        $startDesc = date(<span class="string">'Y-m-d H:i:s'</span>) . <span class="string">' 开始执行！'</span> . PHP_EOL;</span><br><span class="line">        $logFile = <span class="keyword">__DIR__</span> . <span class="string">'/refactor_data.log'</span>;</span><br><span class="line">        <span class="keyword">echo</span> $startDesc;</span><br><span class="line">        </span><br><span class="line">        file_put_contents($logFile, $startDesc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据初始化</span></span><br><span class="line">        $updateData = [];</span><br><span class="line">        $success = $failed = $exception = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $datum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                $failed++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                file_put_contents(logFile, $datum[<span class="string">'id'</span>] . <span class="string">'由于xxx执行失败'</span> . PHP_EOL, FILE_APPEND);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                $exception++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                file_put_contents(logFile, $datum[<span class="string">'id'</span>] . <span class="string">'由于xxx无法执行'</span> . PHP_EOL, FILE_APPEND);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理脚本...</span></span><br><span class="line">            file_put_contents($logFile, $datum[<span class="string">'id'</span>] . PHP_EOL, FILE_APPEND);</span><br><span class="line">            $success++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $timeStop = microtime(<span class="keyword">true</span>);</span><br><span class="line">        $endDesc = date(<span class="string">'Y-m-d H:i:s'</span>) . <span class="string">'执行结束！'</span> . PHP_EOL;</span><br><span class="line">        file_put_contents($logFile, $endDesc, FILE_APPEND);</span><br><span class="line">        <span class="keyword">echo</span> $endDesc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化执行耗时</span></span><br><span class="line">        $seconds = round($timeStop - $timeStart, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">switch</span> ($seconds) &#123;</span><br><span class="line">            <span class="keyword">case</span> $seconds &gt; <span class="number">60</span> &amp;&amp; $seconds &lt; <span class="number">3600</span>:</span><br><span class="line">                $elapsed = intval($seconds / <span class="number">60</span>) . <span class="string">'m'</span> . ($seconds % <span class="number">60</span>) . <span class="string">'s'</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> $seconds &gt; <span class="number">3600</span> &amp;&amp; $seconds &lt; <span class="number">86400</span>:</span><br><span class="line">                $elapsed = intval($seconds / <span class="number">3600</span>) . <span class="string">'h'</span> . intval($seconds % <span class="number">3600</span> / <span class="number">60</span>) . <span class="string">'m'</span> . ($seconds % <span class="number">60</span>) . <span class="string">'s'</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                $elapsed = $seconds . <span class="string">'s'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化内存单位</span></span><br><span class="line">        $formatStorageUnit = <span class="function"><span class="keyword">function</span> <span class="params">($scale)</span> </span>&#123;</span><br><span class="line">            $gb = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">            $mb = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">            $kb = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">switch</span> ($scale) &#123;</span><br><span class="line">                <span class="keyword">case</span> $scale &gt;= $gb:</span><br><span class="line">                    $humanUnit = round($scale / $gb, <span class="number">2</span>) . <span class="string">'GB'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> $scale &gt;= $mb:</span><br><span class="line">                    $humanUnit = round($scale / $mb, <span class="number">2</span>) . <span class="string">'MB'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> $scale &gt;= $kb:</span><br><span class="line">                    $humanUnit = round($scale / $kb, <span class="number">2</span>) . <span class="string">'KB'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    $humanUnit = $scale . <span class="string">'B'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> $humanUnit;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        $total = <span class="number">999</span>;</span><br><span class="line">        $summary = <span class="string">'=============统计摘要信息================'</span> . PHP_EOL .</span><br><span class="line">            <span class="string">'本次共需处理'</span> . $total . <span class="string">'条数据，成功'</span> . $success . <span class="string">'条，失败'</span> . $failed . <span class="string">'条，无法处理'</span> .</span><br><span class="line">            $exception . <span class="string">'条。'</span> . PHP_EOL . <span class="string">'执行耗时'</span> . $elapsed . <span class="string">', 内存消耗'</span> . $formatStorageUnit(memory_get_usage()) .</span><br><span class="line">            <span class="string">'，内存消耗峰值'</span> . $formatStorageUnit(memory_get_peak_usage()) . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        file_put_contents($logFile, $summary, FILE_APPEND);</span><br><span class="line">        <span class="keyword">echo</span> $summary;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 邮件通知执行结果</span></span><br><span class="line">        (<span class="keyword">new</span> Mail())-&gt;sendMail([</span><br><span class="line">            <span class="string">'title'</span>    =&gt; <span class="string">'xxx脚本执行完成'</span>,</span><br><span class="line">            <span class="string">'body'</span>     =&gt; $summary,</span><br><span class="line">            <span class="string">'receiver'</span> =&gt; <span class="string">'mail@example.com'</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">        <span class="comment">// 邮件通知执行结果</span></span><br><span class="line">        (<span class="keyword">new</span> Mail())-&gt;sendMail([</span><br><span class="line">            <span class="string">'title'</span>    =&gt; <span class="string">'xxx脚本执行失败'</span>,</span><br><span class="line">            <span class="string">'body'</span>     =&gt; <span class="string">'执行失败，错误原因：'</span> . $e-&gt;getMessage(),</span><br><span class="line">            <span class="string">'receiver'</span> =&gt; <span class="string">'mail@example.com'</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前就是这些了，再有新的经验随时补充:)</p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间黑洞</title>
      <link href="/post/time-blackhole/"/>
      <url>/post/time-blackhole/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87b8wwj7yj30q40b8myo.jpg" alt=""></p><a id="more"></a><p>为什么你总在加班？为什么你下班后身心俱疲，但又感觉一天没做什么？你的时间都去哪儿了？如何才能早点下班回家？今天，我们来探讨一下这个如今非常普遍现象背后的原因。</p><h1 id="办公环境"><a href="#办公环境" class="headerlink" title="办公环境"></a>办公环境</h1><p>不知道你有没有这样的经历：你的旁边是电话销售或者售后服务，当你准备将构思好的一段代码写下来时，他们的一通电话让你的构思像被一阵龙卷风袭击一样，再也想不起来。你感觉自己就像置身于菜市场一样，根本无法写出什么像样的代码。</p><p>现在开放式办公越来越受欢迎，看起来似乎让同事间的沟通更加的高效、同事的关系也更加融洽，但事实却是你经常被旁边同事与他人的讨论打扰，忍受着视觉与听觉的污染，让你无法集中注意力。原本半小时就可以完成的任务，你需要经常停下来重新捋一下思路，你花费了更长的时间来完成任务，质量还打了折扣。</p><p>开放式办公与格子间办公各有利弊，前者更便于沟通，让员工无法在上班时间娱乐；后者给员工一个相对独立的空间，能更加专注高效处理事件。二者似乎难以抉择，正如没有最好的方式，只有合适的方式一样，可以为员工提供两种办公环境，让员工自由选择。如果采用开放式办公只是为了防止员工上班“摸鱼”，你或许应该改善的是招聘标准，而不是让工作效率降低的工作环境。</p><h1 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h1><p>你可能也有过这样的经历：被邀请参加一个会议，进去之后发现很多的参会者，认真听了一会儿后，发现似乎和你没有什么关系。当你正想看一下之前收藏的博客时，又突然被提问。眼看会议室时间就要到了，组织者似乎对本场会议不是很满意，又约定两天后继续讨论。</p><p>毫无疑问，会议是一种高成本的高效沟通方式，但很多人将这种沟通方式滥用，反而浪费了很多的时间。因此，这种形式需要组织者在会前认真做很多准备工作，如：明确会议主题、必要与会人员、参会者会议前需要了解的内容、会议所要达到的效果等。</p><h1 id="需求评估"><a href="#需求评估" class="headerlink" title="需求评估"></a>需求评估</h1><p>产品需求的合理性，需求与系统间的平衡，投入产出比等，这是我们每个开发者在需求评估时都需要考虑的问题。产品经理与开发者应该站在各自的角度评估需求，并给出合理的解释。对于那些收益较少，但会对系统稳定及维护造成很大冲击的需求，请严辞拒绝，如果产品经理用领导向你施压，而领导又无法给出令人信服的理由，你或许应该考虑换一个团队了。</p><p><strong>一个畸形的需求会像核辐射一样污染整个项目</strong>。到时你不得不每天充当救火队员，即使在下班时间也会常常收到报警提醒。</p><p>如果你评估后认为需求合理，但产品要求你3天完成一个不可能完成的任务，请不要高估自己的能力，说明你的真实情况。要么延长开发时间，要么增加人手。说明自己在不可能的时间完成任务并不丢人，承诺失信才更加丢人。</p><h1 id="拼凑代码"><a href="#拼凑代码" class="headerlink" title="拼凑代码"></a>拼凑代码</h1><p>你编程的方式是不是在不停的试验，寻找一种看上去能工作的组合？即使你这样随意的开发过程能够产生出一个正确的程序，但你真的清楚你写的代码是如何运行的吗？清楚其中所隐藏的 bug 吗？你需要真正理解你的代码是如何工作的，而不是瞎猜。</p><p>相比与拼凑代码的程序员，优秀程序员会首先理解需求，然后在脑海中模拟程序的执行，再将执行过程用伪代码的方式记录下来，检索逻辑是否存在漏洞，是否有值得优化的地方。当他们确定好之后，再转换为代码语言。在这个过程中，他们用80%的时间思考，用20%的时间写出高质量的代码，而他们大多数时间看起来并不是那么忙。他们用伪代码来检查自己的整个代码，也确保自己在编写代码过程中不会走偏而浪费时间。</p><p>在编写完成后，差的程序员自己跑一遍代码就提交给测试，而优秀的程序员会重新审视自己刚写的代码，这个过程中又能发现80%的错误，诸如拼写错误，判断边界条件等。不经审视的代码在测试后收到一大堆的问题反馈，如需求不符，数据显示错误等显而易见的问题，在来回反馈问题、处理问题的沟通中，时间又在不知不觉间来到了下班时间，但现在的问题还很多，意味着你今晚要加班解决了。</p><p>在这个过程中，我们发现好的开发过程并不会提升你的工作时间和工作量，反而会让你更早下班，安心休息。</p><ul><li>认真评估与理解需求</li><li>用伪代码检查可行性与常见问题</li><li>将伪代码转换为编程语言</li><li>审视自己的代码，你通常能找到80%的错误，从而节省大量时间</li></ul><h1 id="调试-bug"><a href="#调试-bug" class="headerlink" title="调试 bug"></a>调试 bug</h1><p>你可能在工作中经常会听到这样的话：</p><ul><li>这问题不可能是我的，我什么也没改</li><li>昨天还好好的，怎么今天突然就不行了呢？</li><li>我本地跑的好好的，为什么一到线上就不行了？</li></ul><p>要知道，如果你写的程序出了问题，那就是你的原因，不是计算机的，也不是编译器的。程序不会每次都产生不同的结果。它不是自己写出来的，是你写的，所以，请对它负责。</p><p>我们可能还会在工作中遇到这样的一种人：</p><ul><li>查找bug时不停的在程序中散布<code>print</code>，如果<code>print</code>没有找到原因，那就随便修改点什么，让程序看起来好像正常了</li><li>出现的问题不值一提，要解决它们并不需要彻底弄懂程序。只要能让程序看起来正常运行就行了</li><li>不需要重写这段自己两个月前的烂代码，只要能让这段程序跑起来就行</li></ul><p>在大多数情况下，查找并理解 bug 通常占用了整个调试工作的 90%。因此，如果你已经在查找 bug 中花费了太多的时间，你或许应该优化你的异常处理，能够快速定位到问题所在；也应该优化你的代码，不要让那些难以阅读的代码花费太多时间。治标不治本的问题处理方式同样会让你和这个问题纠缠在一起，浪费更多的时间，</p><h1 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h1><p>不让苍蝇烦扰你的最好方式就是消灭苍蝇，因此，我们需要高质量来减少我们在 bug 中所花费的大量时间。而质量保障在项目中又是一个设计面很广泛的话题，更详细的内容可阅读《代码大全》等经典书籍，也可以查看我的<a href="http://blog.shixinyu.space/2019/09/28/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B/">《代码大全》笔记</a>。</p><p>软件质量大体包括以下方面：</p><ul><li>需求调研</li><li>产品设计</li><li>技术架构(是否包含取悦老板的部分？)</li><li>项目实施人员配置(《人月神话》)</li><li>数据表设计</li><li>开发规范<ul><li>高质量的类</li><li>高质量的子程序</li><li>防范式编程</li></ul></li><li>质量保障是否全程关注</li><li>自动化测试</li><li>bug 追踪</li><li>bug 分析统计</li></ul><p>经验告诉我们：错误越早引入软件当中，问题就会越复杂，修正这个错误的代价也就越高，因为错误会牵涉到系统的更多部分。因此，保障开发质量并不会让你做很多工作，而会让你节省很多时间。那些为了追求速度而放弃质量的决策者是愚蠢的。提高质量不仅能缩短开发周期、降低开发成本，也让工作与生活的平衡成为可能。</p><h1 id="远离老好人领导"><a href="#远离老好人领导" class="headerlink" title="远离老好人领导"></a>远离老好人领导</h1><p>这样的领导大包大揽一大堆，不清楚职责边界。看似做了很多工作，但又有很多问题。这不会给你增加成就感，反而徒增挫败感：每天的问题如洪水猛兽吞噬着每个人的时间，你和他反馈现状，他只会让你放弃你的想法；你和他讨论问题的解决方案，他的方案是权宜之计。请远离这样的领导，他只会不停吞噬你宝贵的时间。</p><hr><p>那些经常哭诉自己每天从早干到晚的人不值得同情，抱怨解决不了任何问题，只会浪费更多的时间。</p><p>最后，我想引用一段知乎用户在相似问题下的<a href="https://www.zhihu.com/question/342244497/answer/815161940" target="_blank" rel="noopener">回答</a>：</p><blockquote><p>为什么几十年前，很多思想家都幻想过。<br>随着科技发展，人们每天只需要工作3-5小时。<br>人们可以享受生活，享受自由，享受家庭，享受大自然。</p><p>为什么科技越发展，人们越没法享受科技发展的红利？<br>人们不仅没法每天工作3-5小时，996还成了福报，35岁被裁员成了标配。<br>为什么科技越发展，劳动者越痛苦，劳动时间越长。<br>为什么现在的绝大部分劳动者，都养不活两个孩子？</p><p>科技真的进步了吗？社会真的发展了吗？<br>如果科技进步了，社会发展了，文化繁荣了。<br>那么是什么夺走了人们的生活，时间，孩子？</p></blockquote><hr><p>相关阅读<br><a href="https://anaxi.com/blog/2018/10/15/top-12-things-that-destroy-developer-productivity/" target="_blank" rel="noopener">Top 12 Things That Destroy Developer Productivity</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件编程，随笔杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
            <tag> 时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】通俗讲解网站扩展</title>
      <link href="/post/website-extension/"/>
      <url>/post/website-extension/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1drnb6tzij30jg0bf0tz.jpg" alt=""></p><a id="more"></a><h1 id="【译】通俗讲解网站扩展"><a href="#【译】通俗讲解网站扩展" class="headerlink" title="【译】通俗讲解网站扩展"></a>【译】通俗讲解网站扩展</h1><blockquote><p><em>译者注：本文译自 Arcentry 文章《Scaling webapps for newbs &amp; non-techies》，点击<a href="https://arcentry.com/blog/scaling-webapps-for-newbs-and-non-techies/" target="_blank" rel="noopener">此处</a>查看原文</em></p></blockquote><p>本文简要的介绍了网站如何从一台服务器到承受数百万用户的架构部署演化，主要为新入门开发者和非从业人员而写。</p><h2 id="网站扩展"><a href="#网站扩展" class="headerlink" title="网站扩展"></a>网站扩展</h2><p>现在，假设你刚刚完成了你的网站，在线商店、社交 APP 或者别的什么，当项目上线时，感觉一切都好极了：每天有几百个用户访问你的网站，网站快速做出请求响应，一切都在有条不紊地进行着。</p><p>但是之后一件可怕的事情出现了：你的网站一夜爆红！</p><p>越来越多的用户开始涌向你的网站，每小时、每分钟、每秒钟成千上万的用户发来请求……这对老板来说，真是一个天大的好消息，但对基础运维来说，简直就是一场噩梦，因为现在，你需要做网站的扩展来承受洪水般的流量。这意味着你需要：</p><ul><li>同时处理更多的请求</li><li>除了光纤被挖断，服务的高可用</li><li>服务来自世界各地的用户</li></ul><h2 id="如何扩展"><a href="#如何扩展" class="headerlink" title="如何扩展"></a>如何扩展</h2><p>几年前，这样的问题会从水平扩展与垂直扩展的角度开始讨论。垂直扩展是指通过提升单机的处理能力来处理更多的请求，而水平扩展则是通过复制当前架构模型来提升处理能力。</p><p>今天，几乎没有人再使用垂直扩展，原因很简单：</p><ul><li>计算机的价格越来越昂贵，而性能提升却微乎其微</li><li>单台服务器的性能存在天花板</li><li>多核CPU也就是多个单核CPU的并行处理效率，那为什么不进行水平扩展呢？<br>OK，我们选用水平扩展来提升网站，但又需要怎么做呢？</li></ul><h3 id="1-单一服务器"><a href="#1-单一服务器" class="headerlink" title="1. 单一服务器"></a>1. 单一服务器</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1dnqtex5gj30jg0bumxv.jpg" alt=""></p><p>这可能是你最初的架构。一台服务器既运行着业务，又存储着数据，简单又实用，但为了满足更高的要求，这种架构只能运行在性能更强的服务器上，这不是我们所希望的。</p><h3 id="2-增加反向代理"><a href="#2-增加反向代理" class="headerlink" title="2. 增加反向代理"></a>2. 增加反向代理</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1dnxk7if8j30jg0alwf6.jpg" alt=""></p><p>为了应付大流量，你第一步需要做的是增加反向代理。就像是酒店的前台，你可以让客人直接到他的客房，但事实上，你需要一位大堂经理，判断客人是否可以进入，是否已经提前预定好客房，如果客房已满，你应该友好地告知客人，而不是让客人自己挨个去查看。这个例子很好的解释了反向代理，反向代理通常只是接收与转发请求，然后这些请求在处理完成后从我们的服务器返回给用户。当用户向服务器发起请求时，这些请求需要路由到我们的服务器上，所以我们称之为“反向代理”。</p><p>反向代理的作用如下：</p><ul><li>可用性检查。确保我们的服务正常运行</li><li>路由。转发请求到正确的处理终端</li><li>鉴权。确保用户有权限访问服务</li><li>防火墙。确保仅被授权的用户可以访问</li></ul><h3 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3. 负载均衡"></a>3. 负载均衡</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1doii7p2zj30jg0csgmn.jpg" alt=""></p><p>大多数的反向代理服务器还有一个作用：负载均衡。负载均衡是一个较为简单的概念：想象一下，有100个用户准备在限定的时间内进行支付，不幸的是，你的支付服务只能同时处理50笔交易，该怎么解决呢？你只需要同时运行两台支付服务就可以了。</p><p>负载均衡服务器现在需要将支付请求分流到两台服务器上，用户A的支付在S1上处理，用户B的支付在S2上处理，用户C的支付在S3上处理……</p><p>如果同时有500个用户发起支付请求该怎么办呢？没错！你只需将支付服务器扩展到10台来分发处理这些请求即可。</p><h3 id="4-增强数据库"><a href="#4-增强数据库" class="headerlink" title="4. 增强数据库"></a>4. 增强数据库</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1doshmdyij30jg0bwwfh.jpg" alt=""></p><p>负载均衡可以将用户的请求在多台服务器进行处理，但你注意到其中的问题了吗？我们可以扩展几十台、几百台甚至几千台服务器来处理请求，但所有的数据都储存在了同一个数据库中。</p><p>所以，我们可以用同样的办法来扩展数据库吗？答案是 No！这里涉及到了数据一致性的问题。我们需要保证系统所使用的数据是一致的，不一致的数据会导致一系列的问题，比如：同一个订单被多次处理，我们从一个100元的账户进行了两次扣款操作……那我们又该如何调整数据库来确保数据的一致性呢？</p><p>首先我们要做的就是将数据库功能拆分，一部分只负责接收与存储数据，其他部分只进行数据的检索。这种解决方案被称为主从复制或者读写分离。假设数据被读取的频率高于写入频率，我们可以将数据一处写入，多处读取（被读取的数据是写入数据的副本）。这里的缺点是我们只能在一处写入数据，这对于中小型网站来说没有问题，但不适用 Facebook 这样的网站，我们将在第9章进一步讨论如何扩展这样级别的数据库。</p><h3 id="5-微服务"><a href="#5-微服务" class="headerlink" title="5. 微服务"></a>5. 微服务</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1dpdetz6uj30jg0c3wfw.jpg" alt="Microservices"></p><p>到现在为止，我们还是用一台服务器来处理所有的事情：处理支付、订单、库存查询、网站运行、管理账户等。</p><p>这或许不是件坏事——单一服务器意味着更低的复杂度、也更利于开发人员。但随着服务器的扩展，事情开始变得复杂与低效：</p><ul><li>不同服务器处理相同的事情——对每个登陆的用户而言，可能有几百个页面需要处理，但这些都是由同一个服务器完成的。</li><li>开发团队随着业务扩张——随着越来越多的开发者在同一台服务器上工作，冲突也越来越多</li><li>单一服务器意味着当我们想要完成新版本的迭代时，必须完成所有的工作。当一个团队想要快速发布更新时，由于依赖的另一个团队只完成了一半，导致了危险的相互依赖性。</li></ul><p>微服务的出现很好的解决了这些问题。微服务的概念很简单——将你的服务以功能单元进行拆分，并进行独立部署。微服务具有以下优点：</p><ul><li>每个服务能都被独立扩展，让我们能更加灵活地调整以适应业务发展（<em>译者注：比如邀请注册的网站限时开放注册，此时有大量的注册请求，我们可以扩展注册账户服务器的处理能力；当双十一进行大量支付处理时，我们可以扩展支付系统的处理能力，活动结束后，再将处理能力进行恢复，此为弹性扩容</em>）</li><li>运维团队能够独立处理各功能单元，他们能负责微服务的整个生命周期（创建、部署、升级等）</li><li>每个微服务可以使用所需资源。如第4章那样，需要数据库的扩展</li></ul><h3 id="6-缓存与CDN"><a href="#6-缓存与CDN" class="headerlink" title="6. 缓存与CDN"></a>6. 缓存与CDN</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1dq9od5rcj30jg0c8abp.jpg" alt=""></p><p>有什么比工作更高效的方法吗？（What’s better than working more efficiently?）答案是什么都不做！我们所使用的网站或APP由大量的静态资源所组成，如图片、JavaScript 和 CSS 文件，某些产品的预渲染登陆页等。相对于在每次请求时重新计算或者重新生成这些资源，我们使用“缓存”来加速响应并节约服务器资源——缓存记录最新的结果，并直接返回给再次请求的用户。</p><p>大型的缓存服务被称为CDN（Content Delivery Network，内容分发网络）——大量的缓存内容被存放在世界各地。CDN能让用户就近快速获取到所需资源，而不需要每次跨越千山万水到中央服务器获取。</p><h3 id="7-消息队列"><a href="#7-消息队列" class="headerlink" title="7. 消息队列"></a>7. 消息队列</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1dqm3ll8uj30jg0bdjsz.jpg" alt="Message Queues"></p><p>你去过游乐场吗？是不是经常需要排队购票呢？地铁闸机口、银行柜台、游乐场售票处都是解释“子容量并行性”（sub-capacity parallelism）概念非常好的例子。没错，他们都是并行处理的：多个售票窗口同时售票，但他们又无法同时为每个人服务，因此，在每个窗口后开了排队。</p><p>同样的，在大型网站中。每分钟有成百上千的图片上传到 Instagram、Facebook，每张图片都需要被处理、裁剪、分析与打标签（<em>译者注：如反恐扫黄系统</em>），这是非常耗时的。所以，与其让用户等待图片上传完成及所有的处理过程，不如服务器在接收到图片后再做以下三件事：</p><ul><li>存储原始图片，不做任何处理</li><li>向用户返回图片上传成功</li><li>对待处理图片增加标识，指定待处理部分</li></ul><p>其他服务通过检索待处理标识来逐一处理，直到完成所有待处理任务。管理这样任务的系统被称为“消息队列”。使用消息队列有很多好处：</p><ul><li>将任务与处理异步化。有时许多图片需要被处理，有时只有几张；有时有很多CPU资源可用，有时却只有部分CPU资源可用。通过将待处理任务堆积，而不是直接处理，我们可以确保我们的系统可用性，而且任务不会丢失。</li><li>缓冲请求，扩展处理资源。当有大量用户上传图片时，我们需要时间来调拨更多的处理资源，如果没有消息队列，可能直接导致宕机。相反，有消息队列系统时，我们可以将请求添加到任务队列中，在处理资源到位后再进行处理，保证网站的可用性。</li></ul><blockquote><p>好了，现在我们的网站可以承受相当大的流量请求了，但如果我们想要承受更大的流量该怎么做？好吧，我们还需要做以下的一些工作：</p></blockquote><h3 id="8-分片"><a href="#8-分片" class="headerlink" title="8. 分片"></a>8. 分片</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1drnb6tzij30jg0bf0tz.jpg" alt=""></p><p>什么是分片呢？“分片是一种通过将服务拆分为多个单元来并行处理的一种技术，每个单元只负责某些部分”（”Sharding is a technique of parallelizing an application’s stacks by separating them into multiple units, each responsible for a certain key or namespace”）</p><p>所以，到底什么是分片呢？分片其实是一个非常简单的概念：想要像 Facebook 那样服务20亿用户？将你的架构改造成类似于26个 mini 版的 Facebook，每个用户通过不同的英语字母表来区分。Aaron Abrahams？应该被A服务器处理；Zacharias Zuckerberg? 应该被Z服务器处理……</p><p>分片不仅仅基于字母，也可以基于数字或者其他规则，如位置、使用频率等。你可以分片你的服务器、数据库或者其他服务资源，这完全取决于你的业务需要。</p><blockquote><p><em>译者注：分片技术，简而言之，就是将功能模块进行打包复制，类似于第3章的方案，提高并行处理能力。</em></p></blockquote><h3 id="9-DNS"><a href="#9-DNS" class="headerlink" title="9. DNS"></a>9. DNS</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1dsbsehduj30jg0bfmyg.jpg" alt=""></p><p>到目前为止，你部署了单一的负载均衡服务器——即使你花费高昂的价格购买了性能更强劲的服务器，由于硬件的物理限制，仍然难以满足大量的请求。幸运的是，在世界范围内，分布着一个在流量到达我们服务器前非常稳定的负载均衡工具——DNS(Domain Name System，域名系统)。该系统能将域名”arcentry.com”映射到具体的网络地址（IP），如143.204.47.77，该系统也允许我们为同一个域名指定多个不同的IP，从而在不同的机器上处理相同请求。</p><blockquote><p>非常感谢你能耐心看到这里，我希望这篇文章能对你有些用处。但是，如果你是IT从业人员，或许你在读了这篇文章后，又想到了一个困扰你很久的问题：什么是云服务？</p></blockquote><h1 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h1><p>云服务又是什么呢？已经2018年了，解决上述许多问题的最便宜和最有效的办法很明显：不用亲自解决！相反，由你的云服务提供商来为你扩展系统，而无需亲自处理这些问题，你只需关注自身业务。（<em>译者注：据统计显示，目前中国有40%的网站在阿里云托管，最近的阿里云事故导致大量的企业受损，这对一些小型企业来说，是灭顶之灾，因此如果自身有能力，还是要掌控局面，毕竟数据无价，如果必须选择云服务商，在选择靠谱的服务商外，不要把鸡蛋放在一个篮子里</em>）</p><p>以我的网站为例，我不需要做以上扩展的任何事情（除了数据的读写分离），只需要将网站托管在AWS上，没有服务器，没有烦恼。</p><p>但云服务也不是银弹，它也有自身一些问题与权衡。请继续关注本系列的下篇文章，以了解有关“面向新手与非技术人员云服务”的更多信息。</p><hr><blockquote><p>个人总结：应对大规模流量的处理层级为：DNS ==&gt; CDN缓存 ==&gt; 负载均衡服务器 ==&gt; 消息队列 ==&gt; 容器集群 ==&gt; 分片 ==&gt; 数据库读写分离</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>supervisor启动服务失败</title>
      <link href="/post/supervisor-start-error/"/>
      <url>/post/supervisor-start-error/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cmpr0nrcj30qo0c8q3c.jpg" alt=""></p><a id="more"></a><p>起因<br>最近一个多月 MBP 每天下午不定时突然重启，所幸每次重启后的不受影响，正好项目也比较紧张，也就忍忍先赶项目了，期间联系了 Apple 在线客服，但总是让我升级系统重试，上周正好项目上线了，赶紧抓紧时间预约了周五下午的天才吧，到了之后告诉我由于过保，检测费用300元，需要48小时的检测时间，同时需要告知售后开机密码。我一听就不干了，周一能不能干活先不说，把密码告诉你，那我银行卡的两块五没了怎么办？！</p><p>由于这个问题是最近出现的，因此我判断不是硬件的问题，只要是软件的问题就好说，直接拿出大招——重装系统。虽说格盘前已经尽可能的备份了自己能想到的所有文件，但总是会有些遗漏的地方，比如 docker 镜像</p><p>正文<br>重新安装完系统后，从同事那里拷贝过来了 docker 镜像，但启动容器后无法正常发起请求，进入容器使用命令<code>supervisorctl status</code>看到 nginx 没有启动，遂使用命令<code>supervisorctl start nginx</code>启动 nginx，但提示 <code>supervisor ERROR (spawn error)</code>，虽然有错误提示，但这样的提示对我来说就是没有提示，然后使用命令<code>supervisorctl tail nginx stdout</code>进一步查看信息，终于发现是由于相关的日志文件没有权限导致 nginx 服务无法正常启动，通过对比 MySQL 服务发现，nginx 服务用 work 账户执行，但日志文件的所有者和所属组却是 root，难怪会没有权限，于是使用<code>chown</code>和<code>chgrp</code>命令将日志文件的所有者与所属组更正，再次执行<code>supervisorctl start nginx</code>后，nginx 正常启动了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件推荐</title>
      <link href="/post/software-recommand/"/>
      <url>/post/software-recommand/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cn0syzb9j30zk0k0q6l.jpg" alt=""></p><a id="more"></a><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><h2 id="1-Notebook"><a href="#1-Notebook" class="headerlink" title="1. Notebook"></a>1. <a href="https://www.zoho.com/notebook/notebook-for-mac.html" target="_blank" rel="noopener">Notebook</a></h2><p>这是一款非常漂亮的笔记本，虽然我目前使用的是印象笔记和马克飞象，但我真的也非常喜欢这款笔记，我想我以后会尝试使用。<br><img src="https://www.zoho.com/notebook/images/mobile-inspired-gestures.png" alt="notebook"></p><h2 id="2-iPic"><a href="#2-iPic" class="headerlink" title="2. iPic"></a>2. <a href="http://toolinbox.net/iPic/" target="_blank" rel="noopener">iPic</a></h2><p>这是一款上传图片到各种图床的软件，对于经常使用 Markdown 写博客的用户来说，这简直就是福音，但坏消息是这款软件免费的只能使用微博图床，其他的图床都是是付费的。<br><img src="https://ww4.sinaimg.cn/middle/006tKfTcgy1fewqw208xmg30j60aske8.gif" alt="ipic"></p><h2 id="3-Mounty"><a href="#3-Mounty" class="headerlink" title="3. Mounty"></a>3. <a href="http://enjoygineering.com/mounty/" target="_blank" rel="noopener">Mounty</a></h2><p>由于 macOS 不支持 NTFS 的读写，因此通常需要使用 Paragon NTFS 或 Tuxera NTFS 来读写 NTFS 格式的磁盘，但这两款软件都是付费的，而免费版的 Mounty 同样能做到，因此我选择 Mounty。<br><img src="http://enjoygineering.com/mounty/img/example.png" alt="Mounty"></p><h2 id="4-iStat-Menus"><a href="#4-iStat-Menus" class="headerlink" title="4. iStat Menus"></a>4. <a href="https://github.com/Chris911/iStats" target="_blank" rel="noopener">iStat Menus</a></h2><p>一款实时查看电脑运行状态的工具，包括 CPU、硬盘、电池、网络等。<br><img src="http://ohx73ws1b.bkt.clouddn.com/istat.png" width="400"></p><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><h2 id="1-httpie"><a href="#1-httpie" class="headerlink" title="1. httpie"></a>1. httpie</h2><p>一款终端高亮格式化显示的http解析工具<br><img src="https://raw.githubusercontent.com/jakubroztocil/httpie/master/httpie.png" alt="httpie"></p><h2 id="2-mycli"><a href="#2-mycli" class="headerlink" title="2. mycli"></a>2. mycli</h2><p>一款自动完成终端 MySQL 命令高亮与提示的工具<br><img src="https://raw.githubusercontent.com/dbcli/mycli/master/screenshots/main.gif" alt="mycli demo"></p><h1 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h1><h2 id="1-Octotree"><a href="#1-Octotree" class="headerlink" title="1. Octotree"></a>1. <a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="noopener">Octotree</a></h2><p>Github 侧边栏目录结构<br><img src="http://upload-images.jianshu.io/upload_images/1094967-b6c0f72ef039a5c2?imageMogr2/auto-orient/strip" alt="octotree"></p><h2 id="2-GitHub-Hovercard"><a href="#2-GitHub-Hovercard" class="headerlink" title="2. GitHub Hovercard"></a>2. <a href="https://chrome.google.com/webstore/detail/github-hovercard/mmoahbbnojgkclgceahhakhnccimnplk" target="_blank" rel="noopener">GitHub Hovercard</a></h2><p>鼠标悬停显示更多信息，包括用户的摘要信息、commit 的摘要信息等<br><img src="http://upload-images.jianshu.io/upload_images/1094967-335a21063edfa79d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GitHub Hovercard"><br><img src="http://upload-images.jianshu.io/upload_images/1094967-a11d109a7a6ac19b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="repo"></p><h2 id="3-Isometric-Contributions"><a href="#3-Isometric-Contributions" class="headerlink" title="3. Isometric Contributions"></a>3. <a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien?hl=zh-CN" target="_blank" rel="noopener">Isometric Contributions</a></h2><p>3D 显示用户的仓库提交历史<br><img src="http://upload-images.jianshu.io/upload_images/1094967-c7e914bc8cc17bfd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="commit record"></p><hr><p>查看更多 Mac 精品软件可前往 <a href="https://github.com/jaywcjlove/awesome-mac" target="_blank" rel="noopener">Awesome Mac</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac 效率神器 - Alfred</title>
      <link href="/post/alfred/"/>
      <url>/post/alfred/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87cudg3j3j30i208cjse.jpg" alt=""></p><a id="more"></a><p>21世纪最重要的是什么？效率啊！今天我们就来讲一款让你效率提升300%的神器 Alfred，上图就是它的样子。Are you kidding me?! 就一个搜索框就能提升300%的效率？这不就是 OS X 自带的 Spotlight 嘛，你比罗永浩还能吹！别急，别急，待我慢慢道来。</p><h1 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h1><h2 id="1-搜索引擎"><a href="#1-搜索引擎" class="headerlink" title="1. 搜索引擎"></a>1. 搜索引擎</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_1.gif" alt="Web Search"></p><h2 id="2-打开文件"><a href="#2-打开文件" class="headerlink" title="2. 打开文件"></a>2. 打开文件</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_2.gif" alt="Open File"></p><h2 id="3-打开应用"><a href="#3-打开应用" class="headerlink" title="3. 打开应用"></a>3. 打开应用</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_3.gif" alt="Applicatioin"></p><h2 id="4-查找文件"><a href="#4-查找文件" class="headerlink" title="4. 查找文件"></a>4. 查找文件</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_4.gif" alt="Find File"></p><h2 id="5-计算器"><a href="#5-计算器" class="headerlink" title="5. 计算器"></a>5. 计算器</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_5.gif" alt="Calculator"></p><h1 id="进阶应用"><a href="#进阶应用" class="headerlink" title="进阶应用"></a>进阶应用</h1><h2 id="1-自定义搜索"><a href="#1-自定义搜索" class="headerlink" title="1. 自定义搜索"></a>1. 自定义搜索</h2><p>在搜索框中输入「Alfred」回车，依次点击 Features -&gt; Web Search<br><br>以下是我的一些自定义搜索配置，安装 Alfred 软件后打开下列「alfred://」开头的 URL 即可自动添加</p><blockquote><p>Docker Hub alfred://customsearch/Docker%20Store/ds/utf8/nospace/https%3A%2F%2Fstore.docker.com%2Fsearch%3Fq%3D%7Bquery%7D</p><p>GitHub<br>alfred://customsearch/GitHub/github/utf8/nospace/https%3A%2F%2Fgithub.com%2Fsearch%3Fq%3D%7Bquery%7D%26ref%3Dopensearch</p><p>PHP 中文手册<br>alfred://customsearch/PHP%20Manual/p/utf8/nospace/http%3A%2F%2Fphp.net%2Fsearch.php%3Fshow%3Dquickref%26pattern%3D%7Bquery%7D</p><p>MDN 手册<br>alfred://customsearch/MDN%20Web%20Docs/mdn/utf8/nospace/https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fsearch%3Fq%3D%7Bquery%7D</p><p>StackOverflow<br>alfred://customsearch/StackOverflow/so/utf8/nospace/http%3A%2F%2Fstackoverflow.com%2Fsearch%3Fq%3D%7Bquery%7D</p><p>Google 翻译为中文<br>alfred://customsearch/Google%E7%BF%BB%E8%AF%91%E4%B8%AD%E6%96%87/g2cn/utf8/nospace/https%3A%2F%2Ftranslate.google.com%2F%23auto%2Fzh-CN%2F%7Bquery%7D</p><p>Google 翻译为英文<br>alfred://customsearch/Google%20%E7%BF%BB%E8%AF%91%E8%8B%B1%E6%96%87/g2en/utf8/nospace/https%3A%2F%2Ftranslate.google.com%2F%23auto%2Fen%2F%7Bquery%7D</p></blockquote><h2 id="2-历史剪切板"><a href="#2-历史剪切板" class="headerlink" title="2. 历史剪切板"></a>2. 历史剪切板</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_6.gif" alt="Clipbord"></p><h2 id="3-代码片段"><a href="#3-代码片段" class="headerlink" title="3. 代码片段"></a>3. 代码片段</h2><p>我们经常会输入手机号、邮箱、身份证号等常用信息，程序员可能会有一些常用代码，每次手动输入不仅麻烦，而且经常输错，现在，用「Snippets」功能来拯救你吧。比如，我以关键字「demo」作为”Hello world”的关键字，依次点击 Features-&gt;Snippets，按照图示设置即可<br><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_setting.jpg" alt="Snippets"><br>最终的效果就是这样的：<br><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_7.gif" alt="Snippets"></p><p>如果你想每次都输出不同内容时，就需要用到占位符了，比如我想输出当前时间，你可以这样<br><img src="http://inews.gtimg.com/newsapp_match/0/2868860882/0" alt=""><br>时间的格式不是你想要的？在系统设置中的地区与语言中自定义你的时间吧:)</p><h2 id="4-系统命令"><a href="#4-系统命令" class="headerlink" title="4. 系统命令"></a>4. 系统命令</h2><p>Alfred 支持多个系统命令，如 lock 锁定电脑，emptytrash 清空回收站，restart 重启电脑，quit 退出指定应用等，这些都可以在 Features-&gt;System 中查看及设置。个人不太推荐使用 lock 和 emptytrash 以外的命令，使用第三方程序来关机或退出应用可能会导致一些意外情况，比如我昨天使用 quit iterm2 导致composer 命令无法执行，zsh 中加载了composer 的插件，最终导致整个终端都无法正常使用。</p><h2 id="5-执行终端命令"><a href="#5-执行终端命令" class="headerlink" title="5. 执行终端命令"></a>5. 执行终端命令</h2><p>Alfred 默认调用系统内置的 Terminal，可在 Features-&gt;Terminal/Shell 中参照<a href="https://github.com/stuartcryan/custom-iterm-applescripts-for-alfred修改配置，将" target="_blank" rel="noopener">https://github.com/stuartcryan/custom-iterm-applescripts-for-alfred修改配置，将</a> Terminal 修改为 iTerm2。</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_8.gif" alt="Terminal"></p><h1 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h1><p>Alfred 真正的黑科技是 workflow，话不所说，直接上图：</p><h2 id="1-翻译"><a href="#1-翻译" class="headerlink" title="1. 翻译"></a>1. 翻译</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_9.gif" alt="Translate"></p><h2 id="2-时间戳转换"><a href="#2-时间戳转换" class="headerlink" title="2. 时间戳转换"></a>2. 时间戳转换</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_10.gif" alt="Timestamp Convert"></p><h2 id="3-色值转换"><a href="#3-色值转换" class="headerlink" title="3. 色值转换"></a>3. 色值转换</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_11.gif" alt="Color Show"></p><h2 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4. Hash"></a>4. Hash</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_12.gif" alt="Hash"></p><p>我使用的 workflow 已上传至百度云盘，链接:<a href="https://pan.baidu.com/s/1eVyVe7DR9_NH_9vqafys9w" target="_blank" rel="noopener">https://pan.baidu.com/s/1eVyVe7DR9_NH_9vqafys9w</a>  密码:c1z9</p><hr><p>参考文章：<br><img src="https://kuaibao.qq.com/s/20180211A01CU900?refer=cp_1026%200%20%E5%88%86%E4%BA%AB%20%20%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81" alt="Mac效率神器Alfred系列教程-Snippets文字扩展"></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行下使用代理</title>
      <link href="/post/proxy-on-terminal/"/>
      <url>/post/proxy-on-terminal/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ohx73ws1b.bkt.clouddn.com/proxy.png" alt="proxy"></p><a id="more"></a><p>对于经常需要依赖国外资源的开发者，终端的下载速度让人抓狂，诸如常见的 wget、curl、git、brew 等命令行工具超慢，甚至无法获取资源，这就需要搭建一个科学上网利器，例如目前流行的shadowsocks，我们配置好 shadowsocks 服务器端后，安装对应系统的客户端便可，然而当你构建的时候还是会很慢，这时你发现系统自带的终端或 iTerm 2 是不走 Socks5 。</p><p>因在终端下不支持Socks5代理，只支持http代理，这就需要曲径通幽了。</p><h1 id="Mac平台下安装"><a href="#Mac平台下安装" class="headerlink" title="Mac平台下安装"></a>Mac平台下安装</h1><blockquote><p>环境：<br>OS X 10.12.5<br>ShadowsocksX-NG 1.5.0</p></blockquote><p>OS X 10.11之后较新的系统默认设置下不会安装成功。苹果在新系统中加入了SIP安全机制，他会阻止第三方程序向系统目录内（/System，/bin，/sbin，/usr(除了/usr/local)）进行写操作，sudo也不行。办法是先把SIP关了，等装好软件配置好后再打开SIP。或者改用其他软件。</p><p>关闭SIP也麻烦，遂用privoxy这个经典软件，它刚好就是安装在/usr/local内，不需要关闭SIP也可以正常使用。</p><h3 id="1-privoxy安装"><a href="#1-privoxy安装" class="headerlink" title="1. privoxy安装"></a>1. privoxy安装</h3><p><code>brew install privoxy</code></p><h3 id="2-privoxy配置"><a href="#2-privoxy配置" class="headerlink" title="2. privoxy配置"></a>2. privoxy配置</h3><p><code>vim /usr/local/etc/privoxy/config</code><br>在文件末尾输入：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen-address <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8118</span></span><br><span class="line">forward-socks5 / localhost:<span class="number">1086</span> .</span><br></pre></td></tr></table></figure><p>第一行设置privoxy监听任意IP地址的8118端口(privoxy的默认端口)。第二行设置本地socks5代理客户端端口，注意不要忘了最后有一个空格和点号。<br><em>旧版 ShadowsocksX 创建的 「SOCKS5 代理」端口 默认是 1080，新版 ShadowsocksX-NG 创建的 「SOCKS5 代理」端口 默认改成 1086 升级后别忘了修改代理插件对应的端口。</em></p><h3 id="3-启动privoxy"><a href="#3-启动privoxy" class="headerlink" title="3. 启动privoxy"></a>3. 启动privoxy</h3><p>因为没有安装在系统目录内，所以启动的时候需要打全路径。<br><code>sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config</code></p><h3 id="4-测试shadowsocks"><a href="#4-测试shadowsocks" class="headerlink" title="4. 测试shadowsocks"></a>4. 测试shadowsocks</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">1086</span></span><br><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8118</span></span><br></pre></td></tr></table></figure><h3 id="5-privoxy使用"><a href="#5-privoxy使用" class="headerlink" title="5. privoxy使用"></a>5. privoxy使用</h3><p>在<code>~/.bashrc</code>或<code>~/zshrc</code>中加入以下开关函数，方便使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy_off</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unset</span> http_proxy</span><br><span class="line">    <span class="keyword">unset</span> https_proxy</span><br><span class="line">    <span class="keyword">echo</span> -e <span class="string">"已关闭代理"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy_on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    export no_proxy=<span class="string">"localhost,127.0.0.1,localaddress,.localdomain.com"</span></span><br><span class="line">    export http_proxy=<span class="string">"http://127.0.0.1:8118"</span></span><br><span class="line">    export https_proxy=$http_proxy</span><br><span class="line">    <span class="keyword">echo</span> -e <span class="string">"已开启代理"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>source ~/.bashrc</code>或<code>source ~/.zshrc</code>使配置立即生效。</p><h3 id="7-开启代理测试"><a href="#7-开启代理测试" class="headerlink" title="7. 开启代理测试"></a>7. 开启代理测试</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~  <span class="selector-tag">proxy_on</span></span><br><span class="line">已开启代理</span><br><span class="line">~  <span class="selector-tag">curl</span> <span class="selector-tag">ip</span><span class="selector-class">.cn</span></span><br><span class="line">当前 <span class="selector-tag">IP</span>：8<span class="selector-class">.8</span><span class="selector-class">.8</span><span class="selector-class">.8</span> 来自：美国</span><br></pre></td></tr></table></figure><h1 id="Linux下的安装"><a href="#Linux下的安装" class="headerlink" title="Linux下的安装"></a>Linux下的安装</h1><blockquote><p>环境：<br>CentOS 7.3.1611</p></blockquote><h3 id="1-安装shadowsocks、pip、privoxy"><a href="#1-安装shadowsocks、pip、privoxy" class="headerlink" title="1. 安装shadowsocks、pip、privoxy"></a>1. 安装shadowsocks、pip、privoxy</h3><p>请先确保你已经添加了EPEL源，<code>yum repolist</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum repolist</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading<span class="built_in"> mirror </span>speeds <span class="keyword">from</span> cached hostfile</span><br><span class="line"> * base: mirrors.nju.edu.cn</span><br><span class="line"> * elrepo: mirrors.ircam.fr</span><br><span class="line"> * epel: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * extras: mirrors.njupt.edu.cn</span><br><span class="line"> * updates: mirrors.njupt.edu.cn</span><br><span class="line">源标识           源名称                                                状态</span><br><span class="line">base/7/x86_64    CentOS-7 - Base                                        9,363</span><br><span class="line">elrepo           ELRepo.org<span class="built_in"> Community </span>Enterprise Linux Repository - el    194</span><br><span class="line">epel/x86_64      Extra Packages <span class="keyword">for</span> Enterprise Linux 7 - x86_64        11,873</span><br><span class="line">extras/7/x86_64  CentOS-7 - Extras                                        446</span><br><span class="line">updates/7/x86_64 CentOS-7 - Updates                                     2,089</span><br><span class="line">repolist: 23,965</span><br></pre></td></tr></table></figure><p>如果尚未添加，则使用<code>sudo yum -y install epel-release</code>添加EPEL。</p><p>使用以下命令安装shadowsocks、pip、privoxy：<br><code>$ sudo yum -y install python-pip privoxy</code><br><code>$ sudo pip install shadowsocks</code></p><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><h4 id="2-1-配置ss"><a href="#2-1-配置ss" class="headerlink" title="2.1 配置ss"></a>2.1 配置ss</h4><p><code>$ sudo mkdir -p /etc/shadowsocks</code><br><code>$ sudo vi /etc/shadowsocks/config.json</code><br>config.json配置内容为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"server"</span>:<span class="string">"bot02.rom.mk"</span>,（你的代理服务器<span class="built_in">IP</span>或域名地址）</span><br><span class="line"> <span class="string">"server_port"</span>:<span class="number">443</span>,（代理服务器上监听的端口号）</span><br><span class="line"> <span class="string">"local_port"</span>:<span class="number">1080</span>,（本地的监听端口号）</span><br><span class="line"> <span class="string">"password"</span>:<span class="string">"xxxx"</span>,（代理服务器的密码）</span><br><span class="line"> <span class="string">"timeout"</span>:<span class="number">600</span>,</span><br><span class="line"> <span class="string">"method"</span>:<span class="string">"aes-256-cfb（加密方式）"</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><em>若未配置local_port，则默认为1080</em></p><h4 id="2-2-启动ss"><a href="#2-2-启动ss" class="headerlink" title="2.2 启动ss"></a>2.2 启动ss</h4><p>后台运行shadowsocks：<br>启动：<code>sslocal -c /etc/shadowsocks/config.json -d start</code><br>停止：<code>sslocal -c /etc/shadowsocks/config.json -d stop</code></p><p>但这样每次重启系统的时候都需要执行启动命令来启动ss，我们可以通过以下方法设置开机自动启动：<br><code>vi /usr/lib/systemd/system/sslocal.service</code><br>内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">PermissionsStartOnly=true</span><br><span class="line">ExecStartPre=/bin/mkdir -p /run/shadowsocks</span><br><span class="line">ExecStartPre=/bin/chown nobody:nobody /run/shadowsocks</span><br><span class="line">ExecStart=/usr/bin/sslocal -c /etc/shadowsocks/config.json</span><br><span class="line">Restart=on-abort</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">UMask=0027</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>执行命令<code>systemctl start sslocal</code>启动ss，<br>执行命令<code>systemctl status sslocal</code>查看ss状态，如果是<code>active</code>，执行<code>systemctl enable sslocal</code>设置开机自启。<br>执行<code>reboot</code>重启系统，然后使用<code>systemctl status sslocal</code>查看启动情况，如有异常请根据日志提示解决。</p><p>这样我们就能很方便的通过系统命令<code>systemctl</code>来管理ss进程了。</p><h4 id="2-2-privoxy配置"><a href="#2-2-privoxy配置" class="headerlink" title="2.2 privoxy配置"></a>2.2 privoxy配置</h4><p><code>$ sudo vi /etc/privoxy/config</code><br>在文件末尾输入：<br><code>forward-socks5 / 127.0.0.1:1080 .</code></p><p>启动privoxy<br><code>$ sudo service privoxy restart</code></p><p>同样的，执行<code>systemctl enable privoxy</code>设置开机启动privoxy</p><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><p>参照Mac下的配置设置开关函数。<br>使用Telnet测试shadowsocks和privoxy是否正常<br><code>telnet 127.0.0.1 1080</code><br><code>telnet 127.0.0.1 8118</code><br>可以连接成功说明正常运行。</p><p>执行以下命令查看实际效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~  <span class="selector-tag">proxy_on</span></span><br><span class="line">已开启代理</span><br><span class="line">~  <span class="selector-tag">curl</span> <span class="selector-tag">ip</span><span class="selector-class">.cn</span></span><br><span class="line">当前 <span class="selector-tag">IP</span>：8<span class="selector-class">.8</span><span class="selector-class">.8</span><span class="selector-class">.8</span> 来自：美国</span><br><span class="line">~  <span class="selector-tag">proxy_off</span></span><br><span class="line">已开启代理</span><br><span class="line">~  <span class="selector-tag">curl</span> <span class="selector-tag">ip</span><span class="selector-class">.cn</span></span><br><span class="line">当前 <span class="selector-tag">IP</span>：121<span class="selector-class">.69</span><span class="selector-class">.50</span><span class="selector-class">.42</span> 来自：北京市 电信通</span><br></pre></td></tr></table></figure><h1 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h1><p>我们终端中的http和https请求通过开关函数转发到了privoxy的8118端口，然后被privoxy转换为socks5协议转发到shadowsocks的1080或1086端口，最后本地运行的shadowsocks客户端与远程shadowsocks服务器通信，从而实现命令下的代理功能。</p><hr><p>参考文章：</p><ol><li><a href="https://lvii.gitbooks.io/outman/content/ss.mac.html" target="_blank" rel="noopener">shadowsocks on Mac OS X</a></li><li><a href="http://www.cashqian.net/blog/001486989831982332565298e4942a2bb8f56b08f9d2475000" target="_blank" rel="noopener">Mac命令行终端下使用shadowsocks翻墙</a></li><li><a href="http://ian.wang/196.htm" target="_blank" rel="noopener">Shadowsocks+Privoxy打造Linux / Mac socks和http代理</a></li><li><a href="https://juejin.im/entry/58d29f6161ff4b006cb218d9" target="_blank" rel="noopener">使用 shadowsocks 加速 Mac 自带终端或 iTerm 2</a></li><li><a href="http://www.iosugar.com/2017/02/19/Mac-terminal-environment/" target="_blank" rel="noopener">Mac终端环境走代理</a></li><li><a href="http://www.guanxigo.com/cross-gfw-in-linux-terminal" target="_blank" rel="noopener">Linux终端下翻墙教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 终端 </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL知识点总结</title>
      <link href="/post/mysql-notes/"/>
      <url>/post/mysql-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cmfudal9j30p00b4gmd.jpg" alt=""></p><a id="more"></a><h2 id="一、-数据类型"><a href="#一、-数据类型" class="headerlink" title="一、 数据类型"></a>一、 数据类型</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga7n2rzixaj315m0mgwi6.jpg" alt=""></p><h3 id="1-1-选择优化的数据类型"><a href="#1-1-选择优化的数据类型" class="headerlink" title="1.1 选择优化的数据类型"></a>1.1 选择优化的数据类型</h3><ol><li>更小的通常最好：更小的数据占用更少的系统资源</li><li>使用内建的类型来存储合适的内容，如使用DATETIME或TIMESTAMP存储时间，而不是VARCHAR</li><li>尽量避免使用null，因为这会降低性能</li><li>TIMESTAMP只使用DATETIME的一半空间，并且会根据时区来自动更新，当TIMESTAMP设置默认值为CURRENT_TIMESTAMP和NOW()时，TIMESTAMP的值并不会随着更改某一字段而自动更改。</li></ol><h3 id="1-2-数据类型需要注意的"><a href="#1-2-数据类型需要注意的" class="headerlink" title="1.2 数据类型需要注意的"></a>1.2 数据类型需要注意的</h3><h4 id="1-2-1-数值型"><a href="#1-2-1-数值型" class="headerlink" title="1.2.1 数值型"></a>1.2.1 数值型</h4><ul><li>INT(11)其实并没有什么意义，它并不会限制数值的合法范围。</li><li><strong>DECIMAL类型主要用于存储精确的小数类型（如金额）</strong>，因为需要额外的空间和计算开销，因此只在对小数进行精确计算时才使用DECIMAL。</li><li>浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。</li></ul><h4 id="1-2-2-字符串型"><a href="#1-2-2-字符串型" class="headerlink" title="1.2.2 字符串型"></a>1.2.2 字符串型</h4><ul><li>VARCHAR使用更少的存储空间，但索引速度低于CHAR，VARCHAR需要额外的信息来保存长度信息。</li><li>使用VARCHAR(5)和VARCHAR(20)来存储’hello’的空间开销是一样的，但VARCHAR(20)会消耗更长的列，因此我们只分配真正需要的空间。</li><li><strong>使用枚举(ENUM)和SET代替字符串类型，在MySQL内部使用整数存储ENUM和SET类型，然后在做比较时转换为字符串</strong>。</li></ul><h4 id="1-2-3-日期时间型"><a href="#1-2-3-日期时间型" class="headerlink" title="1.2.3 日期时间型"></a>1.2.3 日期时间型</h4><ul><li>MySQL能存储的最小时间粒度为秒。</li><li><code>DATETIME([fsp])``TIMESTAMP[(fsp)]``TIME[(fsp)]</code>可设定一个0~6位的微秒时间。</li><li>DATETIME能保存大范围的值，精度为秒，可保存1001~9999年。该类型存储与时区无关，使用8个字节的存储空间。</li><li>TIMESTAMP只使用4个字节的存储空间，因此只能保存1970~2038年，MySQL中也提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数将日期转换为Unix时间戳。</li><li>MySQL 4.1及以上版本按照DATETIME的方式格式化显示TIMESTAMP的值，这只是显示上的区别，与4.1前的版本在存储上并没有区别。</li><li>TIMESTAMP默认为NOT NULL</li></ul><h4 id="1-2-4-位数据型"><a href="#1-2-4-位数据型" class="headerlink" title="1.2.4 位数据型"></a>1.2.4 位数据型</h4><p>从MySQL 5.0开始，新增BIT数据类型，该类型可用于存储一个或多个true/false值，BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位……BIT列的最大长度是64个位。但BIT类型应该谨慎使用，对于大部分应用，最好避免使用这种类型。</p><p>在数据表中，一旦选定了字段类型，就要确保在所有关联表中都使用同样的数据类型。</p><h3 id="1-3-数据表设计需注意的"><a href="#1-3-数据表设计需注意的" class="headerlink" title="1.3 数据表设计需注意的"></a>1.3 数据表设计需注意的</h3><ol><li>太多的列。过多的列（如数千个）会导致性能下降。</li><li>太多的关联。MySQL限制了每个关联操作最多只能有61张表。一个粗略的经验法则，如果希望查询执行得到快速且并发性好，单个查询最好在12个表以内做关联。</li><li>防止过度使用枚举（ENUM）。如：country enum(‘’,’0’,’1’,’2’,…,’31’)</li><li><strong>尽量避免使用null</strong>，建议尽可能使用替代方案。即使需要存储一个事实上的‘空值’时，可以使用0，空字符串或其他特殊值来代替。但也不要走极端，当确实需要表示未知值时，使用null也比使用奇怪的值好，比如使用全0作日期时间会导致很多问题，可以配置MySQL的SQL_MODE来禁止不可能的日期。</li></ol><h2 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h2><h3 id="2-1-基础命令"><a href="#2-1-基础命令" class="headerlink" title="2.1 基础命令"></a>2.1 基础命令</h3><ol><li>查询数据：<code>SELECT [DISTINCT] 字段 [AS 别名] FROM 表名 [JOIN 表名2 ON 条件] [WHERE 条件(LIKE|AND|OR|BETWEEN|IN|NOT IN|EXISTS|NOT EXISTS)] [GROUP BY 字段 [HAVING 条件]] [ORDER BY 字段 [DESC]] [LIMIT [OFFSET,]条数]；</code>（<strong>注意使用<code>GROUP BY</code>时所有的<code>SELECT</code>的字段都要列出</strong>）</li></ol><ul><li>在处理SQL语句时，所有的空格都会被忽略，因此SQL语句可以换行以增强易读性。</li><li>一般而言，除非你确实需要表中的每一列，否则最好别使用<code>*</code>通配符。虽然使用通配符能让你省事，但检索不需要的列会降低检索和应用程序的性能。</li><li><code>DESC</code>关键字只应用到直接位于其前面的列名。如果想在多个列上进行降序排序，必须对每一列指定<code>DESC</code>关键字。</li><li>确定值是否为<code>NULL</code>时，不能简单的检查是否= NULL，应该使用<code>IS NULL</code>。注意<code>NULL</code>与<code>&#39;&#39;</code>不同，<code>NULL</code>表示空值，而<code>&#39;&#39;</code>是一个值。</li><li><code>IN</code>操作符完成了与<code>OR</code>相同的功能。<code>IN</code>操作符的语法更清晰、直观。<code>IN</code>操作符一般比一组<code>OR</code>操作符执行的更快。</li><li>别名可以是一个单词或多个单词，多个单词时要在引号中，但别名最好用一个单词。<strong>表别名也可以实现自身的联表查询</strong>。</li><li>单条查询条件用<code>WHERE</code>，分组查询条件用<code>HAVING</code>，联表查询条件用<code>ON</code>。</li><li>联表查询时，联结的表越多，性能下降也越多。</li><li>组合查询（UNION）从查询结果集中自动去除了重复的行，使用<code>UNION ALL</code>，DBMS不取消重复的行。</li><li><code>UNION</code>几乎总是完成与多个<code>WHERE</code>条件相同的工作。<code>UNION ALL</code>为<code>UNION</code>的一种形式，它完成<code>WHERE</code>子句完成不了的工作。如果确实需要每个条件的匹配行全部出现（包括重复行），就必须使用<code>UNION ALL</code>，而不是<code>WHERE</code>。</li><li>在某些SQL中，<code>INSERT INTO</code>中的<code>INTO</code>是可选的，但为了保证SQL的移植性，最好不要省略该关键字。</li><li>MySQL中可以进行算数运算，如常见的加、减、乘、除。</li><li><strong>在数据表中，ID字段最好是自动生成的，以确保唯一、准确。</strong></li><li>无论是在编写SQL还是普通代码时，应该多加注释，注释并不会影响性能，但能让自己和别人更容易理解和更安全的修改代码。</li><li><code>EXISTS|NOT EXISTS (从句)</code>条件返回的是布尔值</li></ul><ol start="2"><li>插入数据：<code>INSERT|REPLACE [IGNORE] INTO 表名(字段1，字段2) VALUES(值1，值2),(值1，值2) [ON DUPLICATE KEY UPDATE 字段=值];</code></li></ol><ul><li>如果某个字段是主键索引或唯一索引，普通的插入语句是会报错的，而使用关键词<code>IGNORE</code>则会警告，但不会影响正常的执行，重复数据仍然没有插入</li></ul><ol start="3"><li>更新数据：<code>UPDATE 表名 SET 字段1=值1，字段2=值2 WHERE 条件;</code></li></ol><ul><li><strong><em>在<code>UPDATE</code>或<code>DELETE</code>语句使用<code>WHERE</code>子句前，应该先用<code>SELECT</code>进行测试，保证它过滤的是正确的记录，以防编写的<code>WHERE</code>子句不正确。</em></strong></li><li>如果DBMS支持禁止无<code>WHERE</code>的<code>UPDATE</code>和<code>DELETE</code>的执行，那最好启用它。</li></ul><ol start="4"><li>删除数据：<code>DELETE FROM 表名 WHERE 条件;</code></li></ol><ul><li><code>DELETE</code>删除的是行，要删除列，使用<code>UPDATE</code>语句。</li><li>如果想从表中删除所有行，可以使用<code>TRUNCATE TABLE</code>语句来代替<code>DELETE</code>，它完成了相同的工作，但速度更快（因为不记录数据的变动）。</li></ul><h3 id="2-2-数据库"><a href="#2-2-数据库" class="headerlink" title="2.2 数据库"></a>2.2 数据库</h3><ol start="5"><li>创建数据库：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名;</code></li><li>删除数据库：<code>DROP DATABASE [IF EXISTS] 数据库名;</code></li><li>查看建库语句：<code>SHOW CREATE DATABASE 数据库名;</code></li><li>选择数据库：<code>USE 数据库名;</code></li><li>查看数据库：<code>SHOW DATABASES;</code></li><li>查看数据库信息：<code>STATUS;</code></li><li>设置命令行字符集：<code>SET NAMES UTF8;</code></li><li>查看数据表的最后修改时间：<code>select TABLE_NAME,UPDATE_TIME from INFORMATION_SCHEMA.tables where TABLE_SCHEMA=&#39;数据库名&#39;;</code></li></ol><h3 id="2-3-数据表"><a href="#2-3-数据表" class="headerlink" title="2.3 数据表"></a>2.3 数据表</h3><ol start="13"><li>创建数据表：<code>CREATE TABLE [IF NOT EXISTS] 数据表名();</code></li></ol><ul><li><strong>为每一列设置默认值，使用<code>DEFAULT</code>而不是<code>NULL</code>。</strong><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">COMMENT</span>=<span class="string">'用户表'</span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li>查看建表语句：<code>SHOW CREATE TABLE 数据表名;</code></li><li>查看数据表：<code>SHOW TABLES;</code></li><li>查看当前数据库下数据表的自增ID值：<code>SHOW TABLE STATUS;</code></li><li>查看表结构：<code>DESC 表名;</code>或<code>SHOW COLUMNS FROM 表名;</code></li><li>删除数据表：<code>DROP TABLE [IF EXISTS] 数据表名;</code></li></ol><p>-<strong>使用关系规则防止意外删除。</strong>许多DBMS允许强制实施有关规则，防止删除与其他表相关联的表。在实施这些规则时，如果对某个表发布一条<code>DROP TABLE</code>语句，且该表是某个关系的组成部分，则DBMS将阻止这条语句执行，直到该关系被删除为止。</p><ol start="19"><li>修改表名：<code>RENAME TABLE 旧表名 TO 新表名;</code><br>####2.3.1 复制表结构和数据</li><li><strong>复制表结构：<code>CREATE TABLE 新表名 LIKE 原表名;</code></strong>(与原表结构相同，建表语句相同)</li><li><strong>复制表结构及数据到新表：<code>CREATE TABLE 表名 SELECT * FROM 表名;</code></strong>（注意该方式与原表的结构会有差异，建表语句不同，如自增会消失）</li><li>复制数据到另一张表（结构相同）：<code>INSERT INTO 表名 SELECT * FROM 表名;</code></li><li>复制数据到另一张表（结构不同）：<code>INSERT INTO 表名(字段1，字段2) SELECT 字段1，字段2 FROM 表名;</code></li><li>查看字段编码：<code>SHOW FULL COLUMNS FROM 表名;</code></li></ol><h3 id="2-4-其它"><a href="#2-4-其它" class="headerlink" title="2.4 其它"></a>2.4 其它</h3><h4 id="2-4-1-视图"><a href="#2-4-1-视图" class="headerlink" title="2.4.1 视图"></a>2.4.1 视图</h4><ol start="25"><li>创建视图：<code>CREATE VIEW 视图名 AS SELECT ...;</code></li></ol><ul><li>视图是一张虚拟的表。</li></ul><ol start="26"><li>删除视图：<code>DROP VIEW 视图名;</code></li></ol><h4 id="2-4-2-存储过程"><a href="#2-4-2-存储过程" class="headerlink" title="2.4.2 存储过程"></a>2.4.2 存储过程</h4><ol start="27"><li>创建存储过程：<code>CREATE PROCEDURE 存储过程名();</code></li><li>创建函数：<code>CREATE FUNCTION 函数名();</code></li></ol><h4 id="2-4-3-触发器"><a href="#2-4-3-触发器" class="headerlink" title="2.4.3 触发器"></a>2.4.3 触发器</h4><ol start="29"><li>查看触发器：<code>SHOW TRIGGERS;</code></li><li>删除触发器：<code>DROP TRIGGER 触发器名</code></li></ol><h4 id="2-4-4-事务"><a href="#2-4-4-事务" class="headerlink" title="2.4.4 事务"></a>2.4.4 事务</h4><ol start="31"><li>查看事务开关状态：<code>SHOW VARIABLES LIKE &#39;autocommit&#39;;</code></li><li>打开/关闭事务的自动提交：<code>SET AUTOCOMMIT = 0|1;</code></li><li>创建临时表：<code>CREATE TEMPORARY TABLE 表名();</code>（临时表仅在当前连接有效，当关闭连接时，MySQL会自动删除表。临时表无法用<code>SHOW TABLES</code>命令查看）</li></ol><h4 id="2-4-5-系统信息"><a href="#2-4-5-系统信息" class="headerlink" title="2.4.5 系统信息"></a>2.4.5 系统信息</h4><ol start="34"><li>查看当前用户名：<code>SELECT USER();</code></li><li>查看当前数据库：<code>SELECT DATABASE();</code></li><li>查看MySQL版本：<code>SELECT VERSION();</code></li></ol><h3 id="2-5-ALTER"><a href="#2-5-ALTER" class="headerlink" title="2.5 ALTER"></a>2.5 ALTER</h3><p>ALTER操作有<code>ALTER TABLE</code>，<code>ALTER DATABASE</code>，<code>ALTER EVENT</code>，<code>ALTER PROCEDURE</code>，<code>ALTER VIEW</code>等命令</p><h4 id="2-5-1-表的操作"><a href="#2-5-1-表的操作" class="headerlink" title="2.5.1 表的操作"></a>2.5.1 表的操作</h4><p><em>使用<code>ALTER TABLE</code>要极为小心，应该在进行改动前做完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，也许无法删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</em></p><ol><li><strong>增加字段：<code>ALTER TABLE 表名 ADD [COLUMN] 字段名 字段类型 [FIRST|AFTER 字段名];</code></strong></li><li><strong>修改字段名及类型：<code>ALTER TABLE 表名 CHANGE [COLUMN] 旧字段名 新字段名 字段类型;</code></strong></li><li>修改字段类型：<code>ALTER TABLE 表名 MODIFY 字段名 类型 [NOT NULL];</code></li><li><strong>删除字段：<code>ALTER TABLE 表名 DROP [COLUMN] 字段名;</code></strong></li><li><strong>添加普通/唯一索引：<code>ALTER TABLE 表名 ADD INDEX/UNIQUE 索引名(字段1[,字段2]);</code></strong></li></ol><ul><li>请注意：对多个字段同时添加普通索引时，只对这些字段都进行检索时索引才会生效，仅对其中任何一个检索都不会有预期的效果。</li></ul><ol><li>创建短索引：<code>CREATE INDEX 索引名 ON 表名(字段(长度));</code> 或<code>KEY 索引名 (字段(长度))</code> 对于<code>CHAR</code>和<code>VARCHAR</code>列，只用它的一部分来创建索引，既可以节省索引空间，又可以加快索引速度。</li><li>添加主键：<code>ALTER TABLE 表名 ADD PRIMARY KEY (字段名);</code></li></ol><ul><li>MySQL中不允许有多个主键</li><li>主键的特点：非空且唯一，按需添加自增</li><li>主键的名字就是PRIMARY</li></ul><ol start="7"><li>设置主键的自增起始值：<code>ALTER TABLE 表名 AUTO_INCREMENT = 100;</code></li><li>添加外键：<code>ALTER TABLE 表名 ADD [CONSTRAINT [约束名]] FOREIGN KEY (字段1[,字段2]) REFERENCES 表名(字段1[,字段2]) [ON DELETE|UPDATE CASCADE|RESTRICT];</code></li></ol><ul><li><code>CASCADE</code>（级联）：如果删除父表中的数据，则子表中的相应数据也一同被删除或更新</li><li><code>RESTRICT</code>（限制）：如果父表对应的子表中有相关的数据，则不允许删除或更新父表中的数据</li><li>外键约束用于子表中，而且父表与子表必须使用相同的存储引擎</li><li>当一张表中有多个外键时，可以使用约束名来进行区分，如果约束名省略，则由系统自动生成</li><li>创建外键约束的条件：<pre><code>-  两张表都必须是InnoDB引擎（MyISAM不支持外键），且它们没有临时表- 外键关联的字段必须有相似的数据类型- 外键关联的字段必须建立了索引</code></pre></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/create-table-foreign-keys.html" target="_blank" rel="noopener">外键的官方文档</a></li></ul><ol start="8"><li>删除普通/唯一索引：<code>DROP INDEX 索引名 ON 表名;</code>或<code>ALTER TABLE 表名 DROP INDEX 字段名;</code></li><li>删除主键：<code>ALTER TABLE 表名 DROP PRIMARY KEY;</code></li><li>删除外键：<code>ALTER TABLE 表名 DROP FOREIGN KEY 约束名;</code></li><li>修改表名：<code>ALTER TABLE 旧表名 RENAME TO 新表名;</code></li><li>修改字段默认值：<code>ALTER TABLE 表名 ALTER 字段名 SET DEFAULT 默认值;</code></li><li>删除字段的默认值：<code>ALTER TABLE 表名 ALTER 字段名 DROP DEFAULT;</code></li><li>修改表的字符集：<code>ALTER TABLE 表名 DEFAULT CHARSET UTF8;</code></li></ol><h4 id="2-5-2-库的操作"><a href="#2-5-2-库的操作" class="headerlink" title="2.5.2 库的操作"></a>2.5.2 库的操作</h4><ul><li>修改库的字符集：<code>ALTER TABLE 库名 DEFAULT CHARSET UTF8;</code></li></ul><h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><h3 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h3><ul><li>拼接输出的内容：<code>CONCAT(字段1，字段2，……)</code></li><li>从左开始截取字符串：<code>LEFT(str, length)</code></li><li>从右开始截取字符串：<code>RIGHT(str, length)</code></li><li>截取字符串：<code>SUBSTRING(str, pos [,length] )</code>（可截取中文）</li><li>字符串长度：<code>LENGTH()</code>（包含中文时返回字符集下中文所占长度）</li><li>返回字符个数：<code>CHAR_LENGTH()</code></li><li>去除字符串左右的空格：<code>TRIM()</code></li><li>转小写：<code>LOWER()</code></li><li>转大写：<code>UPPER()</code></li><li>字符串比较：<code>STRCMP(字段1，字段2)</code>（字段1&lt;字段2返回-1，否则返回1，相等返回0）</li><li><code>SOUNDEX()</code>是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对字符串进行发音比较而不是字母比较。</li><li>加密函数：<code>PASSWORD(&#39;加密内容&#39;)</code></li><li>MD5加密函数：<code>MD5(&#39;加密内容&#39;)</code></li></ul><h3 id="3-2-数值函数"><a href="#3-2-数值函数" class="headerlink" title="3.2 数值函数"></a>3.2 数值函数</h3><ul><li>数据类型转换：<code>CONVERT(&#39;转换内容&#39;，目标类型)</code></li><li>取余数：<code>MOD(x,y)</code></li><li>四舍五入：<code>TRUNCATE(x,y)</code></li><li>进制转换：<code>CONV(&#39;数值&#39;，进制，目标进制)</code></li><li>格式化结果：<code>FORMAT(数值，保留小数位数)</code></li><li>IP地址转数值：<code>INET_ATON(&#39;IP地址&#39;)</code>（Address TO Number）</li><li>数值转IP地址：<code>INET_NTOA(数值)</code>(Number TO Address)<ul><li>mysql用无符号整型存储IPv4</li></ul></li></ul><h3 id="3-3-日期时间函数"><a href="#3-3-日期时间函数" class="headerlink" title="3.3 日期时间函数"></a>3.3 日期时间函数</h3><ul><li>获取当前日期时间：<code>NOW()</code></li><li>获取当前日期：<code>CURDATE()</code></li><li>获取UTC日期：<code>UTC_DATE()</code></li><li>获取UTC时间：<code>UTC_TIME()</code></li><li>获取季度：<code>QUARTER(&#39;17-05-07&#39;)</code></li><li>获取分钟：<code>MINUTE(&#39;10:23:21&#39;)</code></li><li>获取秒数：<code>SECOND(&#39;10:23:21&#39;)</code></li></ul><h3 id="3-4-条件判断函数"><a href="#3-4-条件判断函数" class="headerlink" title="3.4 条件判断函数"></a>3.4 条件判断函数</h3><ul><li><code>IF(表达式，值1，值2)</code>类似于三元运算，如果表达式结果为真取值1，否则取值2</li><li><code>IFNULL(值1，值2)</code>优先返回非null的值，如<code>IFNULL(8,NULL)</code>和<code>IFNULL(NULL,8)</code>和<code>IFNULL(8,7)</code>都返回8</li></ul><h2 id="四、-MySQL权限"><a href="#四、-MySQL权限" class="headerlink" title="四、 MySQL权限"></a>四、 MySQL权限</h2><h3 id="4-1-MySQL权限经验原则："><a href="#4-1-MySQL权限经验原则：" class="headerlink" title="4.1 MySQL权限经验原则："></a>4.1 MySQL权限经验原则：</h3><ol><li>只授予满足需求的最小权限；</li><li>限制登录IP；</li><li>为每个用户设置高强度的密码；</li><li>定期清理不需要的用户，回收权限或者删除用户。</li></ol><h3 id="4-2-常用权限命令"><a href="#4-2-常用权限命令" class="headerlink" title="4.2 常用权限命令"></a>4.2 常用权限命令</h3><ul><li>创建用户：<code>CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</code>host可为IP地址段或域名或%，%表示不限制登录IP</li><li>创建并给用户授权：<br><code>mysql&gt; GRANT all|select,insert,update,delete ON dbname.tbname TO &#39;user&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION;</code><ul><li>例子：<br><code>mysql&gt; GRANT all ON *.* TO Jack@&#39;localhost&#39; IDENTIFIED BY &quot;p@55w0rd&quot; WITH GRANT OPTION;Query OK, 0 rows affected (0.01 sec)</code><br>该命令表示：为本地登录的用户Jack赋予所有数据库与所有数据表的所有权限，并且将登录密码设置为‘p@55w0rd’，而且允许该用户将自己拥有的授予其他用户。</li></ul></li><li>刷新权限：<code>mysql&gt; FLUSH PRIVILEGES;</code></li><li>查看权限：<code>mysql&gt; SHOW GRANTS [FOR &#39;jack&#39;@&#39;%&#39;];</code></li><li>撤销权限：<code>mysql&gt; REVOKE delete ON *.* FROM &#39;jack&#39;@&#39;loaclhost&#39;;</code></li><li>删除用户：<code>mysql&gt; DROP USER &#39;jack&#39;@&#39;localhost&#39;;</code></li><li>账户重命名：<code>mysql&gt; RENAME USER &#39;jack&#39;@&#39;%&#39; TO &#39;rose&#39;@&#39;%&#39;;</code></li><li>修改自己密码：<code>mysql&gt; SET PASSWORD=&#39;密码&#39;;</code></li><li>修改其他用户密码：<code>mysql&gt; SET PASSWORD FOR &#39;jack&#39;@&#39;localhost&#39;=PASSWORD(&#39;123456&#39;);</code></li><li>注：在MySQL 5.7及以上版本，mysql.user的密码字段由<code>password</code>更换为了<code>authentication_string</code><br><img src="http://ohx73ws1b.bkt.clouddn.com/mysql%20privilege.png" alt="Alt text"></li></ul><p><img src="http://ohx73ws1b.bkt.clouddn.com/mysql%20perm.png" alt="Alt text"></p><h2 id="五、存储过程"><a href="#五、存储过程" class="headerlink" title="五、存储过程"></a>五、存储过程</h2><ul><li>查看所有存储过程：<code>select name from mysql.proc;</code>或<code>select routine_name from information_schema.routines;</code></li><li>查看某个数据库下的存储过程：<code>select name from mysql.proc where db=&#39;数据库名&#39;;</code>或<code>select routine_name from information_schema.routines where routine_schema=&#39;数据库名&#39;;</code></li><li>查看存储过程的详细内容：<code>SHOW CREATE PROCEDURE 数据库.存储过程名;</code></li><li>修改存储过程：<code>ALTER PROCEDURE 名称 [特性……]</code><ul><li>MySQL的存储过程只能修改其特性，不能修改过程体，若要修改过程体，只能删除后重新创建。</li></ul></li><li>删除存储过程：<code>DROP PROCEDURE [数据库.]存储过程名</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置读取test表中的数据的存储过程</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> sxy;</span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sxy(<span class="keyword">IN</span> <span class="keyword">var</span> <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`id`</span> = <span class="keyword">var</span>;</span><br><span class="line"><span class="keyword">END</span>//</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">CALL</span> sxy(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="六、触发器"><a href="#六、触发器" class="headerlink" title="六、触发器"></a>六、触发器</h2><p>触发器经常用于加强数据的完整性约束和业务规则等。<br>一般来说，约束的处理速度比触发器快，因此应该尽量使用约束。<br>在MySQL中，创建触发器的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称 触发时机(<span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span>) 触发事件(<span class="keyword">INSERT</span>|<span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span>)  </span><br><span class="line">  <span class="keyword">ON</span> 表名 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">  <span class="keyword">BEGIN</span></span><br><span class="line">    触发器程序体(<span class="keyword">SQL</span>语句)</span><br><span class="line">  <span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>由此可见，可以建立6种触发器，即：BEFORE INSERT、BEFORE UPDATE、BEFORE DELETE、AFTER INSERT、AFTER UPDATE、AFTER DELETE。</p><p>另外有一个限制是不能同时在一个表上建立2个相同类型的触发器，因此在一个表上最多建立6个触发器。<br>查看触发器</p><ol><li><p>通过show语句查看触发器<br><code>SHOW TRIGGERS;</code></p></li><li><p>通过系统表查看触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> information_shcema;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tirggers;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">triggers</span> <span class="keyword">where</span> TRIGGER_NAME = <span class="string">'触发器名称'</span>;</span><br></pre></td></tr></table></figure></li></ol><p>触发器中的<code>new</code>和<code>old</code></p><ol><li>针对<code>update</code>操作，<code>new</code>表示的是更新后的值，<code>old</code>表示的是更新前的数据。</li><li>针对<code>insert</code>操作，<code>new</code>表示的是新增的值。</li><li>针对<code>delete</code>操作，<code>old</code>表示的是被删除的值。</li></ol><p>示例1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入触发器</span></span><br><span class="line">mysql&gt; delimiter $$</span><br><span class="line">mysql&gt; create trigger tab1_after_insert after insert</span><br><span class="line">    -&gt; on tab1 for each row</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;   insert into tab2(tab2_id) values(new.tab1_id);</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; $$</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line">mysql&gt; delimiter $$</span><br><span class="line">mysql&gt; create trigger tab1_delete_after after delete</span><br><span class="line">    -&gt; on tab1 for each rows</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;   delete from tab2 where tab2_id = old.tab1_id;</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; $$</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新学生表的同时也更新记录表</span></span><br><span class="line">delimiter $$</span><br><span class="line">mysql&gt; create trigger student1_update_after after update</span><br><span class="line">    -&gt; on student1 for each row</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;  if new.student_id != old.student_id then</span><br><span class="line">    -&gt;   update update_student1 set student_id = new.student_id, update_date = now()</span><br><span class="line">    -&gt;   where student_id = old.student_id;</span><br><span class="line">    -&gt;  end if;</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; $$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>示例4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除学生表的时候也删除记录表</span></span><br><span class="line">mysql&gt; delimiter $$</span><br><span class="line">mysql&gt; create trigger student1_delete_before before delete</span><br><span class="line">    -&gt; on student1 for each row</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;  delete from update_student1</span><br><span class="line">    -&gt;  where student_id = old.student_id;</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; $$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="七、事务"><a href="#七、事务" class="headerlink" title="七、事务"></a>七、事务</h2><p>事务控制语句：</p><ul><li>BEGIN或START TRANSACTION；显示地开启一个事务；</li><li>COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的；</li><li>ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li><li>SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；</li><li>RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li><li>ROLLBACK TO identifier；把事务回滚到标记点；</li><li>SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BEGIIN;<span class="comment">-- 开启事务</span></span><br><span class="line">SQL语句1;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> sql1;</span><br><span class="line">IF(SQL语句1执行失败)</span><br><span class="line">  <span class="keyword">ROLLBACK</span>;<span class="comment">-- 撤销所有执行</span></span><br><span class="line">SQL语句2;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> sql2;</span><br><span class="line">IF(SQL语句2执行失败)</span><br><span class="line">  <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> sql1;<span class="comment">-- 撤销部分执行</span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> sql1;<span class="comment">-- 删除保存点</span></span><br><span class="line"><span class="keyword">BEGIN</span>;<span class="comment">-- 嵌套事务</span></span><br><span class="line">SQL语句3;</span><br><span class="line">IF(SQL语句3执行失败)</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> sql2;</span><br><span class="line"><span class="keyword">COMMIT</span>;  </span><br><span class="line"><span class="keyword">COMMIT</span>;<span class="comment">-- 提交事务</span></span><br></pre></td></tr></table></figure>参考文章：<a href="http://www.jellythink.com/archives/952" target="_blank" rel="noopener">说说MySQL中的事务</a></li></ul><h2 id="八、-MySQL中的日志"><a href="#八、-MySQL中的日志" class="headerlink" title="八、 MySQL中的日志"></a>八、 MySQL中的日志</h2><p>共4种：</p><ol><li>错误日志：记录mysql服务的启动、运行、停止时出现的问题</li><li>查询日志（通用日志）：记录用户的所有操作</li><li>二进制日志：记录所有更改数据的语句，可以用于数据复制</li><li>慢查询日志：记录所有执行时间超过long_query_time的所有查询。官方的慢查询阈值只能设置大于1秒的，使用microslow-patch可以查询毫秒级的。</li></ol><p>除了错误日志默认开启外，其他日志都是默认关闭的。但日志既会影响mysql的性能，又会占用大量磁盘空间。因此，如果不必要，应尽可能少地开启日志。根据不同的使用环境，考虑开启不同的日志。例如开发环境中优化查询效率低的语句，可以开启慢查询日志，或者生产环境中发现某些SQL执行特别慢也可以开启。如果磁盘空间不是特充足可以在高峰期间开启，在捕获到查询慢的SQL之后再关闭慢查询日志。如果需要搭建复制环境，那么就一定要开启二进制日志，如果数据特别重要也建议开启二进制日志，以便数据库损坏的时候也可以通过二进制日志挽救一部分数据。通用日志无论在哪种情况下，一般不建议开启 。</p><p>常用命令</p><ul><li>查看日志信息：<code>show variables like &#39;%log_%&#39;;</code></li><li>查看错误日志的存储位置：<code>show variables LIKE &#39;log_error&#39;;</code></li><li>删除错误日志：<code>flush logs;</code><ul><li>MySQL 5.5.7版本前，<code>flush logs</code>可以将错误日志文件重命名为<code>filename.err_old</code>，并创建新的日志文件。但是从MySQL 5.5.7开始，<code>flush logs</code>只是重新打开日志文件，并不做日志备份和创建的操作。如果日志文件不存在，mysql启动或者执行flush logs时会创建新的日志文件</li></ul></li></ul><p>Mac使用HomeBrew安装的MySQL是没有my.cnf文件的，需要自己手动创建，具体信息请查看另一个笔记：<a href="https://app.yinxiang.com/shard/s27/nl/1310329143/2918975e-22e9-4749-a19c-38d792fdf8d5/" target="_blank" rel="noopener">在 Mac 下用 Homebrew 安装 MySQL配置文件my.cnf问题</a></p><h2 id="九、PHP连接MySQL的方式"><a href="#九、PHP连接MySQL的方式" class="headerlink" title="九、PHP连接MySQL的方式"></a>九、PHP连接MySQL的方式</h2><p>当考虑连接到MySQL数据库服务器的时候，有三种主要的API可供选择：</p><ul><li>PHP的MySQL扩展</li><li>PHP的MySQLi扩展</li><li>PHP数据对象（PDO）</li></ul><p>三者各有优缺点：</p><ol><li><p>mysql扩展提供了一个面向过程 的接口，并且是针对MySQL4.1.3或更早版本设计的。因此，这个扩展虽然可以与MySQL4.1.3或更新的数据库服务端 进行交互，但并不支持后期MySQL服务端提供的一些特性。</p></li><li><p>MySQLi扩展可以用于使用 MySQL4.1.3或更新版本中新的高级特性。其主要优势有：</p><ul><li>面向对象接口</li><li>prepared语句支持</li><li>多语句执行支持</li><li>事务支持</li><li>增强的调试能力</li><li>嵌入式服务支持</li></ul></li><li><p>PDO提供了一个统一的API接口可以使得你的PHP应用不去关心具体要 连接的数据库服务器系统类型。也就是说，如果你使用PDO的API，可以在任何需要的时候无缝切换数据库服务器，比如从Firebird 到MySQL，仅仅需要修改很少的PHP代码。<br>PDO的优点在于，它是一个干净的，简单的，可移植的API，<strong>它最主要的缺点是会限制让你不能使用 后期MySQL服务端提供所有的数据库高级特性</strong>。比如，PDO不允许使用MySQL支持的多语句执行。</p></li></ol><h2 id="十、SQL注入"><a href="#十、SQL注入" class="headerlink" title="十、SQL注入"></a>十、SQL注入</h2><p><strong>永远不要信任外界输入的数据</strong>，<strong><em>特别是来自于客户端的</em></strong>，包括选择框、表单隐藏域和 cookie。</p><ul><li>永远不要使用超级用户或所有者帐号去连接数据库。要用权限被严格限制的帐号。</li><li>检查输入的数据是否具有所期望的数据格式。</li><li>使用数据库特定的敏感字符转义函数（比如 mysql_escape_string() 和 sql_escape_string()）把用户提交上来的非数字数据进行转义。如果数据库没有专门的敏感字符转义功能的话 addslashes() 和 str_replace() 可以代替完成这个工作。</li><li>尽量避免显示有关数据库的任何信息，尤其是数据库结构。</li><li>可以选择使用数据库的存储过程和预定义指针等特性来抽象数库访问，使用户不能直接访问数据表和视图。但这个办法又有别的影响。</li></ul><p>mysqli没有提供一个特殊的方法用于打开持久化连接。需要打开一个持久化连接时，你必须在 连接时在主机名前增加<code>p:</code>。</p><p>数据的导出及导入：<br>Linux下操作：<br>导出：<code>mysqldump -h -u -p 数据库名1 [数据库名2]&gt;本地地址</code><br>导入：<code>mysql -h -u -p 数据库名&lt;本地地址</code></p><h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><h3 id="11-1-避免重复插入记录"><a href="#11-1-避免重复插入记录" class="headerlink" title="11.1 避免重复插入记录"></a>11.1 避免重复插入记录</h3><p>1、使用<code>IGNORE</code>关键字。对于<code>PRIMARY KEY</code>或<code>UNIQUE</code>的字段来说，如果数据不重复则插入，重复则忽略（报警告，数据不会插入，不影响正常执行，无此关键字会报错误）。如：<code>INSERT IGNORE INTO test(id,name) VALUES(1,&#39;jack&#39;);</code><br>2、使用<code>REPLACE</code>关键字。该SQL与<code>IGNORE</code>的区别在于，如果数据重复，则先将旧的数据删除，然后插入新的。所以，执行该语句的影响行可以看出是否有重复的数据（为1表示无重复，大于1为重复）。<br>3、使用<code>ON DUPLICATE KEY UPDATE</code>，该句子是在有重复数据的时候，用新数据替换旧数据。</p><h3 id="11-2-统计重复数据"><a href="#11-2-统计重复数据" class="headerlink" title="11.2 统计重复数据"></a>11.2 统计重复数据</h3><p>比如统计重名的学生数量：<code>SELECT COUNT(name) AS deplication,name FROM student_info GROUP BY name HAVING deplication &gt; 1;</code></p><h3 id="11-3-数据导出"><a href="#11-3-数据导出" class="headerlink" title="11.3 数据导出"></a>11.3 数据导出</h3><p>需有FILE权限。</p><h4 id="方法一-使用OUTFILE"><a href="#方法一-使用OUTFILE" class="headerlink" title="方法一 使用OUTFILE"></a>方法一 使用OUTFILE</h4><p><code>SELECT 字段 FROM 表名 [WHERE等过滤条件] INTO OUTFILE &#39;保存路径&#39; [CHARACTER SET GBK] [FIELDS TERMINATED BY &#39;,&#39; [[ENCLOSED BY &#39;&quot;&#39;] LINES TERMINATED BY &#39;\n&#39;]];</code></p><ul><li>注意：由于xls和xlsx的中文默认gbk编码，因此如果数据表编码不一致，需在导出时使用<code>CHARACTER SET GBK</code>指定导出编码；在使用csv（Comma-Separated Values, 逗号分隔值）格式时，需使用<code>FIELDS TERMINATED BY &#39;,&#39;</code>指定字段分隔，否则会出现格式错误。</li></ul><h4 id="方法二-使用mysqldump命令"><a href="#方法二-使用mysqldump命令" class="headerlink" title="方法二 使用mysqldump命令"></a>方法二 使用mysqldump命令</h4><p><code>$mysqldump -u user -p pwd 数据库名 [表名] &gt; 文件;</code>导出指定数据库或指定数据表<br><code>$mysqldump -u user -p pwd --all-databases &gt; 文件;</code>备份所有数据库</p><h3 id="11-4-数据导入"><a href="#11-4-数据导入" class="headerlink" title="11.4 数据导入"></a>11.4 数据导入</h3><p>需有FILE权限。</p><h4 id="方法一-使用LOAD-DATA"><a href="#方法一-使用LOAD-DATA" class="headerlink" title="方法一 使用LOAD DATA"></a>方法一 使用LOAD DATA</h4><p><code>LOAD DATA [LOCAL] INFILE &#39;文件&#39; INTO TABLE 表名 [CHARACTER SET GBK] [FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39; LINES TERMINATED BY &#39;\n&#39;];</code></p><ul><li>注意数据表的编码，即使同为GBK编码，也会出现报错的情况，因此最好在导入前确定数据表与文件的编码，然后指定编码导入。</li><li><strong>无论在导入还是导出csv格式文件时，都需要使用<code>FIELDS TERMINATED BY &#39;,&#39;</code></strong></li><li>如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。</li></ul><h4 id="方法二-使用mysqldump命令-1"><a href="#方法二-使用mysqldump命令-1" class="headerlink" title="方法二 使用mysqldump命令"></a>方法二 使用mysqldump命令</h4><p><code>$mysqldump -u user -p pwd 数据库名 [表名] &lt; 文件;</code></p><h4 id="方法三-使用mysqlimport"><a href="#方法三-使用mysqlimport" class="headerlink" title="方法三 使用mysqlimport"></a>方法三 使用mysqlimport</h4><p><code>$mysqlimport -u user -p [--local] [--fields-terminated-by=&quot;:&quot; --lines-terminated-by=&quot;\r\n&quot; --columns=字段1，字段2] 数据库名 文件名</code></p><p>更多数据导入/导出信息请点击：<a href="https://segmentfault.com/a/1190000003941100" target="_blank" rel="noopener">如何将 JSON, Text, XML, CSV 数据文件导入 MySQL</a></p><h3 id="11-5-索引的性能"><a href="#11-5-索引的性能" class="headerlink" title="11.5 索引的性能"></a>11.5 索引的性能</h3><ul><li>索引改善检索操作的性能，但降低数据插入、修改和删除的性能。因为在执行这些操作时，MySQL必须动态地更新索引。</li><li>索引数据可能要占用大量的存储空间。</li><li>数据量少的字段不适合做索引。并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多可能值的数据（如姓名），能通过索引得到那么多的好处。</li><li>用于排序的字段适合添加索引。索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引。</li><li>可以在索引中定义多个列（如，州和城市）。这样的索引仅在以州+城市的排序时有用，如果以城市排序，则该索引并没什么用处。</li><li><strong>索引的效率随表数据的增加或改变而变化。许多DBA发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想了。最好定期检查索引，并根据需要对索引进行调整。</strong></li></ul><h3 id="11-6-一些术语释义"><a href="#11-6-一些术语释义" class="headerlink" title="11.6 一些术语释义"></a>11.6 一些术语释义</h3><ul><li>DDL(Data Definition Language)：数据定义语言</li><li>DML(Data Manipulation Language)：数据操作语言</li><li>DRL(Data Retrieval Language)：数据查询语言</li></ul><p>更多术语解释：<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html" target="_blank" rel="noopener">MySQL Glossary</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建shadowsocks服务器教程</title>
      <link href="/post/shadowsocks/"/>
      <url>/post/shadowsocks/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87cxihzkzj30hs0a0aaj.jpg" alt=""></p><a id="more"></a><p>搬瓦工系统自带的shadowsocks只支持CentOS 6及以下，那就自己搭建一个吧。</p><h3 id="1-环境："><a href="#1-环境：" class="headerlink" title="1. 环境："></a>1. 环境：</h3><p>服务器端：CentOs 7 64位（全新）<br>客户端：OS X 10.12.5 + ShadowsocksX-NG 1.5.0</p><h3 id="2-安装EPEL"><a href="#2-安装EPEL" class="headerlink" title="2. 安装EPEL"></a>2. 安装EPEL</h3><p><code>$ sudo yum -y install epel-release</code></p><h3 id="3-安装pip"><a href="#3-安装pip" class="headerlink" title="3.安装pip"></a>3.安装pip</h3><p><code>$ sudo yum -y install python-pip</code></p><h3 id="4-安装shadowsocks"><a href="#4-安装shadowsocks" class="headerlink" title="4. 安装shadowsocks"></a>4. 安装shadowsocks</h3><p><code>$ sudo pip install shadowsocks</code></p><h3 id="5-配置shadowsocks"><a href="#5-配置shadowsocks" class="headerlink" title="5. 配置shadowsocks"></a>5. 配置shadowsocks</h3><p><code>mkdir /etc/shadowsocks/</code><br><code>$ vi /etc/shadowsocks/config.json</code><br>内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>:<span class="string">"your_server_ip"</span>,</span><br><span class="line">  <span class="attr">"server_port"</span>:<span class="number">443</span>,</span><br><span class="line">  <span class="attr">"password"</span>:<span class="string">"yourpassword"</span>,</span><br><span class="line">  <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">  <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">  <span class="attr">"fast_open"</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"workers"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中各字段的含义：</p><ul><li>server：服务器 IP地址 (IPv4/IPv6)</li><li>server_port：服务器监听的端口，一般设为80，443等，注意不要设为使用中的端口</li><li>password：设置密码，自定义</li><li>timeout：超时时间（秒）</li><li>method：加密方法，可选择 “aes-256-cfb”, “rc4-md5”等等。推荐使用 “rc4-md5”</li><li>fast_open：true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。</li><li>workers：workers数量，默认为 1。</li></ul><h4 id="5-1-多账户配置"><a href="#5-1-多账户配置" class="headerlink" title="5.1 多账户配置"></a>5.1 多账户配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>:<span class="string">"your_server_ip"</span>,</span><br><span class="line">  <span class="attr">"port_password"</span>:&#123;</span><br><span class="line">       <span class="attr">"8381"</span>:<span class="string">"pass1"</span>,</span><br><span class="line">       <span class="attr">"8382"</span>:<span class="string">"pass2"</span>,</span><br><span class="line">       <span class="attr">"8383"</span>:<span class="string">"pass3"</span>,</span><br><span class="line">       <span class="attr">"8384"</span>:<span class="string">"pass4"</span></span><br><span class="line">       &#125;,</span><br><span class="line">  <span class="attr">"timeout"</span>:<span class="number">60</span>,</span><br><span class="line">  <span class="attr">"method"</span>:<span class="string">"rc4-md5"</span>,</span><br><span class="line">  <span class="attr">"fast_open"</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"workers"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-设置shadowsocks开机自启"><a href="#6-设置shadowsocks开机自启" class="headerlink" title="6. 设置shadowsocks开机自启"></a>6. 设置shadowsocks开机自启</h3><p><code>vi /etc/systemd/system/shadowsocks.service</code><br>内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks/config.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>执行以下命令启动 shadowsocks 服务：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">enable</span> shadowsocks</span><br><span class="line">systemctl <span class="keyword">start</span> shadowsocks</span><br></pre></td></tr></table></figure><p>执行命令<code>systemctl status shadowsocks</code>查看ss状态<br>如果 shadowsocks 启动失败，可根据日志 <code>/var/log/shadowsocks.log</code> 信息进行排查。</p><hr><p>参考文章：</p><ol><li><a href="https://php-rmcr7.rhcloud.com/shadowsocks-server/" target="_blank" rel="noopener">教你如何搭建自己的Shadowsocks服务器</a></li><li><a href="https://yuyii.com/2015/12/28/shadowsocks-systemd/" target="_blank" rel="noopener">Shadowsocks systemd 配置</a></li><li><a href="https://morning.work/page/2015-12/install-shadowsocks-on-centos-7.html" target="_blank" rel="noopener">在 CentOS 7 下安装配置 shadowsocks</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地git仓库间的通信</title>
      <link href="/post/communication-with-local-repo/"/>
      <url>/post/communication-with-local-repo/</url>
      
        <content type="html"><![CDATA[<p>同一台电脑的两个git仓库间如何通信呢？</p><a id="more"></a><p>首先要明确一点：git是<strong>分布式</strong>版本管理工具。也就是说各个git仓库间是<strong>相互独立</strong>的。</p><p>现在，我们在<code>admin</code>家目录下新建两个git仓库，分别取名为<code>t1</code>和<code>t2</code>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[admin<span class="meta">@bravo</span> ~]$ git init t1</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> <span class="regexp">/home/</span>admin<span class="regexp">/t1/</span>.git/</span><br><span class="line">[admin<span class="meta">@bravo</span> ~]$ git init t2</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> <span class="regexp">/home/</span>admin<span class="regexp">/t2/</span>.git/</span><br><span class="line">[admin<span class="meta">@bravo</span> t1]$</span><br></pre></td></tr></table></figure><p>然后，进入t1目录，创建一个名为t1的文件，并加入git跟踪</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[admin@<span class="keyword">bravo </span><span class="built_in">t1</span>]$ touch <span class="built_in">t1</span></span><br><span class="line">[admin@<span class="keyword">bravo </span><span class="built_in">t1</span>]$ git <span class="keyword">add </span>.</span><br><span class="line">[admin@<span class="keyword">bravo </span><span class="built_in">t1</span>]$ git commit -m <span class="string">'create t1'</span></span><br><span class="line">[master (root-commit) <span class="number">701</span>f<span class="number">8b</span>8] create <span class="built_in">t1</span></span><br><span class="line"> <span class="number">0</span> files changed, <span class="number">0</span> <span class="keyword">insertions(+), </span><span class="number">0</span> deletions(-)</span><br><span class="line"> create mode <span class="number">100644</span> <span class="built_in">t1</span></span><br><span class="line">[admin@<span class="keyword">bravo </span><span class="built_in">t1</span>]$</span><br></pre></td></tr></table></figure><p>接下来，进入t2目录，并关联t1仓库</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">admin</span>@bravo t1]$ cd ../t2</span><br><span class="line">[<span class="keyword">admin</span>@bravo t2]$ git remote <span class="keyword">add</span> t1 /home/<span class="keyword">admin</span>/t1</span><br><span class="line">[<span class="keyword">admin</span>@bravo t2]$ git remote -vv</span><br><span class="line">t1/home/<span class="keyword">admin</span>/t1 (<span class="keyword">fetch</span>)</span><br><span class="line">t1/home/<span class="keyword">admin</span>/t1 (push)</span><br></pre></td></tr></table></figure><p>最后，拉取t1目录中的文件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">admin@</span>bravo t2]$ git fetch t1</span><br><span class="line">remote: Counting objects: <span class="number">3</span>, done.</span><br><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">From /home/admin/t1</span><br><span class="line"> * [new branch]      master     -&gt; t1/master</span><br><span class="line">[<span class="symbol">admin@</span>bravo t2]$ git merge t1/master</span><br><span class="line">[<span class="symbol">admin@</span>bravo t2]$ ls</span><br><span class="line">t1</span><br><span class="line">[<span class="symbol">admin@</span>bravo t2]$</span><br></pre></td></tr></table></figure><p>好了，现在你就可以在t2仓库中同步到t1仓库中的内容了，由于git能够精确到行，因此很方便文件冲突的解决。</p><p>说了这么多，这有什么用呢？<br>在我们开发时，经常是前后端分离的，而且大家的代码都在同一台测试服务器上，一个完整的功能需要前后端代码合并后才能测试，这种方式就能完美合并前后端代码了。</p><p>注意：首先要对被拉取代码的目录拥有读取权限，也就是t1目录要有r才能执行上述操作。</p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些常见的PHP面试题</title>
      <link href="/post/php-interview/"/>
      <url>/post/php-interview/</url>
      
        <content type="html"><![CDATA[<p>这都是我面试的血泪史啊:(</p><a id="more"></a><h3 id="一、-数组及传值方式的考察"><a href="#一、-数组及传值方式的考察" class="headerlink" title="一、 数组及传值方式的考察"></a>一、 数组及传值方式的考察</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  $arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">  <span class="keyword">foreach</span> ($arr <span class="keyword">as</span> &amp;$v) &#123;</span><br><span class="line">  <span class="comment"># code...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">foreach</span> ($arr <span class="keyword">as</span> $v) &#123;</span><br><span class="line">  <span class="comment"># code...</span></span><br><span class="line">  &#125;</span><br><span class="line">  print_r($arr);</span><br></pre></td></tr></table></figure><p>结果是$arr = [‘a’,’b’,’b’]，你答对了吗？</p><p>反正我是想了一个礼拜才弄明白:)</p><p>解析：这道题首先要注意第一次循环中的”&amp;”符号，考察的是PHP中的引用赋值和拷贝赋值。</p><p>  最后出现“令人意外”的结果的原因就在于，第一次循环是每次把$arr元素的地址给了$v，而$v的地址在循环结束后有没被释放掉，所以第一次循环结束后$v存的是$arr[2]的<strong>地址</strong>，第二次循环是把$arr的值分别给了$v，由于此时的$v指向的是$arr[2]，所以每次指针的移动都是把当前的元素放入$arr[2]中，所以</p><ul><li>第一次循环$arr = [‘a’,’b’,’a’];</li><li>第二次循环$arr = [‘a’,’b’,’b’];</li><li>第三次循环$arr = [‘a’,’b’,’b’];</li></ul><p>第三次循环的结果就是把自己的$arr[2]的内容取出来赋给$arr[2]，所以结果是$arr = [‘a’,’b’,’b’];</p><p>因此我们<strong>在使用”&amp;”符号时，最好将其unset掉，否则会导致意外行为</strong>。</p><p>最后上一个图说明一下：<br><img src="http://ohx73ws1b.bkt.clouddn.com/foreach%E9%9D%A2%E8%AF%95%E9%A2%98.jpg" alt=""></p><p>参考资料：<a href="https://segmentfault.com/q/1010000008279730" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008279730</a></p><hr><h3 id="二、-数组的考察"><a href="#二、-数组的考察" class="headerlink" title="二、 数组的考察"></a>二、 数组的考察</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="number">9</span>;</span><br><span class="line">$t = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">foreach</span>($t <span class="keyword">as</span> $v)</span><br><span class="line">&#123;</span><br><span class="line">$v += $a;</span><br><span class="line">&#125;</span><br><span class="line">var_dump($t);</span><br></pre></td></tr></table></figure><p>结果是<code>1</code>而不是<code>10</code>。</p><hr><h3 id="三、-SQL的考察"><a href="#三、-SQL的考察" class="headerlink" title="三、 SQL的考察"></a>三、 SQL的考察</h3><p>现有一个学生成绩表student,内容如下：</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E8%A1%A8.png" alt=""></p><p>请据表查询，</p><ol><li>用一个select查出两门及以上的不及格者的平均成绩</li><li>统计学生不及格科目的个数</li><li>获取每个学生的最佳科目及成绩</li><li>获取不及格学生的名字及科目</li></ol><p>答：</p><ol><li><p><code>select name, sum(score&lt;60) as num, avg(score) as avg_score  from student  group by name having num &gt; 1;</code><br><br><img src="http://ohx73ws1b.bkt.clouddn.com/2%E9%97%A8%E5%8F%8A%E4%BB%A5%E4%B8%8A%E4%B8%8D%E5%8F%8A%E6%A0%BC%E7%9A%84%E5%B9%B3%E5%9D%87%E5%88%86.png" alt=""></p></li><li><p><code>select name, sum(score &lt; 60) as no_pass from student group by name;</code><br><br><img src="http://ohx73ws1b.bkt.clouddn.com/%E4%B8%8D%E5%8F%8A%E6%A0%BC%E7%A7%91%E7%9B%AE%E6%95%B0.png" alt=""></p></li><li><p><code>select name, subject, score from student where score in (select max(score) as score from student group by name);</code><br><br><img src="http://ohx73ws1b.bkt.clouddn.com/%E6%9C%80%E4%BD%B3%E7%A7%91%E7%9B%AE%E5%8F%8A%E6%88%90%E7%BB%A9.png" alt=""></p></li><li><p><code>select name, group_concat(subject) as subject from (select name, subject from student where score &lt; 60) as info group by name;</code>//此处需要注意的是，子查询语句结果需要给一个alias，否则会报错<br><br><img src="http://ohx73ws1b.bkt.clouddn.com/%E4%B8%8D%E5%8F%8A%E6%A0%BC%E7%A7%91%E7%9B%AE%E5%88%97%E8%A1%A8.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UA列表</title>
      <link href="/post/browser-user-agent-list/"/>
      <url>/post/browser-user-agent-list/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87d074zw5j30b4069glv.jpg" alt=""></p><a id="more"></a><p>常见UA列表如下：</p><table><thead><tr><th align="center">BROWSER</th><th align="center">USER AGENT</th></tr></thead><tbody><tr><td align="center">Safari 10.0</td><td align="center">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12) AppleWebKit/602.1.50 (KHTML, like Gecko) Version/10.0 Safari/602.1.50</td></tr><tr><td align="center">Safari 10.0-iOS10-iPhone</td><td align="center">Mozilla/5.0 (iPhone; CPU iPhone OS 10_0 like Mac OS X) AppleWebKit/602.1.38 (KHTML, like Gecko) Version/10.0 Mobile/14A300 Safari/602.1</td></tr><tr><td align="center">Safari 10.0-iOS10-iPod touch</td><td align="center">Mozilla/5.0 (iPod; CPU iPhone OS 10_0 like Mac OS X) AppleWebKit/602.1.38 (KHTML, like Gecko) Version/10.0 Mobile/14A300 Safari/602.1</td></tr><tr><td align="center">Safari 10.0-iOS10-iPad</td><td align="center">Mozilla/5.0 (iPad; CPU OS 10_0 like Mac OS X) AppleWebKit/602.1.38 (KHTML, like Gecko) Version/10.0 Mobile/14A300 Safari/602.1</td></tr><tr><td align="center">Microsoft Edge</td><td align="center">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/13.10586</td></tr><tr><td align="center">Internet Explorer  11</td><td align="center">Mozilla/5.0 (Windows NT 6.3; Win64, x64; Trident/7.0; rv:11.0) like Gecko</td></tr><tr><td align="center">Internet Explorer  10</td><td align="center">Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)</td></tr><tr><td align="center">Internet Explorer  9</td><td align="center">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)</td></tr><tr><td align="center">Internet Explorer  8</td><td align="center">Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)</td></tr><tr><td align="center">Internet Explorer  7</td><td align="center">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)</td></tr><tr><td align="center">Google Chrome - Mac</td><td align="center">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36</td></tr><tr><td align="center">Google Chrome - Windows</td><td align="center">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36</td></tr><tr><td align="center">Firefox - Mac</td><td align="center">Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:46.0) Gecko/20100101 Firefox/46.0</td></tr><tr><td align="center">Firefox - Windows</td><td align="center">Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:46.0) Gecko/20100101 Firefox/46.0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统封装小感</title>
      <link href="/post/encapsule-os-notes/"/>
      <url>/post/encapsule-os-notes/</url>
      
        <content type="html"><![CDATA[<p><embed height="415" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=8679165&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></embed></p><a id="more"></a><hr><p>经过近一周的奋战，终于把去年8月就想录制的系统封装教程录制剪辑完毕了，现已上线：</p><p>Bilibili : <a href="http://www.bilibili.com/video/av8679165/" target="_blank" rel="noopener">http://www.bilibili.com/video/av8679165/</a></p><p>YouTube : <a href="https://www.youtube.com/watch?v=urmczmqsHn4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=urmczmqsHn4</a></p><p>在这个过程中，确实学到了不少，也折腾了不少，首先是距离上次封装已经有半年了，自己记忆模糊，然后是第一次录制，上来直接开录，导致推到两三次，最后就是Castasia、Premiere、After Effect等软件的使用，毕竟新手，用起来总是磕磕碰碰，所幸最终教程顺利上线，自己也总结一下本次的经验，以便今后参考：</p><ol><li>录制视频前，自己要先把录制的内容走一遍，尽可能使录制一气呵成。可以把录制内容拆分步骤，记录在旁边，减少出错。对于自己出现的问题在后期处理时重点标出</li><li>对于一些文字内容，可以适当放大屏幕来提高体验，这一点可以通过Premiere的效果控件中的缩放来实现</li><li>对于一些不必要的过程，可适当进行剪辑，倍速播放等</li><li>在整个录制过程中，耗时很多的几个步骤是：<ul><li>系统打补丁（近3小时）</li><li>镜像文件的保存（1小时左右）</li><li>wim转esd格式（2小时）</li><li>Castasia保存录制的原生视频（1小时）</li><li>Pr导出剪辑好的视频（1小时）</li></ul></li><li>本次录制使用了VMware封装、Castasia 9.0录屏、Premiere剪辑、After Effect添加字幕</li><li>在最后的上传中，由于YouTube强大的Content ID机制，我其中的一段背景音乐因为侵权而导致整个视频都被静音，最后移除该段音乐解决。<br><img src="http://ohx73ws1b.bkt.clouddn.com/YouTube%E9%9F%B3%E4%B9%90%E7%89%88%E6%9D%83.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac和CentOS命令行下文件校验</title>
      <link href="/post/file-chek-on-terminal/"/>
      <url>/post/file-chek-on-terminal/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cn5iehl5j30he08xt9l.jpg" alt=""></p><a id="more"></a><p>　　你从互联网上下载了某个文件(比如安装程序、ISO映像文件或压缩文件)后，该文件可能因各种错误情形而遭到损坏，比如由于网络连接上的传输错误、下载受到中断、存储硬件有故障、文件系统错误等。抛开此类错误情形不说，文件还有可能被攻击者在下载过程中或下载前恶意篡改。比如说，攻击者对认证中心做手脚后，就能发动中间人(MITM)攻击，引诱你从假冒的HTTPS网站下载感染了恶意软件的文件。</p><p>　　为了保护自己远离这些种类的问题，你从互联网下载文件时，我们常常建议验证文件的真实性和完整性。尤其是你下载了相当敏感的文件(比如操作系统映像文件、应用程序二进制代码和可执行的安装程序等)后，盲目地相信已下载文件可不是一个好习惯。</p><p>在Mac平台下，你可以使用以下方式进行校验：</p><ol><li>MD5：<code>md5 filename</code></li><li>SHA1: <code>shasum filename</code></li><li>CRC32: <code>crc32 filename</code></li></ol><p>CentOS平台下则是：</p><ol><li>MD5: <code>md5sum filename</code></li><li>SHA1: <code>shasum filename</code></li></ol><p>是不是方便了很多呢？</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> md5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】浅谈CSRF攻击方式</title>
      <link href="/post/csrf-attack/"/>
      <url>/post/csrf-attack/</url>
      
        <content type="html"><![CDATA[<p>好久没更新了，hexo命令都要忘记了。。。</p><a id="more"></a><h3 id="一-CSRF是什么？"><a href="#一-CSRF是什么？" class="headerlink" title="一.CSRF是什么？"></a>一.CSRF是什么？</h3><p>　　CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><h3 id="二-CSRF可以做什么？"><a href="#二-CSRF可以做什么？" class="headerlink" title="二.CSRF可以做什么？"></a>二.CSRF可以做什么？</h3><p>　　你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p><h3 id="三-CSRF漏洞现状"><a href="#三-CSRF漏洞现状" class="headerlink" title="三.CSRF漏洞现状"></a>三.CSRF漏洞现状</h3><p>　　CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。</p><h3 id="四-CSRF的原理"><a href="#四-CSRF的原理" class="headerlink" title="四.CSRF的原理"></a>四.CSRF的原理</h3><p>　　下图简单阐述了CSRF攻击的思想：</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/CRSF%E6%94%BB%E5%87%BB.jpg" alt="CSRF攻击"></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><p>　　1. 登录受信任网站A，并在本地生成Cookie。</p><p>　　2. 在不登出A的情况下，访问危险网站B。</p><p>　　看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><p>　　1. 你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</p><p>　　2. 你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</p><p>　　3. 上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</p><p>　　上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;）</p><p>　　示例1：</p><p>　　银行网站A，它以GET请求来完成银行转账的操作，如：<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a></p><p>　　危险网站B，它里面有一段HTML的代码如下：</p><p>  <code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code></p><p>  首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……</p><p>　　为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的<img>以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作</a>……</p><p>　　示例2：</p><p>　　为了杜绝上面的问题，银行决定改用POST请求完成转账操作。</p><p>　　银行网站A的WEB表单如下：　　</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"Transfer.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">　   <span class="tag">&lt;<span class="name">p</span>&gt;</span>ToBankId: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"toBankId"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">　   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Money: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"money"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">　   <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Transfer"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   后台处理页面Transfer.php如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_REQUEST[<span class="string">'toBankId'</span>] &amp;&amp;　<span class="keyword">isset</span>($_REQUEST[<span class="string">'money'</span>])) &#123;</span><br><span class="line">    buy_stocks($_REQUEST[<span class="string">'toBankId'</span>],　$_REQUEST[<span class="string">'money'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  危险网站B，仍然只是包含那句HTML代码：</p><p><code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code></p><p>和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求 的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。</p><p>　　示例3：</p><p>　　经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'toBankId'</span>] &amp;&amp;　<span class="keyword">isset</span>($_POST[<span class="string">'money'</span>])) &#123;</span><br><span class="line">    buy_stocks($_POST[<span class="string">'toBankId'</span>],　$_POST[<span class="string">'money'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   然而，危险网站B与时俱进，它改了一下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">　　　　　　<span class="function"><span class="keyword">function</span> <span class="title">steal</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">     　　　　 iframe = <span class="built_in">document</span>.frames[<span class="string">"steal"</span>];</span></span><br><span class="line"><span class="actionscript">　　     　　 iframe.document.Submit(<span class="string">"transfer"</span>);</span></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">　　<span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"steal()"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"steal"</span> <span class="attr">display</span>=<span class="string">"none"</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">name</span>=<span class="string">"transfer"</span>　<span class="attr">action</span>=<span class="string">"http://www.myBank.com/Transfer.php"</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"toBankId"</span> <span class="attr">value</span>=<span class="string">"11"</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行!</p><p>　　总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个<img>就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。</p><p>　　理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</p><h3 id="五-CSRF的防御"><a href="#五-CSRF的防御" class="headerlink" title="五.CSRF的防御"></a>五.CSRF的防御</h3><p>　　我总结了一下看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。</p><p>　　1. 服务端进行CSRF防御</p><p>　　服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p><p>　　(1).Cookie Hashing(所有表单都包含同一个伪随机值)：</p><p>　　这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//构造加密的Cookie信息</span></span><br><span class="line">$value = “DefenseSCRF”;</span><br><span class="line">setcookie(”cookie”, $value, time()+<span class="number">3600</span>);</span><br></pre></td></tr></table></figure><p>在表单里增加Hash值，以认证这确实是用户发送的请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span>　$hash = md5($_COOKIE[<span class="string">'cookie'</span>]); <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">”POST”</span> <span class="attr">action</span>=<span class="string">”transfer.php”</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”text”</span> <span class="attr">name</span>=<span class="string">”toBankId”</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”text”</span> <span class="attr">name</span>=<span class="string">”money”</span>&gt;</span></span><br><span class="line">　　&lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt;</span><br><span class="line">　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”submit”</span> <span class="attr">name</span>=<span class="string">”submit”</span> <span class="attr">value</span>=<span class="string">”Submit”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在服务器端进行Hash值验证</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'check'</span>])) &#123;</span><br><span class="line">     $hash = md5($_COOKIE[<span class="string">'cookie'</span>]);</span><br><span class="line">     <span class="keyword">if</span>($_POST[<span class="string">'check'</span>] == $hash) &#123;</span><br><span class="line">          doJob();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　<span class="comment">//...</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。<br>　　(2).验证码</p><p>　　这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。</p><p>　　(3).One-Time Tokens(不同的表单包含一个不同的伪随机值)</p><p>　　在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。</p><p>　　以下我的实现:</p><p>　　1).先是令牌生成函数(gen_token())：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">gen_token</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　　　<span class="comment">//这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。</span></span><br><span class="line">　　　　<span class="comment">//这个可以参考我写的Findbugs笔记中的《Random object created and used only once》</span></span><br><span class="line">          $token = md5(uniqid(rand(), <span class="keyword">true</span>));</span><br><span class="line">          <span class="keyword">return</span> $token;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>2).然后是Session令牌生成函数(gen_stoken())：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen_stoken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     $pToken = <span class="string">""</span>;</span><br><span class="line">　　　<span class="keyword">if</span>($_SESSION[STOKEN_NAME]  == $pToken)&#123;</span><br><span class="line">　　　　　<span class="comment">//没有值，赋新值</span></span><br><span class="line">　　　　　$_SESSION[STOKEN_NAME] = gen_token();</span><br><span class="line">　　　&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">　　　　　<span class="comment">//继续使用旧的值</span></span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3).WEB表单生成隐藏输入域的函数：　　</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">gen_input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          gen_stoken();</span><br><span class="line">          <span class="keyword">echo</span> “&lt;input type=\”hidden\” name=\”<span class="string">" . FTOKEN_NAME . “\”</span></span><br><span class="line"><span class="string">               value=\”"</span> . $_SESSION[STOKEN_NAME] . “\”&gt; “;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>4).WEB表单结构：</p><pre><code class="html"><span class="php"><span class="meta">&lt;?php</span></span><span class="php">     session_start();</span><span class="php">     <span class="keyword">include</span>(<span class="string">'functions.php'</span>);</span><span class="php"><span class="meta">?&gt;</span></span><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">”POST”</span> <span class="attr">action</span>=<span class="string">”transfer.php”</span>&gt;</span>     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”text”</span> <span class="attr">name</span>=<span class="string">”toBankId”</span>&gt;</span>     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”text”</span> <span class="attr">name</span>=<span class="string">”money”</span>&gt;</span>     <span class="php"><span class="meta">&lt;?</span> gen_input(); <span class="meta">?&gt;</span></span>     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”submit”</span> <span class="attr">name</span>=<span class="string">”submit”</span> <span class="attr">value</span>=<span class="string">”Submit”</span>&gt;</span><span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></code></pre><p>5).服务端核对令牌：</p><p>　　这个很简单，这里就不再啰嗦了。</p><p>　　上面这个其实不完全符合“并行会话的兼容”的规则，大家可以在此基础上修改。</p><hr><p>文章转载自：<a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRSF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS离线下载之二</title>
      <link href="/post/vps-download-part-II/"/>
      <url>/post/vps-download-part-II/</url>
      
        <content type="html"><![CDATA[<p>解决VPS下载好的文件如何同步到百度云的问题。</p><a id="more"></a><p>现在我们已经将文件下载到我们的vps了，但怎么取回本地呢？</p><p>楼主首先尝试的是用wget命令下载到服务器，然后用FTP取回本地，后来测试发现FTP在同一时间、同一个文件上传在500KB/，下载最高50KB/，这也太鸡肋了，一番Google后发现可以使用<a href="https://github.com/houtianze/bypy" target="_blank" rel="noopener">Bypy</a>同步到百度云。</p><p>关于同步到百度云，由于已经有博主写了一篇很好的文章，我就全文转载了。</p><blockquote><p>前一段时间接了个小任务，要把YouTube上的几百个视频下载回来，用百度云网盘分享给公司的同事供学习使用。</p><p>当老板发邮件问我这事儿是否能办时，我很快就回复说没问题，因为“从YouTube下载视频”这种事之前我也不是没做过。网上有一大批在线工具能够嗅探出YouTube视频的下载链接，然后直接用常规手段（迅雷啥的）下载就可以了。本地下载工具也不少，如著名的IDM就能够直接下载网页上嵌套的视频文件，几乎是万能的。不过，这次的任务有点复杂：一来要下载的文件太多了，我总不能重复操作几百次来下载每个视频吧；二来，还得上传到百度云，这么多视频，靠我家里那小水管，没个几天几夜恐怕是上传不完的，多费劲呀。</p><p>然后我就开始琢磨这件事能不能更自动化、更高效一些来实现。呃，放狗上Google搜了一下，找到了几个大杀器，参考了一下各位大神的教程后，我也拼凑出了一个解决方案。</p><p>长话短说：</p><p>在美国VPS上安装YouTube专用下载工具，远程下载想要的YouTube视频到服务器上；在VPS上安装百度云网盘上传工具，将已经下载到VPS中的视频上传到云端。</p><p>这个方案的好处很明显：用位于美国的VPS下载本身服务器就在美国的YouTbe网站视频，速度相当快（实测可以超过60MB/s）。从美国VPS上传文件到百度云，速度虽然受限（一般是几百Kb每秒，偶见超过1MB/s的），但仍比我在国内本地的上传网速要快得多。更重要的是，这个方案是高度自动化、批量进行的，不用手动对付每个视频。</p><p>短话长说：</p><p>接下来要写的详细教程，是一个大杂烩。你在网上能找到的特定教程，都是有特定限制条件的，例如你的VPS用的是啥操作系统，你要实现多大程度的自动化，等等。在完成这个教程的过程中，我也踩了不少坑，幸亏有万能的Google相助。</p><h2 id="1-安装VPS操作系统"><a href="#1-安装VPS操作系统" class="headerlink" title="1 安装VPS操作系统"></a>1 安装VPS操作系统</h2><p>我用的是DigitalOcean（若使用我的推荐链接注册DigitalOcean，您的账户可以立即获得10美金，相当于免费获得两个月的使用权）最基础的套餐，每月5$，20G的SSD储存空间，1T流量。安装的操作系统是CentOS 7（请注意操作系统的选择，这很重要，后面我会提到原因），节点为旧金山（据说从大陆访问会比较快）。所以，如果你也是DO用户的话，可以完全照我这篇教程来做，准没问题。不是的话，请酌情参考就好了，其他问题我不负责解答哈，毕竟，我是一个伪技术流……</p><p>首先要赞下DigitalOcean的VPS用起来真是方便，点几下鼠标就能创建好一台服务器。理论上用SSH密钥登录会更安全，不过我偷懒，只是简单用LastPass生成一个几十位长度的随机密码，需要用到就复制粘贴一下好了（请大家不要向我学习……）。禁用root账号登录，修改SSH端口号什么的，这些安全措施也可以做下，我就不多说了，不太清楚的话请自行Google。</p><p>前面提过VPS的操作系统问题，为啥我用CentOS 7呢？因为这个版本默认自带的Python是2.7.5（截至本文发布时是这样的），而这个教程中会用到的百度云网盘Linux客户端（bypy）依赖的Python版本号为2.7x。一开始我装了个CentOS 6，其自带Python 6.x，不符合要求；Google了好多教程，还是没能装上Python 2.7x（在DO的这个系统上需要自行编译Python，各种报错很无奈）；最后决定放弃CentOS 6，换成7，因为有那个工夫折腾Python，我还不如去看几集美剧是吧，呃，好像我又无意中暴露了什么……</p><h2 id="2-安装youtube-dl"><a href="#2-安装youtube-dl" class="headerlink" title="2 安装youtube-dl"></a>2 安装youtube-dl</h2><p>传说中的第一个大杀器终于粗线了：youtube-dl。这个工具可以用来下载一系列国外网站的在线视频，如油管家的。它既有本地客户端，也可以被部署在服务器上。</p><p>用Putty登入VPS后，依次执行以下两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;wget https://yt-dl.org/downloads/latest/youtube-dl -O /usr/<span class="built_in">local</span>/bin/youtube-dl</span><br><span class="line">&gt;chmod a+rx /usr/<span class="built_in">local</span>/bin/youtube-dl</span><br></pre></td></tr></table></figure><p>然后就没了。是的就是这么简单，现在你已经装完youtube-dl，可以在VPS上远程下载指定的YouTube视频了。</p><p>最简单的命令如下：</p><p><code>youtube-dl video-url</code></p><p>把上面的这个video-url换成具体某个YouTube视频的URL就可以直接下载了。注意，youtube-dl会默认下载视频到当前执行命令的目录下。</p><p>YouTube有Playlist功能，即播放列表，你可以用Google账号登录，然后就可以把若干视频添加保存到Playlist。如果你想要批量下载某个Playlist的视频，就可以把前面那条下载命令中的 video-url换成具体Playlist的链接。话句话说，想要一次下载多个YouTube视频，你可以考虑用这个Playlist功能。</p><p>不过呢，像本文开头提到的这个任务，如果我要手动添加几百个视频到Playlist那得累到手抽筋：我得先点开每一个视频的具体链接，然后再点两下鼠标才能将之添加进Playlist。好了不绕弯了，说这么多，就是想烘托出youtube-dl的另一个激动人心的功能：支持读取下载链接列表文件。这意味着我可以先把所有下载链接整理好后放进一个txt文件，然后让youtube-dl去读取这个txt文件就行了，接下来它就会自动下载全部的视频。该方法的命令如下：</p><p><code>youtube-dl -a video_url.txt</code></p><p>这里的 -a 参数表示读取外部链接文件。</p><p>具体细节操作在后面会提到，请耐心往下看……</p><h2 id="3-安装byby"><a href="#3-安装byby" class="headerlink" title="3 安装byby"></a>3 安装byby</h2><p>Byby是一个百度云网盘的Python客户端，可在Linux环境下通过命令行来操作。</p><p>在本文的操作环境下，安装byby需要更多的步骤，byby官网没有介绍那么详细，所以我参考了其他网友的教程。</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><code>yum install git</code></p><h3 id="安装Python-Pip"><a href="#安装Python-Pip" class="headerlink" title="安装Python Pip"></a>安装Python Pip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;yum -y install epel-release</span><br><span class="line">&gt;yum -y install python-pip</span><br><span class="line">&gt;yum clean all</span><br></pre></td></tr></table></figure><p>说明：先装扩展源EPEL再装Python Pip才不会报错。</p><h3 id="安装Requests"><a href="#安装Requests" class="headerlink" title="安装Requests"></a>安装Requests</h3><p>pip install requests</p><p>完成以上步骤后，才开始正式安装bypy。</p><p>依次执行以下三行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;git <span class="built_in">clone</span> https://github.com/houtianze/bypy byby/</span><br><span class="line">&gt;<span class="built_in">cd</span> byby/</span><br><span class="line">&gt;python bypy.py list</span><br></pre></td></tr></table></figure><p>此时的命令行界面会出现提示，按照以下步骤来授权你的百度云账号使用bypy客户端：</p><p>左键选中用于百度账号授权的那行URL，即可复制该文本（在Putty中选中即可复制，不用Ctrl+C），在浏览器中打开此链接。<br>登录你的百度账号，然后复制授权码。<br>回到Putty命令行界面，粘贴授权码进去，回车即可开始启动授权操作。<br>稍等几秒，授权即可成功。</p><p>为了方便在任意目录下使用bypy命令，还需要设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> /byby</span><br><span class="line">&gt;cp bypy.py /usr/bin</span><br></pre></td></tr></table></figure><p>完成以上设置后，如果要将VPS某个文件夹下的所有文件上传到百度云，最简单的命令如下：</p><p><code>bypy.py upload</code></p><p>还可以加参数，如 -v 可以显示上传进度：</p><p><code>bypy.py upload -v</code></p><p>默认情况下，本方案上传到百度云的文件全部存放在“我的应用数据 –&gt; bypy”路径下。</p><h2 id="4-下载与上传视频"><a href="#4-下载与上传视频" class="headerlink" title="4 下载与上传视频"></a>4 下载与上传视频</h2><p>在Putty命令行界面中创建一个专门的目录用于存放下载的视频文件，然后CD至此目录下，创建一个包含所有下载链接的txt文件（使用vi命令即可）。在此目录下，执行下载命令：</p><p><code>youtube-dl -c -i -a video_url.txt</code></p><p>呃，眼尖的你可能已经发现了，上面这条命令好像多出了两个参数？没错，youtube-dl提供了很多有用的附加参数，这里用到的是：</p><p>-c 断点续传（如果由于意外原因下载中断了，再次启动下载命令时，可以实现断点续传）<br>-i 忽略报错（如果出现某些链接无法打开或者下载的问题，会自动绕过，继续下载其他视频）<br>下载的话一般很快，但是上传到百度云并没有那么快。为了防止关闭Putty窗口后，下载/上传进程就断掉了，可以考虑使用Screen远程会话管理功能。简单介绍就是，有了这玩意儿，你可以在Putty中启动下载或者上传进程，让其在后台运行，然后关掉Putty离开电脑旁该干啥干啥去，有需要的话回来重新打开窗口就可以看到进程依然在跑。</p><p>要检查操作系统是否支持screen，可以直接输入screen然后回车，如果提示找不到这个命令，那就是系统还没安装好这个东西。在CentOS 7中安装screen很简单，一条命令而已：</p><p><code>yum install screen</code></p><p>安装完毕后，输入 screen -S sessionname 即可创建一个名为 sessionname 的screen会话窗口。在此窗口中执行想要做的任务，然后同时按下 ctrl + a，松开后按下 d，即可将此session放到后台去运行，并回到之前的对话窗口。在非screen对话窗口中，输入 screen -ls 可以列举已有的screen进程。输入 “screen -r 进程代码” 就可以再次调出正在运行的screen进程。</p><p>由于我要上传到百度云的文件太多了，我不可能守在电脑前等它完成所有任务，所以screen这个功能还是非常实用的。</p><p>本文主要参考链接：<br><a href="https://github.com/rg3/youtube-dl/" target="_blank" rel="noopener">https://github.com/rg3/youtube-dl/</a><br><a href="https://github.com/houtianze/bypy" target="_blank" rel="noopener">https://github.com/houtianze/bypy</a><br><a href="http://yesido.info/2015/03/linux-upload-document-to-baidu-cloud/（编者按：链接已失效）" target="_blank" rel="noopener">http://yesido.info/2015/03/linux-upload-document-to-baidu-cloud/（编者按：链接已失效）</a></p></blockquote><p>原文链接：<a href="http://www.typemylife.com/use-vps-download-videos-from-youtube-upload-to-baidu-cloud/" target="_blank" rel="noopener">http://www.typemylife.com/use-vps-download-videos-from-youtube-upload-to-baidu-cloud/</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离线下载 </tag>
            
            <tag> VPS </tag>
            
            <tag> 百度云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS离线下载之一</title>
      <link href="/post/vps-download-part-I/"/>
      <url>/post/vps-download-part-I/</url>
      
        <content type="html"><![CDATA[<p>有一台VPS可以做各种各样好玩儿的东西，这不，楼主开始折腾离线下载了。</p><a id="more"></a><h1 id="离线下载概述"><a href="#离线下载概述" class="headerlink" title="离线下载概述"></a>离线下载概述</h1><p>既然我们要使用服务器离线下载，首先来了解一下离线下载的原理：<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD.png" alt=""></p><p>那么离线下载有什么优势呢？</p><ol><li>对于一些慢速的大文件，可以扔到服务器上慢慢下，下好了再取回本地，避免长时间的等待；</li><li>如果你的vps位于国外，有些资源的下载vps速度更快，本地你可能耗时一整天都不一定能下完，就算下完了也可能是一个损坏的文件包，而vps几乎可以做到秒下，然后将下载好的资源同步到国内的百度云，这样绕个弯子会节省不少的时间。</li></ol><h1 id="离线下载方式"><a href="#离线下载方式" class="headerlink" title="离线下载方式"></a>离线下载方式</h1><p>在Linux系统中有这样几种命令行下载方式：</p><h3 id="1-wget"><a href="#1-wget" class="headerlink" title="1. wget"></a>1. wget</h3><p>wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p><h3 id="2-curl"><a href="#2-curl" class="headerlink" title="2. curl"></a>2. curl</h3><p>curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。</p><h3 id="3-axel"><a href="#3-axel" class="headerlink" title="3. axel"></a>3. axel</h3><p>axel是Linux下一个不错的HTTP/ftp高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度。比如在国内VPS或服务器上下载lnmp一键安装包用Axel就比wget快。</p><h3 id="4-aria2"><a href="#4-aria2" class="headerlink" title="4. aria2"></a>4. aria2</h3><p>Aria2是一个基于命令行的开源下载工具，支持多协议、多来源(HTTP/HTTPS、FTP、BitTorrent、Metalink协议等)、多线程的下载。它比axel优秀的地方在于完全支持BitTorrent协议，同时可以作为BitTorrent客户端来下载种子文件,支持Metalink协议,远程控制(通过web端)下载进程。</p><p>主要优势如下：</p><ul><li>高速，自动多线程下载；</li><li>断点续传；</li><li>轻量占用内存非常少，通常情况平均4~9MB内存占用(官方介绍)；</li><li>多平台。支援 Win/Linux/OSX/Android 等操作系统下的部署；</li><li>模块化。分段下载引擎，文件整合速度快；</li><li>支持RPC界面远程；</li><li>全面支持BitTorrent协议；</li></ul><p>Aria2官方项目页面：<a href="https://aria2.github.io/" target="_blank" rel="noopener">https://aria2.github.io/</a></p><p>关于Aria2的安装和使用教程请参见：<a href="http://www.hi-linux.com/2016/05/09/CentOS%E4%B8%8B%E6%90%AD%E5%BB%BAAria2%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">CentOS下搭建Aria2远程下载环境</a></p><h3 id="5-各种下载工具的比较"><a href="#5-各种下载工具的比较" class="headerlink" title="5. 各种下载工具的比较"></a>5. 各种下载工具的比较</h3><table><thead><tr><th align="center">协议</th><th align="center">wget</th><th align="center">curl</th><th align="center">axel</th><th align="center">aria</th></tr></thead><tbody><tr><td align="center">HTTP(S)</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td align="center">FTP</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td align="center">SFTP</td><td align="center">✗</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr><tr><td align="center">BitTorrent</td><td align="center">✗</td><td align="center">✗</td><td align="center">✗</td><td align="center">✓</td></tr><tr><td align="center">Metalink</td><td align="center">✗</td><td align="center">✗</td><td align="center">✗</td><td align="center">✓</td></tr><tr><td align="center">Telnet</td><td align="center">✗</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr><tr><td align="center">IMAP</td><td align="center">✗</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr><tr><td align="center">POP3</td><td align="center">✗</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr><tr><td align="center">SMTP</td><td align="center">✗</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离线下载 </tag>
            
            <tag> aria2 </tag>
            
            <tag> wget </tag>
            
            <tag> curl </tag>
            
            <tag> axel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>增强你的Mac词典</title>
      <link href="/post/enhance-mac-dicts/"/>
      <url>/post/enhance-mac-dicts/</url>
      
        <content type="html"><![CDATA[<p>Mac自带的词典功能远比你想象的强大,你完全可以自定义你的词典。</p><a id="more"></a><p>Mac自带的词典功能，不仅能用三指轻触查询，如果你对词典不满意，还可以自己添加词典，如牛津、朗文、英汉、汉英、法汉、德汉、汉法、汉德、日汉、汉日；甚至康熙大辞典，以及湘雅医学专业词典。只要你能找到合适的词典包即可。所以完全没有必要安装有道词典等第三方词典。</p><h3 id="1-下载词典转换工具"><a href="#1-下载词典转换工具" class="headerlink" title="1 下载词典转换工具"></a>1 下载词典转换工具</h3><p>DictUnifier下载地址：<a href="https://github.com/jjgod/mac-dictionary-kit" target="_blank" rel="noopener">https://github.com/jjgod/mac-dictionary-kit</a></p><h3 id="2-下载词典包"><a href="#2-下载词典包" class="headerlink" title="2 下载词典包"></a>2 下载词典包</h3><p>词典包下载地址：<a href="http://abloz.com/huzheng/stardict-dic/zh_CN/" target="_blank" rel="noopener">http://abloz.com/huzheng/stardict-dic/zh_CN/</a></p><h3 id="3-词典转换"><a href="#3-词典转换" class="headerlink" title="3 词典转换"></a>3 词典转换</h3><p>打开DictUnifier，然后将下载好的词典包拖拽到DictUnifier中，按照提示操作即可。</p><p>一般来说，词典包安装后，Dictionary会自动打开，这时你就会发现新增的词典了。</p><p>特别提醒：有些Mac OS版本，需要在Dictionary的偏好设置里面（command加逗号），把需要的词典勾选一下～</p><h3 id="4-删除词典"><a href="#4-删除词典" class="headerlink" title="4 删除词典"></a>4 删除词典</h3><p>对于不想要的词典：</p><ol><li>在Dictionary界面不显示——在Dictionary的“系统设置”里面，把不想用的词典前面的“对勾”去掉</li><li>想完全删去——在下面这两个文件夹内，找到相应的.dictionary文件，delete<ul><li>Macintosh HD/Library/Dictionaries文件夹</li><li>Macintosh HD/Users/你的用户名/Library/Dictionaries文件夹</li></ul></li></ol><p>一篇详细的英文参考教程：<a href="https://davidtse916.wordpress.com/2008/01/24/adding-dictionaries-to-the-built-in-dictionary-application-in-leopard/" target="_blank" rel="noopener">https://davidtse916.wordpress.com/2008/01/24/adding-dictionaries-to-the-built-in-dictionary-application-in-leopard/</a></p><h3 id="其他词典工具推荐"><a href="#其他词典工具推荐" class="headerlink" title="其他词典工具推荐"></a>其他词典工具推荐</h3><p>GoldenDict是一个开源的词典项目，可在Windows、Mac、Linux全平台下使用，而且支持中文，项目主页<a href="https://github.com/goldendict/goldendict/wiki" target="_blank" rel="noopener">https://github.com/goldendict/goldendict/wiki</a></p><p>GoldenDict添加网络词典教程：<a href="https://www.shanbay.com/team/thread/34543/938905/" target="_blank" rel="noopener">https://www.shanbay.com/team/thread/34543/938905/</a></p><p>GoldenDict添加本地词典教程：<a href="http://jingyan.baidu.com/article/f25ef254459199482c1b829c.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/f25ef254459199482c1b829c.html</a></p><p>与GoldenDict类似的还有StarDict，不过该项目因为版权问题已经停止维护了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 效率 </tag>
            
            <tag> 词典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让你的博客被Google收录</title>
      <link href="/post/how-to-make-you-blog-included-by-google/"/>
      <url>/post/how-to-make-you-blog-included-by-google/</url>
      
        <content type="html"><![CDATA[<p>hexo搭建的博客快速让Google收录教程</p><a id="more"></a><h3 id="1-注册一个谷歌账号"><a href="#1-注册一个谷歌账号" class="headerlink" title="1 注册一个谷歌账号"></a>1 注册一个谷歌账号</h3><p>打开<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">Google搜索引擎提交入口</a></p><h3 id="2-下载验证文件"><a href="#2-下载验证文件" class="headerlink" title="2 下载验证文件"></a>2 下载验证文件</h3><p><img src="http://babymaychen.github.io/uploads/downloadCheck.png" alt="验证文件"></p><p>下载Google的验证文件之后，需要在文件开头添加layout: false来取消hexo对其进行的转换，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">source/google0b4c8a25b65d7c2a.html</span></span><br><span class="line"><span class="attr">layout:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">google-site-verification:</span> <span class="string">google0b4c8a25b65d7c2a.html</span></span><br></pre></td></tr></table></figure><h3 id="3-将验证文件放入网站的根目录"><a href="#3-将验证文件放入网站的根目录" class="headerlink" title="3 将验证文件放入网站的根目录"></a>3 将验证文件放入网站的根目录</h3><p>以GitHub为例，打开博客主页，点击”Upload files”，将验证文件放入项目根目录</p><h3 id="4-访问验证文件"><a href="#4-访问验证文件" class="headerlink" title="4 访问验证文件"></a>4 访问验证文件</h3><p>然后打开浏览器输入：http://你的网站域名/你下载的验证文件名字.html ，如果你看到了一串字符(注：只有一串字符)，那就成功了。</p><h3 id="5-添加站点地图"><a href="#5-添加站点地图" class="headerlink" title="5 添加站点地图"></a>5 添加站点地图</h3><p>什么是站点地图呢？Google的解释是:</p><blockquote><p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</p></blockquote><p>对于使用Hexo写博客的小伙伴来说，可以使用 hexo-generator-sitemap 插件来生成Sitemap。插件的使用很简单，只需要下载即可：</p><p><code>npm install hexo-generator-sitemap --save</code></p><p>在博客根目录的_config.yml中添加如下代码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sitemap:</span></span><br><span class="line"><span class="symbol">path:</span> sitemap.xml</span><br></pre></td></tr></table></figure><p>这里的缩进很重要(不解释，试一下就知道了),然后编译并部署博客。</p><h3 id="6-让Google收录博客"><a href="#6-让Google收录博客" class="headerlink" title="6 让Google收录博客"></a>6 让Google收录博客</h3><p>向<a href="https://www.google.com/webmasters/tools" target="_blank" rel="noopener">Google站长工具</a>提交sitemap</p><p>添加了站点验证通过后，选择站点，之后在抓取——站点地图中就能看到添加/测试站点地图<br><img src="http://babymaychen.github.io/uploads/sitemap.png" alt=""></p><hr><p>参考资料</p><ol><li><a href="http://babymaychen.github.io/2016/07/20/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%A2%ABGoogle%E5%88%B0/" target="_blank" rel="noopener">孙小妹的博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/55796365" target="_blank" rel="noopener">Hexo 博客优化之 Next 主题功能强化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令总结</title>
      <link href="/post/git-notes/"/>
      <url>/post/git-notes/</url>
      
        <content type="html"><![CDATA[<p>这可能是东半球最详细的Git命令总结了:-)</p><a id="more"></a><blockquote><p>Git使用教程——<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">《Pro Git》</a><br><br><br>Git视频教程<a href="http://study.163.com/course/courseMain.htm?courseId=1003268008" target="_blank" rel="noopener">人人都会用git</a><br><br><br>git在本地分为3个区：工作区，暂存区和本地仓库。<br><br><br>Git更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个快照流。<br><br><br>git中任何<em>已提交</em>的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 –amend 选项覆盖的提交也可以恢复<br><br><br><a href="https://dotblogs.com.tw/wasichris/2016/04/29/225157" target="_blank" rel="noopener">[Git] Reset - mixed, hard and soft</a><br><a href="https://www.zybuluo.com/phper/note/223883" target="_blank" rel="noopener">git pull和git fetch、git reset 和 git revert 的区别用法</a></p></blockquote><hr><h1 id="一、本地操作"><a href="#一、本地操作" class="headerlink" title="一、本地操作"></a>一、本地操作</h1><h2 id="1-1-基础命令"><a href="#1-1-基础命令" class="headerlink" title="1.1 基础命令"></a>1.1 基础命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git init [directory]</code></td><td>初始化git本地仓库</td></tr><tr><td>`git reset –hard commit-id</td><td>HEAD^</td></tr><tr><td><code>git relog</code></td><td>查看git历史操作命令</td></tr><tr><td><code>git rm --cached file_name</code></td><td>删除暂存区的文件,如果暂存区的文件<strong>被修改</strong>，则<strong>需要使用<code>-f</code>参数</strong></td></tr><tr><td><code>git mv file_from file_to</code></td><td>修改文件名</td></tr><tr><td><code>git reset HEAD filename</code></td><td>取消暂存的文件（丢弃<code>git add</code>后的文件）</td></tr><tr><td><code>git checkout .</code></td><td>丢弃工作区所有文件的修改</td></tr><tr><td><code>git checkout -- filename</code></td><td>丢弃工作区指定文件的修改（ <em>注意文件名前的空格</em> ）</td></tr><tr><td><code>git checkout HEAD .</code></td><td>丢弃工作区与暂存区的所有文件的修改</td></tr><tr><td><code>git checkout HEAD -- filename</code></td><td>丢弃总做区与暂存区指定文件的修改</td></tr><tr><td><code>git config --list</code></td><td>查看git的配置信息</td></tr></tbody></table><h2 id="1-2-克隆"><a href="#1-2-克隆" class="headerlink" title="1.2 克隆"></a>1.2 克隆</h2><p>Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p><p>克隆命令：<code>git clone git@github.com:user/repo.git  [local_repo_name]</code><br>clone时端口号不为默认的22时，需将命令修改为 <code>$git clone ssh://user@host:port/user/repo.git [local_repo_name]</code></p><h2 id="1-3-比较"><a href="#1-3-比较" class="headerlink" title="1.3 比较"></a>1.3 比较</h2><p><code>git diff</code>查看工作区与暂存区文件的差异<br><code>git diff --cached</code>查看暂存区与本地仓库的文件差异<br><code>git diff HEAD</code>查看工作区与本地仓库的文件差异</p><h2 id="1-4-提交"><a href="#1-4-提交" class="headerlink" title="1.4 提交"></a>1.4 提交</h2><p><code>git commit -m &#39;description&#39;</code><br><code>git commit -a -m &#39;description&#39;</code>将<code>git add</code>与<code>git commit</code>命令合并使用，此时会自动将已跟踪的文件加入暂存并提交<br><code>git commit --amend</code>修改提交信息。若文件A已经提交，然后发现文件B忘记提交，可以执行<code>git add B</code>后执行<code>git commit --amend</code>，来实现A，B同时提交的效果。</p><h2 id="1-5-储藏"><a href="#1-5-储藏" class="headerlink" title="1.5 储藏"></a>1.5 储藏</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git stash</code></td><td>将当前工作区内容储藏</td></tr><tr><td><code>git stash list</code></td><td>查看储藏的所有内容</td></tr><tr><td><code>git stash show -p stash@{n}</code></td><td>显示储藏内容</td></tr><tr><td><code>git stash apply</code></td><td>将最近储藏的文件取回到工作区，栈中仍存在该储藏文件</td></tr><tr><td><code>git stash apply stash@{n}</code></td><td>取出指定储藏的文件</td></tr><tr><td><code>git stash pop</code></td><td>应用储藏并删除栈中内容</td></tr><tr><td><code>git stash drop stash@{n}</code></td><td>丢弃储藏内容</td></tr><tr><td><code>git stash -u</code></td><td>暂存未被跟踪的文件</td></tr></tbody></table><h2 id="1-6-查看历史"><a href="#1-6-查看历史" class="headerlink" title="1.6 查看历史"></a>1.6 查看历史</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git log</code></td><td>显示详细记录</td></tr><tr><td><code>git log -p -2</code></td><td>查看最近2次的提交信息，包括被改动的内容</td></tr><tr><td><code>git log --stat</code></td><td>显示每次提交的统计信息</td></tr><tr><td><code>git log --pretty=oneline</code> 或 <code>git log --oneline</code></td><td>简要显示提交信息</td></tr><tr><td><code>git log --graph</code></td><td>图形化显示分支、合并历史</td></tr><tr><td><br></td><td></td></tr></tbody></table><center> `git log`输出选项</center><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-n</code></td><td align="left">仅显示最近的n条提交</td></tr><tr><td align="left"><code>--since</code>, <code>--after</code></td><td align="left">仅显示指定时间之后的提交</td></tr><tr><td align="left"><code>--until</code>, <code>--before</code></td><td align="left">仅显示指定时间之前的提交</td></tr><tr><td align="left"><code>--author</code></td><td align="left">仅显示指定作者相关的提交</td></tr><tr><td align="left"><code>--committer</code></td><td align="left">仅显示指定提交者的相关提交</td></tr><tr><td align="left"><code>--grep</code></td><td align="left">仅显示含指定关键字的提交</td></tr><tr><td align="left"><code>--decorate</code></td><td align="left">查看指针情况</td></tr><tr><td align="left"><code>-S</code></td><td align="left">仅显示添加或移除了某个关键字的提交</td></tr></tbody></table><h2 id="1-7-变基"><a href="#1-7-变基" class="headerlink" title="1.7 变基"></a>1.7 变基</h2><p><strong>请勿在本地仓库外有副本的分支执行变基操作！</strong><br>变基能够让提交历史变得更加简洁。<br>只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。<br><code>git rebase master dev</code>将dev分支内容变基到master分支上</p><p>变基前：<br><img src="http://ohx73ws1b.bkt.clouddn.com/git%20branch.png" alt=""></p><p>变基后：<br><img src="http://ohx73ws1b.bkt.clouddn.com/git%20rebase.png" alt=""></p><p>假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 git rebase 命令的 –onto 选项，选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：<code>$ git rebase --onto master server client</code><br>多分支变基前：<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%A4%9A%E5%88%86%E6%94%AF%E5%8F%98%E5%9F%BA.png" alt=""><br>多分支变基后<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%A4%9A%E5%88%86%E6%94%AF%E5%8F%98%E5%9F%BA%E7%BB%93%E6%9E%9C.png" alt=""></p><hr><h1 id="二、远程仓库"><a href="#二、远程仓库" class="headerlink" title="二、远程仓库"></a>二、远程仓库</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git remote</code></td><td>显示本地仓库关联的所有远程仓库</td></tr><tr><td><code>git remote -v</code></td><td>显示远程仓库的URL</td></tr><tr><td><code>git remote add local-repo-name url</code></td><td>关联远程仓库</td></tr><tr><td><code>git remote rm local-repo-name</code></td><td>取消与远程仓库的关联</td></tr><tr><td><code>git fetch remote-name</code></td><td>拉取远程仓库的所有分支</td></tr><tr><td><code>git push remote-name branch-name</code></td><td>将当前分支推送到远程分支</td></tr><tr><td><code>git remote show [remote-name]</code></td><td>显示指定远程仓库的详细信息</td></tr><tr><td><code>git remote rename old-name new-name</code></td><td>重命名远程仓库名</td></tr></tbody></table><hr><h1 id="三、分支"><a href="#三、分支" class="headerlink" title="三、分支"></a>三、分支</h1><h2 id="3-1-基础命令"><a href="#3-1-基础命令" class="headerlink" title="3.1 基础命令"></a>3.1 基础命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git branch branch-name [commit-hash]</code></td><td>新建分支</td></tr><tr><td><code>git checkout branch-name</code></td><td>切换分支</td></tr><tr><td><code>git checkout -b branch-name</code></td><td>新建并切换到新分支</td></tr><tr><td><code>git branch</code></td><td>查看本地分支</td></tr><tr><td><code>git branch -r</code></td><td>查看远程分支</td></tr><tr><td><code>git branch -a</code></td><td>查看所有分支</td></tr><tr><td><code>git branch -d branch-name</code></td><td>删除分支</td></tr><tr><td><code>git merge branch-name</code></td><td>合并分支到当前分支</td></tr><tr><td><code>git branch --merged</code></td><td>查看已经合并分支</td></tr><tr><td><code>git branch --no-merged</code></td><td>查看尚未合并的分支</td></tr><tr><td><code>git branch -v</code></td><td>查看分支的最后一次提交</td></tr><tr><td><code>git branch -vv</code></td><td>查看本地分支的跟踪分支, 示例<a href="https://git-scm.com/book/zh/v2/Git-分支-远程分支" target="_blank" rel="noopener">点此</a></td></tr><tr><td><code>git push origin test:master</code></td><td>本地分支test推送给远程master分支（若master不存在，则自动创建）</td></tr><tr><td><code>git push origin :test</code> 或 <code>git push origin --delete test</code></td><td>删除远程test分支</td></tr></tbody></table><br>## 3.2 分支合并分支合并时直接会将内容覆盖<p><img src="http://ohx73ws1b.bkt.clouddn.com/branch_merge.png" alt="分支合并"></p><br>## 3.3 分支冲突仅当修改**同一文件的同一区域**的时候才会产生冲突，git无法执行“快速合并”（如下图）的合并就可能产生冲突<p><img src="http://ohx73ws1b.bkt.clouddn.com/branch_conflict.png" alt="分支冲突"><br>分支冲突解决后，需要使用<code>git add</code>和<code>git commit</code>命令再次提交</p><br>>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？<hr><h1 id="四、Github中的项目地址"><a href="#四、Github中的项目地址" class="headerlink" title="四、Github中的项目地址"></a>四、Github中的项目地址</h1><ul><li>HTTPS形式：<code>https://github.com/&lt;user&gt;/&lt;project_name&gt;</code></li><li>SSH形式：<code>git@github.com:&lt;user&gt;/&lt;project_name&gt;</code></li><li>通常对于公开项目可以优先分享基于 HTTPS 的 URL，因为用户克隆项目不需要有一个 GitHub 帐号。 如果你分享 SSH URL，用户必须有一个帐号并且上传 SSH 密钥才能访问你的项目。 HTTPS URL 与你贴到浏览器里查看项目用的地址是一样的。</li></ul><hr><h1 id="五、使用Git-Hooks实现项目自动部署"><a href="#五、使用Git-Hooks实现项目自动部署" class="headerlink" title="五、使用Git Hooks实现项目自动部署"></a>五、使用Git Hooks实现项目自动部署</h1><p>YouTube视频教程：<a href="https://www.youtube.com/watch?v=7-qAb4YZF2g" target="_blank" rel="noopener">Git deploy to staging server using post-receive hook<br>Auto-Buffer Options</a><br>git钩子教程：<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">Git钩子</a></p><h2 id="第一步：在服务器上创建一个git裸仓库"><a href="#第一步：在服务器上创建一个git裸仓库" class="headerlink" title="第一步：在服务器上创建一个git裸仓库"></a>第一步：在服务器上创建一个git裸仓库</h2><p><code>$ sudo git init --bare sample.git  #创建一个名为sample的git裸仓库</code></p><h2 id="第二步：配置裸仓库下的hooks文件夹的下post-receive（若该文件不存在请手动创建），配置内容为："><a href="#第二步：配置裸仓库下的hooks文件夹的下post-receive（若该文件不存在请手动创建），配置内容为：" class="headerlink" title="第二步：配置裸仓库下的hooks文件夹的下post-receive（若该文件不存在请手动创建），配置内容为："></a>第二步：配置裸仓库下的hooks文件夹的下post-receive（若该文件不存在请手动创建），配置内容为：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">GIT_WORK_TREE=/home/wwwroot/wxsxy/wxsxy git checkout -f  <span class="comment"># 此处设置你要部署的项目目录即可</span></span><br></pre></td></tr></table></figure><p>然后为此脚本赋予可执行权限<code>chmod +x post-receive</code></p><h2 id="第三步：（目前方法一存在无法推送的问题）"><a href="#第三步：（目前方法一存在无法推送的问题）" class="headerlink" title="第三步：（目前方法一存在无法推送的问题）"></a>第三步：（目前方法一存在无法推送的问题）</h2><h3 id="方法一：本地仓库关联远程裸仓库"><a href="#方法一：本地仓库关联远程裸仓库" class="headerlink" title="方法一：本地仓库关联远程裸仓库"></a>方法一：本地仓库关联远程裸仓库</h3><p><code>git remote add origin ssh://root@107.182.180.235:26972/home/bare.git（端口号非默认22的情况 ）</code><br>然后本地仓库中代码编辑完成后推送至远程裸仓库，裸仓库会自动将代码部署到服务器的项目地址下<br><code>git push origin master</code></p><h3 id="方法二：git-clone裸仓库（克隆自动关联），然后在裸仓库中添加代码推送即可"><a href="#方法二：git-clone裸仓库（克隆自动关联），然后在裸仓库中添加代码推送即可" class="headerlink" title="方法二：git clone裸仓库（克隆自动关联），然后在裸仓库中添加代码推送即可"></a>方法二：git clone裸仓库（克隆自动关联），然后在裸仓库中添加代码推送即可</h3><hr><h1 id="六、git的配置"><a href="#六、git的配置" class="headerlink" title="六、git的配置"></a>六、git的配置</h1><p>设置用户名与邮件地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;John Doe&quot;</span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>查看配置信息<br><code>git config --list</code><br>git别名设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line">$ git config --global alias.unstage &apos;reset HEAD --&apos;</span><br><span class="line">$ git config --global alias.last &apos;log -1 HEAD&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备份 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件的恢复</title>
      <link href="/post/recovery-of-the-file/"/>
      <url>/post/recovery-of-the-file/</url>
      
        <content type="html"><![CDATA[<p>相信大家都会有丢失文件的经历，接下来，我们就来谈谈在哪里能够买到”后悔药”。</p><a id="more"></a><h3 id="方法一-使用具有定时备份功能的移动硬盘"><a href="#方法一-使用具有定时备份功能的移动硬盘" class="headerlink" title="方法一 使用具有定时备份功能的移动硬盘"></a>方法一 使用具有定时备份功能的移动硬盘</h3><p>比如我的WD My Passport Ultra就有定时备份的功能，而且可以对硬盘进行加密，从而保证数据的安全</p><h3 id="方法二-使用Windows的备份功能"><a href="#方法二-使用Windows的备份功能" class="headerlink" title="方法二 使用Windows的备份功能"></a>方法二 使用Windows的备份功能</h3><p>在控制面板中进行设置备份功能，好想很少人使用啊</p><h3 id="方法三-在Mac下使用Time-Machine"><a href="#方法三-在Mac下使用Time-Machine" class="headerlink" title="方法三 在Mac下使用Time Machine"></a>方法三 在Mac下使用Time Machine</h3><p>Mac下的Time Machine是一款非常好用的备份工具，不过我们需要设置好备份哪些文件，这样才能在后悔的时候挽救我们</p><h3 id="方法四-使用Mac自带的文本编辑工具"><a href="#方法四-使用Mac自带的文本编辑工具" class="headerlink" title="方法四 使用Mac自带的文本编辑工具"></a>方法四 使用Mac自带的文本编辑工具</h3><p>这个工具我个人觉得不是很好用，但它隐藏了一个十分实用的功能——恢复被修改的文件。<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91.jpg" alt="恢复文件"></p><p><img src="http://ohx73ws1b.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95.png" alt="文稿历史记录"></p><h3 id="方法五-使用git"><a href="#方法五-使用git" class="headerlink" title="方法五 使用git"></a>方法五 使用git</h3><p>git作为如今最为流行的版本管理工具，这应该是这个世界上最好的备份管理工具了，当你丢过一次代码或把代码搞的很乱的时候就知道它有多么重要了。不过这个工具对于普通用户有一定的学习成本，但如果一个程序员说你不会git那就要面壁了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows常见网络故障及解决办法</title>
      <link href="/post/network-diagnose/"/>
      <url>/post/network-diagnose/</url>
      
        <content type="html"><![CDATA[<p>日常生活中，我们总是会在Windows中遇到莫名其妙其妙的网络问题，今天，博主就自己遇到的网络问题及解决办法与各位分享一下。</p><a id="more"></a><p>如果电脑不能正常上网，请按照以下步骤进行尝试修复：</p><ol><li><p>网络图标有黄色感叹号</p><p>解决办法：命令行(Windows+R)运行命令“netsh winsock reset ”后重启即可。</p></li><li><p>笔记本的WiFi物理开关是否打开</p><p>解决办法：找到WiFi开关并打开</p></li><li><p>动态IP或静态IP是否设置正确<br><img src="http://ohx73ws1b.bkt.clouddn.com/DHCP%E8%AE%BE%E7%BD%AE.png" alt=""></p><p> 解决办法：根据自己的网络情况正确设置图示页面，通常家用路由器环境保持图示设置即可。</p></li><li><p>WLAN服务是否启用<br> <img src="http://ohx73ws1b.bkt.clouddn.com/%E5%90%AF%E5%8A%A8WLAN%E6%9C%8D%E5%8A%A1.png" alt=""></p><p> 解决办法：打开计算机管理，查看WLAN服务状态，未启用则设置为“自动”</p></li><li><p>网络设备驱动器有黄色感叹号</p><p>解决办法：使用“驱动精灵”或“驱动人生”等工具尝试修复驱动</p></li><li><p>是否启用了一个无效的代理</p><p>解决办法：重新更换有效代理或不使用代理</p></li><li><p>能正常使用QQ，但无法打开网页</p><p>解决办法：请尝试设置图一中的DNS为114.114.114.114和114.114.115.115后重新尝试</p></li></ol><hr><p>另附一些诊断网络状态的命令</p><ol><li>ping 127.0.0.1       检查tcp/ip协议是否正常</li><li>ping 本机ip    检查网卡</li><li>ping 网关地址     检查和网关的连接性</li><li>nslookup命令可用于查看DNS是否正常</li><li>ping远程网站查看网络连通性</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动硬盘的分区</title>
      <link href="/post/partition/"/>
      <url>/post/partition/</url>
      
        <content type="html"><![CDATA[<p>我们刚拿到一个移动硬盘的时候，通常都是将其根据我们的需要划分为多个分区，那首先要了解一下各种格式的优缺点及适用场景：</p><a id="more"></a><h4 id="各种格式对比"><a href="#各种格式对比" class="headerlink" title="各种格式对比"></a>各种格式对比</h4><table><thead><tr><th align="center">格式</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">FAT32</td><td align="center">全平台支持</td><td align="center">不支持单个文件大于4G的移动</td></tr><tr><td align="center">NTFS</td><td align="center">Windows平台下最佳</td><td align="center">Mac平台下可读不可写（可购买Paragon NTFS for Mac写入数据）</td></tr><tr><td align="center">exFAT</td><td align="center">全平台支持，适合小文件的存储，U盘常用格式</td><td align="center">据查在某些情况下容易丢失数据</td></tr><tr><td align="center">HFS+（日志式）</td><td align="center">Mac下最佳，TimeMachine要求的格式</td><td align="center">Windows下不可读不可写</td></tr><tr><td align="center">ext4</td><td align="center">Linux下最佳，可读写NTFS和HFS+</td><td align="center">暂未发现</td></tr><tr><td align="center">表格数据来源：<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AF%B9%E6%AF%94" target="_blank" rel="noopener">文件系统对比</a></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="实际分区举例"><a href="#实际分区举例" class="headerlink" title="实际分区举例"></a>实际分区举例</h4><p>以博主的情况为例，手上有一个WD My Passport Ultra的1T移动硬盘，通常在Mac下使用，而且要用此盘作Time Machine，其次就是Windows平台的使用，因此需要划分3个分区。Mac分区和Time Machine自然是日志式，Windows平台格式如果是FAT32自然是很方便，但经常会移动4G以上的文件，exFAT又可能会丢失数据，因此决定使用NTFS格式。</p><p>接下来，在Windows平台下使用磁盘精灵（DiskGenius）将硬盘分为1个600G的FAT32格式和1个400G的NTFS格式，然后在Mac自带的磁盘工具下将FAT32格式的600G再划分为400G和200G的日志式，这样就能够满足我的日常生活需要了，而且稳定性和兼容性都很不错。<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA.jpg" alt="硬盘分区"></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分区 </tag>
            
            <tag> 磁盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac设置快速休眠和锁屏</title>
      <link href="/post/mac-sleep-and-lock-screen/"/>
      <url>/post/mac-sleep-and-lock-screen/</url>
      
        <content type="html"><![CDATA[<p>众所周知，在Windows操作系统下，我们可以通过<code>Windows+L</code>键来锁定屏幕，转到Mac平台下一段时间后，我发现Mac似乎并没有这样的按键，一番搜索后，发现了以下几种方法来实现快速锁屏或休眠。</p><a id="more"></a><h3 id="方式一-合盖"><a href="#方式一-合盖" class="headerlink" title="方式一 合盖"></a>方式一 合盖</h3><p>众所周知，Mac系统非常的稳定，我们甚至可以半年不关机，即合即走，即开即用，非常方便。因此，我们可以通过盒盖的方式来使系统进入休眠的状态，但这种方式不够安全，如果你刚刚盒盖起身离去，另一个人马上就过来打开你的电脑，他仍然可以不需要输入密码而直接进入系统。在休眠状态下，系统会断开网络，保存正在运行的程序状态，直至系统被唤醒。</p><h3 id="方式二-触发角"><a href="#方式二-触发角" class="headerlink" title="方式二 触发角"></a>方式二 触发角</h3><p>打开”系统偏好设置”，然后点击屏幕保护程序下的触发角</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/%E8%AE%BE%E7%BD%AE%E8%A7%A6%E5%8F%91%E8%A7%92.jpg" alt="触发角设置"></p><p>这样，当鼠标移动到显示器的右下角时，系统就会进入休眠状态。如果你有外接显示器，无论你在哪个显示器下进行此操作都是可以生效的。</p><p>这种方式下，实质与方式一相同，只不过不需要合盖而已，因此同样不够安全。</p><h3 id="方式三-Alfred锁定计算机"><a href="#方式三-Alfred锁定计算机" class="headerlink" title="方式三 Alfred锁定计算机"></a>方式三 Alfred锁定计算机</h3><p>由于方式一、二对于有重要数据的人来说仍然不够安全，因此我们需要一种能够像Windows+L那样的快速锁屏方式来保证数据安全。<br>首先来简单介绍以下Alfred，这是一个提升Mac效率的神器，可以看作是系统自带的Spotlight的增强版，我们绝大多数的操作都可以在呼出Alfred后马上执行，如查单词（付费版）、算术、打开软件、使用搜索引擎搜索（自定义搜索引擎需付费）等。</p><p>当然了，Alfred也具备了Spotlight所没有的锁屏功能，我们直接呼出Alfred后输入”lock”回车即可锁定屏幕，从而保证我们的数据安全。而且这一功能在免费版本中即可使用。</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/Alfred%E9%94%81%E5%B1%8F.jpg" alt="Alfred"></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁屏 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 休眠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外接显示器的设置</title>
      <link href="/post/external-display-tutorial/"/>
      <url>/post/external-display-tutorial/</url>
      
        <content type="html"><![CDATA[<p>小屏幕的MacBook/MacBook Pro放在桌上长时间使用，眼睛比较累，而且，长时间低头看屏幕，易得颈椎病，绝对有损健康。配一台大屏幕的外置显示器不失为两全其美的好办法。</p><a id="more"></a><p>首先，得买一台中意的大屏幕LED显示器（废话undefined ）。一般22~27吋的、全高清的就比较好。如果你经济条件好，当然可以买尺寸更大的、分辨率更高的Apple大屏显示器。</p><p>其次，摆放好本本和外置显示器的位置，根据支持的接口情况，将大屏幕LED显示器与MacBook Air/MacBook Pro用ThunderBolt或HDMI线连接后，开机。</p><p>接着，进行一些必要的设置。以显示器设为“扩展”为例：</p><ol><li><p>打开“系统偏好设置-显示器”，出现两个显示器的设置窗口。可以将设置窗口拖到任一显示屏上。如果不能正确显示外置显示器信息，就点击“检测显示器”。</p></li><li><p>对每一块显示屏，设置相应的最合适的分辨率。<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E8%AE%BE%E7%BD%AE.jpg" alt="外接显示器的设置"></p></li><li><p>点击“排列”，将显示器图形拖到跟实际位置对应的左/右位置。这样，当你将外置显示器设置为默认的“扩展”桌面时，就不至于发生要将鼠标反向移动到另一块屏幕上的尴尬。<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E6%8E%92%E5%88%97.jpg" alt="外接显示器的排列设置"></p></li><li><p>如果你要将外置显示器作为主屏幕，还必须进行以下设置：<br>（1）将设置图中小屏幕上面的白色菜单栏拖到大屏幕图标上方。两个屏幕都会闪一下，菜单栏就移到大屏幕上方，大屏就是主屏幕了。<br>（2）如果你原来已将Dock放在小屏幕的左/右侧，而现在Dock仍在小屏幕上，那么，还要将Dock移到大屏幕上。方法是：右键点击“Dock”的“斑马线”分隔符，选择“置于屏幕上的位置-左边/右边”，将Dock设置到大屏侧边。注意：如果你喜欢将Dock放在主屏幕的右边，那么，开始安排位置的时候，你的本本就应该放在外置显示器的左边，因为你的大屏是小屏幕的“扩展”；反之亦然。</p></li><li><p>如果需要的话，选中“在菜单中显示显示器图标”，在桌面顶部菜单中出现显示器图标，方便以后更改设置。</p></li><li><p>如果你要关闭本本的小屏幕、只用外置大屏幕，那么，只要合上本本的盖子，几秒后大屏幕自动黑屏后再变亮，你就可以用鼠标在大屏幕上操作了。如果你要输入文字，那么，还需要添加一个键盘（USB或蓝牙、无线的都可以）</p></li><li><p>如果你觉得在外接显示器后移动鼠标变得费力，那你可以试试在Chrome或Firefox下安装Vimium扩展，这样就可以无需鼠标畅游web了<br><img src="http://ohx73ws1b.bkt.clouddn.com/Vimium.jpg" alt="Vimium"></p></li></ol><p>Windows下的设置大同小异，在此不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chrome插件推荐</title>
      <link href="/post/chrome-extension/"/>
      <url>/post/chrome-extension/</url>
      
        <content type="html"><![CDATA[<p>扩展推荐列表</p><h3 id="1-Adblock-Plus"><a href="#1-Adblock-Plus" class="headerlink" title="1. Adblock Plus"></a>1. <a href="https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="noopener">Adblock Plus</a></h3><a id="more"></a><p>   推荐理由：强力去除各种广告，包括YouTube的视频广告，不过无法过滤视屏广告。有些网站会反屏蔽广告，否则不能浏览页面，这样的网站加白名单就好了。</p><h3 id="2-Infinity新标签页"><a href="#2-Infinity新标签页" class="headerlink" title="2. Infinity新标签页"></a>2. <a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="noopener">Infinity新标签页</a></h3><p>   推荐理由：优雅的图标、漂亮的壁纸，每日自动切换，天天都有好心情</p><h3 id="3-Tampermonkey-Firefox中是GreaseMonkey附加组件"><a href="#3-Tampermonkey-Firefox中是GreaseMonkey附加组件" class="headerlink" title="3. Tampermonkey(Firefox中是GreaseMonkey附加组件)"></a>3. <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Tampermonkey</a>(Firefox中是GreaseMonkey附加组件)</h3><p>   推荐理由：脚本工具的管理工具，可以通过修改本地的js或css代码来自定义页面。<br>   以下推荐脚本列表：</p><ul><li><a href="https://greasyfork.org/zh-CN/scripts/17800-%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E4%BA%91%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%99%90%E5%88%B6" target="_blank" rel="noopener">一行代码，解决百度云大文件下载限制</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/24192-kill-baidu-ad" target="_blank" rel="noopener">百度广告(首尾推广及右侧广告)清理</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/10582-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%AB%98%E9%9F%B3%E8%B4%A8%E6%94%AF%E6%8C%81" target="_blank" rel="noopener">网易云音乐高音质支持</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/6489-zhihu-visitor" target="_blank" rel="noopener">知乎免登录</a></li></ul><h3 id="4-网盘助手"><a href="#4-网盘助手" class="headerlink" title="4. 网盘助手"></a>4. 网盘助手</h3><p>   推荐理由：本地安装Aria2后配合此扩展绕过百度云限速与客户端大小限制</p><h3 id="5-Proxy-SwitchyOmega"><a href="#5-Proxy-SwitchyOmega" class="headerlink" title="5. Proxy SwitchyOmega"></a>5. <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">Proxy SwitchyOmega</a></h3><p>   推荐理由：轻松快捷管理和切换代理，仍然记得当年GAE和这个配合翻GFW</p><h3 id="6-OneTab"><a href="#6-OneTab" class="headerlink" title="6. OneTab"></a>6. <a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">OneTab</a></h3><p>   由于Chrome特别消耗内存，对于那些我们暂时不看的页面，我们都可以收集到OneTab中，降低系统内存消耗</p><h3 id="7-JSON-Viewer"><a href="#7-JSON-Viewer" class="headerlink" title="7. JSON Viewer"></a>7. JSON Viewer</h3><p>   推荐理由：将json格式的数据格式化输出，方便阅读。由于之前的JSONView被提示有安全漏洞，就转为这个了。</p><h3 id="8-Vimium"><a href="#8-Vimium" class="headerlink" title="8. Vimium"></a>8. <a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="noopener">Vimium</a></h3><p>   推荐理由：忘掉鼠标吧，用Vim的快捷键来浏览网页，快速准确找到你想要的</p><h3 id="9-Xdebug-helper"><a href="#9-Xdebug-helper" class="headerlink" title="9. Xdebug helper"></a>9. <a href="https://chrome.google.com/webstore/detail/xdebug-helper/eadndfjplgieldjbigjakmdgkmoaaaoc" target="_blank" rel="noopener">Xdebug helper</a></h3><p>   推荐理由：配合IDE调试代码，程序员必备神器</p><h3 id="10-Postman"><a href="#10-Postman" class="headerlink" title="10. Postman"></a>10. <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="noopener">Postman</a></h3><p>推荐理由：Postman是调试web api的一款利器，它能够发送任何类型的HTTP requests (GET, HEAD, POST, PUT..)，附带任何数量的参数+ headers。</p><p>支持不同的认证机制（basic, digest, OAuth），接收到的响应语法高亮（HTML，JSON或XML）。</p><p>Postman 能够保留了历史的请求，这样我们就可以很容易地重新发送请求，有一个“集合”功能，用于存储所有请求相同的API/域。</p><h3 id="11-EditThisCookie"><a href="#11-EditThisCookie" class="headerlink" title="11. EditThisCookie"></a>11. <a href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg" target="_blank" rel="noopener">EditThisCookie</a></h3><p>推荐理由：EditThisCookie是一个cookie管理器。您可以添加，删除，编辑，搜索，锁定和屏蔽cookies！</p><h3 id="12-FeHelper"><a href="#12-FeHelper" class="headerlink" title="12. FeHelper"></a>12. <a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad" target="_blank" rel="noopener">FeHelper</a></h3><p>推荐理由：提供了很多常用的FE工具，包括字符串编解码、图片base64编码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析等。</p><p>非常实用，强烈推荐！</p><h3 id="13-划词翻译"><a href="#13-划词翻译" class="headerlink" title="13. 划词翻译"></a>13. <a href="https://chrome.google.com/webstore/detail/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/ikhdkkncnoglghljlkmcimlnlhkeamad" target="_blank" rel="noopener">划词翻译</a></h3><p>推荐理由：一个简便但强大的翻译扩展。支持谷歌、百度、有道、必应四大翻译和朗读引擎，可以方便的查看、复制和朗读不同引擎的翻译结果。</p><p>对阅读英文文档非常有帮助。</p><h3 id="14-豆藤"><a href="#14-豆藤" class="headerlink" title="14.豆藤"></a>14.<a href="http://www.douban.com/note/481190431/" target="_blank" rel="noopener">豆藤</a></h3><p>推荐理由：豆瓣是个好网站，找书找电影先去豆瓣逛逛～豆藤可以一键找出电影、书籍的下载地址，还提供了很多豆瓣的很多小功能。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo遇到的那些坑</title>
      <link href="/post/hexo-error/"/>
      <url>/post/hexo-error/</url>
      
        <content type="html"><![CDATA[<p>首先，贴上我搭建成功的教程地址 <a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="noopener">史上最详细的Hexo博客搭建图文教程</a></p><a id="more"></a><p>其次，这个博客里还有hexo中常见的问题 <a href="https://xuanwo.org/2014/08/14/hexo-usual-problem/" target="_blank" rel="noopener">Hexo常见问题解决方案</a></p><p>接下来，我们来谈谈我在搭建时遇到的一些坑：</p><h3 id="1-hexo的3行报错-DTrace-错误"><a href="#1-hexo的3行报错-DTrace-错误" class="headerlink" title="1. hexo的3行报错(DTrace 错误)"></a>1. hexo的3行报错(DTrace 错误)</h3>   <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/Release/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/default/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/Debug/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br></pre></td></tr></table></figure><p>   出现这种情况是因为GFW导致npm下载过程中依赖库不完整</p><p>   解决办法：</p><p>   更换国内镜像<a href="http://www.jianshu.com/p/0deb70e6f395" target="_blank" rel="noopener">http://www.jianshu.com/p/0deb70e6f395</a><br>   然后 卸载并重新安装<br>   <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-<span class="keyword">cli</span> -g</span><br><span class="line">$ npm install hexo-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure><br>   或者使用以下命令安装解决<br>   <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">npm</span> install hexo --<span class="literal">no</span>-optional</span><br></pre></td></tr></table></figure><br>   反正我是用的更换源的办法解决的，这样解决的更彻底，速度提升了不只一个量级。</p><h3 id="2-博客在本地测试正常，部署到线上没有样式"><a href="#2-博客在本地测试正常，部署到线上没有样式" class="headerlink" title="2. 博客在本地测试正常，部署到线上没有样式"></a>2. 博客在本地测试正常，部署到线上没有样式</h3><p>   这个情况我们可以在控制台中看到，样式的相关文件加载报了404错误，就是因为路径的填写问题，注意hexo官网对于网址路径的解释<br>   <img src="http://ohx73ws1b.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98.jpg" alt="博客路径问题"></p><h3 id="3-hexo-g命令报错"><a href="#3-hexo-g命令报错" class="headerlink" title="3. hexo g命令报错"></a>3. <code>hexo g</code>命令报错</h3><p>   <img src="http://ohx73ws1b.bkt.clouddn.com/hexo%20g%E6%8A%A5%E9%94%99.jpg" alt="渲染报错"><br>   如果遇到hexo g报错的情况，这并不是由于文件的权限问题导致的，同样是由于yml严格的语法问题导致的，这个问题导致我用IDE打开博客时都会卡死<br>   <img src="http://ohx73ws1b.bkt.clouddn.com/hexo%20g.jpg" alt="渲染报错根源"></p><p>   因此，我们在编辑yml文件时要格外的小心，除了<code>:</code>后<strong>必须</strong>有空格外，其中的缩进也是有严格要求的，我们可以通过在线网站<a href="http://www.yamllint.com/" target="_blank" rel="noopener">YAML Lint</a>来帮助我们排错，以免因为yml的格式问题耗费太多的时间。</p><h3 id="4-Hexo常见问题解决方案"><a href="#4-Hexo常见问题解决方案" class="headerlink" title="4. Hexo常见问题解决方案"></a>4. Hexo常见问题解决方案</h3><p><a href="https://xuanwo.org/2014/08/14/hexo-usual-problem/" target="_blank" rel="noopener">https://xuanwo.org/2014/08/14/hexo-usual-problem/</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH密钥登录教程</title>
      <link href="/post/ssh-login-tutorial/"/>
      <url>/post/ssh-login-tutorial/</url>
      
        <content type="html"><![CDATA[<p>从此再也不怕忘记密码了;)</p><a id="more"></a><h3 id="Step-1：检查密钥"><a href="#Step-1：检查密钥" class="headerlink" title="Step 1：检查密钥"></a>Step 1：检查密钥</h3><p>查看本机~/.ssh/目录下是否有ssh公钥(id_rsa.pub)和私钥(id_rsa)，如果没有或者干脆连.ssh目录都不存在，那么请使用<code>ssh-keygen -t rsa -C &quot;email@example.com&quot;</code>来创建ssh密钥。</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/SSH%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90.jpg" alt="生成ssh密钥"></p><p>它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。</p><h3 id="Step-2：将公钥放置到远程服务器"><a href="#Step-2：将公钥放置到远程服务器" class="headerlink" title="Step 2：将公钥放置到远程服务器"></a>Step 2：将公钥放置到远程服务器</h3><p>将本机的<strong>公钥.ssh/id_rsa.pub</strong>放置在远程服务器对应用户名目录（如/root/.ssh）下的<code>/.ssh/authorized_keys</code>中，一行一个，并且将.ssh和authorized_keys权限设置为700和600。<br>一个便捷的命令：<code>ssh-copy-id -i ~/.ssh/id_rsa.pub  root@192.168.0.3  [-pport]</code></p><ul><li>该命令会自动将本地的ssh公钥复制到远程主机的authorized_keys文件中，同时会自动设置相关权限。</li><li>若不支持该命令请手动复制id_rsa.pub内容到远程主机的authorized_keys（不存在请创建），或者使用ftp或sftp拷贝后重命名。</li></ul><h3 id="Step-3-设置本地ssh"><a href="#Step-3-设置本地ssh" class="headerlink" title="Step 3:设置本地ssh"></a>Step 3:设置本地ssh</h3><p>设置~/.ssh目录下的config文件</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/SSH%E7%9A%84%E9%85%8D%E7%BD%AE.jpg" alt="配置ssh"></p><h3 id="Step-4-使用ssh密钥登录"><a href="#Step-4-使用ssh密钥登录" class="headerlink" title="Step 4:使用ssh密钥登录"></a>Step 4:使用ssh密钥登录</h3><p>使用ssh+别名登录</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/SSH%E7%9A%84%E7%99%BB%E5%BD%95.jpg" alt="使用ssh密钥登录"></p><p>PS:如果你配置ssh免密钥登录失败时，检查一下</p><ol><li>你的authorized_keys文件是否放置在对应用户的文件夹下</li><li>你的.ssh和authorized_keys的权限设置是否正确</li></ol><h3 id="附：ssh原理"><a href="#附：ssh原理" class="headerlink" title="附：ssh原理"></a>附：ssh原理</h3><p>ssh密钥登录的原理：当我们使用普通方式登录时，远程主机通过/etc/shadow验证用户名和密码。而当我们配置好了ssh密钥登录时，我们每次发送登录请求时都会携带本机的私钥前往远程主机，远程主机收到登录请求后，不再去/etc/shadow校验，而转去authorized_keys查看是否已经存在对应的公钥（因为ssh的密钥是成对生成的，所以fingerprint是一样的），校验成功则登录成功，否则拒绝登录请求。</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/ssh%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> linux </tag>
            
            <tag> 密钥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装Windows系统教程</title>
      <link href="/post/install-windows-on-linux/"/>
      <url>/post/install-windows-on-linux/</url>
      
        <content type="html"><![CDATA[<p>今天，有一台已经安装了Ubuntu 16.04，未分区的系统需要安装Windows 7双系统。</p><a id="more"></a><p>那接下来的第一步自然就是分区了，在Windows中磁盘精灵分区用的溜，但Linux中怎么分区呢？查询后得知Linux中可以用Gparted视图工具来分区，所以，Ubuntu系统用apt-get install gparted，CentOS用yum install gparted安装。</p><p>你以为分区就这么顺利？too young too simple，进去后才发现正在运行的系统所在分区是不可以执行分区操作的，具体的表现就是/dev/sda*有把钥匙，并且磁盘容量的调整最大值和最小值都是磁盘总容量。好吧，再次Google，原来可以用Live USB（类似于Windows下的PE环境）来进行分区操作，接下来就开始用软碟通制作Ubuntu的启动盘，在漫长的等待后终于顺利分出一个空白分区，然后用gparted将未分配的分区格式化为NTFS格式（<font color=red>Windows系统分区必须此格式</font>）。</p><p>接下来用优启通安装Windows 7，在重启的过程中系统提示“windows boot manager has been blocked by the current security policy”，那就关了boot选项的secure boot吧，兴冲冲的进去后发现这个选项是！灰！的！我&amp;*#w&amp;@%……折腾半天才想起来，现在的系统环境是UEFI+GPT，而Windows 7及以下只支持BIOS+MBR，要强制安装Windows 7只能将GPT转为MBR了，但这样会清空全盘数据，权衡之下，装Windows 10 LTSB吧，恰好之前封装过。重新将Windows分区格掉后开始安装，一切顺利，半小时后安装结束。双系统都能顺利进入和正常使用。</p><p>正当我为自己点赞时，开机发现竟然没有双系统选择延时，每次自动进入启动顺序的第一个系统，那这个问题怎么解决呢？再次查询后发现EasyBCD工具可以修复引导，使双系统开机出现选择按钮，不过呢，由于有其他事暂时没试，有空再搞，毕竟不是特别严重的问题。</p><hr><p>次日更<br>今天发现朋友的电脑开机竟然有了系统选择项，那我也就不用折腾了，这次系统的安装以完美收场，撒花～</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Windows </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信连Wi-Fi使用教程</title>
      <link href="/post/wechat-wifi-tutorial/"/>
      <url>/post/wechat-wifi-tutorial/</url>
      
        <content type="html"><![CDATA[<p>如今，越来越多的商家开始支持免费Wi-Fi，很多顾客到店后都会询问Wi-Fi密码是多少</p><a id="more"></a>，有些打印的贴在墙上的还好，至少识别起来不是那么费劲，有些手写的就要多花一些时间才能连接成功。我就在想，有没有什么更加便捷的方式让用户一键连接？带着这个问题，我想到了如今无处不在的二维码，二维码中可以蕴藏链接、文本等信息，如果顾客能够扫描二维码直接连接岂不是更好？在一番查找后找到了联图网，该网站支持Wi-Fi格式的二维码，且对生成的二维码允许嵌入logo等自定义设置，增添一些趣味。尝试一番后以失败告终，这种方案的问题在于，手机的确可以读取出Wi-Fi名和密码，但结果是文本的形式，顾客还需复制粘贴才可以。然后就在想，现在越来越多的软件都有扫描二维码功能，那谁来做这个Wi-Fi一键连接是最佳人选呢？答案当然是老少咸宜的微信！于是又去进行查询，果然，微信已于2015年3月份在公众号推出了该功能，下面，我们就来看看如何开通和使用吧～<p>首先，你要有一个门面店（至少要让微信相信你有），然后你还要有一个微信公众号，还没有的商家快去注册一个吧，相信微信的注册引导已经很清楚了。<br>注册成功后，登录公众号后台，点击“添加功能插件”（如下图），然后点击“微信连Wi-Fi”，然后依此点击“开通”—&gt;“同意”服务协议—&gt;”返回”—&gt;“查看功能”。<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%85%AC%E4%BC%97%E5%8F%B7%E8%8F%9C%E5%8D%95.jpeg" alt="公众号菜单"></p><p><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8F%92%E4%BB%B6.jpeg" alt="公众号插件"></p><p>至此，微信连Wi-Fi开通成功，左侧功能新增“门店管理”和“微信连Wi-Fi”两个按钮。</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%B0%E5%A2%9E%E8%8F%9C%E5%8D%95.jpeg" alt="公众号新增菜单"></p><p>现在，我们点击“门店管理”，然后点击“新建门店”，之后填写门店的基本信息，完成后切换到“微信连Wi-Fi”，点击“设备管理”和“添加设备”，填写相关信息即可（注意此处的<font color=red>Wi-Fi名和密码至少要有一个是以大写的“WX”开头</font>）。然后将生成的二维码下载并粘贴在店内的醒目位置即可，顾客来了之后只需使用微信扫描该二维码即可一键连接Wi-Fi（扫描二维码时需联网，会<strong>消耗少量流量</strong>）。</p><p>公众号后台更可查看Wi-Fi在线人数以及历史趋势图，据此分析店铺的客流量，调整店铺的业务。更可向用户推送优惠券等促销内容。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> wifi </tag>
            
            <tag> 公众号 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
